transformation SynchHWPortPartsTransformation(inout input : PlatformPackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype HardwarePackage uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformPackage uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.0/');
/*

main() {
	input.rootObjects()[ResourceInstancePart]->forEach(part) {
	assert fatal (not part.resourceInstanceType.oclIsUndefined()) with log("No Resource Instance is set.");
	// IMPORTANT: Before replacing existing portParts, make sure that those portParts
		// that will be removed after the replacement are also removed from the resource.
 	part.hwportParts->forEach(port) {
			-- only delete those HWPortParts whose hwPortInstanceType is not contained in the current resourceInstance
		if (part.resourceInstanceType.hwportInstances ->excludes(port.hwPortInstance)) then {
				
			// Remove its Link the Bus is kept
			//	var comMedia : Set(CommunicationMedia) := port.connectedMedia->select(m|m.oclIsTypeOf(Link));
			//	connectors->forEach(c) {
			//		c.connectorEndpoints := Set { };
			//		if (c.oclIsKindOf(PortConnector)) then {
		//				part.parentComponent.connectors := part.parentComponent.connectors->excluding(c.oclAsType(PortConnector));
		//			} endif; 
		//		};  
				// remove from resource
				input.removeElement(port);
				port.dump();
			}endif;
			
		}; 
			
						createHWPortParts(part);
			
		};  
		
		
		input.rootObjects()[HWPlatformPart]->forEach(part) {
		assert fatal (not part.hwplatformType.oclIsUndefined()) with log("No HW Platform Type is set.");
	
	// IMPORTANT: Before replacing existing portParts, make sure that those portParts
		// that will be removed after the replacement are also removed from the resource.
 	part.delegationPorts->forEach(port) {
			-- only delete those HWPortParts whose hwPortInstanceType is not contained in the current resourceInstance
		if (part.hwplatformType.delegationPorts ->excludes(port.hwPortInstance)) then {
			//	
			// Remove its Link the Bus is kept
			//	var comMedia : Set(CommunicationMedia) := port.connectedMedia->select(m|m.oclIsTypeOf(Link));
			//	connectors->forEach(c) {
			//		c.connectorEndpoints := Set { };
			//		if (c.oclIsKindOf(PortConnector)) then {
			//			part.parentComponent.connectors := part.parentComponent.connectors->excluding(c.oclAsType(PortConnector));
			//		} endif; 
			//	};  
				 remove from resource
				input.removeElement(port);
				port.dump();
			}endif;
			
		}; 
			
		createHWPortParts(part);
			
		};  
			
}







// create new port parts for the component part
helper createHWPortParts(inout resourceInstancePart : ResourceInstancePart) {
	
	var resourceInstance : ResourceInstance := resourceInstancePart.resourceInstanceType;
	
	resourceInstance.hwportInstances -> forEach(hwport){
	if((resourceInstancePart.hwportParts -> select(p | p.hwPortInstance = hwport)) -> isEmpty()) then {
			resourceInstancePart.hwportParts += new HWPortPart(hwport);
		} endif;
	};
	
}

helper createHWPortParts(inout hwplatformPart : HWPlatformPart) {
	
	var hwplatform : HWPlatform := hwplatformPart.hwplatformType;
	
	hwplatform.delegationPorts -> forEach(hwport){
	if((hwplatformPart.delegationPorts -> select(p | p.hwPortInstance = hwport)) -> isEmpty()) then {
			hwplatformPart.delegationPorts += new HWPortPart(hwport);
		} endif;
	};
	
}

// instantiate port part that references the given port
constructor HWPortPart::HWPortPart(port : HWPortInstance) {
	name := port.name;
	hwPortInstance:=port;
}

*/