[comment encoding = UTF-8 /]
[**
 * The documentation of the module RealtimeStatechartHeader.
 */]
[module RealtimeStatechartHeader('http://www.fujaba.de/muml/connector/0.4.0', 'http://www.fujaba.de/muml/behavior/0.4.0',
				'http://www.storydriven.org/core/0.3.1',
				'http://www.fujaba.de/muml/actionlanguage/0.4.0',
				'http://www.fujaba.de/muml/msgtype/0.4.0',
				'http://www.fujaba.de/muml/types/0.4.0',
				'http://www.fujaba.de/modelinstance/0.4.0',
				'http://www.fujaba.de/muml/component/0.4.0',
				'http://www.fujaba.de/muml/instance/0.4.0',
				'http://www.fujaba.de/muml/realtimestatechart/0.4.0',
				'http://www.fujaba.de/muml/hardware/1.0/',
				'http://www.fujaba.de/muml/psm/codegen/0.1.0',
				'http://www.fujaba.de/muml/swplatform/0.4.0/',
				'http://www.fujaba.de/muml/psm/0.4.0/')]

[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::stringQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::modelQueries]

[**
 * The documentation of the template generateElement.
 * @param anOclAny
 */]
[template public generate_RTSCHeader(comp: Component, rtsc : RealtimeStatechart, path : String) post(trim())]

[file (path+getFileName(rtsc, true, false), false, 'UTF-8')]
/**
 * @file 
 * @author generated
 * @brief Specification of Realtime-StateChart: [rtsc.getName()/]
 * @details This files contains the description of the Realtime-StateChart: [rtsc.getName()/] and its behavior which is executed
 */

#ifndef [getHeaderDefine(rtsc)/]
#define [getHeaderDefine(rtsc)/]

[includes(comp, rtsc)/]
//ENUM
	[variables(comp, rtsc)/]

//METHOD STUBS
	[constructor(comp, rtsc)/]
	[initialize(rtsc)/]
	[destroy(rtsc)/]		
	[process(rtsc)/]

	[exit(rtsc)/]
			
	[isInState(rtsc)/]
	[isTerminated(rtsc)/]

#endif /* [getHeaderDefine(rtsc)/] */
[/file]
[/template]


[**
 * Generates includes
 * 
 * @param statechart
*/]
[template public includes (comp:Component, rtsc : RealtimeStatechart) post(trim())]
#include "../lib/clock.h"
#include "../lib/syncChannel.h"
#include "../lib/MiddlewareTypes.h"
#include "../Middleware/MiddlewareCore.h"
#include "../[comp.getFileName(true)/]"
[if ((rtsc.eAllContents(Operation)->asSet() - rtsc.eAllContents(APICall)->asSet())->size() > 0)]#include "../operations/operations.h"[/if]
[if (rtsc.eAllContents(APICall)->size() > 0)]#include "../apiCallCode/implementations.h"[/if]
[/template]

[**
 * Generates the enum for the statechart.
 * 
 * @param statechart
*/]
[template private variables (comp: Component, rtsc: RealtimeStatechart) post(trim())]
/** 
 * @brief This enum represents the States of the Realtime-StateChart: [rtsc.getName()/]
 */
	typedef enum {
		[for (state : State | rtsc.states) separator (',')]
			[getStateNames(state)/]	 
		[/for]
	}[getClassName(rtsc, true)/];


	/**
	 * 
	 * @brief Description of the Realtime-StateChart: [rtsc.getName()/]
	 * @details This struct represents the  Realtime-StateChart: [rtsc.getName()/] and its States
	 */
struct [getClassName(rtsc)/] {	
		[comment Member variable for the parent component. /]	
		[comp.getClassName()/] * parentComponent; /**< A pointer to the parent ComponentInstance of Type: [comp.getClassName()/] , which has this Realtime-StateChart as its behavior */			


		[getClassName(rtsc, true)/] [getVariableName(rtsc)/]; /**< The current State of the Realtime-StateChart: [rtsc.getName()/] */
		[comment Member variables for the current state of each region. /]	

		[for (region : Region | rtsc.eAllContents(Region))]
			[getClassName(rtsc, true)/] [getVariableName(region.embeddedStatechart)/]; /**< Represents the State: [region.getName()/] of the Realtime-StateChart: [rtsc.getName()/] */
		[/for]
		
	
		[comment Member variables for the clocks of each region. /]
		[for (clock : Clock | rtsc.eAllContents(Clock))]
			Clock [getVariableName(clock)/]; /**< The Clock: [clock.getName()/] */
		[/for]
	
		[comment @TODO Member variables for the clocks of after transitions. /]	
		
	
		[comment Member variables for the clocks of do actions. /]
		[for (state : State | rtsc.states) ? (not state.doEvent.oclIsUndefined() and state.doEvent.action.extension->size()>0)]
			Clock [getClockVariableName(state)/]; /**< Clock for do action @todo document here */
		[/for]
	

		
		[comment Member variables for the variables of each region. /]	
		[for (var : Variable | rtsc.eAllContents(Variable))]
			[comment]			
			[if (variable.kind = VariableKind::EXTERN)]extern[elseif (variable.scope = VariableScope::LOCAL)]static[/if]
			[/comment] 
			[getTypeName(var)/] [getVariableName(var)/]; /**< The Realtime-StateChart Variable: [var.getName()/] of Type: [var.dataType.name/] */
		[/for]
	
		[for (port : Port | comp.ports) ? (oclIsKindOf(HybridPort))]
			[let hPort : HybridPort = port.oclAsType(HybridPort)]
				[hPort.dataType.getTypeName()/] [hPort.getVariableName()/];
			[/let]		
		[/for]


		[comment Member variables for the synchronization channels /]	
		[for (syncChannel : SynchronizationChannel | rtsc.eAllContents(State)->collect(channels)->asSet())]
			[getClassName(syncChannel)/]* [getVariableName(syncChannel)/]; /**< The Realtime-StateChart's Synchronization Channel: [syncChannel.getName()/] */
		[/for]

		[if (rtsc.oclIsKindOf(ParameterizedRealtimeStatechart))]
			[let prtsc : ParameterizedRealtimeStatechart = rtsc.oclAsType(ParameterizedRealtimeStatechart)]
				[for (para : RealtimeStatechartParameter | prtsc.allParameters)]
					[if (para.oclIsKindOf(APICallParameter))]
					[let apiOp : Operation = para.oclAsType(Operation)]
						[apiOp.returnType.getTypeName()/] (*[apiOp.getMethodName()/])([for (p : Parameter | apiOp.parameters) separator (',')][p.dataType.getTypeName()/][/for]); /**< A Function Pointer to the API-Call: [apiOp.getName()/] */
					[/let]
					[/if]
				[/for]
			[/let]
		[/if]
	} ;
[/template]


[template private getStateNames (state : State) post(trim())]
[getName(state)/] /**< Represents the State: [state.getName()/] of the Realtime-StateChart: [state.parentStatechart.getName()/] */
[if not (state.simple)],
	[for (innerState : State | state.embeddedRegions.embeddedStatechart.states) separator (',')]
		[getStateNames(innerState)/] 
	[/for]
[/if]
[/template]

[**
 * Generates header of the constructor of the statechart
 * 
 * @param statechart
*/]
[template public constructor (component: Component, rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Creates an Instance of the Realtime-StateChart: [rtsc.getName()/]
 * @details Allocates Memory for the struct [getClassName(rtsc)/]
 * 
 * @param parentComponent An Instance of the Component: [getClassName(component)/] which behavior is described via this Realtime-StateChart
 * @return A Pointer to the new created [getClassName(rtsc)/]
 */
	[getClassName(rtsc)/]* [getCreateMethodName(rtsc)/]([getClassName(component)/]* parentComponent);
[/template]

[template private initialize (rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Initializes an Instance of the Realtime-StateChart: [rtsc.getName()/]
 * @details All struct members of the struct [getClassName(rtsc)/] are initialized,
 *			and all Regions of the Realtime-StateChart are initialized, too.
 * 
 * @param rtsc The specific [getClassName(rtsc)/] to be initialized
 */
	void [getInitializeMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[for (region: Region | rtsc.eAllContents(Region))]
/**
 * @brief Initializes the Region: [region.getName()/] of the Realtime-StateChart: [rtsc.getName()/]
 * @details The Member [getClassName(rtsc)/]::[getVariableName(region.embeddedStatechart)/] is initialized
 * 
 * @param stateChart The specific [getClassName(rtsc)/] whose Region shall be initialized
 */
	void [getInitializeMethodName(region)/]([getSuperClassName(rtsc)/]* stateChart);
[/for]
[/template]

[template private destroy(rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Destroys the Realtime-StateChart: [rtsc.getName()/]
 * @details Frees the Memory for the struct [rtsc.getClassName()/]
 * 
 * @param rtsc The specific [rtsc.getClassName()/] to be destroyed
 */	
	void [getDestroyMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]

[template private process (rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Executes the next Step of the Realtime-StateChart: [rtsc.getName()/]
 * 
 * @param rtsc The specific [rtsc.getClassName()/] to be executed
 */	
void [getProcessMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]

[template private exit (rtsc : RealtimeStatechart) post(trim())]
	[for (region : Region | rtsc.getAllRegions())]
/**
 * @brief Leaves the Region: [region.name/] of the Realtime-StateChart: [rtsc.getName()/]
 * @details This method is called, whenever a the Region: [region.name/] is left.
 * 			The correct State is set and all Exit-Events are executed.
 *
 * @param rtsc The specific [getClassName(rtsc)/] whose Region: [region.name/] shall be exit
 */
	void [getExitMethodName(region)/]([getClassName(rtsc)/]* rtsc);
	[/for]
[/template]

[template private isInState (rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Returns wether the Realtime-StateChart: [rtsc.getName()/] is in a specific State
 * 
 * @param rtsc The specific Realtime-StateChart: [rtsc.getClassName()/]
 * @param state One of the States of the Enum: [getClassName(rtsc, true)/]
 * 
 * @return True, If the Realtime-StateChart is in the specific State, otherwise False
 * @todo  Why is this int and not bool, like everywhere else
 */	
	int [getIsInStateMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc, [getClassName(rtsc, true)/] state);
[/template]

[template private isTerminated (rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Checks if the execution of the Realtime-StateChart: [rtsc.getName()/]  is terminated
 * 
 * @param rtsc The specific Realtime-StateChart: [rtsc.getClassName()/]
 * @return Always True
 * @todo  always true is returned
 */	
bool [getTerminateMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]


