[comment encoding = UTF-8 /]
[**
 * Contains all templates for generating the internal logic of the middleware.
 */]
[module InternalLogic('http://www.fujaba.de/muml/connector/0.4.0', 'http://www.fujaba.de/muml/behavior/0.4.0',
				'http://www.storydriven.org/core/0.3.1',
				'http://www.fujaba.de/muml/actionlanguage/0.4.0',
				'http://www.fujaba.de/muml/msgtype/0.4.0',
				'http://www.fujaba.de/muml/types/0.4.0',
				'http://www.fujaba.de/modelinstance/0.4.0',
				'http://www.fujaba.de/muml/component/0.4.0',
				'http://www.fujaba.de/muml/instance/0.4.0',
				'http://www.fujaba.de/muml/realtimestatechart/0.4.0',
				'http://www.fujaba.de/muml/hardware/1.0/',
				'http://www.fujaba.de/muml/psm/codegen/0.1.0',
				'http://www.fujaba.de/muml/swplatform/0.4.0/',
				'http://www.fujaba.de/muml/psm/0.4.0/')]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::stringQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::modelQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::middlewareQueries]


[**
 * In this template, all sub-templates are called, which are used to generate the files for the InternalLogic (IL)
 * component of the middleware.
 * @param anOclAny
 */]
[template public generateMiddlewareILFiles(rsri : RefinedStructuredResourceInstance, path : String, cgm : CodGenAllocation)]
[generateMiddlewareILHeader(rsri, path)/]
[generateMiddlewareILClass(rsri, path, cgm)/]
[/template]

[**
 * generates the includes for this file.
*/]
[template private includes(rsri :RefinedStructuredResourceInstance)]
#include "stdlib.h"
#include "../lib/MiddlewareTypes.h"
#include "../lib/NetworkInterface.h"
#include "../lib/port.h"
#include "MiddlewareCore.h"
#include "../GlobalIdentifier.h"

[/template]

[**
 * Generates the header file for the InternalLogic of the middleware.
 * @param rsri the (home)-ECU
 * @param path the current file-path for generating files
*/]
[template private generateMiddlewareILHeader(rsri : RefinedStructuredResourceInstance, path : String)]
[file(path+'/Middleware/MiddlewareInternalLogic.h',false,'UTF-8')]
/**
 * @file 
 * @author generated
 * @brief Specification of the Core Functionality of the Middleware
 * @details This files contains the  Functions for Routing and to Identify Ports based on their PortID
 * 
 */
#ifndef MIDDLEWAREINTERNALLOGIC_H_
#define MIDDLEWAREINTERNALLOGIC_H_
[comment include includes/]
[includes(rsri)/]

/**
 * @brief Determines for a PortID the ECUID of the target ECU
 * @details To determine the target ECU a ECU-table, based on the allocation-model
 * For now, only a switch-case statement. 
 * @todo Later this should be implemented in some hash-table to allow changes during runtime.
 * 
 * @param targetPort the PortID of the target Port
 * @return the ECUID of the target ECU
 */
ECUID MW_getTargetECU(PortID targetPort);

/**
 * @brief  Determines the target ECU for Network Communication
 * @details When a Message is received, we have to look if this Messages is for this ECU or shall be forwared to another ECU.
 *          Thus, this Function return the next ECU to which a Message shall be forwarded
 * 
 * @param ecu the ECUID of the target ECU
 * @return the ECUID of the NextStepECU, if the ECU is not reachable -1 is returned
 * @note if the ECU is not reachable -1 is returned
 */
ECUID MW_getNextStepECU(ECUID ecu);

/**
 * @brief Get returns a NetworkInterface which is able to contact the NextStep-ECU
 * @details When the NextStep-ECU is determinded via ECUID MW_getNextStepECU(ECUID ecu), then this Function returns the corresponding NetworkInterface
 *          over which the NextStep-ECU can be contacted
 * 
 * @param ecu the ECUID of an connected ECU
 * @return the NetworkInterface which is able to contact the target ECU directly or indirectly
 */
NetworkInterface* MW_getNetworkInterface(ECUID ecu);

/**
 * @brief Get the Port with the given PortID
 * @details This function returns a Pointer to a Port for a given PortID, thus this Port must belong to a Component which is allocated on this ECU: [rsri.getName()/]
 *          and which is contained in the struct Middleware
 * 
 * @param portID the PortID for which the corresponding Port shall be returned
 * @return A Pointer to the Port with the given PortID, if none could be found NULL
 * @note returns NULL if no Port could be found
 */
Port* MW_getPortforIdentifier(PortID portID);

/**
 * @brief Return the  PortID of a receiving port for a given sender PortID
 * @details This function returns the PortID of every Port, no matter if its allocated on this ECU: [rsri.getName()/] or on any other ECU
 * 
 * @param portID the PortID of the sender Port
 * @return the PortID of the corresponding receiver Port, if no one could be found 0
 * @note returns 0 if no receiver Port could be found
 */
PortID MW_getTargetPortIDforIdentifier(PortID portID);

#endif /* MIDDLEWAREINTERNALLOGIC_H_ */
[/file]
[/template]

[**
 * Generates the implementation file for the InternalLogic of the middleware.
 * @param rsri the (home)-ECU
 * @param path the current file-path for generating files
*/]
[template private generateMiddlewareILClass(rsri : RefinedStructuredResourceInstance, path : String, cgm : CodGenAllocation)]
[file(path+'/Middleware/MiddlewareInternalLogic.c',false,'UTF-8')]
#include "MiddlewareInternalLogic.h"


/*
 * determines the targetECU
 * uses ECU-table, based on the allocation-model
 * For now, only a switch-case statement. Later this should be implemented
 * in some hash-table to allow changes during runtime.
 */
[comment generate switch-case-statement for all possible target-ports, returns the target ECU/]
ECUID MW_getTargetECU(PortID targetPort) {
	switch(targetPort){

	[for (port: PortInstance | cgm.eAllContents(AtomicComponentInstance).portInstances)]
		case [getIdentifierVariableName(port.oclAsType(DiscretePortInstance))/]:
		return [getIdentifierVariableName(port.componentInstance.oclAsType(RefinedAtomicComponentInstance).allocatedResourceInstance)/];
		break;
	[/for]
		default:
			return -1;
		}
}

/*
 * determines the targetECU for network communication
 * uses ECU-table, based on the PDM
 */
ECUID MW_getNextStepECU(ECUID ecu)
{
   switch (ecu) {
[for (ecu: RefinedStructuredResourceInstance | cgm.eAllContents(RefinedStructuredResourceInstance))]
case [getIdentifierVariableName(ecu)/]:
[if ecu=rsri]
	return [getIdentifierVariableName(rsri)/];
[elseif getNextHopEcuJava(rsri, ecu, cgm).oclIsUndefined()]
	return -1;
[else]	
	return [getNextHopEcuJava(rsri, ecu, cgm).oclAsType(RefinedStructuredResourceInstance).getIdentifierVariableName()/];
[/if]
	break;
[/for]
        default:
            return -1;
    }
}

/*
 * returns a network interface which is able to contact the NextStep-ECU
 * uses NI-table, based on PDM
 */
NetworkInterface* MW_getNetworkInterface(ECUID ecu)
{
	switch (ecu)
	{
[for (ecu: RefinedStructuredResourceInstance | cgm.eAllContents(RefinedStructuredResourceInstance))]
[if (ecu = rsri)]
case [getIdentifierVariableName(ecu)/]:
	return mw->intern;
	break;
[else]
case [getIdentifierVariableName(ecu)/]:
[if getNetworkInterfaceJava(rsri, ecu, cgm).oclIsUndefined()]
	return NULL;
[else]
	return mw->[(getNetworkInterfaceJava(rsri, ecu, cgm)).oclAsType(HWPortInstance).getName()/];
[/if]
	break;
[/if]
[/for]
        default: return NULL; 
	}
}

Port* MW_getPortforIdentifier(PortID portID){
    switch (portID) {
[for (port: DiscretePortInstance | rsri.allocatedAtomicComponentInstances.oclAsType(AtomicComponentInstance).eAllContents(DiscretePortInstance))]
case [port.getIdentifierVariableName()/]:
	return mw->[port.componentInstance.getVariableName()/]->[port.portType.getVariableName()/];
	break;
[/for]
        default:
            return NULL;
    }
    
}


/*
* Return the  PortID of a receiving port for a given sender PortID
*
*/
PortID MW_getTargetPortIDforIdentifier(PortID portID){ 
switch (portID) {
      [for (port: PortInstance | cgm.eAllContents(AtomicComponentInstance).portInstances)]
		case [getIdentifierVariableName(port.oclAsType(DiscretePortInstance))/]:
		[comment  get the DiscretePortInstance to which this PortInstance "port" is connected; is always a 1-1 Relation, thus, the first one is choosen/]
		return [getIdentifierVariableName(port.connectorInstances.connectorEndpointInstances->select(portInstance|portInstance<>port)->first().oclAsType(DiscretePortInstance))/];
		break;
	[/for]
        default:
            return -1;
    }
}
[/file]
[/template]

[query public getNetworkInterfaceJava(my_ecu : RefinedStructuredResourceInstance , target_ecu : RefinedStructuredResourceInstance, codegen : CodGenAllocation) : HWPortInstance = 
invoke('de.uni_paderborn.fujaba.muml.model.gen.c.helper.Routing','getNetworkInterface(de.uni_paderborn.fujaba.muml.psm.codegen.RefinedStructuredResourceInstance, de.uni_paderborn.fujaba.muml.psm.codegen.RefinedStructuredResourceInstance, de.uni_paderborn.fujaba.muml.psm.codegen.CodGenAllocation)', Sequence{my_ecu, target_ecu, codegen}) /]
[query public getNextHopEcuJava( my_ecu : RefinedStructuredResourceInstance , target_ecu : RefinedStructuredResourceInstance, codegen : CodGenAllocation,) : RefinedStructuredResourceInstance = 
invoke('de.uni_paderborn.fujaba.muml.model.gen.c.helper.Routing','getNextHopECU(de.uni_paderborn.fujaba.muml.psm.codegen.RefinedStructuredResourceInstance, de.uni_paderborn.fujaba.muml.psm.codegen.RefinedStructuredResourceInstance, de.uni_paderborn.fujaba.muml.psm.codegen.CodGenAllocation)', Sequence{my_ecu, target_ecu, codegen}) /]