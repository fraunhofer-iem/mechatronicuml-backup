[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate_rtsc.
 */]
[module RealtimeStatechart('http://www.fujaba.de/muml/connector/0.4.0', 'http://www.fujaba.de/muml/behavior/0.4.0',
				'http://www.storydriven.org/core/0.3.1',
				'http://www.fujaba.de/muml/actionlanguage/0.4.0',
				'http://www.fujaba.de/muml/msgtype/0.4.0',
				'http://www.fujaba.de/muml/types/0.4.0',
				'http://www.fujaba.de/modelinstance/0.4.0',
				'http://www.fujaba.de/muml/component/0.4.0',
				'http://www.fujaba.de/muml/instance/0.4.0',
				'http://www.fujaba.de/muml/realtimestatechart/0.4.0',
				'http://www.fujaba.de/muml/hardware/1.0/',
				'http://www.fujaba.de/muml/psm/codegen/0.1.0',
				'http://www.fujaba.de/muml/swplatform/0.4.0/',
				'http://www.fujaba.de/muml/psm/0.4.0/')]

[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::stringQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::modelQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::middlewareQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::actionlanguage::expression]


[**
 * Generates the implementation file for a given realtime statechart
 * @param component the component which is embedding the statechart
 * @param rtsc the realtime statechart
 */]
[template public generate_RTSC(component : Component, rtsc : RealtimeStatechart, path : String) post(cdtbeautifier())]
	[file (path+getFileName(rtsc, false, false), false, 'UTF-8')]

		////////////////////////////////////////////////////////////////////////////////
		// Includes
		////////////////////////////////////////////////////////////////////////////////
		[includes(rtsc, component)/]



		[variables(component, rtsc)/]
		////////////////////////////////////////////////////////////////////////////////
		// Initialization
		////////////////////////////////////////////////////////////////////////////////
		[initialize(rtsc)/]

		////////////////////////////////////////////////////////////////////////////////
		// Construction and destruction
		////////////////////////////////////////////////////////////////////////////////
		[constructor(component, rtsc)/]

		[destroy(component, rtsc)/]
	
		////////////////////////////////////////////////////////////////////////////////
		// Processing the statechart
		////////////////////////////////////////////////////////////////////////////////
	
		[verifySyncChannel(component, rtsc)/]

		
		[process(component, rtsc)/]
		
		[exit(component, rtsc)/]		
			
		[isInState(component, rtsc)/]
		[isTerminated(component, rtsc)/]


		[comment getterAndSetter(component, statechart)/]

		[comment connect(component, statechart)/]
	[/file]
[/template]



[**
 * Generates the enum for the statechart.
 * 
 * @param statechart
*/]
[template private variables (comp: Component, rtsc: RealtimeStatechart) post(trim())]	
 
[/template]





[** generates all needed #includes
 * @param component
 * @param rtsc
*/]
[template public includes(rtsc : RealtimeStatechart, component : Component) post(cdtbeautifier())]
	#include <stdio.h>
	#include <stdlib.h>
	#include "../GlobalIdentifier.h"
	#include "[getClassName(rtsc).toLowerFirst()/].h"
[comment TODO/]
	[comment for (syncChannel : SynchronizationChannel | rtsc.states->select(channels->size() > 0)->collect(channels)->select(parameters->size() > 0)->asSet())/]
[comment getFileName(syncChannel., true)/]
	[comment /for/]

[/template]



[** generates the initialize methods for the realtime statechart and all its regions
 * @param rtsc the realtime statechart
*/]
[template private initialize (rtsc : RealtimeStatechart) post(cdtbeautifier())]
	
	[for (region: Region | rtsc.eAllContents(Region))]
		 		[let firstState : State = region.embeddedStatechart.getInitalState()]
			[if not (region.embeddedStatechart.oclIsUndefined())]
				void [getInitializeMethodName(region)/]([getSuperClassName(rtsc)/]* stateChart) {
				[comment Member variables for the clocks of each region. /]
				[for (clock : Clock | region.embeddedStatechart.clocks->collect(oclAsType(Clock)))]
					Clock_reset(stateChart->[getVariableName(clock)/]);
				[/for]

			
				[comment TODO Member variables for the clocks of do actions. /]
				[for (state : State | region.embeddedStatechart.states) ? (not state.doEvent.oclIsUndefined())]					
					Clock_reset(stateChart->[getClockVariableName(state)/]);
				[/for]

				[comment Member variables for the variables of each region. /]	
				[for (variable : Variable | region.embeddedStatechart.variables->collect(oclAsType(Variable)))]
					stateChart->[getVariableName(variable)/] = [getDefaultValue(variable)/];
				[/for]
			
			
			[else]
				static void [getInitializeMethodName(region)/]([getSuperClassName(rtsc)/]* stateChart) {
			[/if]
				stateChart->[getVariableName(region)/] = [getName(firstState)/];

				[entryActions(rtsc, firstState)/]

				[for (innerRegion : Region | firstState.embeddedRegions)]
					[getInitializeMethodName(innerRegion)/](stateChart);
				[/for]
			}
 		[/let]
	[/for]



[comment init for rootStateChart/]
[let firstState : State = rtsc.getInitalState()] 
				void [getInitializeMethodName(rtsc)/]([getSuperClassName(rtsc)/]* stateChart) {
				[comment Member variables for the clocks of each region. /]
				[for (clock : Clock | rtsc.clocks->collect(oclAsType(Clock)))]
					Clock_reset(stateChart->[getVariableName(clock)/]);
				[/for]
			
				[comment TODO Member variables for the clocks of after transitions. /]	

			
				[comment TODO Member variables for the clocks of do actions. /]
				[for (state : State | rtsc.states) ? (not state.doEvent.oclIsUndefined())]					
					Clock_reset(stateChart->[getClockVariableName(state)/]);
				[/for]

				[comment Member variables for the variables of each region. /]	
				[for (variable : Variable | rtsc.variables->collect(oclAsType(Variable)))]
					stateChart->[getVariableName(variable)/] = [getDefaultValue(variable)/];
				[/for]
			

				stateChart->[getVariableName(rtsc)/] = [getName(firstState)/];

				[entryActions(rtsc, firstState)/]

				[for (innerRegion : Region | firstState.embeddedRegions)]
					[getInitializeMethodName(innerRegion)/](stateChart);
				[/for]
			}
 		[/let]

[/template]


[** generates the constructor for a realtime statechart
 * @param rtsc the realtime statechart
*/]
[template public constructor (component : Component, rtsc : RealtimeStatechart) post(cdtbeautifier())]
	[getClassName(rtsc)/]* [getCreateMethodName(rtsc)/]([getClassName(component)/]* parentComponent) {
		[getClassName(rtsc)/]* stateChart = ([getClassName(rtsc)/]*)malloc(sizeof([getClassName(rtsc)/]));
		if (stateChart != NULL) {
			stateChart->parentComponent = parentComponent;
		
			[for (syncChannel : SynchronizationChannel | rtsc.eAllContents(State)->collect(channels)->asSet())]
				stateChart->[getVariableName(syncChannel)/] = [getCreateMethodName(syncChannel)/]();
			[/for]			
	/*
			if (stateChart->parentComponent != NULL
				[for (syncChannel : SynchronizationChannel | rtsc.eAllContents(State)->collect(channels)->asSet())]
					&& stateChart->[getVariableName(syncChannel)/] != NULL				
				[/for]			 
			) {
				[getInitializeMethodName(rtsc)/](stateChart);
			} else {
				fprintf(stderr, "Initialization of [getClassName(rtsc)/] failed\n");

				[getDestroyMethodName(rtsc)/](stateChart);
				stateChart = NULL;
			}
		} else {
			fprintf(stderr, "Creation of [getClassName(rtsc)/] failed\n");
		*/}
		return stateChart;
	}
[/template]


[** generates the destructor for a realtime statechart
 * @param component
 * @param rtsc
*/]
[template private destroy(component : Component, rtsc:RealtimeStatechart)]
	void [getDestroyMethodName(rtsc)/]([getSuperClassName(rtsc)/]* stateChart) {
		if(stateChart != NULL) {
		[for (syncChannel : SynchronizationChannel | rtsc.eAllContents(State)->collect(channels)->asSet())]
			[getDestroyMethodName(syncChannel)/](stateChart->[getVariableName(syncChannel)/]);
		[/for]

			free(stateChart);
		}
	}
[/template]

[** generates the processStep-methods for a realtime statechart and all its regions. This methode will execute one execution
 * step of the statechart / of a region
 *
 * @param component
 * @param rtsc the realtime statechart
*/]
[template private process (component: Component, rtsc : RealtimeStatechart) post(cdtbeautifier())]
[for (state : State | rtsc.states)]
				[if (not state.oclAsType(State).simple)]
					[for (region : Region | state.embeddedRegions)]
						[process(component, region.embeddedStatechart)/]
					[/for]
				[/if]
		[/for]
		 void [getProcessMethodName(rtsc)/]([getSuperClassName(rtsc)/]* stateChart) {
			switch (stateChart->[getVariableName(rtsc)/]) {
				[for (state : State | rtsc.states)]
					case [getName(state)/]:
						[if (state.outgoingTransitions->size() > 0)]
							[for (outgoingTransition : Transition | state.outgoingTransitions->sortedBy(priority)->reverse()) separator(' else ')]
								if ( [transitionCondition(component, rtsc, outgoingTransition, true)/] ) {
						    		[transition(component, outgoingTransition)/]
								}
							[/for] 
							else {
						[/if]
						[comment @TODO doActions/]
						// execute do action
						[if (not state.doEvent.oclIsUndefined())]
							//do event...clocks....
						[else]
							// nothing to do
						[/if]

						[if (state.channels->size() > 0)]
							[getVerifyMethodName(state)/](stateChart);
						[/if]
					
						[comment Execute the inner regions /]	
						[for (reg : Region | state.embeddedRegions->sortedBy(priority)->reverse())]
							[getProcessMethodName(reg.embeddedStatechart)/](stateChart);
						[/for]


						[if (state.outgoingTransitions->size() > 0)]
							}
						[/if]
					break;
				[/for]
				default: break;
			}
		}		
[/template]

[**
 * Generates the verify methods for each state with synchronization channels. This methods checks, 
 * if a synchornization channel is enabled
 * 
 * @param component
 * @param statechart
*/]
[template private verifySyncChannel (component : Component, rtsc : RealtimeStatechart) post(cdtbeautifier())]
	[for (state : State | rtsc.eAllContents(State)) ? (state.channels->size()>0)]
		static void [getVerifyMethodName(state)/]([getSuperClassName(rtsc)/]* stateChart) {
			[for (syncChannel : SynchronizationChannel | state.channels)]
				// [getName(syncChannel)/] synchronization channel
				[for (region : Region |	state.embeddedRegions->sortedBy(priority)->reverse())]
					[for (transition : Transition | region.embeddedStatechart->collect(transitions)) separator (' else ') ? (transition.synchronization.kind.toString() = 'SEND' and transition.synchronization.syncChannel = syncChannel)]
						if (stateChart->[getVariableName(transition.statechart)/] == [getName(transition.source.oclAsType(State))/] [transitionCondition(component, rtsc, transition, false)/]) {							
							[getClassName(syncChannel)/]_enableSend(stateChart->[getVariableName(syncChannel)/]);
						}									
					[/for]					
				[/for]
				[for (region : Region |	state.embeddedRegions->sortedBy(priority)->reverse())]
					[for (transition : Transition | region.embeddedStatechart->collect(transitions)) separator (' else ') ? (transition.synchronization.kind.toString() = 'RECEIVE' and transition.synchronization.syncChannel = syncChannel)]
						if (stateChart->[getVariableName(transition.statechart)/] == [getName(transition.source.oclAsType(State))/] [transitionCondition(component, statechart, transition, false)/]) {
							SyncChannel_enableReceive(stateChart->[getVariableName(syncChannel)/]);
						}				
					[/for]
				[/for]
			[/for]			
		}
	[/for]
[/template]

[** generates all needed commands for fireing a transition. This includes all events, actions
 * clock resets and changing the state 
 *
 * @param component
 * @param rtsc
*/]
[template private transition (component : Component, transition : Transition) post(cdtbeautifier()) {
	source : Vertex = transition.source; 
	target : Vertex = transition.target;
	targetRTSC : RealtimeStatechart = target.oclAsType(State).parentStatechart;
	targetParentState : State = target.eContainer(State);
	rtsc : RealtimeStatechart = transition.eContainer(RealtimeStatechart);
}]
	
	[comment Trigger events /]
	[if (not transition.triggerMessageEvent.oclIsUndefined())]	
	[let msg: Message = transition.triggerMessageEvent.message]
		MiddlewareMessage* mwMsg = Port_receiveMessage([getGetterName(getPortForRegion(transition.statechart.parentRegion))/](stateChart->parentComponent),[msg.instanceOf.getIdentifierVariableName()/]);				
		
		[if msg.instanceOf.parameters->size() > 0]
			struct [msg.instanceOf.getTypeName()/] *  msg = ([msg.instanceOf.getTypeName()/]*) malloc(sizeof(struct [msg.instanceOf.getTypeName()/]));
			[msg.instanceOf.getUnmarshallingMethodName()/](mwMsg->_mumlMsg, msg, 0);
			[comment do something with the message/]
		[/if]
//printf("received message of type %d",mwMsg->_msgID );
				fflush(stdout);		
	[/let]
	[/if]

	[comment Exit actions/]	
	[if (source.oclIsTypeOf(State))]
		// execute exit actions
		[exitActionRecursive(component, rtsc, source.oclAsType(State))/]
	[/if]	

	[comment Transition effects/]
	// Transition Effects (incl. clock resets)
	[if (not (transition.action.oclIsUndefined() and transition.clockResets->isEmpty()))]
	[if (not (transition.action.oclIsUndefined()))]
	
	[for (exp : Expression | transition.action.expressions)]
			[generateExpression(exp, '')/];

	
	[/for]

	[/if]
	[for (clock : Clock |  transition.clockResets)]
		Clock_reset(stateChart->[getVariableName(clock)/]);
	[/for]
	[else]
		// nothing to do
	[/if]
	
	[comment Raise events/]	
		[if (not transition.raiseMessageEvent.oclIsUndefined())]	
			[for (msg : Message | transition.raiseMessageEvent.message)]
				[if msg.instanceOf.parameters->size() > 0]
					//create new Parameter struct for [msg.instanceOf.getStructName()/]
					struct [msg.instanceOf.getStructName()/] *  msg = ([msg.instanceOf.getTypeName()/]*) malloc(sizeof(struct [msg.instanceOf.getTypeName()/]));
					[comment parameter binding to message parameters/]
					[for (pb : ParameterBinding | msg.parameterBinding)]
						msg->_[pb.parameter.getName()/] = [generateExpression(pb.value, '')/];
					[/for]
				[/if]

				//send Message
				MW_sendMessage(MW_getTargetPortIDforIdentifier(stateChart->parentComponent->[getVariableName(getPortForRegion(transition.statechart.parentRegion))/]->ID),[msg.instanceOf.getIdentifierVariableName()/],[if msg.instanceOf.parameters->size() > 0] msg[else]NULL[/if]);
				//printf("sent message of type %d",[msg.instanceOf.getIdentifierVariableName()/] );
				fflush(stdout);			
[/for]

		[else]
			// nothing to do			
		[/if]

		[comment release Trigger events /]
//release all created received events
	[if (not transition.triggerMessageEvent.oclIsUndefined())]	
	[let msg: Message = transition.triggerMessageEvent.message]	
		[if msg.instanceOf.parameters->size() > 0]
		free(msg);
		[/if]
		free(mwMsg);

	[/let]
	[/if]	
		[comment release Trigger events /]
//release all created sent events
	[if (not transition.raiseMessageEvent.oclIsUndefined())]	
	[let msg: Message = transition.raiseMessageEvent.message]	
		[if msg.instanceOf.parameters->size() > 0]
		free(msg);
		[/if]
	[/let]
	[/if]	
	[comment State change /]	
	// change the state
	[if (transition.target.oclIsKindOf(State))]		
		stateChart->[getVariableName(targetRTSC)/] = [getName(transition.target.oclAsType(State))/];
	[elseif (transition.target.oclIsTypeOf(EntryPoint))]
		stateChart->[getVariableName(target.oclAsType(EntryPoint).state.parentStatechart)/] = [getName(transition.target.oclAsType(EntryPoint).state)/];
	[/if]

	[if (target.oclIsTypeOf(State))]		
		[entryActionsRecursive(rtsc, target.oclAsType(State))/]
	[elseif (target.oclIsTypeOf(EntryPoint))]
		[entryActions(rtsc, targetParentState)/]
		[for (t : Transition | target.outgoingTransitions)]
		[transition(component, t)/]		
		[/for]
	[elseif (target.oclIsTypeOf(ExitPoint))]
		[exitAction(component, rtsc, targetParentState)/]
		[transition(component, target.outgoingTransitions->first())/]
	[/if]

[/template]


[** generates the condition for a given transition
 * @param component
 * @param rtsc the realtime statechart
 * @param transition the transition
 * @param sync is a sync channel used?
*/]
[template public transitionCondition (component:Component, rtsc : RealtimeStatechart, transition : Transition, sync : Boolean )]
	[if (transition.triggerMessageEvent->size()=0 and transition.clockConstraints->size()=0 and transition.guard.oclIsUndefined() and transition.synchronization.oclIsUndefined())]
		1
	[elseif (sync  and (transition.synchronization.kind.toString() = 'SEND'))]
		SyncChannel_send((SyncChannel*) stateChart->[getVariableName(transition.synchronization.syncChannel)/])
	[elseif (sync and (transition.synchronization.kind.toString() = 'RECEIVE'))]
		SyncChannel_receive((SyncChannel*) stateChart->[getVariableName(transition.synchronization.syncChannel)/])	
	[else]
		[if (not sync and (transition.triggerMessageEvent->notEmpty() or transition.clockConstraints->notEmpty() or transition.guard->notEmpty()))]
			&&
		[/if]
		[comment checks for trigger events /]	
		[if (transition.triggerMessageEvent->size()>0)]	
		[for (msg : Message | transition.triggerMessageEvent.message) separator(' && ')]			
			Port_doesMessageExist([getGetterName(getPortForRegion(transition.statechart.parentRegion))/](stateChart->parentComponent), [msg.instanceOf.getIdentifierVariableName()/])
		[/for]
		[/if]

		[comment checks the clock guard /]		
		[if (transition.clockConstraints->size()>0)]
	 		[if (transition.triggerMessageEvent->size() > 0)]
			 &&
			[/if]
	 		[getClockConstraint(rtsc, transition)/]
		[/if]

		[comment checks the conditional guard/]		
		[if (transition.guard->size()>0)]
	 		[if (transition.clockConstraints->size()>0 or transition.triggerMessageEvent->size() > 0)]
	 		&&
			[/if]
	 		[getGuardConstraint(component, rtsc, transition)/]

	    [/if]
	[/if] 
[/template]


[**
 * generates a clock clock constraint for a given transition
 * @param rtsc the realtime statechart
 * @param transition the transition 
*/]
[template private getClockConstraint(rtsc : RealtimeStatechart, transition : Transition) post(cdtbeautifier())]
	[if (transition.clockConstraints->size()>0)]
	[for (clockCons : ClockConstraint | transition.clockConstraints) separator (' && ')]Clock_getTime(stateChart->[clockCons.clock.getVariableName()/])[clockCons.operator.getOpSymbol()/][clockCons.bound.value.generateExpression('')/] * [clockCons.bound.getTimeUnitFactor()/] [/for]
	[/if]
[/template]


[**
 * generates a guard constraint for a given transition
 * @param rtsc the realtime statechart
 * @param transition the transition 
*/]
[template private getGuardConstraint(component: Component, rtsc : RealtimeStatechart, transition : Transition) post(cdtbeautifier())]
[getGuardExpression(transition.guard)/]
[/template]

[**
 * Generates a guard 

ion
 * @param expression the expression
*/]
[template public getGuardExpression(expression : Expression)]
[if expression.oclIsKindOf(ComparisonExpression) or expression.oclIsKindOf(LogicalExpression)]
	[generateExpression(expression, '')/]
[elseif expression.oclIsKindOf(Block)]
	[expression.oclAsType(Block).expressions->at(1).getGuardExpression()/]
[elseif expression.oclIsKindOf(LiteralExpression)]
	[expression.oclAsType(LiteralExpression).value/]
[elseif expression.oclIsKindOf(OperationCall)]
[expression.generateExpression('')/]
[/if]

[/template]



[**
 * Performs the entry behaviour of the state.
 * 
 * @param component 
 * @param statechart
 * @param state
*/]
[template private entryActions(rtsc : RealtimeStatechart, state : State) post(cdtbeautifier())]
	// execute entry actions
	[if (state.entryEvent.oclIsUndefined() or ( state.entryEvent.action.oclIsUndefined() and state.entryEvent.clockResets->isEmpty() ))]
		// nothing to do
	[else]				
		[if (not state.entryEvent.action.oclIsUndefined())]
			[for (exp : Expression | state.entryEvent.action.expressions)]			
			[generateExpression(exp, '')/];
			[/for]
		[/if]				
		
		[comment clock reset/]		
		[for (clock : Clock | state.entryEvent.clockResets)]
			Clock_reset(stateChart->[getVariableName(clock)/]);
		[/for]
	[/if]
[/template]

[**
 * Performs the entry behaviour of the state and activates all inner regions. 
 * 
 * @param component 
 * @param statechart
 * @param state
*/]
[template private entryActionsRecursive(rtsc : RealtimeStatechart, state : State) post(cdtbeautifier())]
	[entryActions(rtsc, state)/]
	[for (innerReg : Region | state.getInnerRegions() )]
			[getInitializeMethodName(innerReg)/](stateChart);
	[/for]
[/template]

[**
 * Performs the exit behaviour of the state.
 * 
 * @param component 
 * @param statechart
 * @param state
*/]
[template private exitAction(component : Component, rtsc : RealtimeStatechart, state : State) post(cdtbeautifier()){
exp : Expression = state.exitEvent.action.expressions->at(1);
}]
	[if (state.exitEvent.oclIsUndefined() or state.exitEvent.action.oclIsUndefined() and state.exitEvent.clockResets->size()=0)]
		// nothing to do
	[else]
		[if (not (state.exitEvent.action.oclIsUndefined()))]
			[generateExpression(exp, '')/];
		[/if]
		[for (clock : Clock | state.exitEvent.clockResets)]
			Clock_reset(stateChart->[getVariableName(clock)/]);
		[/for]
	[/if]
[/template]

[**
 * Performs the exit behaviour of the state and calls the exit functions of all sub regions.
 * 
 * @param component 
 * @param statechart
 * @param state
*/]
[template private exitActionRecursive(component : Component, rtsc : RealtimeStatechart, state : State) post(cdtbeautifier())]
	[exitAction(component, rtsc, state)/]	
[for (innerReg : Region | state.getInnerRegions())]
		[getExitMethodName(innerReg)/](stateChart);
	[/for]
[/template]

[**
 * Generates the exit methods for the statechart and each region, if necessary.
 * 
 * @param component
 * @param rtsc
*/]
[template private exit (component : Component, rtsc : RealtimeStatechart) post(cdtbeautifier())]
	[for (region : Region | rtsc.getAllRegions())]
		 void [getExitMethodName(region)/]([getClassName(rtsc)/]* stateChart) {
			switch (stateChart->[getVariableName(region)/]) {
				[for (innerState : State | region.embeddedStatechart.states)]
					case [getName(innerState)/]:
						[exitActionRecursive(component, rtsc, innerState)/]
						break;
				[/for]
				default: break;
			}
		}
	[/for]
[/template]

[**
 * Generates the isInState method.
 * 
 * @param component
 * @param statechart
*/]
[template private isInState (component : Component, rtsc : RealtimeStatechart) post(cdtbeautifier())]
	int_t [getIsInStateMethodName(rtsc)/]([getSuperClassName(rtsc)/]* stateChart, [getSuperClassName(rtsc, true)/] state) {
		[if (rtsc.getAllRegions()->size()>0)]
		return ([for (region : Region | rtsc.getAllRegions()->collect(oclAsType(Region))) separator (' || ')]stateChart->[getVariableName(region)/] == state[/for]);
		[else]
		return (stateChart->[getVariableName(rtsc)/] == state);
		[/if]	

} 
[/template]

[template private isTerminated (component : Component, rtsc : RealtimeStatechart) post(cdtbeautifier())]
	bool_t [getTerminateMethodName(rtsc)/]([getSuperClassName(rtsc)/]* stateChart) {
		//TODO
	return true;
} 
[/template]


[template private getRegionVariables (rtsc: RealtimeStatechart, state : State) post(cdtbeautifier())]
	[if (not state.oclAsType(State).simple)]
		[for (region : Region | state.embeddedRegions)]	
			[getClassName(rtsc, true)/] [getVariableName(region.embeddedStatechart)/];
				[for (innerState : State | region.embeddedStatechart.states)]
					[getRegionVariables(rtsc, state)/]
				[/for]
		[/for]
	[/if]
[/template]



