/*
 * generated by Xtext
 */
package org.muml.uppaal.trace.scoping;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.muml.uppaal.NTA;
import org.muml.uppaal.core.NamedElement;
import org.muml.uppaal.core.TypedElement;
import org.muml.uppaal.declarations.Declaration;
import org.muml.uppaal.declarations.Declarations;
import org.muml.uppaal.declarations.TypedDeclaration;
import org.muml.uppaal.declarations.Variable;
import org.muml.uppaal.expressions.Expression;
import org.muml.uppaal.expressions.IdentifierExpression;
import org.muml.uppaal.templates.AbstractTemplate;
import org.muml.uppaal.templates.RedefinedTemplate;
import org.muml.uppaal.templates.Template;
import org.muml.uppaal.trace.LocationActivity;
import org.muml.uppaal.trace.NamedElementReference;
import org.muml.uppaal.trace.ProcessIdentifier;
import org.muml.uppaal.trace.SingleNamedElementReference;
import org.muml.uppaal.types.StructTypeSpecification;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class DiagnosticTraceScopeProvider extends
		AbstractDeclarativeScopeProvider {

	private NTA nta;

	public void setNTA(NTA nta) {
		this.nta = nta;
	}

	private NTA getNTA() {
		return nta;
	}

	@Override
	public IScope getScope(EObject context, EReference reference) {
		IScope scope = super.getScope(context, reference);
		return scope;
	}

	List<AbstractTemplate> getTemplates(NTA nta) {

		List<AbstractTemplate> templates = new ArrayList<AbstractTemplate>();

		Iterator<EObject> iterator = nta.eAllContents();

		while (iterator.hasNext()) {

			EObject eObject = iterator.next();

			if (eObject instanceof AbstractTemplate) {
				templates.add((AbstractTemplate) eObject);
			}

		}

		return templates;

	}

	private Template getBaseTemplate(AbstractTemplate abstractTemplate) {

		if (abstractTemplate instanceof Template) {
			return (Template) abstractTemplate;
		}

		if (abstractTemplate instanceof RedefinedTemplate) {
			return getBaseTemplate(((RedefinedTemplate) abstractTemplate)
					.getReferredTemplate());
		}

		return null;

	}

	IScope scope_AbstractTemplate(ProcessIdentifier process, EReference ref) {

		return Scopes.scopeFor(getTemplates(getNTA()));

	}

	IScope scope_Location(LocationActivity locationActivity, EReference ref) {

		ProcessIdentifier process = locationActivity.getProcess();

		if (process != null) {

			Template baseTemplate = getBaseTemplate(process.getTemplate());

			return Scopes.scopeFor(baseTemplate.getLocation());

		}

		return IScope.NULLSCOPE;
	}

	IScope scope_ProcessIdentifier_template(EObject eObject, EReference ref) {

		return Scopes.scopeFor(getTemplates(getNTA()));

	}

	IScope scope_SingleNamedElementReference_namedElement(
			NamedElementReference namedElementReference, EReference ref) {

		SingleNamedElementReference singleReference = namedElementReference
				.getSingleNamedElementReference();

		NamedElement namedElement = singleReference.getNamedElement();

		return Scopes.scopeFor(getVariables(namedElement));

	}

	IScope scope_SingleNamedElementReference_namedElement(EObject eObject,
			EReference ref) {

		List<NamedElement> namedElements = new ArrayList<NamedElement>();

		namedElements.addAll(getGlobalVariables(getNTA()));
		namedElements.addAll(getTemplates(getNTA()));

		return Scopes.scopeFor(namedElements);

	}

	List<Variable> getVariables(NamedElement namedElement) {

		if (namedElement instanceof NTA) {
			return getGlobalVariables((NTA) namedElement);
		}

		if (namedElement instanceof AbstractTemplate) {
			return getLocalVariables((AbstractTemplate) namedElement);
		}

		if (namedElement instanceof Variable) {
			return getFields((Variable) namedElement);
		}

		return Collections.emptyList();

	}

	List<Variable> getGlobalVariables(NTA nta) {

		List<Variable> variables = new ArrayList<Variable>();

		Iterator<EObject> iterator = nta.eAllContents();

		while (iterator.hasNext()) {

			EObject eObject = iterator.next();

			if (eObject instanceof Variable) {
				variables.add((Variable) eObject);
			}

		}

		return variables;

	}

	List<Variable> getLocalVariables(AbstractTemplate abstractTemplate) {

		List<Variable> variables = new ArrayList<Variable>();

		Template template = getBaseTemplate(abstractTemplate);

		Declarations declarations = template.getDeclarations();

		for (Declaration declaration : declarations.getDeclaration()) {

			if (declaration instanceof TypedDeclaration) {

				TypedDeclaration typedDeclaration = (TypedDeclaration) declaration;

				for (TypedElement variable : typedDeclaration.getElements()) {
					if (variable instanceof Variable) {
						variables.add((Variable) variable);
					}
				}

			}

		}

		return variables;

	}

	List<Variable> getFields(Variable variable) {

		List<Variable> fields = new ArrayList<Variable>();

		Expression typeDefinition = variable.getTypeDefinition();

		boolean done = false;
		while (!done) {
			done = true;

			if (typeDefinition instanceof IdentifierExpression) {
				IdentifierExpression identifier = (IdentifierExpression) typeDefinition;

				if (identifier.getIdentifier() instanceof TypedElement) {
					TypedElement element = (TypedElement) identifier
							.getIdentifier();

					if (element.getTypeDefinition() instanceof IdentifierExpression
							|| element.getTypeDefinition() instanceof StructTypeSpecification) {
						typeDefinition = element.getTypeDefinition();
						done = false;
					}
				}
			} else if (typeDefinition instanceof StructTypeSpecification) {
				StructTypeSpecification struct = (StructTypeSpecification) typeDefinition;

				for (TypedDeclaration typedDeclaration : struct
						.getDeclaration()) {

					for (TypedElement var : typedDeclaration.getElements()) {
						if (var instanceof Variable) {
							fields.add((Variable) var);
						}
					}
				}
			}
		}

		// TypeSpecification typeSpecification = getTypeSpecification(variable
		// .getTypeDefinition());
		//
		// if (typeSpecification instanceof StructTypeSpecification) {
		//
		// StructTypeSpecification struct = (StructTypeSpecification)
		// typeSpecification;
		//
		// for (DataVariableDeclaration declaration : struct.getDeclaration()) {
		// fields.addAll((declaration.getVariable()));
		// }
		//
		// }

		return fields;

	}

	// TypeSpecification getTypeSpecification(Expression typeDefinition) {
	//
	// if (typeDefinition instanceof TypeSpecification) {
	// return (TypeSpecification) typeDefinition;
	// }
	//
	// if (typeDefinition instanceof TypeReference) {
	//
	// Type type = ((TypeReference) typeDefinition).getReferredType();
	//
	// if (type instanceof DeclaredType) {
	//
	// return getTypeSpecification(((DeclaredType) type)
	// .getTypeDefinition());
	//
	// }
	//
	// }
	//
	// return null;
	//
	// }

}
