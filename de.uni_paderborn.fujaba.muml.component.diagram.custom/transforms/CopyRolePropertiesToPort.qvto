modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.2.2');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.2.2');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.2.2');
modeltype RTSCPackage uses muml::realtimestatechart('http://www.fujaba.de/muml/0.2.2');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.2.2');
modeltype TypesPackage uses muml::types("http://www.fujaba.de/muml/0.2.2");
modeltype ValuetypePackage uses muml::valuetype("http://www.fujaba.de/muml/0.2.2");
modeltype MessageTypePackage uses muml::msgtype("http://www.fujaba.de/muml/0.2.2");
modeltype BehaviorPackage uses muml::behavior("http://www.fujaba.de/muml/0.2.2");

modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.3.15");

transformation CopyRolePropertiesToPort(inout input : ModelInstancePackage);

main() {

	-- parse input parameters
	var thePort : DiscretePort := input.objects()[DiscretePort] -> any(true);
	var theRootNode : RootNode := input.objects()[RootNode] -> any(true);

	-- copy the role properties
	copyRolePropertiesToPort(thePort, theRootNode);
}

-- copies all relevant role properties to the port
helper copyRolePropertiesToPort(inout thePort : DiscretePort, inout theRootNode : RootNode){
	
	-- get role
	var theRole := thePort.refinedRole;
	
	-- cardinality
	thePort.cardinality.lowerBound.value := theRole.cardinality.lowerBound.value;
	thePort.cardinality.upperBound.value := theRole.cardinality.upperBound.value;
	
	-- receiver message types
	var recvMsgTypes : OrderedSet(MessageType);
	theRole.receiverMessageTypes -> forEach(msgType){
		recvMsgTypes += msgType;
	};
	thePort.receiverMessageTypes := recvMsgTypes;
	
	-- sender message types
	var senderMsgTypes : OrderedSet(MessageType);
	theRole.senderMessageTypes -> forEach(msgType){
		senderMsgTypes += msgType;
	};
	thePort.senderMessageTypes := senderMsgTypes;
	
	-- copy behavior specification
	copyBehavior(theRole, thePort, theRootNode);
}


-- copies the behavior of the role into the port if the port belongs to an atomic component
helper copyBehavior(inout theRole : Role, inout thePort : DiscretePort, inout theRootNode : RootNode){

	if(thePort.component.oclIsKindOf(AtomicComponent)) then {
		-- copy real-time statechart
		if(thePort.cardinality.upperBound.value = 1) then{
			-- single port, RTSC is referenced by behavior reference
			thePort.behavior := (theRole.behavior.deepclone()).oclAsType(RealtimeStatechart);
			
			-- contain in resource
			storeRealtimeStatechart(thePort.behavior.oclAsType(RealtimeStatechart), theRootNode, thePort.component.oclAsType(AtomicComponent));
			
			-- adjust name
			thePort.behavior.oclAsType(RealtimeStatechart).name := thePort.behavior.oclAsType(RealtimeStatechart).name + '_' + thePort.name;
		} else {
			-- multi port, RTSC is referenced by roleAndAdaptationBehavior
			thePort.roleAndAdaptationBehavior := (theRole.roleAndAdaptationBehavior.deepclone()).oclAsType(RealtimeStatechart);
			
			-- contain copied RTSC in resource
			storeRealtimeStatechart(thePort.roleAndAdaptationBehavior.oclAsType(RealtimeStatechart), theRootNode, thePort.component.oclAsType(AtomicComponent));
			
			-- set behavior and adaptationBehavior references
			thePort.behavior := getMultiPortBehaviorRTSC(theRole, thePort);
			thePort.adaptationBehavior := getMultiPortAdaptationRTSC(theRole, thePort);
			
			-- adjust name
			thePort.roleAndAdaptationBehavior.oclAsType(RealtimeStatechart).name := thePort.roleAndAdaptationBehavior.oclAsType(RealtimeStatechart).name + '_' + thePort.name;
		} endif;
	} endif;
}

-- this mapping ensures that the port RTSC will be contained in the resource at the right place
helper storeRealtimeStatechart(inout rtsc : RealtimeStatechart, inout theRootNode : RootNode, inout component : AtomicComponent){
	-- contain in resource: either hook into component RTSC or put into the RTSC category
	if(component.behavior.oclIsUndefined()) then{
		var category : ModelElementCategory := getRTSCCategory(theRootNode);
		category.modelElements += rtsc;
	} else {
		-- obtain component RTSC
		var componentRTSC: RealtimeStatechart := component.behavior.oclAsType(RealtimeStatechart);
		componentRTSC.states -> forEach(state){
			-- search initial state and add new region containing the statechart to it
			if(state.initial = true) then{
				var newRegion : Region := new Region();
				state.embeddedRegions += newRegion;
				newRegion.embeddedStatechart := rtsc;
			} endif;
		}
		
	}endif;
}

-- returns the RTSC of a multi-port corresponding to the behavior RTSC of a multirole 
query getMultiPortBehaviorRTSC(in theRole : Role, in thePort : DiscretePort) : RealtimeStatechart{
	-- obtain RTSC name
	var rtscName := theRole.behavior.oclAsType(RealtimeStatechart).name;
	
	-- search in port RTSC
	thePort.roleAndAdaptationBehavior.oclAsType(RealtimeStatechart).states -> forEach(state){
		state.embeddedRegions -> forEach(region){
			if(region.embeddedStatechart.name = rtscName) then{
				return region.embeddedStatechart;
			} endif;
		}
	};
	
	return null;
} 

-- returns the RTSC of a multi-port corresponding to the adaptation RTSC of a multirole 
query getMultiPortAdaptationRTSC(in theRole : Role, in thePort : DiscretePort) : RealtimeStatechart{
	-- obtain RTSC name
	var rtscName := theRole.adaptationBehavior.oclAsType(RealtimeStatechart).name;
	
	-- search in port RTSC
	thePort.roleAndAdaptationBehavior.oclAsType(RealtimeStatechart).states -> forEach(state){
		state.embeddedRegions -> forEach(region){
			if(region.embeddedStatechart.name = rtscName) then{
				return region.embeddedStatechart;
			} endif;
		}
	};
	
	return null;
} 

-- return the RTSC category of the root node
query getRTSCCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.realtimestatechart.category') -> any(true);
}

-- constructor for creating new regions
constructor Region::Region() {
	
}