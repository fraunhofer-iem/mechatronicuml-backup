transformation InstantiationTransformation(inout input : ComponentPackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');

modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
	input.rootObjects()[ComponentPart]->forEach(part) {
		// IMPORTANT: Before replacing existing portParts, make sure that those portParts
		// that will be removed after the replacement are also removed from the resource.
		// See MUML #564
		part.portParts->forEach(p) {
			-- only delete those port parts whose port type is not contained in the current component type (see #591)
			if (part.componentType.ports ->excludes(p.portType)) then {
				// also remove from coordination protocol occurrence
				part.parentComponent.coordinationProtocolOccurences->forEach(c) {
					c.portParts := c.portParts->excluding(p); 
				};
				
				// Remove all its connectors
				var connectors : Set(Connector) := p.connectors;
				connectors->forEach(c) {
					c.connectorEndpoints := Set { };
					if (c.oclIsKindOf(PortConnector)) then {
						part.parentComponent.connectors := part.parentComponent.connectors->excluding(c.oclAsType(PortConnector));
					} endif;
				};
				
				// remove from resource
				input.removeElement(p);
			}endif;
		};
		
		// and from connectors
		
				
		// Remove stale coordinationProtocolOccurrences
		part.parentComponent.coordinationProtocolOccurences := part.parentComponent.coordinationProtocolOccurences->reject(portParts->isEmpty());
		
		// Replace existing portParts with newly created portParts
		createPortParts(part);
		
		// Create CoordinationProtocolOccurrences a.k.a CoordinationProtocolParts and associate PortParts
		part.portParts->forEach(p) {
			if (p.portType.oclIsKindOf(DiscretePort) and p.coordinationProtocolOccurence.oclIsUndefined()) then {
				var coordinationProtocol : CoordinationProtocol := p.portType.oclAsType(DiscretePort).refinedRole.coordinationProtocol.oclAsType(CoordinationProtocol);
				if (not coordinationProtocol.oclIsUndefined()) then {
					// Try to find an existing protocol part (was occurrence) for this protocol
					p.coordinationProtocolOccurence := part.parentComponent.coordinationProtocolOccurences->any(c | c.coordinationProtocol = coordinationProtocol);
					if (p.coordinationProtocolOccurence.oclIsUndefined()) then {
						// If none found, create one
						p.coordinationProtocolOccurence := new CoordinationProtocolOccurrence(coordinationProtocol);
						part.parentComponent.coordinationProtocolOccurences += p.coordinationProtocolOccurence;
					} endif;
				} endif
			} endif;
		}
	};
}

-- create new port parts for the component part
helper createPortParts(inout componentPart : ComponentPart) {
	
	var componentType : Component := componentPart.componentType;
	
	componentType.ports -> forEach(port){
		-- if no port part exists that references this port as its port type, create new port part (see #591)
		if((componentPart.portParts -> select(p : PortPart | p.portType = port)) -> isEmpty()) then {
			componentPart.portParts += new PortPart(port);
		} endif;
	};
	
}

-- instantiate port part that references the given port
constructor PortPart::PortPart(type : Port) {
	portType := type;
	name := type.name;
}

constructor CoordinationProtocolOccurrence::CoordinationProtocolOccurrence(p : CoordinationProtocol) {
	coordinationProtocol := p;
}