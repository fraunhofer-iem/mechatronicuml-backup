transformation InstantiationTransformation(inout input : ComponentPackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.4.0");

modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
 
	var components := input.rootObjects()[StructuredComponent];	
	if (components->isEmpty()) then {
		components := input.rootObjects()[RootNode].categories.modelElements[StructuredComponent]->asSet();
	} endif;
	
	components->forEach(component) {
	
		-- Disconnect invalid PortParts
		component.embeddedComponentParts.portParts->select(p |
			 // XXX: Workaround for #731; Essentially we are removing all PortPart->CoordinationProtocolParts connections and
			 // 	 which leads to all CoordinationProtocolParts also being removed afterwards as they have no connections
			 // 	 and then we recreate everything.
			 //      If you remove the "true" and use "not p.isValid()" again, please retest #731.
			 true
			 -- not p.isValid()
		)->forEach(pp) {
			pp.coordinationProtocolPart := null;
		};
		
		-- Remove empty CoordinationProtocolParts
		component.coordinationProtocolParts->select(portParts->isEmpty())->forEach(p) {
			input.removeElement(p);
		};
		

		-- Merge CoordinationProtocolParts that can reach each other
		--component.coordinationProtocolParts->forEach(p, q) {
		--	if (p != q and p.coordinationProtocol = q.coordinationProtocol and p.isReachable(q)) then {
		--		p.portParts += q.portParts;
		--		input.removeElement(q);
		--	} endif;
		--};
		
		
		
		--component.connectors[AssemblyConnector]->forEach(a) {
		--	component.coordinationProtocolParts->forEach(p) {
		--		if (p.portParts->intersection(a.connectorEndpoints[PortPart])->isEmpty()) then {
		--			
		--		} endif;
		--	};
		--};
		
		// Create or reuse CoordinationProtocolParts for all valid PortParts
		component.embeddedComponentParts.portParts->select(p | p.isValid())->forEach(p) {
			var refinedRole := p.refinedRole;
			
			-- Find all PortParts that are reachable via AssemblyConnectors
			var reachablePortParts := p.allReachablePortParts();

			-- Find CoordinationProtocolPart that already contains any PortPart that is reachable via AssemblyConnectors.
			var coordinationProtocolPart := component.coordinationProtocolParts->any(c | not c.portParts->intersection(reachablePortParts)->isEmpty());
		
			-- Make sure we have one CoordinationProtocolPart to add to; if none was found, create a new one
			if (coordinationProtocolPart = null) then {
				coordinationProtocolPart := new CoordinationProtocolPart(refinedRole.coordinationProtocol.oclAsType(CoordinationProtocol));
				p.componentPart.parentComponent.coordinationProtocolParts += coordinationProtocolPart;
			} endif;
			
			-- Associate this PortPart with the Coordination Protocol Part
			p.coordinationProtocolPart := coordinationProtocolPart;
		};
	};
}

query PortPart::isValid() : Boolean {
	return self.connectors[AssemblyConnector]->notEmpty() and self.refinedRole != null 
	--XXX: maybe remove the following line? seems to make the workaround r4009 unnecessary!  
	and self.allReachablePortParts().coordinationProtocolPart->asSet()->excluding(self.coordinationProtocolPart)->isEmpty();
}

query CoordinationProtocolPart::isReachable(p : CoordinationProtocolPart) : Boolean {
	return self.portParts->select(pp | p.isReachable(pp))->notEmpty();
}

query CoordinationProtocolPart::isReachable(portPart : PortPart) : Boolean {
	return self.portParts.allReachablePortParts()->excludes(portPart);
}

query PortPart::allReachablePortParts() : OrderedSet(PortPart) {
	return OrderedSet{ self }->closure(connectors[AssemblyConnector].portParts);
}
constructor CoordinationProtocolPart::CoordinationProtocolPart(p : CoordinationProtocol) {
	coordinationProtocol := p;
}