import transforms.lib.MUML2UPPAAL.Queries;
import transforms.lib.MUML2UPPAAL.IDs;
import transforms.lib.MUML2UPPAAL.Types;
import transforms.lib.MUML2UPPAAL.Enums;
import transforms.lib.MUML2UPPAAL.Decls;

import transforms.lib.RTSCUtil;

import transforms.lib.MUML2UPPAAL.Async.Variables;

library Expressions;

modeltype muml_actionLanguage uses 'http://www.muml.org/pim/actionlanguage/1.0.0';
modeltype muml_behavior uses pim::behavior('http://www.muml.org/pim/1.0.0');
modeltype muml_types uses pim::types('http://www.muml.org/pim/1.0.0');
modeltype muml_rtsc uses pim::realtimestatechart('http://www.muml.org/pim/1.0.0');
modeltype storydriven_core uses 'http://www.muml.org/core/1.0.0';
modeltype storydriven_expressions uses core::expressions('http://www.muml.org/core/1.0.0');
modeltype storydriven_expressions_common uses core::expressions::common('http://www.muml.org/core/1.0.0');
modeltype uppaal_expressions uses uppaal::expressions('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_statements uses uppaal::statements('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_types uses uppaal::types('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_declarations uses uppaal::declarations('http://www.muml.org/uppaal/1.0.0');
	
	query muml_behavior::Variable :: belongsToSubrole() : Boolean {
		return assert fatal (false) with log("Should be overridden")
	}
	
	query muml_behavior::Operation :: belongsToSubrole() : Boolean {
		return assert fatal (false) with log("Should be overridden")
	}

	-- convenience constructors
	
	constructor uppaal_expressions::LiteralExpression :: LiteralExpression(i : Integer) {
		text := i.repr()
	}
	
	constructor uppaal_expressions::LiteralExpression :: LiteralExpression(b : Boolean) {
		text := b.repr()
	}
	
	
	-- general typed named elements
	
	abstract mapping TypedNamedElement :: TypedNamedElement2Variable() : uppaal_declarations::Variable {
				
		name := self.name.addSuffixNumberUnderline();
		
		
		-- traverse type structure of the typed element, add an index as long as we face an array data type 
		
		var t : DataType = self.dataType;
		
		-- assert non-null type to avoid infinite while loop 		
		assert fatal (t != null) with log('No data type specified.');
		
		while (t.oclIsKindOf(ArrayDataType)) {
						
			-- prepend to ensure correct index order (changed to append TODO is this correct?)
			
			index += object uppaal_expressions::LiteralExpression {
					
					text := t.oclAsType(ArrayDataType).cardinality.value.repr();
			};
			
			t := t.oclAsType(ArrayDataType).type;
			
		}
								
	}
	
	
	
	-- operations
	
	mapping Operation :: Operation2FunctionDeclaration() : TypedDeclaration {
		elements := self.map Operation2Function();
		
		typeDefinition := object IdentifierExpression {
			identifier := self.returnType.map DataType2Type();
		}
	}
	
	mapping Operation :: Operation2Function() : Function {
	
		name := self.name;
		
	
					
		-- add additional parameter declarations 
		-- parameters represent the component and port/role instance IDs to be used as an index for variable access inside the function's body
		
		var componentInstanceID : uppaal_declarations::Variable := self.map Operation2ComponentInstanceID(); 
		
		parameter += object ParameterContainer {
		
				typeDefinition := object DataPrefixExpression {
				
					prefix := DataVariablePrefix::CONST;
					
					dataTypeExpression := object IdentifierExpression {
						identifier := map ComponentInstanceType();
					}
				
				};
				
				elements += componentInstanceID;
			
		};
		
		var portOrRoleInstanceID : uppaal_declarations::Variable;
		if(self.isPortOrRoleOperation()){
			portOrRoleInstanceID := self.map Operation2PortOrRoleInstanceID(); 
			
			parameter += object ParameterContainer {

				typeDefinition := object DataPrefixExpression {
				
					prefix := DataVariablePrefix::CONST;
							
					dataTypeExpression := object IdentifierExpression {
						identifier := map DiscretePortInstanceType();
					}
				};
					
				elements += portOrRoleInstanceID;
			};
		};
		
		var subPortOrRoleInstanceID : uppaal_declarations::Variable;
		
		if(self.belongsToSubrole()) 
		then {
			subPortOrRoleInstanceID := self.map Operation2SubPortOrRoleInstanceID(); 
			
			parameter += object ParameterContainer {
			
					typeDefinition := object DataPrefixExpression {
					
					prefix := DataVariablePrefix::CONST;
					
					dataTypeExpression := object IdentifierExpression {
							identifier := map DiscretePortInstanceType();
						}
					};
					
					elements += subPortOrRoleInstanceID;
							
			};
		} endif;

		
		-- map predefined parameters	
				
		parameter += self.parameters->map Parameter2Parameter();
		
		
		-- map function expressions to a single block
		if(self.belongsToSubrole()) {
			block := self.implementations->map Expressions2Block(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		} else if(self.isPortOrRoleOperation()){
			block := self.implementations->map Expressions2Block(componentInstanceID, portOrRoleInstanceID, null);
		} else {
			block := self.implementations->map Expressions2Block(componentInstanceID, null, null);
		}
		endif;	 	
		
	}
	
	mapping LocalVariableDeclarationStatement :: DeclarationStatement2VariableDeclaration(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : TypedDeclaration {
		
		typeDefinition := object IdentifierExpression {
			identifier := self.variable.dataType.map DataType2Type();
		};
		
		elements := self.map DeclarationStatement2Variable(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
	
	mapping LocalVariableDeclarationStatement :: DeclarationStatement2Variable(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_declarations::Variable {
		
		init {
			result := self.variable.map Variable2Variable();
		}
		
		-- map the initializer 
		initializer := self.variable.initializeExpression.map Expression2Initializer(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
				
	}
	
	mapping storydriven_expressions::Expression :: Expression2Initializer(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : Initializer
		disjuncts storydriven_expressions::Expression::Expression2ExpressionInitializer, actionlanguage::ArrayInitializeExpression::Expression2ArrayInitializer;
		
	
	mapping storydriven_expressions::Expression :: Expression2ExpressionInitializer(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : ExpressionInitializer when {not self.oclIsKindOf(actionlanguage::ArrayInitializeExpression)} {
		expression := self.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);	
	}
	
	mapping actionlanguage::ArrayInitializeExpression :: Expression2ArrayInitializer(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : ArrayInitializer when {self.expressions->notEmpty()} {
		
		initializer := self.expressions->map Expression2Initializer(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
			
	mapping muml_behavior::Parameter :: Parameter2Parameter() : uppaal_declarations::ParameterContainer {
				
			elements += self.map Parameter2ParameterVariable();
					
			typeDefinition := object IdentifierExpression {
			
				identifier := self.dataType.map DataType2Type();
				
			}
			
	}

	mapping Parameter :: Parameter2Variable() : uppaal_declarations::Variable
		inherits TypedNamedElement::TypedNamedElement2Variable {};
	
	mapping Parameter :: Parameter2ParameterVariable() : uppaal_declarations::Variable
		inherits TypedNamedElement::TypedNamedElement2Variable {};
	
			
	mapping Operation :: Operation2ComponentInstanceID() : uppaal_declarations::Variable {
		
		name := 'componentInstanceID';
		
	}
	
	mapping muml_behavior::Parameter :: Parameter2DataVariableDeclaration() : uppaal_declarations::TypedDeclaration {
				
		init {
			result := object TypedDeclaration {
			
				elements += self.map Parameter2Variable();
						
				typeDefinition := object IdentifierExpression {
				
					identifier := self.dataType.map DataType2Type();
					
				}
				
			}
		}
		
	} 
	
	mapping Operation :: Operation2PortOrRoleInstanceID() : uppaal_declarations::Variable {
		
		name := 'portOrRoleInstanceID';
		
	}
	
	mapping Operation :: Operation2SubPortOrRoleInstanceID() : uppaal_declarations::Variable {
		
		name := 'subPortOrRoleInstanceID';
		
	}
	
	
	-- variables and parameters
	
	mapping muml_behavior::Variable :: Variable2VariableDeclaration() : TypedDeclaration {
					
		typeDefinition := object DataPrefixExpression {
			
			if(self.constant) {
				prefix := DataVariablePrefix::CONST;
			};
						 
			dataTypeExpression := object IdentifierExpression {
				identifier := self.dataType.map DataType2Type();
			}
		};			
	
		elements += self.map Variable2Variable();
		
	}
	
	mapping muml_behavior::Variable :: Variable2Variable() : uppaal_declarations::Variable merges TypedNamedElement::TypedNamedElement2Variable {
									
		-- add an artificial index to make non-local variables accessible for multiple instances by means of their IDs	
		
		var idRange : DeclaredType = self.map Variable2IDRange();
		
		if (not idRange.oclIsUndefined())
		then {
		
			index += object IdentifierExpression {
					identifier := idRange
			};
		}
		endif;
		
		-- reproduce the initializer
		
		if (self.initializeExpression != null)
		then {
		
			assert fatal (idRange.typeDefinition.oclIsKindOf(RangeTypeSpecification)) with log('Expect range type specification here');
			var bounds : IntegerBounds = idRange.typeDefinition.oclAsType(RangeTypeSpecification).bounds;

			assert fatal (bounds.lowerBound.oclIsKindOf(uppaal_expressions::LiteralExpression)) with log('Expect literal expression here');	
			var minID : Integer = bounds.lowerBound.oclAsType(uppaal_expressions::LiteralExpression).text.asInteger();
			var maxID : Integer = overallNumberOfDiscretePortInstances();
			
			// TODO support initializers that refer to other variables
			// to achieve this, specify appropriate ID values instead of 'null' below
			// problem: UPPAAL variable instances are expected below, but the ID variables are not accessible from the global declarations. Use expressions as params instead?	
			
			-- always use an array initializer since our variables are always declared as arrays (possibly of size 1 if minID=maxID)					
			initializer := object ArrayInitializer {
							
				Set{minID..maxID-1}->forEach(ID) {
					
					initializer += self.initializeExpression.multiMapExpression2Initializer(null,null,null);
				
				}	
			}
			
		}
		endif;
		
	}
	
	helper storydriven_expressions::Expression :: multiMapExpression2Initializer(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : Initializer {
		
		var resolved : Initializer = self.resolveoneIn(storydriven_expressions::Expression::Expression2Initializer, Initializer);
		
		var initializer : Initializer;
		
		if (resolved.oclIsUndefined())
		then {
			initializer := self.map Expression2Initializer(componentInstanceID,portOrRoleInstanceID, subPortOrRoleInstanceID);
		}
		else {
			initializer := resolved.deepclone().oclAsType(Initializer);
		}
		endif;
		
		return initializer
		
	}
	
		
	-- expressions
	
	mapping storydriven_expressions::Expression :: Expression2Expressions(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : List(uppaal_expressions::Expression)
	disjuncts
		muml_actionLanguage::Block::Block2Expressions,
		storydriven_expressions::Expression::SimpleExpression2Expressions;
		
	mapping muml_actionLanguage::Block :: Block2Expressions(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : List(uppaal_expressions::Expression) {
		
		result += self.expressions->map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
	
	mapping storydriven_expressions::Expression :: SimpleExpression2Expressions(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : List(uppaal_expressions::Expression) {

		result += self.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
		
						
	mapping storydriven_expressions::Expression :: createExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::Expression 
	disjuncts
		storydriven_expressions_common::UnaryExpression::createUnaryExpression, 
		storydriven_expressions_common::BinaryExpression::createBinaryExpression, 
		storydriven_expressions_common::LiteralExpression::createLiteralExpression,
		muml_actionLanguage::TypedNamedElementExpression::TypedNamedElementExpression2IdentifierExpression,
		muml_actionLanguage::OperationCall::createCall,
		muml_actionLanguage::Assignment::createAssignmentExpression,
		muml_actionLanguage::Assignment::Assignment2ChoiceAssignment,
		muml_actionLanguage::IfStatement::createIfExpression,
		muml_actionLanguage::Block::createSingleExpression,
		muml_actionLanguage::TriggerMessageExpression::TriggerMessageExpression2ArgumentAccessExpression,
		muml_actionLanguage::DiscreteInteractionEndpointReference::DiscreteInteractionEndpointReference2InstanceReference,
		muml_actionLanguage::ArrayIndexExpression::ArrayIndexExpression2Expression,
		storydriven_expressions::Expression::failOnUnsupportedExpression
	when {
		-- the following expression subtypes are processed separately and should not be mapped to UPPAAL expressions
		(not self.oclIsKindOf(LocalVariableDeclarationStatement)) and
		(not self.oclIsKindOf(NondeterministicChoiceExpression)) and
		-- exclude empty blocks
		(self.oclIsKindOf(Block) implies self.oclAsType(Block).expressions->notEmpty())
	};
	
	
	helper OrderedSet(PositionSelector) :: createIdentifierExpressionWithSelectors(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::IdentifierExpression {
				
		var posSelector := self->last();
		
		assert fatal (not posSelector.kind.oclIsUndefined()) with log("Position kind required");
		
		return object uppaal_expressions::IdentifierExpression {
		
			if(posSelector.kind = PositionSelectorKind::SELF)
			then {
				
				assert fatal (subPortOrRoleInstanceID != null) with log("Cannot resolve self-reference: subPortOrRoleInstanceID is missing. Do you use the self-keyword outside of your subrole behavior?");
				
				identifier := cicToVerify().discretePortInstances()->map DiscretePortInstances2SelfArray()
				
			} 
			elif(posSelector.kind = PositionSelectorKind::FIRST) 
			then {
			
				identifier := cicToVerify().discretePortInstances()->map DiscretePortInstances2FirstArray()
			
			}
			elif(posSelector.kind = PositionSelectorKind::LAST) 
			then {
			
				identifier := cicToVerify().discretePortInstances()->map DiscretePortInstances2LastArray()
			
			}
			elif(posSelector.kind = PositionSelectorKind::NEXT) 
			then {
			
				assert fatal (subPortOrRoleInstanceID != null) with log("Cannot resolve next-reference: subPortOrRoleInstanceID is missing. Do you use the next-keyword outside of your subrole behavior?");
			
				identifier := cicToVerify().discretePortInstances()->map DiscretePortInstances2NextArray()
			
			}
			elif(posSelector.kind = PositionSelectorKind::PREV) 
			then {
			
				assert fatal (subPortOrRoleInstanceID != null) with log("Cannot resolve previous-reference: subPortOrRoleInstanceID is missing. Do you use the previous-keyword outside of your subrole behavior?");
			
				identifier := cicToVerify().discretePortInstances()->map DiscretePortInstances2PreviousArray()
			
			}
			endif;
	
			var newInput : OrderedSet(PositionSelector) = self->subOrderedSet(1, self->size()-1);
			
			if(newInput->isEmpty() or newInput->oclIsInvalid())
			then {
				index += object IdentifierExpression {
					if(subPortOrRoleInstanceID = null)
					then {
						identifier := portOrRoleInstanceID
					} else {
						identifier := subPortOrRoleInstanceID 
					} endif;
				}
			} else {
				index += newInput->createIdentifierExpressionWithSelectors(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
			} endif;
			
		};

	}
	
	mapping ArrayIndexExpression::ArrayIndexExpression2Expression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::Expression{
		init{
			result := self.index.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		}
	}
	
	mapping DiscreteInteractionEndpointReference :: DiscreteInteractionEndpointReference2InstanceReference(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::IdentifierExpression  {
		
		// TODO at this point we just map the selector expression to a specific subport instance ID. What remains is the implementation for all port instance types
		
		init {
			assert fatal (not self.position.oclIsUndefined()) with log("Position required");
			
			var positionSelectors := object List(PositionSelector){};
			var currentSelector := self.position;
			while(not currentSelector.oclIsUndefined()) {
				positionSelectors->add(currentSelector);
				currentSelector := currentSelector.successor
			};
			
			result := positionSelectors->asOrderedSet()->createIdentifierExpressionWithSelectors(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		}
		
	}
	
	mapping TriggerMessageExpression :: TriggerMessageExpression2ArgumentAccessExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::ScopedIdentifierExpression {

		
		-- TYPEMessageArguments[msg.mArgsPosition].parameter
		scope := object IdentifierExpression {
			
			identifier := self.messageType.map createParameterTypeBufferFieldVariable();
			
			index += object ScopedIdentifierExpression {
				
				scope := object IdentifierExpression {
					
					identifier := portOrRoleInstanceID.invresolveone(RealtimeStatechart).map createMsgVariable();
					
				};
				
				identifier := object IdentifierExpression {
				
					identifier := map createMessageArgumentsPositionVariable();
					
				};
				 
			}
			
		};
		
		identifier := object IdentifierExpression {
			
			identifier := self.parameter.map Parameter2Variable()
			
		};

	}
		
	
	
	-- unary expressions
	
	mapping storydriven_expressions_common::UnaryExpression :: createUnaryExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::Expression disjuncts
		storydriven_expressions_common::UnaryExpression::createNegation,
		storydriven_expressions_common::UnaryExpression::MinusExpression2MinusExpression;
	
		
	mapping UnaryExpression :: createNegation(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : NegationExpression when {self.operator = UnaryOperator::NOT} {
				
		negatedExpression := self.enclosedExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
				
	}
	
	mapping UnaryExpression :: MinusExpression2MinusExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : MinusExpression when {self.operator = UnaryOperator::MINUS} {
				
		invertedExpression := self.enclosedExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
				
	}	
	
	
	-- binary expressions
				
	mapping storydriven_expressions_common::BinaryExpression :: createBinaryExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::Expression disjuncts
		storydriven_expressions_common::ComparisonExpression::createComparison,
		storydriven_expressions_common::ArithmeticExpression::createArithmeticExpression,
		storydriven_expressions_common::LogicalExpression::LogicalExpression2LogicalExpression,
		storydriven_expressions_common::LogicalExpression::createEquivalenve,
		storydriven_expressions_common::LogicalExpression::createParity;	
	
	abstract mapping storydriven_expressions_common::BinaryExpression :: initBinaryExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::BinaryExpression {
		
		firstExpr := self.leftExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		secondExpr := self.rightExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
	
	mapping ComparisonExpression :: createComparison(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : CompareExpression inherits storydriven_expressions_common::BinaryExpression::initBinaryExpression {
		
		operator := self.operator.mapOperator();
		
	}
	
	mapping storydriven_expressions_common::ArithmeticExpression :: createArithmeticExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::ArithmeticExpression inherits storydriven_expressions_common::BinaryExpression::initBinaryExpression {
		
		operator := self.operator.mapOperator();
		
	}
			
	mapping LogicalExpression :: LogicalExpression2LogicalExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::LogicalExpression when {not self.operator.mapOperator().oclIsUndefined()} {
		
		firstExpr := self.leftExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		operator := self.operator.mapOperator();
		secondExpr := self.rightExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
		
	mapping LogicalExpression :: createEquivalenve(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::LogicalExpression when {self.operator = LogicOperator::EQUIVALENT} {
	
		init {
			
			result := object LogicalExpression {
				
				leftExpression := object LogicalExpression {
					
					leftExpression := self.leftExpression.deepclone().oclAsType(storydriven_expressions::Expression);
					rightExpression := self.rightExpression.deepclone().oclAsType(storydriven_expressions::Expression);
					
					operator := LogicOperator::IMPLY;
					
				};
				
				operator := LogicOperator::AND;
				
				rightExpression := object LogicalExpression {
					
					leftExpression := self.rightExpression.deepclone().oclAsType(storydriven_expressions::Expression);
					rightExpression := self.leftExpression.deepclone().oclAsType(storydriven_expressions::Expression);
					
					operator := LogicOperator::IMPLY;
					
				};
				
			}.map LogicalExpression2LogicalExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
			
		}
		
	}
	
	mapping LogicalExpression :: createParity(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::LogicalExpression when {self.operator = LogicOperator::XOR} {
	
		init {
			
			result := object LogicalExpression {
				
				leftExpression := object LogicalExpression {
					
					leftExpression := self.leftExpression.deepclone().oclAsType(storydriven_expressions::Expression);
					rightExpression := self.rightExpression.deepclone().oclAsType(storydriven_expressions::Expression);
					
					operator := LogicOperator::OR;
					
				};
				
				operator := LogicOperator::AND;
				
				rightExpression := object UnaryExpression {
				
					operator := UnaryOperator::NOT;
					
					enclosedExpression := object LogicalExpression {
						
						leftExpression := self.leftExpression.deepclone().oclAsType(storydriven_expressions::Expression);
						rightExpression := self.rightExpression.deepclone().oclAsType(storydriven_expressions::Expression);
						
						operator := LogicOperator::AND;
											
					}
				
				}
				
			}.map LogicalExpression2LogicalExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
			
		}
		
	}
	
	
	-- other expressions
		
	mapping muml_actionLanguage::Block :: createSingleExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::Expression {
		
		-- mapping a block to an UPPAAL expression is only supported if the block contains just one expression 
			
		init {
			assert fatal (self.expressions->size() = 1) with log ("Only blocks with exactly one expression are currently supported.");
			result := self.expressions->first().map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID)	
		}	
		
	}
	
	// TODO support elseif
	mapping muml_actionLanguage::IfStatement :: createIfExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::ConditionExpression {
				
		assert fatal (self.elseIfStatements->isEmpty()) with log("Mapping an else-if-statement is currently unsupported.");
								
		ifExpression := self.ifCondition.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		thenExpression := self.ifBlock.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		if (self.elseBlock.oclIsUndefined()) {
			assert warning (false) with log("Warning: if statement without else block is translated into ternary expression into Uppaal. Using \"0\" for the elseExpression");
			elseExpression := object uppaal_expressions::LiteralExpression {text := "0"};
		}
		else {
			elseExpression := self.elseBlock.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		}
		
	}
						
	mapping storydriven_expressions_common::LiteralExpression :: createLiteralExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::LiteralExpression {
					
		text := self.value;
		
	}
	
	mapping muml_actionLanguage::Assignment :: createAssignmentExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::AssignmentExpression 
	when {not self.rhs_assignExpression.oclIsKindOf(NondeterministicChoiceExpression)} {
				
		operator := self.assignOperator.mapOperator();
		
		firstExpr := self.lhs_typedNamedElementExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
				
		secondExpr := self.rhs_assignExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
	
	mapping muml_actionLanguage::Assignment :: Assignment2ChoiceAssignment(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::AssignmentExpression
	when {self.rhs_assignExpression.oclIsKindOf(NondeterministicChoiceExpression)} {
		
		firstExpr := self.lhs_typedNamedElementExpression.map TypedNamedElementExpression2IdentifierExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		operator := self.assignOperator.mapOperator();
		
		secondExpr := object IdentifierExpression {
			identifier := self.rhs_assignExpression.oclAsType(NondeterministicChoiceExpression).map Choice2AuxVariable();
		}
		
	}
	
	property nondeterministicChoiceAuxVariableNamePrefix : String = "choice"; 
	
	mapping NondeterministicChoiceExpression :: Choice2AuxVariable() : uppaal_declarations::Variable {
		
		name := nondeterministicChoiceAuxVariableNamePrefix.addSuffixNumberUnderline();
				
	}	
				
	mapping TypedNamedElementExpression :: TypedNamedElementExpression2IdentifierExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : IdentifierExpression
		disjuncts TypedNamedElementExpression::VariableExpression2IdentifierExpression,
				  TypedNamedElementExpression::ParameterExpression2IdentifierExpression;	
		
	mapping TypedNamedElementExpression :: VariableExpression2IdentifierExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : IdentifierExpression
	when {self.typedNamedElement.oclIsKindOf(muml_behavior::Variable)} {
		
		identifier := self.typedNamedElement.oclAsType(muml_behavior::Variable).map Variable2Variable();
						
						
		-- if we need an ID value to access a port/role variable, add the appropriate index
		
		var ID : uppaal_declarations::Variable;
		var variable := self.typedNamedElement.oclAsType(muml_behavior::Variable);
		
		if (variable.isComponentVariable())
		then {
			assert fatal (componentInstanceID != null) with log('Component instance ID required.');
			ID := componentInstanceID
		}
		endif;
		
		
		if (variable.isPortOrRoleVariable())
		then {
			assert fatal (portOrRoleInstanceID != null) with log('Port/role instance ID required.');
			if(variable.belongsToSubrole())
			then {
				assert fatal (subPortOrRoleInstanceID != null) with log('Subport/role instance ID must be specified.');
				ID := subPortOrRoleInstanceID // in case of multiport behavior, this is the subrole singleport instance ID
			} else {
				ID := portOrRoleInstanceID	// in case of multiport behavior, this is the multiport instance ID
			} endif;
		}
		endif;

		
		if (not ID.oclIsUndefined())
		then {
				
			index += object uppaal_expressions::IdentifierExpression {
				identifier := ID;	
			}
			
		}
		endif;
		
		
		-- map indices	
		index += self.elementAccessors->map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
	
	}
	
	mapping TypedNamedElementExpression :: ParameterExpression2IdentifierExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : IdentifierExpression
	when {self.typedNamedElement.oclIsKindOf(muml_behavior::Parameter)} {
		
		identifier := self.typedNamedElement.oclAsType(muml_behavior::Parameter).map Parameter2Variable();
						
		-- map indices
		index += self.elementAccessors->map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);		
	}
	
	mapping muml_actionLanguage::OperationCall :: createCall(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::FunctionCallExpression {
						
		function := self.operation.map Operation2Function();
		
		
		-- create arguments referring to the component and port/role instance IDs of the calling process
		-- arguments are to be used as an index for variable access inside the function's body
		
		if (componentInstanceID.oclIsUndefined())
		then {
			argument += new uppaal_expressions::LiteralExpression(0);
		}
		else {
			
			argument += object uppaal_expressions::IdentifierExpression {
		
				identifier := componentInstanceID;
							
			}
		
		}
		endif;
		
		
		if (portOrRoleInstanceID.oclIsUndefined())
		then {
			argument += new uppaal_expressions::LiteralExpression(0);
		}
		else {
		
			argument += object uppaal_expressions::IdentifierExpression {
		
				identifier := portOrRoleInstanceID;
							
			};
			
			if(self.operation.belongsToSubrole())
			then {
				argument += object uppaal_expressions::IdentifierExpression {
			
					identifier := subPortOrRoleInstanceID;
								
				};
			} endif;
			
		}
		endif;
		
		
		-- add predefined arguments
				
		argument += self.parameterBinding->map ParameterBinding2Expression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
				
	}
	
	mapping storydriven_expressions::Expression :: failOnUnsupportedExpression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::Expression {
				
		init {
			assert fatal (false) with log("Mapping this expression is unsupported due to UPPAAL limitations. CompInsId: " + componentInstanceID.toString() + ". ")
		}	
		
	}
	
	
	
	-- statements
	
	mapping storydriven_expressions::Expression :: createStatement(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::Statement 
	disjuncts
		muml_actionLanguage::Assignment::createAssignmentStatement,
		muml_actionLanguage::Assignment::createIncrementDecrement,
		muml_actionLanguage::Block::Block2Block,
		muml_actionLanguage::WhileLoop::createWhile,
		muml_actionLanguage::DoWhileLoop::createDoWhile,
		muml_actionLanguage::ForLoop::createFor,
		muml_actionLanguage::IfStatement::createIf,
		muml_actionLanguage::ReturnStatement::createReturn,
		storydriven_expressions::Expression::Expression2ExpressionStatement, -- this case covers remaining expression types like OperationCall and TypedNamedElementExpression
		storydriven_expressions::Expression::failOnUnsupportedStatement
	when {not self.oclIsKindOf(LocalVariableDeclarationStatement)};
	
	-- precondition avoids error for local variable declarations, which are to be ignored here since they are handled differently	
	mapping storydriven_expressions::Expression :: failOnUnsupportedStatement(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::Statement
	when {not self.oclIsKindOf(LocalVariableDeclarationStatement)}
	{
		init {
			assert fatal (false) with log('Unsupported expression type.')
		}
	}
		
	
	mapping muml_actionLanguage::Assignment :: createAssignmentStatement(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::ExpressionStatement when {self.assignOperator != AssignOperator::UNSET} {
		
		expression := self.map createAssignmentExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);	
		
	}
	
	mapping muml_actionLanguage::Assignment :: createIncrementDecrement(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : ExpressionStatement when {self.assignOperator = AssignOperator::UNSET} {
		
		expression := object PostIncrementDecrementExpression {
		
			operator := self.incrementDecrementOperator.mapOperator();
			
			expression := self.lhs_typedNamedElementExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
			
		}	
				
	}
	
	mapping muml_actionLanguage::Block :: Block2Block(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::Block {
		
		init {
			result := self.expressions->map Expressions2Block(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID)
		}
		
	}
		
	mapping OrderedSet(storydriven_expressions::Expression) :: Expressions2Block(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::Block {
				
		-- map local declarations
		
		declarations := object LocalDeclarations {
			declaration += self[LocalVariableDeclarationStatement]->map DeclarationStatement2VariableDeclaration(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		};
		
		-- map block statements
		
		statement += self->map createStatement(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
		
	mapping muml_actionLanguage::WhileLoop :: createWhile(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::WhileLoop {
		
		expression := self.loopTest.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		statement := self.block.map Block2Block(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
	
	}
	
	mapping muml_actionLanguage::DoWhileLoop :: createDoWhile(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::DoWhileLoop {
		
		statement := self.block.map Block2Block(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		expression := self.loopTest.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
			
	}
	
	mapping muml_actionLanguage::ForLoop :: createFor(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::ForLoop {
				
		initialization := self.initializeExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		condition := self.loopTest.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		iteration := self.countingExpression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		statement := self.block.map Block2Block(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
			
	}
			
	mapping muml_actionLanguage::IfStatement :: createIf(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::IfStatement {
		
		// TODO support elseif
		
		assert fatal (self.elseIfStatements->isEmpty()) with log("Mapping an else-if-statement is currently unsupported.");
				
		ifExpression := self.ifCondition.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		thenStatement := self.ifBlock.map Block2Block(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		elseStatement := self.elseBlock.map Block2Block(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
						
	mapping muml_actionLanguage::ReturnStatement :: createReturn(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::ReturnStatement {
						
		returnExpression := self.expression.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID)
				
	}
	
	mapping storydriven_expressions::Expression :: Expression2ExpressionStatement(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_statements::ExpressionStatement {
		
		expression := self.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
	}
	
	mapping ParameterBinding :: ParameterBinding2Expression(componentInstanceID : uppaal_declarations::Variable, portOrRoleInstanceID : uppaal_declarations::Variable,  subPortOrRoleInstanceID : uppaal_declarations::Variable) : uppaal_expressions::Expression {
		
		init {
			result := self.value.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		}
		
	}
			