
transformation MUMLPIM2PSM(in cic : InstancePackage, out new_cic:InstancePackage, out components:ComponentPackage);


modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype MessagePackage uses muml::msgtype('http://www.fujaba.de/muml/0.4.0');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype ModelInstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype Actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.4.0');
modeltype Core uses core('http://www.storydriven.org/core/0.3.1');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');


modeltype PSM uses psm('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype SoftPlattform uses swplatform('http://www.fujaba.de/muml/swplatform/0.4.0/');
modeltype PSMInstance uses psm::instance('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PSMRealtimeStateChart uses psm::realtimestatechart::realtimestatechartparameterbinding('http://www.fujaba.de/muml/psm/0.4.0/');


//this extra attribute is used to dermine which hybridPort is connected to which continous port
// to determine the messages
//since the connections are only known at instance level
intermediate property HybridPort::connectedContiniousPort: muml::component::ContinuousPort;
intermediate property ContinuousPort::samplingTimes: Set(muml::valuetype::TimeValue);


// the message Type Repository for the api values 
property apiMessageRepository:MessageTypeRepository;

main() {
	apiMessageRepository:=object MessageTypeRepository{
		name:="api_messageType_Repository";
		comment:="The message types for the api messages"	

	};
		cic.rootObjects()[ComponentInstanceConfiguration]->map mapCIC2CIC();
	
}

/**********************
* Here is the logic for mapping the ComponentInstances
***********************/
mapping ComponentInstanceConfiguration::mapCIC2CIC():ComponentInstanceConfiguration{
	
	annotation:=self.annotation;
	extension:=self.extension.deepclone().oclAsType(Extension);
	name:=self.name;
	comment:=self.comment;
	componentInstances:=self.componentInstances->map mapComponentInstance();
	portConnectorInstances:=self.portConnectorInstances->map mapConnectorInstance();
	
	
}


mapping PortConnectorInstance::mapConnectorInstance():PortConnectorInstance
	disjuncts AssemblyConnectorInstance::mapAssemblyConnectorInstance,DelegationConnectorInstance::mapDelegationConnectorInstance;


mapping AssemblyConnectorInstance::mapAssemblyConnectorInstance():AssemblyConnectorInstance{
	type:=self.type;
	connectorEndpointInstances:=self.connectorEndpointInstances.late resolve(ConnectorEndpointInstance);	
}

mapping DelegationConnectorInstance::mapDelegationConnectorInstance():DelegationConnectorInstance{
	type:=self.type;
	connectorEndpointInstances:=self.connectorEndpointInstances.late resolve(ConnectorEndpointInstance);	
}


/**
 * maps the ComponentInstances of the  CIC to RefinedComponentInstances
**/
mapping ComponentInstance::mapComponentInstance():ComponentInstance
	disjuncts StructuredComponentInstance::mapStructuredComponentInstance,AtomicComponentInstance::mapAtomicComponentInstance;


mapping StructuredComponentInstance::mapStructuredComponentInstance():StructuredComponentInstance{ 
	 name:=self.name;
	 componentType:=self.componentType;
	 portInstances:=self.portInstances->map mapPortInstance();
	 embeddedCIC:=self.embeddedCIC.map mapCIC2CIC();
	}


mapping AtomicComponentInstance::mapAtomicComponentInstance():AtomicComponentInstance{
	 name:=self.name;
	 componentType:=self.componentType;
	 portInstances:=self.portInstances->map mapPortInstance();
	 componentPart:=self.componentPart;
}



abstract mapping PortInstance::abstractmapPortInstance():PortInstance{
	name:=self.name;
	type:=self.type;
	connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);
}

mapping PortInstance::mapPortInstance():PortInstance disjuncts ParameterisableDiscreteSinglePortInstance::mapParameterisableDiscreteSinglePortInstance, DiscreteMultiPortInstance::mapDiscreteMultiPortInstance, DiscreteSinglePortInstance::mapDiscreteSinglePortInstance;
//mapping DiscretePortInstance::mapDiscretePortInstance():DiscretePortInstance disjuncts 



mapping DiscreteMultiPortInstance::mapDiscreteMultiPortInstance():DiscreteMultiPortInstance merges PortInstance::abstractmapPortInstance{
	subInteractionEndpointInstances:=self.subInteractionEndpointInstances.oclAsType(DiscreteSinglePortInstance)->map mapDiscreteSinglePortInstance();
}


mapping DiscreteSinglePortInstance::mapDiscreteSinglePortInstance():DiscreteSinglePortInstance merges PortInstance::abstractmapPortInstance{
	multiInteractionEndpointInstance:=self.multiInteractionEndpointInstance;
	
}


mapping ParameterisableDiscreteSinglePortInstance::mapParameterisableDiscreteSinglePortInstance():ParameterisableDiscreteSinglePortInstance merges PortInstance::abstractmapPortInstance{
	bindings:=self.bindings.deepclone().oclAsType(RealtimeStatechartParameterBinding);
}


/***************************************************************************
* 
*  Here starts the logic for the transformation of Component-Instances (Instance Level)
*
*****************************************************************************/

/**
*
* Replaces the Continuos- and Hybrid-PortInstances with DiscretePortInstances of an AtomicComponentInstances
*
*/
// component instance logic
mapping inout AtomicComponentInstance::ChangeAtomicComponentInstance(){
	portInstances+=self.portInstances[ContinuousPortInstance]->map ReplacePortInstanceWithDiscretePortInstance();
	portInstances+=self.portInstances[HybridPortInstance]->map ReplacePortInstanceWithDiscretePortInstance()
}

/**
*
* Replaces the Continuos- and Hybrid-PortInstances with DiscretePortInstances of a StructuredComponentInstances
*
*/
mapping inout StructuredComponentInstance::ChangeStructuredComponentInstance2StructuredDiscreteComponentInstance(){
	portInstances+=self.portInstances[ContinuousPortInstance]->map ReplacePortInstanceWithDiscretePortInstance();
}


/**
* The General Logic to replace a PortInstance with a  DiscretePortInstance
*/
mapping PortInstance::ReplacePortInstanceWithDiscretePortInstance():DiscreteSinglePortInstance{
	name:=self.name;
	annotation:=self.annotation;
	extension:=self.extension;
	comment:=self.comment;
	connectorInstances:=self.connectorInstances;
	componentInstance:=self.componentInstance;
	type:=self.type.resolveone(DiscretePort);
	//the old port shall be removed at the end
	elementsToRemove+=self;
}

/**
* Replace a hybridPortInstance with a  DiscretePortinstance
*/
mapping HybridPortInstance::ReplacePortInstanceWithDiscretePortInstance():DiscreteSinglePortInstance inherits PortInstance::ReplacePortInstanceWithDiscretePortInstance{
	
}

mappingContinuousPortInstance::ReplacePortInstanceWithDiscretePortInstance():Muml::instance::DiscreteSinglePortInstance
	disjuncts Muml::instance::ContinuousPortInstance::ReplaceContinusPortInstanceWithParaDiscretePortInstance, Muml::instance::ContinuousPortInstance::ReplaceContinusPortInstanceWithSingleDiscretePortInstance {}

/**
* Replace a ContiniuosPortIsntance with a  ParametiredDiscreteSinglePortinstance
*/
mapping ContinuousPortInstance::ReplaceContinusPortInstanceWithParaDiscretePortInstance():ParameterisableDiscreteSinglePortInstance inherits PortInstance::ReplacePortInstanceWithDiscretePortInstance 
when {self.componentInstance.oclIsKindOf(AtomicComponentInstance)}{
 	createPortBindingParameter(apiMappingRepository,result,self);
}

mappingContinuousPortInstance::ReplaceContinusPortInstanceWithSingleDiscretePortInstance():DiscreteSinglePortInstance inherits Muml::instance::PortInstance::ReplacePortInstanceWithDiscretePortInstance 
when {self.componentInstance.oclIsKindOf(StructuredComponentInstance)}{
	
}