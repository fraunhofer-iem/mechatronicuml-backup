import StateChartLibrary;
import CommonLibrary;
import MessageLibrary;

library ComponentLibrary;

modeltype Core uses core('http://www.storydriven.org/core/0.3.1');

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype MessagePackage uses muml::msgtype('http://www.fujaba.de/muml/0.4.0');
modeltype Behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype RTSC uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype TypesPackage uses muml::types('http://www.fujaba.de/muml/0.4.0');

modeltype ModelInstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype Actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.4.0');

modeltype PSM uses psm('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Allocation uses psm::allocation('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Codegen uses psm::codegen('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PortMappingModel uses psm::portapimapping('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype ApiExpessions uses psm::apiexpressions('http://www.fujaba.de/muml/psm/0.4.0/');

modeltype SoftPlattform uses swplatform('http://www.fujaba.de/muml/swplatform/0.4.0/');
modeltype Hardware uses hardware('http://www.fujaba.de/muml/hardware/1.1/');
modeltype Platform uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.1/');
modeltype PlatformInstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype ResourceInstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype Resource uses hardware::hwresource('http://www.fujaba.de/muml/hardware/1.1/');




/***************************************************************************
* 
*  Here starts the logic for the transformation of Components (Type Level)
*
*****************************************************************************/
//component logic

abstract mapping Component::abstractmapComponent():Component{
	name:=self.name;
	annotation:=self.annotation;
	extension:=self.extension;
	comment:=self.comment;
}

mapping Component::mapComponent():Component
	disjuncts StaticStructuredComponent::mapStaticStructuredComponent, StaticAtomicComponent::ChangeContinousComponent2DiscreteComponent,StaticAtomicComponent::ChangeSoftwareComponent2DiscreteComponent {}
	




/**
* Map Structed Component and
*  HybridPorts of a SturcutedComponent are Replaced  with DiscretePorts
*/
mapping in StaticStructuredComponent::mapStaticStructuredComponent():StaticStructuredComponent inherits Component::abstractmapComponent{
	componentKind:=	muml::component::ComponentKind::SOFTWARE_COMPONENT;
	ports:=self.ports->map mapPort(null);	
	embeddedComponentParts:=self.embeddedComponentParts->map mapComponentPart();
}


/**
* The HybridPorts of a HybridComponent are Replaced  with DiscretePorts
*/
mapping in StaticAtomicComponent::ChangeSoftwareComponent2DiscreteComponent():StaticAtomicComponent inherits Component::abstractmapComponent when {self.componentKind=muml::component::ComponentKind::SOFTWARE_COMPONENT}{
	if(self.behavior.oclIsUndefined())then{
			createEmptyRealtimeStateChart(result);
		}else{
				behavior:=self.behavior.deepclone().oclAsType(RealtimeStatechart);
			
		}endif;
	ports:=self.ports->map mapPort(behavior.oclAsType(RealtimeStatechart));	
}


/**
* Changes a ContinousComponent to a DiscreteComponent and Replaces its ContinousPorts with DiscretePorts
*/
mapping in StaticAtomicComponent::ChangeContinousComponent2DiscreteComponent():StaticAtomicComponent inherits Component::abstractmapComponent when {self.componentKind=muml::component::ComponentKind::CONTINUOUS_COMPONENT}{
	componentKind:=	muml::component::ComponentKind::SOFTWARE_COMPONENT;
	//behavior:=self.behavior.deepclone().oclAsType(RealtimeStatechart);
	//create empty statechart here
	createEmptyRealtimeStateChart(result);
	ports:=self.ports->map mapPort(behavior.oclAsType(RealtimeStatechart));	
}


/**
* Map ComponentParts
**/
mapping in ComponentPart::mapComponentPart():ComponentPart{
	annotation:=self.annotation;
	name:=self.name;
	comment:=self.comment;
	parentComponent:=self.parentComponent.resolveone(StructuredComponent);
	portParts:=self.portParts->map mapPortPart();
}

mapping in PortPart::mapPortPart():PortPart{
	connectors:=self.connectors.resolve(Connector);
	portType:=self.portType.resolveone(Port);
	coordinationProtocolPart:=self.coordinationProtocolPart;
}




/**
* Mapping the Ports
**/

mapping Port::mapPort(inout componentStateChart:RealtimeStatechart):Port
	disjuncts DiscretePort::ReplacePortWithDiscretePort, HybridPort::ReplacePortWithDiscretePort, ContinuousPort::ReplacePortWithDiscretePort;


/**
* The General Logic to map  Port 
*/
abstract mapping Port::abstractReplacePortWithDiscretePort(inout componentStateChart:RealtimeStatechart):Port{
	name:=self.name;
	annotation:=self.annotation;
	extension:=self.extension;
	comment:=self.comment;
	connectors:=self.connectors.late resolve(Connector);
	component:=self.component;
	
}

mapping DiscretePort::ReplacePortWithDiscretePort(inout componentStateChart:RealtimeStatechart):DiscretePort inherits Port::abstractReplacePortWithDiscretePort{
	cardinality:=object Cardinality{
			lowerBound:=object NaturalNumber{
				value:=1;
			};
			upperBound:=object NaturalNumber{
				value:=1;
			};
	};
	
}

/**
* Replace a HybridPort with a  DiscretePort
*/
mapping HybridPort::ReplacePortWithDiscretePort(inout componentStateChart:RealtimeStatechart):DiscretePort inherits Port::abstractReplacePortWithDiscretePort{
	
	if(self.component.oclIsKindOf(AtomicComponent)) then{
		//create the message stuff
		var messageType:MessageType:=self.getMessageForDirectedTypedPort();
		var variable:Variable:=self.CreateStateChartVariable();
		self.CreateMessageBufferForDiscretePort(result,messageType);
		//statechart stuff
		AddVariableToStateChart(componentStateChart,variable);
		self.ReplacePortExpressionWithVariableExpression(componentStateChart,variable);
		var portStateChart:RealtimeStatechart;
		portStateChart:=self.map createStatechartHybridPort(messageType,variable);
		storeRealtimeStatechart(portStateChart,componentStateChart);
		behavior:=portStateChart;
	}endif;

}

/**
* Replace a ContinuousPort with a  DiscretePort
*/
mapping ContinuousPort::ReplacePortWithDiscretePort(inout componentStateChart:RealtimeStatechart):DiscretePort inherits Port::abstractReplacePortWithDiscretePort{

	if(self.component.oclIsKindOf(AtomicComponent)) then{
		//create the message stuff
		var messageType:MessageType:=self.getMessageForDirectedTypedPort();
		var variable:Variable:=self.CreateStateChartVariable();
		self.CreateMessageBufferForDiscretePort(result,messageType);
		//statechart stuff		
		AddVariableToStateChart(componentStateChart,variable);
		var portStateChart:RealtimeStatechart;
		portStateChart:=self.map createStatechartContinuousPort(messageType,variable,true);
		storeRealtimeStatechart(portStateChart,componentStateChart);
		behavior:=portStateChart;
	}endif;
	
}





