// automatically generated by Xtext
grammar org.muml.psm.allocation.language.xtext.AllocationSpecificationLanguage with org.eclipse.ocl.xtext.completeocl.CompleteOCL

// use platform uri (the generation fails if NSURIs are used) - the OCL xtext files use
// the platform uri import mechanism as well
import "platform:/resource/org.muml.psm.allocation.language/model/LanguageSpecificationCS.ecore" as cs
import "platform:/resource/org.eclipse.ocl.xtext.essentialocl/model/EssentialOCLCS.ecore" as essentialocl
import "platform:/resource/org.eclipse.ocl.xtext.oclstdlib/model/OCLstdlibCS.ecore" as oclstdlib

Specification returns cs::SpecificationCS:
	{cs::SpecificationCS}
	name=ID '{'
		// preamble
		((ownedImports += ImportCS)*
			& nameProviderImplementationClass=NameProviderImplementationClass
			& storageProviderImplementationClass=StorageProviderImplementationClass
			& oclContext=OCLContext
		)
		// end of preamble
		(ownedImports += ImportCS
			| ownedContexts += ClassifierContextDeclCS
			| relations+=Relation| services += Service | constraints += Constraint
		)*
		(goal=Goal measure=MeasureFunction)? 
	'}'
;

NameProviderImplementationClass returns cs::JavaImplementationProviderCS:
	'nameProvider' implementation=[oclstdlib::JavaClassCS|SINGLE_QUOTED_STRING]
;

StorageProviderImplementationClass returns cs::JavaImplementationProviderCS:
	'storageProvider' implementation=[oclstdlib::JavaClassCS|SINGLE_QUOTED_STRING]
;

OCLContext returns cs::OCLContextCS:
	'oclContext' ownedType=TypedRefCS
;

Service returns cs::ServiceCS:
	'service' name=ID '{'
		dimensions += QosDimension*
	'}'
;

Relation returns cs::RelationCS:
	'relation' (name=ID)? '{'
		tupleDescriptor=TupleDescriptor
		lowerBound=LowerBound
		upperBound=UpperBound
		'ocl' expression=Model ';'
	'}'
;

LowerBound returns cs::BoundCS:
	'lower' expression=Model ';'
;

UpperBound returns cs::BoundCS:
	'upper' expression=Model ';'
;

QosDimension returns cs::QoSDimensionCS:
	'qos' name=ID '{'
		tupleDescriptor=WeightTupleDescriptor
		'ocl' expression=Model ';'
	'}'
;

TypedPair returns cs::TypedPairCS:
	'(' first=TypedNamedPart ',' second=TypedNamedPart ')'
;

TypedNamedPart returns cs::TypedNamedPartCS:
	name=ID ':' ownedType=TypedRefCS
;

TupleDescriptor returns cs::TupleDescriptorCS:
	'descriptors' typedPairs+=TypedPair (',' typedPairs+=TypedPair)* ';'
;

WeightTupleDescriptor returns cs::WeightTupleDescriptorCS:
	'weight' weight=ID ';'
	'descriptors' typedPairs+=TypedPair (',' typedPairs+=TypedPair)* ';'
;

BoundWeightTupleDescriptor returns cs::BoundWeightTupleDescriptorCS:
	'weight' weight=ID ';'
	'bound' bound=ID ';'
	'descriptors' typedPairs+=TypedPair (',' typedPairs+=TypedPair)* ';'
;

Constraint returns cs::ConstraintCS:
	'constraint' (CoherenceConstraint | ResourceConstraint | LocationConstraint)
;

CoherenceConstraint returns cs::CoherenceConstraintCS:
	type=CoherenceConstraintType (name=ID)? '{'
		tupleDescriptor=TupleDescriptor
		'ocl' expression=Model ';'
	'}'
;

ResourceConstraint returns cs::ResourceConstraintCS:
	('resource' | 'requiredResource') (name=ID)? '{'
		tupleDescriptor=BoundWeightTupleDescriptor
		'ocl' expression=Model ';'
	'}'
;

LocationConstraint returns cs::LocationConstraintCS:
	('requiredHardwareResourceInstance' | 'requiredLocation') (name=ID)? '{'
		tupleDescriptor=TupleDescriptor
		'ocl' expression=Model';'
	'}'
;

enum CoherenceConstraintType returns cs::CoherenceConstraintType:
	COLLOCATION='sameLocation' | COLLOCATION='collocation'
		| SEPARATE_LOCATION='differentLocation' | SEPARATE_LOCATION='separateLocation'
;

MeasureFunction returns cs::MeasureFunctionCS:
	'measure' services+=[cs::ServiceCS] ('+' services+=[cs::ServiceCS])*';'
;

enum Goal returns cs::Goal:
	MIN='min' | MAX='max'
;