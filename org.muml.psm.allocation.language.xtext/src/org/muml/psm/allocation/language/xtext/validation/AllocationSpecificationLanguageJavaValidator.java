/*
* generated by Xtext
*/
package org.muml.psm.allocation.language.xtext.validation;

import org.eclipse.ocl.pivot.Type;
import org.eclipse.ocl.pivot.internal.utilities.EnvironmentFactoryInternal;
import org.eclipse.ocl.pivot.utilities.PivotUtil;
import org.eclipse.ocl.xtext.essentialoclcs.ContextCS;
import org.eclipse.xtext.validation.Check;
import org.muml.psm.allocation.language.as.EvaluableElement;
import org.muml.psm.allocation.language.cs.BoundCS;
import org.muml.psm.allocation.language.cs.BoundWeightTupleDescriptorCS;
import org.muml.psm.allocation.language.cs.CoherenceConstraintCS;
import org.muml.psm.allocation.language.cs.CsPackage;
import org.muml.psm.allocation.language.cs.EvaluableElementCS;
import org.muml.psm.allocation.language.cs.LocationConstraintCS;
import org.muml.psm.allocation.language.cs.QoSDimensionCS;
import org.muml.psm.allocation.language.cs.RelationCS;
import org.muml.psm.allocation.language.cs.ResourceConstraintCS;
import org.muml.psm.allocation.language.cs.TupleDescriptorCS;
import org.muml.psm.allocation.language.cs.WeightTupleDescriptorCS;
import org.muml.psm.allocation.language.xtext.typing.TypesUtil;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class AllocationSpecificationLanguageJavaValidator extends org.muml.psm.allocation.language.xtext.validation.AbstractAllocationSpecificationLanguageJavaValidator {
	private static final String typeMismatch = "Type mismatch: expected %s but got %s";
	private static final String noPivotElement = "Unable to retrieve pivot element for object %s";
	
	@Check
	public void checkRelationCS(RelationCS relationCS) {
		TupleDescriptorCS tupleDescriptorCS = relationCS.getTupleDescriptor();
		BoundCS lowerBoundCS = relationCS.getLowerBound();
		BoundCS upperBoundCS = relationCS.getUpperBound();
		ContextCS oclExpression = relationCS.getExpression();
		if (tupleDescriptorCS == null || oclExpression == null
				|| lowerBoundCS == null || upperBoundCS == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(relationCS);
	}
	
	@Check
	public void checkBoundCS(BoundCS boundCS) {
		if (boundCS.getExpression() == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(boundCS);
	}

	@Check
	public void checkCoherenceConstraintCS(CoherenceConstraintCS constraintCS) {
		TupleDescriptorCS tupleDescriptorCS = constraintCS.getTupleDescriptor();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorCS == null || oclExpression == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(constraintCS);
	}
	
	@Check
	public void checkLocationConstraintCS(LocationConstraintCS constraintCS) {
		TupleDescriptorCS tupleDescriptorCS = constraintCS.getTupleDescriptor();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorCS == null || oclExpression == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(constraintCS);
	}
	
	@Check
	public void checkResourceConstraintCS(ResourceConstraintCS constraintCS) {
		BoundWeightTupleDescriptorCS  tupleDescriptorCS = constraintCS.getTupleDescriptor();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorCS == null || tupleDescriptorCS.getWeight() == null
				|| tupleDescriptorCS.getBound() == null || oclExpression == null) {
			// parser/ui will display an error
			return;
		}
		checkTypes(constraintCS);
	}
	
	@Check
	public void checkQoSDimensionCS(QoSDimensionCS qosDimensionCS) {
		WeightTupleDescriptorCS tupleDescriptorCS = qosDimensionCS.getTupleDescriptor();
		ContextCS oclExpression = qosDimensionCS.getExpression();
		if (tupleDescriptorCS == null || tupleDescriptorCS.getWeight() == null
				|| oclExpression == null) {
			return;
		}
		checkTypes(qosDimensionCS);
	}
	
	private void checkTypes(EvaluableElementCS elementCS) {
		EvaluableElement element = PivotUtil.getPivot(EvaluableElement.class, elementCS);
		if (element == null) {
			// this is no "error(...)" but an exceptional situation
			throw new IllegalStateException(String.format(noPivotElement,
					elementCS));
		}
		EnvironmentFactoryInternal envFactory = TypesUtil.getEnvironmentFactory(element);
		Type expectedType = TypesUtil.createType(element);
		Type actualType = element.getExpression().getType();
		boolean conformsTo = TypesUtil.conformsTo(envFactory, actualType, expectedType);
		if (!conformsTo) {
			error(String.format(typeMismatch, expectedType, actualType),
					CsPackage.Literals.EVALUABLE_ELEMENT_CS__EXPRESSION);
		}
	}
	
}
