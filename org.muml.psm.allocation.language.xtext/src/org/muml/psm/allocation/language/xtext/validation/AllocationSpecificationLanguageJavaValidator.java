/*
* generated by Xtext
*/
package org.muml.psm.allocation.language.xtext.validation;

import org.eclipse.ocl.pivot.ExpressionInOCL;
import org.eclipse.ocl.pivot.Type;
import org.eclipse.ocl.pivot.internal.utilities.EnvironmentFactoryInternal;
import org.eclipse.ocl.xtext.essentialoclcs.ContextCS;
import org.eclipse.xtext.validation.Check;
import org.muml.psm.allocation.language.cs.BoundWeightTupleDescriptorCS;
//import org.muml.psm.allocation.language.cs.ComponentResourceTupleDescriptorCS;
import org.muml.psm.allocation.language.cs.CsPackage;
import org.muml.psm.allocation.language.cs.EvaluatableElementCS;
import org.muml.psm.allocation.language.cs.LocationConstraintCS;
//import org.muml.psm.allocation.language.cs.LocationTupleDescriptorCS;
import org.muml.psm.allocation.language.cs.QoSDimensionCS;
import org.muml.psm.allocation.language.cs.RequiredHardwareResourceInstanceConstraintCS;
import org.muml.psm.allocation.language.cs.ResourceConstraintCS;
import org.muml.psm.allocation.language.cs.TupleDescriptorCS;
import org.muml.psm.allocation.language.cs.WeightTupleDescriptorCS;
import org.muml.psm.allocation.language.xtext.typing.TypesUtil;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class AllocationSpecificationLanguageJavaValidator extends org.muml.psm.allocation.language.xtext.validation.AbstractAllocationSpecificationLanguageJavaValidator {
	private static final String typeMismatch = "Type mismatch: expected %s but got %s"; 

	@Check
	public void checkLocationConstraintCS(LocationConstraintCS constraintCS) {
		TupleDescriptorCS tupleDescriptorCS = constraintCS.getTupleDescriptor();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorCS == null || oclExpression == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(constraintCS);
	}
	
	@Check
	public void checkRequiredHardwareResourceInstanceConstraintCS(RequiredHardwareResourceInstanceConstraintCS constraintCS) {
		TupleDescriptorCS tupleDescriptorCS = constraintCS.getTupleDescriptor();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorCS == null || oclExpression == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(constraintCS);
	}
	
	@Check
	public void checkResourceConstraintCS(ResourceConstraintCS constraintCS) {
		BoundWeightTupleDescriptorCS  tupleDescriptorCS = constraintCS.getTupleDescriptor();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorCS == null || tupleDescriptorCS.getWeight() == null
				|| tupleDescriptorCS.getBound() == null || oclExpression == null) {
			// parser/ui will display an error
			return;
		}
		checkTypes(constraintCS);
	}
	
	@Check
	public void checkQoSDimensionCS(QoSDimensionCS qosDimensionCS) {
		WeightTupleDescriptorCS tupleDescriptorCS = qosDimensionCS.getTupleDescriptor();
		ContextCS oclExpression = qosDimensionCS.getExpression();
		if (tupleDescriptorCS == null || tupleDescriptorCS.getWeight() == null
				|| oclExpression == null) {
			return;
		}
		checkTypes(qosDimensionCS);
	}
	
	private void checkTypes(EvaluatableElementCS elementCS) {
		EnvironmentFactoryInternal envFactory = TypesUtil.getEnvironmentFactory(elementCS);
		Type expectedType = TypesUtil.createType(elementCS);
		Type actualType = ((ExpressionInOCL) elementCS.getExpression().getPivot()).getType();
		boolean conformsTo = TypesUtil.conformsTo(envFactory, actualType, expectedType);
		if (!conformsTo) {
			error(String.format(typeMismatch, expectedType, actualType),
					CsPackage.Literals.EVALUATABLE_ELEMENT_CS__EXPRESSION);
		}
	}
}
