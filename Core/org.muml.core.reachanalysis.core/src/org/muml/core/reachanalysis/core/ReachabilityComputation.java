package org.muml.core.reachanalysis.core;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.muml.core.reachanalysis.reachabilitygraph.HashToStateList;
import org.muml.core.reachanalysis.reachabilitygraph.ReachabilityGraph;
import org.muml.core.reachanalysis.reachabilitygraph.ReachabilityGraphFactory;
import org.muml.core.reachanalysis.reachabilitygraph.ReachabilityGraphState;
import org.muml.core.reachanalysis.reachabilitygraph.ReachabilityGraphTransition;

/**
 * Subclasses of this class implement the concrete reachability analysis algorithms.
 */
public abstract class ReachabilityComputation {
	
	/**
	 * Boolean flag indicating whether this reachability computation is executed in debug mode.
	 */
	private static boolean DEBUG = false;

	/**
	 * The reachability graph that is computed by the reachability analysis.
	 */
	protected ReachabilityGraph reachabilityGraph;

	/**
	 * The states that still have to be expanded.
	 */
	protected List<ReachabilityGraphState> todo;

	/**
	 * The solution evaluator that checks for reached states whether they is a solution.
	 */
	protected SolutionEvaluator solutionEvaluator;
	
	/**
	 * Indicates whether the solutionEvaluator has found a solution.
	 */
	private boolean solutionFound = false;
	
	/**
	 * Encodes the maximum length of a path that will be computed by the
	 * reachability computation, i.e., the node at position maxPathLength
	 * on a path will not be expanded.
	 */
	private int maxPathLength = Integer.MAX_VALUE;
	
	/**
	 * Defines the hash level that is used for computing the hash values for the
	 * {@link ReachabilityGraphState}s generated by the reachability analysis. By 
	 * default, LEVEL1 is used.
	 */
	private HashLevel hashLevel = HashLevel.LEVEL1;
	
	/**
	 * Statistics about the computation of the reachability graph.
	 */
	protected ReachabilityComputationStatistics stats = null;

	/**
	 * Constructor. The constructor is intended to be overriden by subclasses
	 * to pass the model to be checked.
	 */
	protected ReachabilityComputation() {
		this.todo = new LinkedList<ReachabilityGraphState>();
		this.solutionEvaluator = new SolutionEvaluator();
	}

	/**
	 * Returns the Reachability Graph.
	 */
	public ReachabilityGraph getReachabilityGraph() {
		return reachabilityGraph;
	}

	/**
	 * Returns the list of states that still have to be expanded.
	 */
	protected List<ReachabilityGraphState> getTodo() {
		return todo;
	}

	/**
	 * Returns the currently used solution evaluator.
	 */
	public SolutionEvaluator getSolutionEvaluator() {
		return solutionEvaluator;
	}

	/**
	 * Allows to set a new solution evaluator. The provided solutionEvaluator
	 * may never by null.
	 */
	public void setSolutionEvaluator(SolutionEvaluator newSolutionEvaluator) {
		if (newSolutionEvaluator == null){
			throw new IllegalArgumentException("Solution Evalutor for the reachability analysis must not be null.");
		}
		
		solutionEvaluator = newSolutionEvaluator;
	}
	
	/**
	 * Returns whether the reachability analysis has found any solution as defined
	 * by the solution evaluator that was used for the search.
	 * @return <i>true</i>, if a solution has been found;
	 * 		   <i>false</i>, otherwise
	 */
	public boolean isSolutionFound() {
		return solutionFound;
	}

	/**
	 * Sets whether the reachability analysis has found any solution as defined
	 * by the solution evaluator that was used for the search.
	 * @param solutionFound
	 */
	protected void setSolutionFound(boolean solutionFound) {
		this.solutionFound = solutionFound;
	}

	/**
	 * Returns the last solution that was found during the reachability analysis.
	 * If no solution was found, this method will return null.
	 * @return 
	 */
	public ReachabilityGraphState getLastSolution(){
		return getSolutionEvaluator().getLastSolution();
	}

	/**
	 * The main method for the reachability analysis. This method will compute the reachability graph
	 * until a solution has been found. If no solution is found, the whole reachability graph will be
	 * computed. By default, a breadth first search will be applied.
	 */
	public void computeReachabilityGraph() {
		
		// start of algorithm
		long totalTime = System.currentTimeMillis();
		
		//initialization phase
		this.reachabilityGraph = createReachabilityGraph();
		this.stats = createStatisticsObject();
		this.todo.clear();
		this.initialize();
		
		//start of computation phase
		long sysTime = System.currentTimeMillis();
		
		//create initial state and add to the containers
		ReachabilityGraphState initialState = createInitialState();
		
		this.reachabilityGraph.setStartState(initialState);
		this.reachabilityGraph.getStates().add(initialState);
		
		computeHashValue(initialState);
		this.reachabilityGraph.addToStatesMap(initialState);
		
		this.getTodo().add(initialState);
			
		//expansion phase
		while(!todo.isEmpty()){
			ReachabilityGraphState curState = todo.get(0);
			todo.remove(0);
			
			//check for solution before expanding the state
			if(solutionEvaluator.checkForPreSolution(curState)){
				this.setSolutionFound(true);
				return;
			}
			
			//expand the state if it does not exceed the maximum path length and 
			//if it is no dead end
			if (curState.getPathDepth() < maxPathLength){ 
				if(solutionEvaluator.isDeadEnd(curState) == false) {
					expand(curState);
				}
			} else {
				stats.numberOfPrunedBranches++;
			}
			
			//check for solution after expanding the state
			if(solutionEvaluator.checkForPostSolution(curState)){
				this.setSolutionFound(true);
				return;
			}
		}
		
		//End of Computation Phase
		long curTime = System.currentTimeMillis();
		stats.timeForReachabilityGraphComputation = curTime - sysTime;
		stats.totalTimeForReachabilityAnalysis = curTime - totalTime;
	}

	/**
	 * This method is called directly after the {@link ReachabilityGraph} has been created.
	 * It is meant to initialize the reachability graph as well as the reachability computation.
	 * This method is intended to be subclassed by concrete implementations.
	 */
	protected abstract void initialize();

	/**
	 * Expands the state given as a parameter, i.e. computing all successor states and checking
	 * them for isomorphismorphic states that are already contained in the reachability graph.
	 */
	protected void expand(ReachabilityGraphState state) {
		//get successors
		HashSet<? extends ReachabilityGraphState> successors = computeSuccessors(state);
		
		//set depth of successor and check for isomorphic states
		for(ReachabilityGraphState curSuccessor : successors){
			curSuccessor.setPathDepth(state.getPathDepth() + 1);
			unifyStates(curSuccessor);
		}
	}
	
	/**
	 * Computes all successors of the given state.
	 * 
	 * @param state
	 * @return a hash set containing all successor states or an empty hash set if no successors exist
	 */
	abstract protected HashSet<? extends ReachabilityGraphState> computeSuccessors(ReachabilityGraphState state);

	/**
	 * Checks whether the newState given as a parameter is isomorphic to a
	 * state which is already contained in the ReachabilityGraph.
	 */
	protected void unifyStates(ReachabilityGraphState newState) {
		//computeFullHash for new state
		long time = System.currentTimeMillis();
		computeHashValue(newState);
		stats.timeForHashComputation += (System.currentTimeMillis() - time);
		
		boolean isoStateFound = false;
		
		//get all states with the same hash
		HashToStateList candidates = this.getReachabilityGraph().getStatesWithHash().get(newState.getHash());
		if (candidates != null){
			
			//state has the same hash as one or more previous states
			stats.hashCollisions++;
			
			//states have the same hash, check for isomorphism to each candidate
			Iterator<ReachabilityGraphState> oldStateIter = candidates.getStates().iterator();
			while(isoStateFound == false && oldStateIter.hasNext()){
				ReachabilityGraphState oldState = oldStateIter.next();
				
				time = System.currentTimeMillis();
				if(isIsomorphic(oldState, newState)){
					
					//newState is isomorphic to oldState
					stats.isomorphismsFound++;
					
					//get predecessor of newState, there has to be exactly one!
					ReachabilityGraphTransition trans = newState.getIncomingTransitions().get(0);
					redirectTransition(oldState, trans, newState);
					this.getReachabilityGraph().getStates().remove(newState);
					this.getReachabilityGraph().getTransitions().add(trans);
					isoStateFound = true;
				}
				stats.timeForIsomorphismCheck += (System.currentTimeMillis() - time);
				
			}
			
		} 
		
		//if no isomorphic state has been found...
		if (!isoStateFound){
			//... add state to graph, todo list, and hash map
			this.getTodo().add(newState);
			this.getReachabilityGraph().getStates().add(newState);
			this.getReachabilityGraph().getTransitions().add(newState.getIncomingTransitions().get(0));
			if (candidates != null){
				candidates.getStates().add(newState);
			} else {
				HashToStateList newList = ReachabilityGraphFactory.eINSTANCE.createHashToStateList();
				newList.setHash(newState.getHash());
				newList.getStates().add(newState);
				this.getReachabilityGraph().getStatesWithHash().put(newState.getHash(), newList);
			}
		}
	}

	/**
	 * The expansion generated the newState as a successor of the expanded state. The newState is
	 * isomorphic to the oldState which is already contained in the reachability graph. This method
	 * now redirects the transition trans=(expandedState -> newState) which has been created during the
	 * expansion to the oldState. After this method has been executed, no transition points to the
	 * newState and trans=(expandedState -> oldState).
	 * 
	 * Subclasses need to override this method if the transition carries additional information that
	 * has to be altered when redirecting this transition.
	 * 
	 * @param oldState a state which is already contained in the reachability graph
	 * @param trans the transition which has to be redirected from the newState to the oldState
	 * @param newState a successor state of the expandedState which is isomorphic to the oldState
	 */
	protected void redirectTransition(ReachabilityGraphState oldState, ReachabilityGraphTransition transition, ReachabilityGraphState newState){
		newState.getIncomingTransitions().remove(transition);
		oldState.getIncomingTransitions().add(transition);
	}
	
	/**
	 * Creates a new ReachabilityGraph. This method has to be overriden
	 * in order to instantiate subclasses of ReachabilityGraph if this is
	 * necessary for special algorithms.
	 * @return
	 */
	protected ReachabilityGraph createReachabilityGraph(){
		return ReachabilityGraphFactory.eINSTANCE.createReachabilityGraph();
	}
	
	/**
	 * Returns an initial state for the reachability analysis.
	 */
	abstract protected ReachabilityGraphState createInitialState();

	/**
	 * Computes a hash value for the state and stores the result in the attribute hashValue of the state.
	 * @param state
	 */
	abstract protected void computeHashValue(ReachabilityGraphState state);
	
	/**
	 * Computes a reflective 1:1 copy of state and assigns the copy to the target of the transition trans.
	 * @param state the {@link ReachabilityGraphState} to be copied
	 * @param trans the {@link ReachabilityGraphTransition} targeting the copy
	 * @return a copy of state
	 */
	abstract public ReachabilityGraphState copyState(ReachabilityGraphState state, ReachabilityGraphTransition trans);
	
	abstract protected boolean isIsomorphic(ReachabilityGraphState state1, ReachabilityGraphState state2);

	protected ReachabilityComputationStatistics createStatisticsObject(){
		return new ReachabilityComputationStatistics(this.reachabilityGraph);
	}
	
	/**
	 * Returns the maximum length of a path computed by the reachability
	 * computation. By default, the value is set to Integer.MAX_VALUE().
	 * @return
	 */
	public int getMaxPathLength() {
		return maxPathLength;
	}

	/**
	 * Sets the maximum length of a path computed by the reachability
	 * computation. By default, the value is set to Integer.MAX_VALUE().
	 * @param maxPathLength
	 */
	public void setMaxPathLength(int maxPathLength) {
		this.maxPathLength = maxPathLength;
	}
	
	/**
	 * Returns whether the reachability computation is executed in debug mode.
	 * @return
	 */
	public static boolean isDEBUG() {
		return DEBUG;
	}

	/**
	 * Sets whether the reachability computation is executed in debug mode.
	 * @param dEBUG
	 */
	public static void setDEBUG(boolean dEBUG) {
		DEBUG = dEBUG;
	}

	/**
	 * Returns statistics about the computation of the reachability graph.
	 * @return
	 */
	public ReachabilityComputationStatistics getReachabilityComputationStatistics() {
		return stats;
	}

	/**
	 * Returns the hash level that is used for computing the hash values for the
	 * {@link ReachabilityGraphState}s generated by the reachability analysis. By 
	 * default, LEVEL1 is used.
	 */
	public HashLevel getHashLevel() {
		return hashLevel;
	}

	/**
	 * Sets the hash level that is used for computing the hash values for the
	 * {@link ReachabilityGraphState}s generated by the reachability analysis. By 
	 * default, LEVEL1 is used.
	 */
	public void setHashLevel(HashLevel hashLevel) {
		this.hashLevel = hashLevel;
	}

} // ReachabilityComputation
