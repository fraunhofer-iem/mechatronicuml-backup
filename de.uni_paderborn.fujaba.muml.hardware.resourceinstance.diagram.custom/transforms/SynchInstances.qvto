transformation ResourceInstanceRepositoryTransformation(inout input: PlatformPackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype HardwarePackage uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype ResourceTypePackage uses hardware::resourcetype('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformPackage uses hardware::platform('http://www.fujaba.de/muml/hardware/1.0/');
modeltype HWValuetypePackage uses hardware::hwvaluetype('http://www.fujaba.de/muml/hardware/1.0/');


/* This transformation creates and initialises the ResourceInstances of a ResourceInstanceRepository.
	A ResourceInstanceRepository references a ResourceTypeRepository which contains the ResourceTypes that are initialized
	in this ResourceInstanceRepository.
	Therefore this transformation creates all instances of the ResourceTypes which are contained in the corresponding ResourceTypeRepository.
*/

main() {
log("QVT-O Script \"ResourceInstanceRepositoryTransformation.qvto\" started.");
	// process ResourceInstanceRepository
	
	
//	input.rootObjects()[ResourceInstanceRepository]->forEach(rip){
//		rip.resourceTypeRepository:=rip.resourceTypeRepository;
//		rip.name:=rip.resourceTypeRepository.name;
//		log("Start to create the ResourceInstances for" +rip.eClass().name +", Name:" +rip.name);
//		var instances : Set(ResourceInstance);
		//create the StructuredResourceInstances of the ResourceInstanceRepository derived from the StructuredResources
//		instances +=rip.resourceTypeRepository.resourceTypes[StructuredResource]->map mapStructuredResource2StructuredResourceInstance();
		
		/* A lonely AtomicResource does not make sense in a ResourceInstanceRepository or in a HWPlatform, so we do not initialize them */
		//instances +=rip.resourceTypeRepository.resourceTypes[AtomicResource]-> map mapAtomicResource2AtomicResourceInstance(); 
		
		//create the DeviceInstances of the ResourceInstanceRepository derived from the Devices
//		instances +=rip.resourceTypeRepository.resourceTypes[Device]->map mapDevice2DeviceInstance();
//		rip.resourceInstances:=instances; 
//	}; 
	
	// process StructuredResourceInstance
	input.rootObjects()[StructuredResourceInstance]->forEach(sri){
		log("Initialize the StructuredResourceInstance for" +sri.eClass().name +", Name:" +sri.name);
			sri.isResourceTypeSet();
			//sri.name:=sri.resourceType.name;
			sri.embeddedAtomicResourceInstances+=sri.synchEmbeddedAtomicResourceInstances();
			sri.hwportInstances+=sri.synchHWPortInstances();
	};
	
	//process DeviceInstance
	input.rootObjects()[SensorInstance]->forEach(di){
		log("Initialize the DeviceInstance for" +di.eClass().name +", Name:" +di.name);
		di.isResourceTypeSet();
		if(di.resourceType.oclIsTypeOf(ResourceTypePackage::Device) and di.resourceType.oclAsType(ResourceTypePackage::Device).deviceType=ResourceTypePackage::DeviceKind::SENSOR) then{
		//di.name:=di.resourceType.name;
		di.hwportInstances+=di.synchHWPortInstances();
		}
		endif;
	};
	
	input.rootObjects()[ActuatorInstance]->forEach(di){
		log("Initialize the DeviceInstance for" +di.eClass().name +", Name:" +di.name);
		di.isResourceTypeSet();
		if(di.resourceType.oclIsTypeOf(ResourceTypePackage::Device) and di.resourceType.oclAsType(ResourceTypePackage::Device).deviceType=ResourceTypePackage::DeviceKind::ACTUATOR) then{
		di.name:=di.resourceType.name;
		di.hwportInstances+=di.synchHWPortInstances();
		}
		endif;
	};
		
}

/*tests if a resource type is set
* if no resource type is set the transformation is aborted
*/
helper ResourceInstance::isResourceTypeSet(){
	assert fatal (not self.resourceType.oclIsUndefined()) with log ("No Resource Type is set for:"+self.eClass().name + ", Name:"+self.name);
}


//keeps the port types and port instances in synch
helper ResourceInstance::synchHWPortInstances():OrderedSet(HWPortInstance){
var resourceType : ResourceType := self.resourceType;
var hwPortInstances : Set(HWPortInstance);
var lowerBound : Integer;
	self.hwportInstances->forEach(portInstance) {
			-- only delete those HWPortParts whose hwPortInstanceType is not contained in the current resourceInstance
		if (resourceType.hwports ->excludes(portInstance.hwportType)) then {
		
				input.removeElement(portInstance);
				portInstance.dump();
			}endif;
			
		}; 
	
	//create new ports
	resourceType.hwports -> forEach(hwport){
	if((self.hwportInstances -> select(p | p.hwportType = hwport)) -> isEmpty()) then {
		lowerBound:=hwport.cardinality.lowerBound.toInteger();
		while(lowerBound>0){
			hwPortInstances += hwport ->map mapHWPort2HWPortInstance(lowerBound);
			lowerBound:=lowerBound-1;
			};
		} endif;
	};
	
	return hwPortInstances->asOrderedSet();
}

/**
* synchs the embedded AtomicResources of a type and an instance of a structured resource
*/
helper StructuredResourceInstance::synchEmbeddedAtomicResourceInstances():OrderedSet(AtomicResourceInstance){
var resourceType : StructuredResource := self.resourceType.oclAsType(StructuredResource);
var embeddedAtomicResourceInstances : Set(AtomicResourceInstance);

self.embeddedAtomicResourceInstances->forEach(atomicInstance) {
			-- only delete those HWPortParts whose hwPortInstanceType is not contained in the current resourceInstance
		if (resourceType.embeddedAtomicResources ->excludes(atomicInstance.resourceType.oclAsType(AtomicResource))) then {
		
				input.removeElement(atomicInstance);
				atomicInstance.dump();
			}endif;
			
		}; 
		
	resourceType.embeddedAtomicResources -> forEach(atomicResource){
	if((self.embeddedAtomicResourceInstances -> select(r | r.resourceType = atomicResource)) -> isEmpty()) then {
			embeddedAtomicResourceInstances += atomicResource ->map mapAtomicResource2AtomicResourceInstance();
		} endif;
	};


return embeddedAtomicResourceInstances->asOrderedSet();
}


//create a StructuredResourceInstance derived from a StructuredResource
mapping  StructuredResource::mapStructuredResource2StructuredResourceInstance():StructuredResourceInstance{
	log("create StructuredResourceInstance for:"+self.eClass().name +", Name:" +self.name);
	name:=self.name;
	resourceType:=self;
	//create the AtomicResourceInstances of this StructuredResourceInstance derived from the embedded AtomicResources of the StructuredResource
	embeddedAtomicResourceInstances:=self.embeddedAtomicResources->map mapAtomicResource2AtomicResourceInstance();
	hwportInstances+=result.synchHWPortInstances();
}




//create a AtomicResourceInstance derived from a AtomicResource.
// The type of the returned AtomicResourceInstance is determined by the type of the AtomicResource.
mapping AtomicResource::mapAtomicResource2AtomicResourceInstance():AtomicResourceInstance{
	init{
		switch{ 	
			case (self.oclIsTypeOf(Processor)){
			result:=new ProcessorInstance(self.oclAsType(Processor));
					}
			case (self.oclIsTypeOf(ProgrammableLogicDevice)){
			result:=new ProgrammableLogicDeviceInstance();
					}
					
			case (self.oclIsTypeOf(Cache)){
			result:=new CacheInstance();
					}
			case (self.oclIsTypeOf(MemoryResource)){
			if(self.oclAsType(MemoryResource).isVolatile=true) then{
					result:=new ProcessingMemoryInstance();
						}endif;
				if(self.oclAsType(MemoryResource).isVolatile=false) then{
					result:=new StorageMemoryInstance();
						}endif;
					}
			else{//sollte nich aufgerufen werden
				result:=new ProcessorInstance();
			}
			};
	}
	log("create AtomicResourceInstance for:"+self.eClass().name+", Name:" +self.name+", Parent is:"+self.parentStructuredResource.name);
	name:=self.name;
	resourceType:=self;
	hwportInstances:=null;
	
}



//create a HWPortInstance derived from a HWPort
// The type of the returned HWPortInstance is derminted by the portType of the HWPort.
mapping HWPort::mapHWPort2HWPortInstance(number:Integer):HWPortInstance{
	init{
		switch{ 
			case (self.portType=(HWPortKind::BUS)){
			result:=new BusPortInstance();
					}
			case (self.portType=(HWPortKind::LINK)){
			result:= new LinkPortInstance();
					}			
			};
	}
	log("create HWPortInstance for:"+self.eClass().name+", Name:" +self.name+", Parent is:"+self.parentResource.name);
	hwportType:=self;
	name:=self.name+" "+number.toString();
}




//create a DeviceInstance derived from a Device
// The type of the returned DeviceInstance is derminted by the deviceType of the Device.
mapping  Device::mapDevice2DeviceInstance():DeviceInstance{
init{
	switch{ 
			case (self.deviceType=(DeviceKind::SENSOR)){
			result:=new SensorInstance();
					}
			case (self.deviceType=(DeviceKind::ACTUATOR)){
			result:= new ActuatorInstance();
					}			
			};
	
}
	log("create DeviceInstance for:"+self.eClass().name+", Name:" +self.name);
	name:=self.name;
	resourceType:=self;
	hwportInstances+=result.synchHWPortInstances();
}


//Constructor for a ProcessorInstance
// The ownedCacheInstance is resolved from the ownedCache of the Processor.
constructor ProcessorInstance::ProcessorInstance(resource:Processor){
	ownedCacheInstance:=resource.ownedCache.late resolveone(CacheInstance);
	frequency:=new Frequency(0);
	
}

constructor ProcessingMemoryInstance::ProcessingMemoryInstance(){
	result.memorySize:=new DataSize(0);
}

constructor StorageMemoryInstance::StorageMemoryInstance(){
	result.memorySize:=new DataSize(0);
}

constructor CacheInstance::CacheInstance(){
	result.memorySize:=new DataSize(0);
}

constructor ProgrammableLogicDeviceInstance::ProgrammableLogicDeviceInstance(){
	result.frequency:=new Frequency(0);
}

constructor DataSize::DataSize(value:EDouble){
	result.value:=value;
	result.unit:=DataSizeUnit::Byte;
}

constructor Frequency::Frequency(value:EDouble){
	result.value:=value;
	result.unit:=FrequencyUnit::Hz;
} 

// Convenience query to cast a natural number to an integer, using -1 as value for infinity.
query NaturalNumber::toInteger() : Integer {
	if (self.infinity) then {
		return -1;
	} endif;
	return self.value;
}

