
modeltype transformationHelper uses "http://www.fujaba.de/muml/model/component/0.3.1";
modeltype rtsc uses "http://www.fujaba.de/muml/model/realtimestatechart/0.3.1";
modeltype msgIFace uses "http://www.fujaba.de/muml/model/msgiface/0.3.1";
modeltype mumlCore uses "http://www.fujaba.de/muml/model/core/0.3.1";
modeltype ecore uses ecore;
modeltype actionLanguage uses "http://www.fujaba.de/muml/actionlanguage/0.2.0";
modeltype sdmCore uses "http://www.storydriven.org/core/0.3.1";
modeltype sdmExpressions uses "http://www.storydriven.org/core/expressions/0.2.0";

-- this transformation copies the input model for the TSC transformation
transformation CopyInputModel(in source : rtsc, out target : rtsc);

-- TODO: 
--   - consider Entry- and ExitPoints of a statechart
--   - consider StateEntry- and ExitPoint of a state

main() {
	source.objects()[RealtimeStatechart]->map copyStatechart()->any(true);
}

mapping RealtimeStatechart::copyStatechart() : RealtimeStatechart{
	log("CopyStatechart");
	-- copy attributes
	name := self.name;
	eventQueueSize := self.eventQueueSize;
	history := self.history;
	
	-- copy references
	clocks += self.clocks -> map copyClock();
	vertices += (self.vertices  -> select(v : Vertex | v.oclIsTypeOf(State))).oclAsType(State) -> map copyStates();
	transitions += self.transitions -> map copyTransitions();
}

mapping Clock::copyClock() : Clock{
	name := self.name;
}

mapping State::copyStates() : State{
	-- copy attributes
	initial := self.initial;
	final := self.final;
	urgent := self.urgent;
	name := self.name;
	
	--copy references
	channels := self.channels -> map copySynchronizationChannels();
	invariants := self.invariants -> map copyClockConstraint();
	doEvent := self.doEvent -> map copyDoEvent() -> any(true); -- to-1 reference, so there is at most one result
	entryEvent := self.entryEvent -> map copyEntryEvent() -> any(true); -- to-1 reference, so there is at most one result
	exitEvent := self.exitEvent -> map copyExitEvent() -> any(true); -- to-1 reference, so there is at most one result
	regions := self.regions -> map copyRegion(); 
}

mapping Transition::copyTransitions() : Transition{
	-- copy attributes
	priority := self.priority;
	blockable := self.blockable;

	-- copy references
	absoluteDeadlines := self.absoluteDeadlines -> map copyAbsoluteDeadline();
	action := self.action.deepclone().oclAsType(Action);
	clockConstraints := self.clockConstraints -> map copyClockConstraint();
	clockResets := self.clockResets.resolve(Clock);
	events := (self.events -> select(v : TransitionEvent | v.oclIsTypeOf(AsynchronousMessageEvent))).oclAsType(AsynchronousMessageEvent) -> map copyAsynchronousMessageEvent();
	relativeDeadline := self.relativeDeadline -> map copyRelativeDeadline() -> any(true);
	result.source := self.source.resolveone(State);
	result.target := self.target.resolveone(State);
	synchronization := self.synchronization -> map copySynchronization() -> any(true);	
	guard := self.guard.deepclone().oclAsType(Expression);
}

mapping Region::copyRegion() : Region{
	log("Copy region");
	-- copy attributes
	priority := self.priority;
	name := self.name;
	
	-- copy the statechart, result will only be one statechart, so select any from the result set of the mapping operation
	statechart := self.statechart -> map copyStatechart() -> any(true);
}

mapping SynchronizationChannel::copySynchronizationChannels() : SynchronizationChannel{
	name := self.name;
	
	-- copy parameters
	parameters := self.parameters.deepclone().oclAsType(Parameter);
}

mapping Synchronization::copySynchronization() : Synchronization{
	kind := self.kind;
	
	--callee
	syncChannel := self.syncChannel.resolveone(SynchronizationChannel);
	
	--parameter binding
	parameterBinding := self.parameterBinding.deepclone().oclAsType(ParameterBinding);
}

mapping ClockConstraint::copyClockConstraint() : ClockConstraint{
	bound := self.bound -> map copyNaturalNumber() -> any(true);
	operator := self.operator;
	clock := self.clock.resolveone(Clock);
}

mapping NaturalNumber::copyNaturalNumber() : NaturalNumber{
	value := self.value;
	infinity := self.infinity;
}

mapping DoEvent::copyDoEvent() : DoEvent{
	periodLower := self.periodLower;
	periodUpper := self.periodUpper;
	action := self.action.deepclone().oclAsType(Action);
}


mapping EntryEvent::copyEntryEvent() : EntryEvent{
	clockResets := self.clockResets.resolve(Clock);
	action := self.action.deepclone().oclAsType(Action);
}

mapping ExitEvent::copyExitEvent() : ExitEvent{
	clockResets := self.clockResets.resolve(Clock);
	action := self.action.deepclone().oclAsType(Action);
}

mapping AsynchronousMessageEvent::copyAsynchronousMessageEvent() : AsynchronousMessageEvent{
	kind := self.kind;
	message := self.message -> map copyMessage() -> any(true); -- to-one reference
}

mapping Message::copyMessage() : Message{
	instanceOf := self.instanceOf;
	parameterBinding := self.parameterBinding.deepclone().oclAsType(ParameterBinding);
}


mapping AbsoluteDeadline::copyAbsoluteDeadline() : AbsoluteDeadline{
	lowerBound := self.lowerBound;
	upperBound := self.upperBound;
	clock := self.clock.resolveone(Clock);
}

mapping RelativeDeadline::copyRelativeDeadline() : RelativeDeadline{
	lowerBound := self.lowerBound;
	upperBound := self.upperBound;
}
