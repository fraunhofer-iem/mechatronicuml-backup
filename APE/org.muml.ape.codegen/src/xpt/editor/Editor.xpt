«IMPORT ape»
«EXTENSION Metamodel»

«DEFINE ClassEditor FOR Class»
«FILE package.generator.sourceFolder + "/" + genQualifiedEditorName().replaceAll('\\.', '/').toString() + '.java'»
package «package.genPackageName()».editor;

/**
 * @generated
 */
public «IF genClass.ecoreClass.abstract»abstract«ENDIF» class «genEditorName()» extends de.uni_paderborn.fujaba.properties.runtime.editors.ClassPropertyEditor {
	«EXPAND classBody»
}
«ENDFILE»
«ENDDEFINE» 

«DEFINE classBody FOR Class»

	/**
	 * @generated
	 */
	public «genEditorName()»(String tab, org.eclipse.emf.common.notify.AdapterFactory adapterFactory, org.eclipse.emf.ecore.EClass eClass) {
		super(tab, adapterFactory, eClass);
	}

	/**
	 * @generated
	 */
	@Override
	protected void createProperties() {
		if (tab == null) {
			«EXPAND createClassElements(this, null)»
		} else
		«FOREACH package.generator.allGenerators().tabs AS tab-»
		if ("«tab.id»".equals(tab)) { // Tab «tab.name»
			«EXPAND createClassElements(this, tab)»
		} else
		«ENDFOREACH-»
		{ }
	}
	
	«FOREACH { this }.union(allSuperClasses).properties.select(p | getHighestContainer(p) == p.clazz) AS this»
		private de.uni_paderborn.fujaba.properties.runtime.editors.AbstractStructuralFeaturePropertyEditor «genField()»;
		private de.uni_paderborn.fujaba.properties.runtime.editors.AbstractStructuralFeaturePropertyEditor «genCreator()»() {
			if (this.«genField()» == null) {
				final org.eclipse.emf.ecore.EStructuralFeature feature = «genFeature.genFeatureLiteral()»;
				final de.uni_paderborn.fujaba.properties.runtime.editors.AbstractStructuralFeaturePropertyEditor editor = «IF editor == null»null;«ELSE»«EXPAND createEditor(this, "feature") FOR editor»«ENDIF»
				«EXPAND addVisibilityFilter("editor", "feature") FOREACH visibilityFilters»
				«EXPAND addReadOnlyFilter("editor", "feature") FOREACH readOnlyFilters»
				«IF initializeOCLExpression != null && initializeOCLExpression.toString().length > 0»
					«EXPAND setInitializeOCLExpression("editor", "feature")»
				«ENDIF»

				«IF genDocumentation() != null»
				editor.setTooltipMessage("«genDocumentation().escapeString()»");
				«ENDIF»
				«EXPAND addCreationConstraintFilter("editor", "feature") FOREACH creationConstraint.filters»
				this.«genField()» = editor;
			}
			return this.«genField()»;
		}
	«ENDFOREACH»


«IF !genClass.ecoreClass.abstract»


	//
	// instantiation
	//
	
	
	/**
	 * @generated
	 */
	public «genEditorName()»(String tab) {
		this(tab, «package.generator.genPluginId()».util.PropertiesUtil.INSTANCE.getAdapterFactory(), «this.genClass.genClassLiteral()»);
	}
	
	/**
	 * @generated
	 */
	public static class Factory implements de.uni_paderborn.fujaba.properties.runtime.factory.IPropertyEditorFactory {
		@Override
		public de.uni_paderborn.fujaba.properties.runtime.editors.IPropertyEditor createPropertyEditor(String tab) {
			return new «genEditorName()»(tab);
		}
		
		@Override
		public boolean hasTab(java.lang.String tab) {
			return java.util.Arrays.asList(
				new java.lang.String[] { «FOREACH genAllTabs() AS tab SEPARATOR ',\n'»"«tab.id»"«ENDFOREACH» }
			).contains(tab);
		}
	}
«ENDIF»
«ENDDEFINE»

«DEFINE createClassElements(Class originalClass, PropertyTab tab) FOR Class»
	«REM»Create Super Classes that are not positioend using base insert points. We put them at the top.«ENDREM»
	«FOREACH superClasses.reject(s | baseInsertPoints.baseClass.contains(s)) AS this»
		«EXPAND createClassElements(originalClass, tab)»
	«ENDFOREACH»
	«REM»my own order of elements«ENDREM»
	«FOREACH orderedElements AS this»
		«EXPAND createElement(originalClass, tab)»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE createElement(Class originalClass, PropertyTab _tab) FOR OrderedElement»ERROR: No codegen for «this.toString()»«ENDDEFINE»
«DEFINE createElement(Class originalClass, PropertyTab _tab) FOR Property»
	«IF originalClass.getHighestContainer(this) == clazz && { originalClass }.union(originalClass.allSuperClasses).propertyCategories.select(c | c.properties.contains(this) && originalClass.getHighestContainer(c) == c.clazz).isEmpty»
		«IF _tab == null || this.tab == _tab»
		addPropertyEditor(«genCreator()»(), false);
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE createElement(Class originalClass, PropertyTab tab) FOR PropertyCategory»
	«IF originalClass.getHighestContainer(this) == clazz»
		«IF !properties.select(p | p != null && p.tab == tab || tab == null).isEmpty»
		addSubCategory("«genCategoryKey()»", "«title»", «IF vertical»org.eclipse.swt.SWT.VERTICAL«ELSE»org.eclipse.swt.SWT.HORIZONTAL«ENDIF», «open»);
		«ENDIF»
		«FOREACH properties.select(p | p != null && p.tab == tab || tab == null) AS property»
			«LET findHighestProperty(originalClass, property) AS highestProperty»
			addEditorToCategory("«genCategoryKey()»", «highestProperty.genCreator()»(), false);
			«ENDLET»
		«ENDFOREACH»
	«ENDIF»
«ENDDEFINE»

«DEFINE createElement(Class originalClass, PropertyTab tab) FOR BaseInsertPoint»
	«EXPAND createClassElements(originalClass, tab) FOR baseClass»
«ENDDEFINE»


«DEFINE createEditor(Property property, String featureVar) FOR PropertyEditor-»
ERROR: No codegen for «this.toString()»
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR CheckboxPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.CheckboxPropertyEditor(adapterFactory, «featureVar»);
«ENDDEFINE»


«DEFINE createEditor(Property property, String featureVar) FOR SpinnerPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.SpinnerPropertyEditor(adapterFactory, «featureVar», «digits»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR RadioPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.OptionPropertyEditor(adapterFactory, «featureVar»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR ComboBoxPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.ComboPropertyEditor(adapterFactory, «featureVar»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR TextPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.TextPropertyEditor(adapterFactory, «featureVar», «multiLine»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR ListPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.ListPropertyEditor(adapterFactory, «featureVar»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR FlattenedListPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.FlattenedListPropertyEditor(adapterFactory, «featureVar»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR ObjectPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.NavigationFeaturePropertyEditor(adapterFactory, «featureVar»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR OCLPropertyEditor-»
new de.uni_paderborn.fujaba.properties.runtime.editors.OCLPropertyEditor(adapterFactory, «featureVar»);
«ENDDEFINE»

«DEFINE createEditor(Property property, String featureVar) FOR CustomPropertyEditor-»
new «fullyQualifiedClassName»(adapterFactory, «featureVar»);
«ENDDEFINE»


«DEFINE addVisibilityFilter(String editorVar, String featureVar) FOR Filter»«ENDDEFINE»
«DEFINE addVisibilityFilter(String editorVar, String featureVar) FOR OCLFilter»
	{
		final org.eclipse.ocl.ecore.OCLExpression expression = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.createOCLExpression("«expression.escapeString()»", «featureVar», getEClass());
		«editorVar».setInput(input);
		«editorVar».registerOCLAdapter(expression, new org.eclipse.emf.common.notify.impl.AdapterImpl() {
			@Override
			public void notifyChanged(org.eclipse.emf.common.notify.Notification notification) {
				boolean visibleBefore = «editorVar».isVisible();
				«editorVar».updateVisibility(true);

				// Set default value, if we are hiding the editor and it was not hidden before.
				if (!«editorVar».isVisible() && visibleBefore) {
					«editorVar».setDefaultValue();
				}
			}
		});
		final org.eclipse.ocl.Query<org.eclipse.emf.ecore.EClassifier, ?, ?> query = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.OCL_ECORE.createQuery(expression);
		org.eclipse.jface.viewers.IFilter filter = new org.eclipse.jface.viewers.IFilter() {

			@Override
			public boolean select(Object object) {
				return object != null && Boolean.TRUE.equals(query.evaluate(object));
			}

		};
		if (filter != null && expression != null) {
			«editorVar».addVisibilityFilter(filter);
		}
	}
«ENDDEFINE»


«DEFINE addReadOnlyFilter(String editorVar, String featureVar) FOR Filter»«ENDDEFINE»
«DEFINE addReadOnlyFilter(String editorVar, String featureVar) FOR OCLFilter»
	{
		final org.eclipse.ocl.ecore.OCLExpression expression = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.createOCLExpression("«expression.escapeString()»", «featureVar», getEClass());
		«editorVar».setInput(input);
		«editorVar».registerOCLAdapter(expression, new org.eclipse.emf.common.notify.impl.AdapterImpl() {
			@Override
			public void notifyChanged(org.eclipse.emf.common.notify.Notification notification) {
				boolean visibleBefore = «editorVar».isVisible();
				«editorVar».updateVisibility(true);

				// Set default value, if we are hiding the editor and it was not hidden before.
				if (!«editorVar».isVisible() && visibleBefore) {
					«editorVar».setDefaultValue();
				}
			}
		});
		final org.eclipse.ocl.Query<org.eclipse.emf.ecore.EClassifier, ?, ?> query = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.OCL_ECORE.createQuery(expression);
		org.eclipse.jface.viewers.IFilter filter = new org.eclipse.jface.viewers.IFilter() {

			@Override
			public boolean select(Object object) {
				return object != null && Boolean.TRUE.equals(query.evaluate(object));
			}

		};
		if (filter != null) {
			«editorVar».addReadOnlyFilter(filter);
		}
	}
«ENDDEFINE»

«DEFINE setInitializeOCLExpression(String editorVar, String featureVar) FOR Property»
	{
		final org.eclipse.ocl.ecore.OCLExpression initExpression = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.createOCLExpression("«initializeOCLExpression.toString().escapeString()»", «featureVar», getEClass());
		final org.eclipse.ocl.Query<org.eclipse.emf.ecore.EClassifier, ?, ?> query = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.OCL_ECORE.createQuery(initExpression);
		if (query != null) {
			«editorVar».setInitializeQuery(query);
		}
	}
«ENDDEFINE»

«DEFINE addCreationConstraintFilter(String editorVar, String featureVar) FOR Filter»«ENDDEFINE»

«DEFINE addCreationConstraintFilter(String editorVar, String featureVar) FOR OCLFilter»
	{
		final org.eclipse.ocl.ecore.OCLExpression expression = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.createOCLExpression("«expression.escapeString()»", «featureVar», getEClass());
		final org.eclipse.ocl.Query<org.eclipse.emf.ecore.EClassifier, ?, ?> query = de.uni_paderborn.fujaba.properties.runtime.RuntimePlugin.OCL_ECORE.createQuery(expression);
		query.getEvaluationEnvironment().add("eclass", null);
		de.uni_paderborn.fujaba.properties.runtime.filter.ICreationFilter filter = new de.uni_paderborn.fujaba.properties.runtime.filter.ICreationFilter() {

			@Override
			public boolean select(Object object, org.eclipse.emf.ecore.EClass eClass) {
				query.getEvaluationEnvironment().replace("eclass", eClass);
				return Boolean.TRUE.equals(query.evaluate(object));
			}

				
		};
		if (filter != null) {
			«editorVar».addCreationFilter(filter);
		}
	}
«ENDDEFINE»