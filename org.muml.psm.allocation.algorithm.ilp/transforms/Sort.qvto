import VariableHelper;
import TupleAccessor;

modeltype allocationSpecification uses cs('http://www.muml.org/psm/allocation/language/cs/1.0.0');
modeltype core uses core('http://www.muml.org/core/1.0.0');
modeltype values uses values('http://www.eclipse.org/ocl/2015/Values');

library Sort;

// common sorting code

query Sequence(NamedElement)::sortComponentResourceSequence() : Sequence(NamedElement) {
	return let indexes : OrderedSet(Integer) = getOddNumbers(1, self->size())
	in
	indexes->collectNested(i | Sequence{self->at(i), self->at(i + 1)})
		->sortedBy(s | s->getVariableName())->flatten()
}

query Sequence(TupleValue)::sortWeightingComponentResourceTuples(tupleDescriptor : WeightTupleDescriptorCS) : Sequence(TupleValue) {
	return self->sortedBy(tv : TupleValue | tv.getWeightingComponentResourceTupleSortId(tupleDescriptor));
}

query TupleValue::getWeightingComponentResourceTupleSortId(tupleDescriptor : WeightTupleDescriptorCS) : String {
	// Order by component_ecu names and add the coefficient/LhsValue as a tie breaker
	// for the sort algo
	// this uniquely identifies a WeightingComponentResourceTuple tuple (because
	// the WeightingComponentResourceTuple tuples are contained in a set => no duplicates)
	return self.toSequence()->sortComponentResourceSequence()->getVariableName()
		+ ILLEGAL_VARIABLE_CHARS()->at(1) + self.getWeighting(tupleDescriptor); 
}

query TupleValue::getWeighting(tupleDescriptor : WeightTupleDescriptorCS) : String {
	return self.get(tupleDescriptor.weight).oclAsType(Real).toString();
}