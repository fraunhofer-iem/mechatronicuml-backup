import org.muml.psm.allocation.algorithm.ocl.TupleAccessorBlackboxUnit;
import Util;

modeltype allocationSpecification uses as('http://www.muml.org/psm/allocation/language/as/1.0.0');
modeltype core uses core('http://www.muml.org/core/1.0.0');
modeltype values uses values('http://www.eclipse.org/ocl/2015/Values');

library TupleAccessor;

helper TupleValue::get(namedPart : String) : OclAny {
	//log("resolve call: ");
	var source : EvaluatableElement := self.invresolveone(EvaluatableElement);
	//log(source.toString());
	return getPart(self, namedPart, source);
}

helper TupleValue::getSequence(namedPart : String) : Sequence(TupleValue) {
	var source : EvaluatableElement := self.invresolveone(EvaluatableElement);
	return getSequencePart(self, namedPart, source);
}

query TupleValue::toSequence() : Sequence(NamedElement) {
	// it might be possible that source is not the source we expect:
	// source might be a previously transformed constraint. This is no problem
	// because we the toSequence call will return the _expected_ sequence.
	// Alternatively, we can fix this be doing an invresolve(...)->last() or
	// ->first() (to be investigated) to get the "correct"/expected constraint
	// (implicit assumption: the tuple value is only accessed during the transformation
	// of the constraint)
	var source : EvaluatableElement := self.invresolveone(EvaluatableElement);
	return source.toSequence(self);
}

query LocationConstraint::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	// there should be exactly one typedPair
	return self.tupleDescriptor.toSequence(tupleValue); 
}

query TupleDescriptor::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	return self.typedPairs->collect(typedPair : TypedPair |
		Sequence{
			tupleValue.get(typedPair.first.name).oclAsType(NamedElement),
			tupleValue.get(typedPair.second.name).oclAsType(NamedElement)
		}
	);
}

query RequiredHardwareResourceInstanceConstraint::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	return self.tupleDescriptor.toSequence(tupleValue);
}

// Note: it is not possible to generalize the next two queries into
// WeightingComponentResourceTupleElement::toSequence, because WeightingComponentResourceTupleElement
// is just a "secondary" superclass in ResourceConstraint' and QoSDimensionConstraint'
// inheritance hierarchy. As a consequence the "catch-call" EvaluatableElement::toSequence
// query is called and the transformation fails. XXX: how does qvto's "linearization" algo work?
query ResourceConstraint::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	// unfortunately we cannot check if tupleValue corresponds to an "inner" tuple
	// (well... we could do this via a blackbox but it is probably not worth the effort)
	// => we assume that the caller knows what he/she is doing
	return self.tupleDescriptor.toSequence(tupleValue);
}

query QoSDimension::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	return self.tupleDescriptor.toSequence(tupleValue);
}

query EvaluatableElement::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	// should not happen
	assert fatal (false) with log("add element specific ::toSequence mapping for " + self.toString());
	return null;
}