import Expressions;
import Util;
import VariableHelper;

modeltype ilptype uses ilp('http://www.muml.org/psm/allocation/ilp/1.0.0');
modeltype expressions uses core::expressions('http://www.muml.org/core/expressions/1.0.0');
modeltype common uses core::expressions::common('http://www.muml.org/core/expressions/common/1.0.0');
modeltype instance uses pim::instance('http://www.muml.org/pim/instance/1.0.0');
modeltype hwpinstance uses hardware::hwplatforminstance('http://www.muml.org/pm/hardware/hwplatforminstance/1.0.0');
modeltype hwrinstance uses hardware::hwresourceinstance('http://www.muml.org/pm/hardware/hwresourceinstance/1.0.0');

library Variables;

helper Sequence(OclAny)::createHelperVariablesAndConstraints(inout ilp : IntegerLinearProgram) : Variable {
	var variable : Variable := self->getVariable();
	if (not variable.oclIsUndefined()) then {
		return variable;
	} endif;
	-- indicates a specification error
	assert fatal (self->size() > 2) with
		log("sequence elements were never related to each other");
	var left : Sequence(OclAny) := self->subSequence(1, self->size() - 2);
	var right : Sequence(OclAny) := self->subSequence(3, self->size());
	var leftVariable : Variable := left->createHelperVariablesAndConstraints(ilp);
	var rightVariable : Variable := right->createHelperVariablesAndConstraints(ilp);
	variable := self->map createBinaryVariable();
	ilp.variables += variable;
	createHelperVariableConstraints(ilp, leftVariable, rightVariable, variable);
	return variable;
}

helper createHelperVariableConstraints(inout ilp : IntegerLinearProgram, leftVariable : Variable,
	rightVariable : Variable, variable : Variable) {
	ilp.constraints += createHelperVariableConstraint(leftVariable, variable);
	ilp.constraints += createHelperVariableConstraint(rightVariable, variable);
	ilp.constraints += createHelperVariableConstraint(leftVariable, rightVariable, variable);
}

helper createHelperVariableConstraint(reducedVariable : Variable, variable : Variable) : ConstraintExpression {
	return new ConstraintExpression(new VariableExpression(variable),
		new VariableExpression(reducedVariable), ComparingOperator::LESS_OR_EQUAL, null);
}

helper createHelperVariableConstraint(leftVariable : Variable,
	rightVariable : Variable, variable : Variable) : ConstraintExpression {
	return new ConstraintExpression(
		new ArithmeticExpression(
			new VariableExpression(leftVariable),
			new VariableExpression(rightVariable),
			ArithmeticOperator::PLUS
		),
		new ArithmeticExpression(
			new LiteralExpression('1'),
			new VariableExpression(variable),
			ArithmeticOperator::PLUS
		), ComparingOperator::LESS_OR_EQUAL, null
	);
}

// binary

mapping Sequence(OclAny)::createBinaryVariable() : Variable {
	log("binary called for: " + self->getVariableName());
	name := self->getVariableName();
	dataType := ILPDataType::BINARY;
}

query Variable::getBinaryVariableSequence() : Sequence(OclAny) {
	return self.invresolveoneIn(
		Sequence(OclAny)::createBinaryVariable,
		Sequence(OclAny)
	);
}