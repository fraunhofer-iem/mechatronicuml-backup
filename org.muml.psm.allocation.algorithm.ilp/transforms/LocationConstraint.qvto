import Expressions;
import OCLEvaluator;
import TupleAccessor;
import Sort;
import Util;
import Variables;
import VariableHelper;

modeltype allocationSpecification uses as('http://www.muml.org/psm/allocation/language/as/1.0.0');
modeltype ilptype uses ilp('http://www.muml.org/psm/allocation/ilp/1.0.0');
modeltype common uses core::expressions::common('http://www.muml.org/core/expressions/common/1.0.0');
modeltype values uses values('http://www.eclipse.org/ocl/2015/Values');

-- XXX: we probably need a semantics change here generate ">= 1" inequalities
-- 		instead of "= 1" equations (needs to be discussed)


library LocationConstraintLib;

// the implementation of the differentLocation constraint differs from the approach,
// which was described in my thesis

helper Specification::createLocationConstraints(inout ilp : IntegerLinearProgram,
	oclContext : OclAny) {
	self.getLocationConstraints()->createLocationConstraint(ilp, oclContext);
}

helper LocationConstraint::createLocationConstraint(inout ilp : IntegerLinearProgram,
	oclContext : OclAny) {
	log("SORT");
	var sequences : Sequence(Sequence(OclAny)) := self.evaluateOCL(oclContext)
		.asTupleValueSequence()
		->collectNested(toSequence())
		->sortComponentResourceSequences(); 
	log("SORT");
	sequences->forEach(seq) {
		seq->createHelperVariableAndConstraints(ilp);
	};
	while (sequences->notEmpty()) {
		var cur : Sequence(OclAny) := sequences->first();
		// since createConstraintExpression generates an equality ("= 1"),
		// we must get rid of duplicates (hence, we do the
		// -> OrderedSet -> Sequence conversion)
		// (actually, todo could be an OrderedSet(Sequence(NamedElement)),
		// but the other helpers/queries expect a Sequence...)
		var todo : Sequence(Sequence(OclAny)) := cur->getAssociatedSequences(sequences)
			->asOrderedSet()->asSequence();
		sequences := sequences->reject(seq | todo->includes(seq));
		todo->createConstraintExpression(ilp, self)
	};
}

query Sequence(Sequence(OclAny))::sortComponentResourceSequences() : Sequence(Sequence(OclAny)) {
	return self->collectNested(seq |
		seq->sortComponentResourceSequence()
	)->sortedBy(seq | seq->getVariableName());
}

/*query TupleValue::toSequences() : Sequence(Sequence(NamedElement)) {
	return let sequence : Sequence(NamedElement) = self.toSequence()
	in
	let indexes : OrderedSet(Integer) = getOddNumbers(1, sequence->size())
	in
	indexes->collectNested(i | sequence->subSequence(i, i + 1));
}*/

query Sequence(OclAny)::getAssociatedSequences(sequence : Sequence(Sequence(OclAny)))
	: Sequence(Sequence(OclAny)) {
	return sequence->select(seq |
		let indexes : OrderedSet(Integer) = getOddNumbers(1, self->size())
		in
		indexes->collect(i |
			seq->at(i)
		)->asBag() = indexes->collect(i | self->at(i))->asBag()
	);
}

helper Sequence(Sequence(OclAny))::createConstraintExpression(inout ilp : IntegerLinearProgram,
	constraint : LocationConstraint) {
	log("createLocationConstraintExpression");
	self->print();
	var comment : String := if constraint.name <> '' then constraint.name else null endif;
	ilp.constraints += self->createAdditionConstraintExpression(
		ComparingOperator::EQUAL,'1', comment
	);
	log("createHWRESConstraintExpression");
}

query Specification::getLocationConstraints() : OrderedSet(LocationConstraint) {
	return self.constraints
		->select(oclIsKindOf(LocationConstraint))
		->collect(oclAsType(LocationConstraint))
		->asOrderedSet();
}
