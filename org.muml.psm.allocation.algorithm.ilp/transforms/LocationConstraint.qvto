import Expressions;
import OCLEvaluator;
import TupleAccessor;
import VariableHelper;
import Variables;

modeltype allocationSpecification uses as('http://www.muml.org/psm/allocation/language/as/1.0.0');
modeltype ilptype uses ilp('http://www.muml.org/psm/allocation/ilp/1.0.0');
modeltype common uses core::expressions::common('http://www.muml.org/core/expressions/common/1.0.0');
modeltype values uses values('http://www.eclipse.org/ocl/2015/Values');


library LocationConstraintLib;

helper Specification::createLocationConstraints(inout ilp : IntegerLinearProgram,
	oclContext : OclAny) {
	self.getCollocationConstraints()->createConstraint(self, ilp, oclContext);
	self.getDifferentLocationConstraints()->createConstraint(self, ilp, oclContext);
}

helper LocationConstraint::createConstraint(specification : Specification,
	inout ilp : IntegerLinearProgram, oclContext : OclAny) {
	log("create LocationConstraint");
	var sequences : Sequence(Sequence(OclAny)) := self.evaluateOCL(oclContext)
		.asTupleValueSequence()
		->collectNested(
			-- convert TupleValue to sequence and sort its elements
			-- (needed in order to prune the "semantical" duplicates)
			toSequence()->sortedBy(getVariableName())
		)
		->asSet() -- prune duplicates
		->asSequence()
		->sortedBy(seq : Sequence(OclAny) |
			seq->getVariableName()
		);
	-- first, all helper variables
	sequences->forEach(seq) {
		seq->createHelperVariables(specification, ilp, oclContext);
	};
	-- then, all constraints (just for "readability" of the ilp)
	sequences->forEach(seq) {
		ilp.constraints += seq->getCommonRelations(specification.relations,
			oclContext)->createConstraintExpression(self);
	}
}

helper Sequence(OclAny)::createHelperVariables(specification : Specification,
	inout ilp : IntegerLinearProgram, oclContext : OclAny) {
	log("helper: " + self->getVariableName());
	var commonRelations : Sequence(Sequence(OclAny)) := self->getCommonRelations(
		specification.relations, oclContext);
	-- hmm maybe we should differentiate here: for differentLocation this
	-- might make sense, but for same location it is (probably) an error
	assert fatal (commonRelations->notEmpty()) with
		log("no common relations found");
	commonRelations->forEach(seq) {
		seq->createHelperVariablesAndConstraints(ilp);
	}
}

helper Sequence(OclAny)::getCommonRelations(relations : OrderedSet(Relation),
	oclContext : OclAny) : Sequence(Sequence(OclAny)) {
	-- do this in a mapping, because this is called at least twice
	-- per sequence
	return map getCommonRelations(self, relations, oclContext);
}

mapping getCommonRelations(sequence : Sequence(OclAny), relations : OrderedSet(Relation),
	oclContext : OclAny) : Sequence(Sequence(OclAny)) {
	init {
		-- compute relevant sequences
		var relSequences : Sequence(Sequence(OclAny)) := relations
			->map getSequences(oclContext)
			->select(seq : Sequence(OclAny) |
				sequence->asSet()->intersection(seq->at(1)->asSet())->notEmpty()
			);
		log("relSequences: " + relSequences->size().toString());
		result := relSequences->product(relSequences)->select(t |
			t.first->at(1) <> t.second->at(1) -- different "sources"
			and
			t.first->at(2) = t.second->at(2) -- same "target"
		)->collectNested(t |
			-- convert tuple to sequence and sort it
			-- (needed in order to prune "semantical" duplicates)
			-- XXX: reuse Sort::sortComponentResourceSequence?
			Sequence{
				Sequence{t.first->at(1), t.first->at(2)},
				Sequence{t.second->at(1), t.second->at(2)}
			}->sortedBy(seq |
				seq->at(1).getVariableName() -- sort by the source's variable name
			)
		)->asSet() -- prune duplicate sequences
		->collectNested(seq |
			Sequence{
				seq->at(1)->at(1),
				seq->at(1)->at(2),
				seq->at(2)->at(1),
				seq->at(2)->at(2)
			}
		)->sortedBy(seq |
			seq->getVariableName()
		);
		log("commonRelations: " + result->size().toString());
	}
}

-- use mapping to cache the results (since this is potentially called
-- quite often)
mapping OrderedSet(Relation)::getSequences(oclContext : OclAny) : Sequence(Sequence(OclAny)) {
	init {
		log("mapping OrderedSet(Relation)::getSequences");
		self->forEach(relation) {
			result += relation.getSequences(oclContext)
		};
	}
}

helper Relation::getSequences(oclContext : OclAny) : Sequence(Sequence(OclAny)) {
	log("helper Relation::getSequences");
	return self.evaluateOCL(oclContext)
		.asTupleValueSequence()
		->collectNested(
			toSequence()
		);
}

helper Sequence(Sequence(OclAny))::createConstraintExpression(locationConstraint : LocationConstraint)
	: ConstraintExpression {
	var comment : String := if locationConstraint.name.oclIsUndefined() or locationConstraint.name = '' then
		''
	else
		locationConstraint.name + '_'
	endif;
	comment := comment
		+ Sequence{self->at(1)->at(1), self->at(1)->at(3)}->getVariableName();
	var op : ComparingOperator := ComparingOperator::GREATER_OR_EQUAL;
	var lit : String := '1';
	if (locationConstraint.type = LocationConstraintTypes::DIFFERENT_LOCATION) then {
		op := ComparingOperator::EQUAL;
		lit := '0';
	} endif;
	return self->createAdditionConstraintExpression(op, lit, comment);
}

query Specification::getCollocationConstraints() : OrderedSet(LocationConstraint) {
	return self.getLocationConstraints(LocationConstraintTypes::SAME_LOCATION);
}

query Specification::getDifferentLocationConstraints() : OrderedSet(LocationConstraint) {
	return self.getLocationConstraints(LocationConstraintTypes::DIFFERENT_LOCATION);
}

query Specification::getLocationConstraints(wantedType : LocationConstraintTypes) : OrderedSet(LocationConstraint) {
	return self.constraints->select(oclIsKindOf(LocationConstraint))
		->collect(oclAsType(LocationConstraint))
		->select(type = wantedType)
		->asOrderedSet();
}