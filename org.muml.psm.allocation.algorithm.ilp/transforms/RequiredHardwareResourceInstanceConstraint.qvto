import Expressions;
import OCLEvaluator;
import Sort;
import Util;
import Variables;
import VariableHelper;

modeltype allocationSpecification uses as('http://www.muml.org/psm/allocation/language/as/1.0.0');
modeltype oclcontext uses oclcontext('http://www.muml.org/psm/allocation/language/oclcontext/1.0.0');
modeltype core uses core('http://www.muml.org/core/1.0.0');
modeltype ilptype uses ilp('http://www.muml.org/psm/allocation/ilp/1.0.0');
modeltype expressions uses core::expressions('http://www.muml.org/core/expressions/1.0.0');
modeltype common uses core::expressions::common('http://www.muml.org/core/expressions/common/1.0.0');
modeltype instance uses pim::instance('http://www.muml.org/pim/instance/1.0.0');
modeltype hwpinstance uses hardware::hwplatforminstance('http://www.muml.org/pm/hardware/hwplatforminstance/1.0.0');
modeltype hwrinstance uses hardware::hwresourceinstance('http://www.muml.org/pm/hardware/hwresourceinstance/1.0.0');
modeltype values uses values('http://www.eclipse.org/ocl/2015/Values');


library RequiredHardwareResourceInstanceConstraintLib;

// the implementation of the differentLocation constraint differs from the approach,
// which was described in my thesis

helper Specification::createHWResInstanceConstraints(inout ilp : IntegerLinearProgram,
	cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) {
	//self.getSameLocationConstraints()->createLocationConstraint(ilp, cic, hpic);
	//self.getDifferentLocationConstraints()->createLocationConstraint(ilp, cic, hpic);
	self.getHWResInstanceConstraints()->createHwResInstanceConstraint(ilp, cic, hpic);
}

helper RequiredHardwareResourceInstanceConstraint::createHwResInstanceConstraint(inout ilp : IntegerLinearProgram,
	cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) {
	var oclContext : OCLContext := createOCLContext(cic, hpic);
	log("SORT");
	var sequences : Sequence(Sequence(NamedElement)) := self.evaluateOCL(oclContext)
		->collectNested(toSequence())
		->sortComponentResourceSequences(); 
	log("SORT");
	sequences->createHelperVariablesAndConstraints(ilp);
	while (sequences->notEmpty()) {
		var cur : Sequence(NamedElement) := sequences->first();
		// since createConstraintExpression generates an equality ("= 1"),
		// we must get rid of duplicates (hence, we do the
		// -> OrderedSet -> Sequence conversion)
		// (actually, todo could be an OrderedSet(Sequence(NamedElement)),
		// but the other helpers/queries expect a Sequence...)
		var todo : Sequence(Sequence(NamedElement)) := cur->getAssociatedSequences(sequences)
			->asOrderedSet()->asSequence();
		sequences := sequences->reject(seq | todo->includes(seq));
		todo->createConstraintExpression(ilp, self)
	};
}

query Sequence(Sequence(NamedElement))::sortComponentResourceSequences() : Sequence(Sequence(NamedElement)) {
	return self->collectNested(seq |
		seq->sortComponentResourceSequence()
	)->sortedBy(seq | seq->getVariableName());
}

/*query TupleValue::toSequences() : Sequence(Sequence(NamedElement)) {
	return let sequence : Sequence(NamedElement) = self.toSequence()
	in
	let indexes : OrderedSet(Integer) = getOddNumbers(1, sequence->size())
	in
	indexes->collectNested(i | sequence->subSequence(i, i + 1));
}*/

query Sequence(NamedElement)::getAssociatedSequences(sequence : Sequence(Sequence(NamedElement)))
	: Sequence(Sequence(NamedElement)) {
	return sequence->select(seq |
		let indexes : OrderedSet(Integer) = getOddNumbers(1, self->size())
		in
		indexes->collect(i |
			seq->at(i)
		)->asBag() = indexes->collect(i | self->at(i))->asBag()
	);
}

helper Sequence(Sequence(NamedElement))::createConstraintExpression(inout ilp : IntegerLinearProgram,
	constraint : RequiredHardwareResourceInstanceConstraint) {
	log("createHWRESConstraintExpression");
	self->print();
	var comment : String := if constraint.name <> '' then constraint.name else null endif;
	ilp.constraints += self->createAdditionConstraintExpression('1', comment);
	log("createHWRESConstraintExpression");
}

query Specification::getHWResInstanceConstraints() : OrderedSet(RequiredHardwareResourceInstanceConstraint) {
	return self.constraints
		->select(oclIsKindOf(RequiredHardwareResourceInstanceConstraint))
		->collect(oclAsType(RequiredHardwareResourceInstanceConstraint))
		->asOrderedSet();
}