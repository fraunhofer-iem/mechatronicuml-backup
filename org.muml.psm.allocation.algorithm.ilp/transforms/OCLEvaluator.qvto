import org.muml.psm.allocation.algorithm.ocl.OCLEvaluatorBlackboxUnit;
import TupleAccessor;
modeltype oclcontext uses oclcontext('http://www.muml.org/psm/allocation/language/oclcontext/1.0.0');
modeltype instance uses pim::instance('http://www.muml.org/pim/instance/1.0.0');
modeltype hwpinstance uses hardware::hwplatforminstance('http://www.muml.org/pm/hardware/hwplatforminstance/1.0.0');
modeltype allocationSpecification uses as('http://www.muml.org/psm/allocation/language/as/1.0.0');
modeltype ocl uses essentialoclcs('http://www.eclipse.org/ocl/2015/EssentialOCLCS');
modeltype values uses values('http://www.eclipse.org/ocl/2015/Values');

library OCLEvaluator;

//blackbox query evaluate(oclExpression : Context, contextObject : OclAny) : OclAny;
//blackbox query evaluateLocationConstraint(oclExpression : Context, contextObject : OclAny) : OrderedSet(TupleValue);

helper EvaluatableElement::evaluateOCL(contextObject : OclAny) : Sequence(TupleValue) {
	var res : Sequence(TupleValue) := evaluateEvaluatableElement(self, contextObject);
	res->createTraceHelper(self);
	return res;
}

helper ResourceConstraint::evaluateOCL(contextObject : OclAny) : Sequence(TupleValue) {
	var res : Sequence(TupleValue) := evaluateEvaluatableElement(self, contextObject);
	res->createTraceHelper(self); // do this first, otherwise the subsequent tv.getSequence fails
	res->collect(tv : TupleValue | tv.getSequence(self.tupleDescriptor.weight))
		->collect(oclAsType(TupleValue))
		->createTraceHelper(self);
	return res;
}

helper TupleValue::createTraceHelper(cs : EvaluatableElement) {
	cs.map createTrace(self);
	return null;
}

mapping EvaluatableElement::createTrace(tv : TupleValue) : TupleValue {
	init {
		result := tv;
		log("create trace (EvaluatableElement) called");
	}
}

helper createOCLContext(cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) : oclcontext::OCLContext {
	log('createOCLContextObject');
	return map createOCLContextObject(cic, hpic);
}

mapping createOCLContextObject(cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) : oclcontext::OCLContext {
	componentInstanceConfiguration := cic;
	hardwarePlatformInstanceConfiguration := hpic;	
}