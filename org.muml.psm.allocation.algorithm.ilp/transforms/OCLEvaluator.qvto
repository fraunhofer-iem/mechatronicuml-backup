import org.muml.psm.allocation.algorithm.ocl.OCLEvaluatorBlackboxUnit;

modeltype oclcontext uses oclcontext('http://www.muml.org/psm/allocation/language/oclcontext/1.0.0');
modeltype instance uses pim::instance('http://www.muml.org/pim/instance/1.0.0');
modeltype hwpinstance uses hardware::hwplatforminstance('http://www.muml.org/pm/hardware/hwplatforminstance/1.0.0');
modeltype allocationSpecification uses as('http://www.muml.org/psm/allocation/language/as/1.0.0');

library OCLEvaluator;

//blackbox query evaluate(oclExpression : Context, contextObject : OclAny) : OclAny;
//blackbox query evaluateLocationConstraint(oclExpression : Context, contextObject : OclAny) : OrderedSet(TupleValue);

helper EvaluatableElement::evaluateOCL(contextObject : OclAny) : OclAny {
	var res : OclAny := evaluateEvaluatableElement(self, contextObject);
	log("evaluateOCL");
	res.map createTrace(self);
	return res;
}

mapping OclAny::createTrace(evaluatableElement : EvaluatableElement) : EvaluatableElement {
	init {
		result := evaluatableElement;
		log("createTrace called");
	}
}

helper createOCLContext(cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) : oclcontext::OCLContext {
	log('createOCLContextObject');
	return map createOCLContextObject(cic, hpic);
}

mapping createOCLContextObject(cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) : oclcontext::OCLContext {
	componentInstanceConfiguration := cic;
	hardwarePlatformInstanceConfiguration := hpic;	
}