transformation reconcile(inout properties : Properties);

modeltype genmodel uses genmodel('http://www.eclipse.org/emf/2002/GenModel');
modeltype ecore uses ecore ('http://www.eclipse.org/emf/2002/Ecore');
modeltype Properties uses properties('http://de.fujaba.properties/0.1');

main() {
	log("QVT-O Script \"reconcile.qvto\" started.");

	properties.rootObjects()[PropertyGenerator]->forEach(generator) {
		generator->map generator();
	}
	
}

mapping inout PropertyGenerator::generator() {

	-- assert that genmodel is defined
	if (not genModel.oclIsUndefined()) then {
		
		-- create plugin definition
		if (plugin.oclIsUndefined()) then {
			plugin := new Plugin(self.genModel);
		} endif;
		
		-- make sure important required bundles are registered
		plugin.requiredBundles += Set {
			"org.eclipse.ui",
			"org.eclipse.core.runtime",
			"org.eclipse.emf.ecore",
			"org.eclipse.emf.edit",
			"de.fujaba.properties.runtime",
			genModel.modelPluginID,
			genModel.editPluginID
		};
		self.referencedGenerators.genModel->forEach(g) {
			plugin.requiredBundles += g.editPluginID;
			plugin.requiredBundles += g.modelPluginID + '.edit.properties';
		};
		
		-- there must be at least one tab
		--if (tabs->isEmpty()) then {
		--	tabs := new PropertyTab('base', 'Base');
		--} endif;
		
		-- make sure, defaultTab is set
		--if (defaultTab.oclIsUndefined()) then {
		--	defaultTab := tabs->first();
		--} endif;
		
		-- generate missing packages
		self.genModel.allSubobjectsOfType(GenPackage)[GenPackage]->select(shouldGenerate())->forEach(package) {
			if (not self.packages.genPackage->includes(package)) then {
				self.packages += self->map createPackage(package);
			} endif;
		};
		
		-- reconcile all packages
		packages->map reconcilePackage(defaultTab);
		
		-- initialize newly created GroupPropertyEditors
--		packages.classes.properties.section[GroupPropertyEditor]->forEach(section) {
--			if section.container().oclIsKindOf(Property) then {
--			var prop : Property := section._property;//container().oclAsType(Property);
--				packages.classes->select(c |
--					prop.genFeature.ecoreFeature.eType.oclAsType(ecore::EClass).eAllSuperTypes->including(prop.genFeature.ecoreFeature.eType.oclAsType(ecore::EClass))->includes(c.genClass.ecoreClass)).properties->select(p | 
--						-- reject eopposite
--						((not p.genFeature.ecoreFeature.oclIsKindOf(ecore::EReference)) or p.genFeature.ecoreFeature.oclAsType(ecore::EReference).eOpposite != prop.genFeature.ecoreFeature)
--						-- reject existing property references
--						and not section.referencedProperties._property->includes(p)
--				)->forEach(prp) {
--					section.referencedProperties += new PropertyReference(prp);
--				}
--			} endif;
--		}
	} endif;
}

mapping inout Package::reconcilePackage(tab : PropertyTab) {
	
	var newClasses : OrderedSet(Class);
	
	
	-- generate missing classes
	self.genPackage.genClasses->select(shouldGenerate())->forEach(_class) {
		if (not self.classes.genClass->includes(_class)) then {
			newClasses += self->map createClass(_class);
		} endif;
	};
	
	if (not newClasses->isEmpty()) then {
		classes += newClasses;
	} endif;
	
	
	-- reconcile all classes
	classes->map reconcileClass(tab);
	
	
	if (not newClasses->isEmpty()) then {
		classes->map initializeCategories()
	} endif;
	
}
 
mapping inout Class::reconcileClass(tab : PropertyTab) {
	-- update list of super classes that can be found using all referenced models
	var superClasses : Set(Class) := package.generator.referencedGenerators->union(Set { package.generator }).packages.classes->reject(superClass | not self.genClass.ecoreClass.eSuperTypes->includes(superClass.genClass.ecoreClass))->asSet();
	
	if (self.superClasses->asSet() != superClasses) then {
		self.superClasses := superClasses;
	} endif;

	-- generate missing properties
	self.genClass.genFeatures->select(shouldGenerate())->forEach(feature) {
		if (not self.properties.genFeature->includes(feature)) then {
			self.properties += self->map createProperty(feature, tab);
		} endif;
	};

	
	-- reconcile all properties
	self.properties->map reconcileProperty();
}

mapping inout Property::reconcileProperty() {
	-- make sure a tab is set
	if (self.tab = null and self.clazz.package.generator.defaultTab != null) then {
		self.tab := self.clazz.package.generator.defaultTab;
	} endif;
}

mapping PropertyGenerator::createPackage(package : GenPackage) : Package {
	genPackage := package;
}
mapping Package::createClass(_class : GenClass) : Class{
	genClass := _class;
}


mapping inout Class::initializeCategories() {
	-- create categories for new class
	
	-- booleans in one category
	var booleanProperties : OrderedSet(Property) := self.properties->select(p | p.genFeature.ecoreFeature.eType.name = 'EBoolean');
	if (not booleanProperties->isEmpty()) then {
		var category : PropertyCategory := new PropertyCategory('Booleans', booleanProperties);
		propertyCategories := propertyCategories->including(category);
	} endif;
}

mapping Class::createProperty(_feature : GenFeature, _tab : PropertyTab) : Property {
	genFeature := _feature;
	tab := _tab;
	editor := _feature->map section()->any(true);
}

mapping GenFeature::section() : PropertyEditor
	disjuncts 
	GenFeature::checkboxSection,
	GenFeature::listSection, 
	GenFeature::radioSection,
	GenFeature::objectSection,
	GenFeature::spinnerSection,
	GenFeature::textSection;


mapping GenFeature::checkboxSection() : CheckboxPropertyEditor when {self.ecoreFeature.eType.name = 'EBoolean'} {
}


mapping GenFeature::listSection() : ListPropertyEditor when {self.ecoreFeature.oclIsKindOf(EReference) and self.ecoreFeature.upperBound > 1} {
}

mapping GenFeature::radioSection() : RadioPropertyEditor when {self.ecoreFeature.eType.oclIsKindOf(EEnum)} {
}



mapping GenFeature::objectSection() : ObjectPropertyEditor when {self.ecoreFeature.oclIsKindOf(EReference) and self.ecoreFeature.oclAsType(EReference).containment and self.ecoreFeature.upperBound = 1} {
}


mapping GenFeature::spinnerSection() : SpinnerPropertyEditor when {self.ecoreFeature.oclIsKindOf(EAttribute) and (self.ecoreFeature.eType.name = 'EInt' or self.ecoreFeature.eType.name = 'EDouble'  or self.ecoreFeature.eType.name = 'EFloat') } {
	digits := 0;
	if (self.ecoreFeature.eType.name = 'EDouble'  or self.ecoreFeature.eType.name = 'EFloat') then {
		digits := 3;
	} endif;
}


mapping GenFeature::textSection() : TextPropertyEditor when {self.ecoreFeature.oclIsKindOf(EAttribute) and self.ecoreFeature.eType.name != 'EBoolean' and not self.ecoreFeature.eType.oclIsKindOf(EEnum) } {
	multiLine := self.propertyMultiLine;
}


query GenPackage::shouldGenerate() : Boolean {
	return not self.genClassifiers->select(shouldGenerate())->isEmpty();
}
query GenClassifier::shouldGenerate() : Boolean {
	return false;
}
query GenClass::shouldGenerate() : Boolean {
	return true;
}
query GenFeature::shouldGenerate() : Boolean {
	return self._property != GenPropertyKind::None and self.ecoreFeature.changeable and not self.ecoreFeature._derived;
}
constructor Plugin::Plugin(genModel : GenModel) {
	name := genModel.modelPluginID + ".edit.properties";
	version := '0.1';
}

constructor PropertyTab::PropertyTab(_id : String, _name : String) {
	id := _id;
	name := _name;
}

constructor PropertyCategory::PropertyCategory(_title : String,  _localProperties : OrderedSet(Property)) {
	title := _title;
	localProperties := _localProperties;
	vertical := false;
}