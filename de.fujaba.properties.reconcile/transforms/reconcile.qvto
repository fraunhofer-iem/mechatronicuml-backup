transformation reconcile(inout properties : Properties);

modeltype genmodel uses genmodel('http://www.eclipse.org/emf/2002/GenModel');
modeltype ecore uses ecore ('http://www.eclipse.org/emf/2002/Ecore');
modeltype Properties uses properties('http://de.fujaba.properties/0.1');

property GROUP_PROPERTY_SECTIONS : OrderedSet(GroupPropertySection) = object OrderedSet(GroupPropertySection){};

main() {
	log("QVT-O Script \"reconcile.qvto\" started.");

	properties.rootObjects()[PropertyGenerator]->forEach(generator) {
		generator->map generator();
	}
	
}

mapping inout PropertyGenerator::generator() {

	-- assert that genmodel is defined
	if (not genModel.oclIsUndefined()) then {
		
		-- create plugin definition
		if (plugin.oclIsUndefined()) then {
			plugin := new Plugin(self.genModel);
		} endif;
		
		-- make sure important required bundles are registered
		plugin.requiredBundles += Set {
			"org.eclipse.ui",
			"org.eclipse.core.runtime",
			"org.eclipse.emf.ecore",
			"de.upb.swt.core.ui.properties",
			genModel.modelPluginID
		};
		
		-- there must be at least one tab
		if (tabs->isEmpty()) then {
			tabs := new PropertyTab('base', 'Base');
		} endif;
		
		-- make sure, defaultTab is set
		if (defaultTab.oclIsUndefined()) then {
			defaultTab := tabs->first();
		} endif;
		
		-- generate missing packages
		self.genModel.allSubobjectsOfType(GenPackage)[GenPackage]->select(shouldGenerate())->forEach(package) {
			if (not self.packages.genPackage->includes(package)) then {
				self.packages += self->map createPackage(package);
			} endif;
		};
		
		-- reconcile all packages
		packages->map reconcilePackage(defaultTab);
		
		-- initialize newly created GroupPropertySections
		GROUP_PROPERTY_SECTIONS->forEach(section) {
			if section.container().oclIsKindOf(Property) then {
			var prop : Property := section._property;//container().oclAsType(Property);
				section.navigatedProperties := packages.classes->select(c | prop.genFeature.ecoreFeature.eType = c.genClass.ecoreClass).properties;
			} endif;
		}
	} endif;
}

mapping inout Package::reconcilePackage(tab : PropertyTab) {
	
	-- generate missing classes
	self.genPackage.genClasses->select(shouldGenerate())->forEach(_class) {
		if (not self.classes.genClass->includes(_class)) then {
			self.classes += self->map createClass(_class);
		} endif;
	};
	
	-- reconcile all classes
	classes->map reconcileClass(tab);
}
 
mapping inout Class::reconcileClass(tab : PropertyTab) {
	
	-- generate missing sections
	self.genClass.genFeatures->select(shouldGenerate())->forEach(feature) {
		if (not self.properties.genFeature->includes(feature)) then {
			self.properties += self->map createProperty(feature, tab);
		} endif;
	};
	
	-- reconcile all sections
	self.properties->map reconcileProperty();
}

mapping inout Property::reconcileProperty() {
	-- nothing to reconcile currently
}

mapping PropertyGenerator::createPackage(package : GenPackage) : Package {
	genPackage := package;
}
mapping Package::createClass(_class : GenClass) : Class{
	genClass := _class;
}
mapping Class::createProperty(_feature : GenFeature, _tab : PropertyTab) : Property {
	genFeature := _feature;
	tab := _tab;
	section := _feature->map section()->any(true);
}

mapping GenFeature::section() : PropertySection
	disjuncts 
	GenFeature::textSection, 
	GenFeature::listSection, 
	GenFeature::radioSection, 
	GenFeature::groupSection;

mapping GenFeature::textSection() : TextPropertySection when {self.ecoreFeature.oclIsKindOf(EAttribute) and not self.ecoreFeature.eType.oclIsKindOf(EEnum) } {
	multiLine := self.propertyMultiLine;
}

mapping GenFeature::listSection() : ListPropertySection when {self.ecoreFeature.oclIsKindOf(EReference) and self.ecoreFeature.upperBound > 1} {
}

mapping GenFeature::radioSection() : RadioPropertySection when {self.ecoreFeature.eType.oclIsKindOf(EEnum)} {
}

mapping GenFeature::groupSection() : GroupPropertySection when {self.ecoreFeature.oclIsKindOf(EReference) and self.ecoreFeature.oclAsType(EReference).containment and self.ecoreFeature.upperBound = 1} {
	GROUP_PROPERTY_SECTIONS += result;
}


query GenPackage::shouldGenerate() : Boolean {
	return true;--return self.genClassifiers->one(shouldGenerate());
}
query GenClass::shouldGenerate() : Boolean {
	return true; -- return self.genFeatures->one(shouldGenerate());
}
query GenFeature::shouldGenerate() : Boolean {
	return true; -- not ecoreFeature.derived;
}
constructor Plugin::Plugin(genModel : GenModel) {
	name := genModel.modelPluginID + ".edit.properties";
	version := '0.1';
}

constructor PropertyTab::PropertyTab(_id : String, _name : String) {
	id := _id;
	name := _name;
}