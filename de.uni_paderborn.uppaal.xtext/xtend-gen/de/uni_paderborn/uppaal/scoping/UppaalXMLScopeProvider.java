/**
 * generated by Xtext
 */
package de.uni_paderborn.uppaal.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import de.uni_paderborn.uppaal.NTA;
import de.uni_paderborn.uppaal.core.NamedElement;
import de.uni_paderborn.uppaal.core.TypedElement;
import de.uni_paderborn.uppaal.declarations.Declaration;
import de.uni_paderborn.uppaal.declarations.GlobalDeclarations;
import de.uni_paderborn.uppaal.declarations.LocalDeclarations;
import de.uni_paderborn.uppaal.declarations.ParameterContainer;
import de.uni_paderborn.uppaal.declarations.SystemDeclarations;
import de.uni_paderborn.uppaal.declarations.TypeDeclaration;
import de.uni_paderborn.uppaal.declarations.TypedDeclaration;
import de.uni_paderborn.uppaal.declarations.TypedElementContainer;
import de.uni_paderborn.uppaal.declarations.Variable;
import de.uni_paderborn.uppaal.expressions.DataPrefixExpression;
import de.uni_paderborn.uppaal.expressions.Expression;
import de.uni_paderborn.uppaal.expressions.IdentifierExpression;
import de.uni_paderborn.uppaal.expressions.QuantificationExpression;
import de.uni_paderborn.uppaal.expressions.ScopedIdentifierExpression;
import de.uni_paderborn.uppaal.parsable.templates_parsable.IdentifiableLocation;
import de.uni_paderborn.uppaal.statements.Block;
import de.uni_paderborn.uppaal.statements.Iteration;
import de.uni_paderborn.uppaal.templates.Edge;
import de.uni_paderborn.uppaal.templates.Location;
import de.uni_paderborn.uppaal.templates.Selection;
import de.uni_paderborn.uppaal.templates.Template;
import de.uni_paderborn.uppaal.types.DeclaredType;
import de.uni_paderborn.uppaal.types.Library;
import de.uni_paderborn.uppaal.types.PredefinedType;
import de.uni_paderborn.uppaal.types.StructTypeSpecification;
import java.util.Iterator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it
 * 
 * Custom scoping for UPPAALs XML format and programming language.
 */
@SuppressWarnings("all")
public class UppaalXMLScopeProvider extends AbstractDeclarativeScopeProvider {
  /**
   * Enumeration to distinguish between different aims for the scoping, i.e. whether we are
   * interested in TypedElements or Types. As this may change during scoping (e.g. when we
   * encounter an array structure) we need to be able to change it on-the-fly.
   */
  private enum ScopeMode {
    TYPES,
    
    TYPED_ELEMENTS,
    
    TYPES_AND_TYPED_ELEMENTS;
  }
  
  /**
   * The Library instance that is used by this ScopeProvider.
   */
  private static Library LIBRARY = null;
  
  /**
   * Helper method that appends the TypedElements of a TypedElementContainer to a given
   * Iterable for NamedElements.
   */
  private Function2<Iterable<NamedElement>, TypedElementContainer, Iterable<NamedElement>> TypedElementContainerReduction = new Function2<Iterable<NamedElement>, TypedElementContainer, Iterable<NamedElement>>() {
    public Iterable<NamedElement> apply(final Iterable<NamedElement> a, final TypedElementContainer b) {
      EList<TypedElement> _elements = b.getElements();
      Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(_elements, NamedElement.class);
      return Iterables.<NamedElement>concat(a, _filter);
    }
  };
  
  /**
   * Helper method that appends the Types of a TypeDeclaration to a given
   * Iterable for NamedElements.
   */
  private Function2<Iterable<NamedElement>, TypeDeclaration, Iterable<NamedElement>> TypeDeclarationReduction = new Function2<Iterable<NamedElement>, TypeDeclaration, Iterable<NamedElement>>() {
    public Iterable<NamedElement> apply(final Iterable<NamedElement> a, final TypeDeclaration b) {
      EList<DeclaredType> _type = b.getType();
      Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(_type, NamedElement.class);
      return Iterables.<NamedElement>concat(a, _filter);
    }
  };
  
  /**
   * Helper method that returns the QualifiedName of an IdentifiableLocation (= the id).
   */
  private Function<IdentifiableLocation, QualifiedName> getNameOfLocation = new Function<IdentifiableLocation, QualifiedName>() {
    public QualifiedName apply(final IdentifiableLocation it) {
      String _id = it.getId();
      return QualifiedName.create(_id);
    }
  };
  
  /**
   * Method that is called via reflection whenever the identifier attribute of an
   * IdentifierExpression needs to be resolved.
   * 
   * @param context Instance of IdentifierExpression.
   * @param ref Instance of the reference, i.e. the identifier attribute.
   * 
   * @return Hopefully a matching scope for the given identifier.
   */
  public IScope scope_IdentifierExpression_identifier(final EObject context, final EReference ref) {
    return this.getIdentifierScope(((IdentifierExpression) context));
  }
  
  /**
   * Method that is called when the source attribute of an edge needs to be resolved.
   * 
   * @param context Edge instance.
   * @param ref EReference instance of the source attribute.
   * 
   * @return Scope for the source attribute.
   */
  public IScope scope_Edge_source(final EObject context, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = context.eContainer();
      final Template container = ((Template) _eContainer);
      EList<Location> _location = container.getLocation();
      Iterable<IdentifiableLocation> _filter = Iterables.<IdentifiableLocation>filter(_location, IdentifiableLocation.class);
      _xblockexpression = Scopes.<IdentifiableLocation>scopeFor(_filter, 
        this.getNameOfLocation, IScope.NULLSCOPE);
    }
    return _xblockexpression;
  }
  
  /**
   * Method that is called when the target attribute of an Edge needs to be resolved.
   * 
   * @param context Edge instance.
   * @param ref EReference instance of the target attribute.
   * 
   * @return Scope for the target attribute.
   */
  public IScope scope_Edge_target(final EObject context, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = context.eContainer();
      final Template container = ((Template) _eContainer);
      EList<Location> _location = container.getLocation();
      Iterable<IdentifiableLocation> _filter = Iterables.<IdentifiableLocation>filter(_location, IdentifiableLocation.class);
      _xblockexpression = Scopes.<IdentifiableLocation>scopeFor(_filter, 
        this.getNameOfLocation, IScope.NULLSCOPE);
    }
    return _xblockexpression;
  }
  
  /**
   * Method that is called when the init attribute of a Template needs to be resolved.
   * 
   * @param context Template instance.
   * @param ref EReference instance for the init attribute.
   * 
   * @return Scope for the init attribute.
   */
  public IScope scope_Template_init(final EObject context, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = context.eContainer();
      final Template template = ((Template) _eContainer);
      EList<Location> _location = template.getLocation();
      _xblockexpression = Scopes.scopeFor(_location);
    }
    return _xblockexpression;
  }
  
  /**
   * Method that is called when the channelType attribute of a ChannelPrefixExpression
   * needs to be resolved.
   * 
   * @param context ChannelPrefixExpression instance.
   * @param ref EReference instance for the channelType attribute.
   * 
   * @return Scope for the channelType attribute.
   */
  public IScope scope_ChannelPrefixExpression_channelType(final EObject context, final EReference ref) {
    final Library lib = UppaalXMLScopeProvider.getLibrary(context);
    EList<PredefinedType> _types = lib.getTypes();
    return Scopes.scopeFor(_types);
  }
  
  /**
   * Main method to find the scope corresponding to a given IdentifierExpression.
   * It checks for certain special cases an then delegates to more specialized
   * methods.
   * 
   * @param identifier The IdentifierExpression that needs resolving.
   * 
   * @return Scope for the IdentifierExpression.
   */
  private IScope getIdentifierScope(final IdentifierExpression identifier) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = identifier.eContainer();
      boolean _matched = false;
      if (!_matched) {
        if (_eContainer instanceof TypedElementContainer) {
          _matched=true;
        }
        if (!_matched) {
          if (_eContainer instanceof TypeDeclaration) {
            _matched=true;
          }
        }
        if (_matched) {
          EReference _eContainmentFeature = identifier.eContainmentFeature();
          String _name = _eContainmentFeature.getName();
          boolean _equals = "typeDefinition".equals(_name);
          if (_equals) {
            return this.getRecursiveScope(identifier, UppaalXMLScopeProvider.ScopeMode.TYPES);
          }
        }
      }
      if (!_matched) {
        if (_eContainer instanceof DataPrefixExpression) {
          _matched=true;
          return this.getRecursiveScope(identifier, UppaalXMLScopeProvider.ScopeMode.TYPES);
        }
      }
      _xblockexpression = this.getRecursiveScope(identifier, UppaalXMLScopeProvider.ScopeMode.TYPED_ELEMENTS);
    }
    return _xblockexpression;
  }
  
  /**
   * Checks whether the given ScopedIdentifierExpression follows the structure that
   * we can scope, i.e. if the "scope" is either an IdentifierExpression or a valid
   * ScopedIdentifierExpression and the identifier is an IdentifierExpression.
   * 
   * @param expr The ScopedIdentifierExpression to check.
   * 
   * @return A boolean indicating whether the structure is valid or not.
   */
  private boolean checkScopedIdentifierExpressionStructure(final ScopedIdentifierExpression expr) {
    Expression _scope = expr.getScope();
    boolean _matched = false;
    if (!_matched) {
      if (_scope instanceof IdentifierExpression) {
        _matched=true;
      }
      if (!_matched) {
        if (_scope instanceof ScopedIdentifierExpression) {
          _matched=true;
        }
      }
      if (_matched) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Specifically scopes ScopedIdentifierExpressions. The method assumes that the
   * structure of the expression is valid, i.e. checkScopedIdentifierExpression
   * returned true.
   * 
   * @param expr The ScopedIdentifierExpression whose identifier attribute should
   * be resolved.
   * 
   * @return A scope that hopefully includes the referenced element.
   */
  private IScope getScopedIdentifierExpressionScope(final ScopedIdentifierExpression expr) {
    StructTypeSpecification struct = null;
    IScope scope = IScope.NULLSCOPE;
    IdentifierExpression identifier = null;
    Expression _scope = expr.getScope();
    boolean _matched = false;
    if (!_matched) {
      if (_scope instanceof IdentifierExpression) {
        _matched=true;
        Expression _scope_1 = expr.getScope();
        identifier = ((IdentifierExpression) _scope_1);
      }
    }
    if (!_matched) {
      if (_scope instanceof ScopedIdentifierExpression) {
        _matched=true;
        Expression _scope_1 = expr.getScope();
        IdentifierExpression _identifier = ((ScopedIdentifierExpression) _scope_1).getIdentifier();
        identifier = _identifier;
      }
    }
    NamedElement _identifier = identifier.getIdentifier();
    if ((_identifier instanceof TypedElement)) {
      NamedElement _identifier_1 = identifier.getIdentifier();
      Expression typeDefinition = ((TypedElement) _identifier_1).getTypeDefinition();
      while (((typeDefinition instanceof IdentifierExpression) && 
        (((IdentifierExpression) typeDefinition).getIdentifier() instanceof DeclaredType))) {
        NamedElement _identifier_2 = ((IdentifierExpression) typeDefinition).getIdentifier();
        Expression _typeDefinition = ((DeclaredType) _identifier_2).getTypeDefinition();
        typeDefinition = _typeDefinition;
      }
      if ((typeDefinition instanceof StructTypeSpecification)) {
        struct = ((StructTypeSpecification) typeDefinition);
      }
    }
    boolean _notEquals = (!Objects.equal(struct, null));
    if (_notEquals) {
      EList<TypedDeclaration> _declaration = struct.getDeclaration();
      Iterable<NamedElement> _emptyList = this.emptyList();
      Iterable<NamedElement> elements = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(_declaration, _emptyList, this.TypedElementContainerReduction);
      IScope _scopeFor = Scopes.scopeFor(elements, IScope.NULLSCOPE);
      scope = _scopeFor;
    }
    return scope;
  }
  
  /**
   * Recursive strategy to find the scope of arbitrary EObjects. Essentially, the
   * containment tree is traversed and on relevant objects the scope is extended.
   * It is recursive as we go up in the containment tree, thus encountering inner
   * scopes first and outer scopes last. This is easier to do with recursion.
   * 
   * @param obj EObject for which to calculate the scope.
   * @param mode Mode telling us whether to scope for TypedElements or Types.
   * 
   * @return An appropiate scope representation for the EObject.
   */
  private IScope getRecursiveScope(final EObject obj, final UppaalXMLScopeProvider.ScopeMode mode) {
    IScope _xblockexpression = null;
    {
      Iterable<NamedElement> elements = this.emptyList();
      EObject curObj = obj.eContainer();
      EObject lastObj = obj;
      UppaalXMLScopeProvider.ScopeMode curMode = mode;
      while ((!Objects.equal(curObj, null))) {
        {
          boolean _matched = false;
          if (!_matched) {
            if (curObj instanceof Variable) {
              _matched=true;
              EReference _eContainmentFeature = lastObj.eContainmentFeature();
              String _name = _eContainmentFeature.getName();
              boolean _equals = "index".equals(_name);
              if (_equals) {
                curMode = UppaalXMLScopeProvider.ScopeMode.TYPES_AND_TYPED_ELEMENTS;
              }
            }
          }
          if (!_matched) {
            if (curObj instanceof ScopedIdentifierExpression) {
              _matched=true;
              boolean _and = false;
              EReference _eContainmentFeature = lastObj.eContainmentFeature();
              String _name = _eContainmentFeature.getName();
              boolean _equals = "identifier".equals(_name);
              if (!_equals) {
                _and = false;
              } else {
                boolean _checkScopedIdentifierExpressionStructure = this.checkScopedIdentifierExpressionStructure(((ScopedIdentifierExpression)curObj));
                _and = _checkScopedIdentifierExpressionStructure;
              }
              if (_and) {
                return this.getScopedIdentifierExpressionScope(((ScopedIdentifierExpression)curObj));
              }
            }
          }
          boolean _or = false;
          boolean _equals = Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPED_ELEMENTS);
          if (_equals) {
            _or = true;
          } else {
            boolean _equals_1 = Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES_AND_TYPED_ELEMENTS);
            _or = _equals_1;
          }
          if (_or) {
            boolean _matched_1 = false;
            if (!_matched_1) {
              if (curObj instanceof NTA) {
                _matched_1=true;
                GlobalDeclarations _globalDeclarations = ((NTA)curObj).getGlobalDeclarations();
                EList<Declaration> _declaration = _globalDeclarations.getDeclaration();
                Iterable<TypedDeclaration> _filter = Iterables.<TypedDeclaration>filter(_declaration, TypedDeclaration.class);
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(_filter, _emptyList, this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof Template) {
                _matched_1=true;
                EList<ParameterContainer> _parameter = ((Template)curObj).getParameter();
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, ParameterContainer>bReduce(_parameter, _emptyList, this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
                LocalDeclarations _declarations = ((Template)curObj).getDeclarations();
                boolean _notEquals = (!Objects.equal(_declarations, null));
                if (_notEquals) {
                  LocalDeclarations _declarations_1 = ((Template)curObj).getDeclarations();
                  EList<Declaration> _declaration = _declarations_1.getDeclaration();
                  Iterable<TypedDeclaration> _filter = Iterables.<TypedDeclaration>filter(_declaration, TypedDeclaration.class);
                  Iterable<NamedElement> _emptyList_1 = this.emptyList();
                  Iterable<NamedElement> _bReduce_1 = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(_filter, _emptyList_1, this.TypedElementContainerReduction);
                  Iterable<NamedElement> _plus_1 = Iterables.<NamedElement>concat(elements, _bReduce_1);
                  elements = _plus_1;
                }
              }
            }
            if (!_matched_1) {
              if (curObj instanceof de.uni_paderborn.uppaal.declarations.Function) {
                _matched_1=true;
                EList<ParameterContainer> _parameter = ((de.uni_paderborn.uppaal.declarations.Function)curObj).getParameter();
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, ParameterContainer>bReduce(_parameter, _emptyList, this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof Block) {
                _matched_1=true;
                LocalDeclarations _declarations = ((Block)curObj).getDeclarations();
                EList<Declaration> _declaration = _declarations.getDeclaration();
                Iterable<TypedDeclaration> _filter = Iterables.<TypedDeclaration>filter(_declaration, TypedDeclaration.class);
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(_filter, _emptyList, this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof Iteration) {
                _matched_1=true;
                EList<TypedElement> _elements = ((Iteration)curObj).getElements();
                Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(_elements, NamedElement.class);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _filter);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof SystemDeclarations) {
                _matched_1=true;
                EList<Declaration> _declaration = ((SystemDeclarations)curObj).getDeclaration();
                Iterable<TypedDeclaration> _filter = Iterables.<TypedDeclaration>filter(_declaration, TypedDeclaration.class);
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(_filter, _emptyList, this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof Edge) {
                _matched_1=true;
                EList<Selection> _selection = ((Edge)curObj).getSelection();
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, Selection>bReduce(_selection, _emptyList, this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof QuantificationExpression) {
                _matched_1=true;
                EList<TypedElement> _elements = ((QuantificationExpression)curObj).getElements();
                Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(_elements, NamedElement.class);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _filter);
                elements = _plus;
              }
            }
          }
          boolean _or_1 = false;
          boolean _equals_2 = Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES_AND_TYPED_ELEMENTS);
          if (_equals_2) {
            _or_1 = true;
          } else {
            boolean _equals_3 = Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES);
            _or_1 = _equals_3;
          }
          if (_or_1) {
            boolean _matched_2 = false;
            if (!_matched_2) {
              if (curObj instanceof NTA) {
                _matched_2=true;
                GlobalDeclarations _globalDeclarations = ((NTA)curObj).getGlobalDeclarations();
                EList<Declaration> _declaration = _globalDeclarations.getDeclaration();
                Iterable<TypeDeclaration> _filter = Iterables.<TypeDeclaration>filter(_declaration, TypeDeclaration.class);
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypeDeclaration>bReduce(_filter, _emptyList, this.TypeDeclarationReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                Iterable<NamedElement> _predefinedTypes = this.getPredefinedTypes(((NTA)curObj));
                Iterable<NamedElement> _plus_1 = Iterables.<NamedElement>concat(_plus, _predefinedTypes);
                elements = _plus_1;
              }
            }
            if (!_matched_2) {
              if (curObj instanceof Template) {
                _matched_2=true;
                LocalDeclarations _declarations = ((Template)curObj).getDeclarations();
                boolean _notEquals = (!Objects.equal(_declarations, null));
                if (_notEquals) {
                  LocalDeclarations _declarations_1 = ((Template)curObj).getDeclarations();
                  EList<Declaration> _declaration = _declarations_1.getDeclaration();
                  Iterable<TypeDeclaration> _filter = Iterables.<TypeDeclaration>filter(_declaration, TypeDeclaration.class);
                  Iterable<NamedElement> _emptyList = this.emptyList();
                  Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypeDeclaration>bReduce(_filter, _emptyList, this.TypeDeclarationReduction);
                  Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                  elements = _plus;
                }
              }
            }
            if (!_matched_2) {
              if (curObj instanceof SystemDeclarations) {
                _matched_2=true;
                EList<Declaration> _declaration = ((SystemDeclarations)curObj).getDeclaration();
                Iterable<TypeDeclaration> _filter = Iterables.<TypeDeclaration>filter(_declaration, TypeDeclaration.class);
                Iterable<NamedElement> _emptyList = this.emptyList();
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypeDeclaration>bReduce(_filter, _emptyList, this.TypeDeclarationReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
          }
          int _size = IterableExtensions.size(elements);
          boolean _greaterThan = (_size > 0);
          if (_greaterThan) {
            IScope _recursiveScope = this.getRecursiveScope(curObj, mode);
            return Scopes.scopeFor(elements, _recursiveScope);
          }
          lastObj = curObj;
          EObject _eContainer = curObj.eContainer();
          curObj = _eContainer;
        }
      }
      boolean _or = false;
      boolean _equals = Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES_AND_TYPED_ELEMENTS);
      if (_equals) {
        _or = true;
      } else {
        boolean _equals_1 = Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES);
        _or = _equals_1;
      }
      if (_or) {
        final Library lib = UppaalXMLScopeProvider.getLibrary(lastObj);
        EList<PredefinedType> _types = lib.getTypes();
        return Scopes.scopeFor(_types);
      }
      _xblockexpression = IScope.NULLSCOPE;
    }
    return _xblockexpression;
  }
  
  /**
   * Gets an instance of Library for the given context.
   * 
   * @param context EObject whose Library should be returned if there is one.
   * 
   * @return An instance of Library.
   */
  private static Library getLibrary(final EObject context) {
    Library _xblockexpression = null;
    {
      boolean _equals = Objects.equal(UppaalXMLScopeProvider.LIBRARY, null);
      if (_equals) {
        Resource _eResource = context.eResource();
        boolean _notEquals = (!Objects.equal(_eResource, null));
        if (_notEquals) {
          Resource _eResource_1 = context.eResource();
          ResourceSet _resourceSet = _eResource_1.getResourceSet();
          EList<Resource> _resources = _resourceSet.getResources();
          for (final Resource res : _resources) {
            EList<EObject> _contents = res.getContents();
            for (final EObject obj : _contents) {
              if ((obj instanceof Library)) {
                UppaalXMLScopeProvider.LIBRARY = ((Library)obj);
                return UppaalXMLScopeProvider.LIBRARY;
              }
            }
          }
          Resource _eResource_2 = context.eResource();
          ResourceSet _resourceSet_1 = _eResource_2.getResourceSet();
          URI _createURI = URI.createURI("platform:/plugin/de.uni_paderborn.uppaal/model/stdlib.xmi", false);
          Resource _resource = _resourceSet_1.getResource(_createURI, true);
          EList<EObject> _contents_1 = _resource.getContents();
          EObject _get = _contents_1.get(0);
          UppaalXMLScopeProvider.LIBRARY = ((Library) _get);
        } else {
          ResourceSetImpl _resourceSetImpl = new ResourceSetImpl();
          URI _createURI_1 = URI.createURI("platform:/plugin/de.uni_paderborn.uppaal/model/stdlib.xmi", false);
          Resource _resource_1 = _resourceSetImpl.getResource(_createURI_1, true);
          EList<EObject> _contents_2 = _resource_1.getContents();
          EObject _get_1 = _contents_2.get(0);
          UppaalXMLScopeProvider.LIBRARY = ((Library) _get_1);
        }
      }
      _xblockexpression = UppaalXMLScopeProvider.LIBRARY;
    }
    return _xblockexpression;
  }
  
  /**
   * Creates an empty Iterable for NamedElements.
   * 
   * @return Empty Iterable for NamedElements.
   */
  private Iterable<NamedElement> emptyList() {
    Iterable<NamedElement> _xblockexpression = null;
    {
      final Iterable<NamedElement> emptyList = CollectionLiterals.<NamedElement>newArrayList();
      _xblockexpression = emptyList;
    }
    return _xblockexpression;
  }
  
  /**
   * Returns all the PredefinedTypes of the given NTA instance.
   * 
   * @param nta Instance of NTA.
   * 
   * @return Iterable of all the PredefinedTypes as NamedElements.
   */
  private Iterable<NamedElement> getPredefinedTypes(final NTA nta) {
    return this.emptyList();
  }
  
  /**
   * Better reduction function that allows start values etc.
   * Thanks: http://shiggyenterprises.wordpress.com/2012/11/27/better-reduce-for-xtend/
   * 
   * @param iterable Iterable to reduce.
   * @param initial Initial value of the combined value.
   * @param fu Reduction function.
   * 
   * @return Reduced version of iterable.
   */
  private <T extends Object, V extends Object> T bReduce(final Iterable<V> iterable, final T initial, final Function2<? super T, ? super V, ? extends T> fu) {
    final Iterator<V> i = iterable.iterator();
    T out = initial;
    while (i.hasNext()) {
      V _next = i.next();
      T _apply = fu.apply(out, _next);
      out = _apply;
    }
    return out;
  }
}
