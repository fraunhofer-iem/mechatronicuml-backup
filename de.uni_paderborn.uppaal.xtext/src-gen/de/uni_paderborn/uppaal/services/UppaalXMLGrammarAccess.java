/*
* generated by Xtext
*/
package de.uni_paderborn.uppaal.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class UppaalXMLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class NTAElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NTA");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cXmlVersion10EncodingUtf8Keyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cXmlVersion10EncodingUtf8Keyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cDOCTYPENtaPUBLICUppaalTeamDTDFlatSystem11ENHttpWwwItUuSeResearchGroupDartsUppaalFlat1_1DtdKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cNtaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cLessThanSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cImportsKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final RuleCall cANY_TOKEN_BUT_XML_CLOSEParserRuleCall_5_3 = (RuleCall)cGroup_5.eContents().get(3);
		private final Keyword cLessThanSignSolidusKeyword_5_4 = (Keyword)cGroup_5.eContents().get(4);
		private final Keyword cImportsKeyword_5_5 = (Keyword)cGroup_5.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_5_6 = (Keyword)cGroup_5.eContents().get(6);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cLessThanSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cDeclarationKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Assignment cGlobalDeclarationsAssignment_6_3 = (Assignment)cGroup_6.eContents().get(3);
		private final RuleCall cGlobalDeclarationsGlobalDeclarationsParserRuleCall_6_3_0 = (RuleCall)cGlobalDeclarationsAssignment_6_3.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_6_4 = (Keyword)cGroup_6.eContents().get(4);
		private final Keyword cDeclarationKeyword_6_5 = (Keyword)cGroup_6.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_6_6 = (Keyword)cGroup_6.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cLessThanSignKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cTemplateKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Assignment cTemplateAssignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cTemplateTemplateParserRuleCall_7_3_0 = (RuleCall)cTemplateAssignment_7_3.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_7_4 = (Keyword)cGroup_7.eContents().get(4);
		private final Keyword cTemplateKeyword_7_5 = (Keyword)cGroup_7.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_7_6 = (Keyword)cGroup_7.eContents().get(6);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cLessThanSignKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cInstantiationKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		private final RuleCall cANY_TOKEN_BUT_XML_CLOSEParserRuleCall_8_3 = (RuleCall)cGroup_8.eContents().get(3);
		private final Keyword cLessThanSignSolidusKeyword_8_4 = (Keyword)cGroup_8.eContents().get(4);
		private final Keyword cInstantiationKeyword_8_5 = (Keyword)cGroup_8.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_8_6 = (Keyword)cGroup_8.eContents().get(6);
		private final Keyword cLessThanSignKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cSystemKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cGreaterThanSignKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final Assignment cSystemDeclarationsAssignment_12 = (Assignment)cGroup.eContents().get(12);
		private final RuleCall cSystemDeclarationsSystemDeclarationsParserRuleCall_12_0 = (RuleCall)cSystemDeclarationsAssignment_12.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_13 = (Keyword)cGroup.eContents().get(13);
		private final Keyword cSystemKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Keyword cGreaterThanSignKeyword_15 = (Keyword)cGroup.eContents().get(15);
		private final Keyword cLessThanSignSolidusKeyword_16 = (Keyword)cGroup.eContents().get(16);
		private final Keyword cNtaKeyword_17 = (Keyword)cGroup.eContents().get(17);
		private final Keyword cGreaterThanSignKeyword_18 = (Keyword)cGroup.eContents().get(18);
		
		////---------------------------------------------------------------------------------------------------------------------------------
		//// XML STRUCTURE
		////---------------------------------------------------------------------------------------------------------------------------------
		//// Note on hidden terminals:
		//// Except for in the XML part comments are generally accepted ANYWHERE. That's
		//// why every rule referenced directly from any part of the XML rules (NTA, Template,
		//// Location, Edge) needs to be manually complemented with
		////   hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT)
		//// as otherwise the hidden(WS) thingy is inherited.
		//NTA returns uppaal::NTA hidden(WS):
		//	("<?xml version=\"1.0\" encoding=\"utf-8\"?>" | "<?xml version=\'1.0\' encoding=\'utf-8\'?>")
		//	"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>"
		//	"<" "nta" ">" // Imports are not used by UPPAAL currently (at least in 2004).
		//	// Source: https://groups.yahoo.com/neo/groups/uppaal/conversations/messages/546
		//	("<" "imports" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "imports" ">")* // Parse the global declarations.
		//	("<" "declaration" ">" globalDeclarations=GlobalDeclarations "</" "declaration" ">")? // Parse all the templates.
		//	("<" "template" ">" template+=Template "</" "template" ">")+ // Instantiation is not used by UPPAAL anymore.
		//	// TODO Support it either way for old files.
		//	("<" "instantiation" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "instantiation" ">")? // Parse the system declarations.
		//	"<" "system" ">" systemDeclarations=SystemDeclarations "</" "system" ">" "</" "nta" ">";
		public ParserRule getRule() { return rule; }

		//("<?xml version=\"1.0\" encoding=\"utf-8\"?>" | "<?xml version=\'1.0\' encoding=\'utf-8\'?>")
		//"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>"
		//"<" "nta" ">" // Imports are not used by UPPAAL currently (at least in 2004).
		//// Source: https://groups.yahoo.com/neo/groups/uppaal/conversations/messages/546
		//("<" "imports" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "imports" ">")* // Parse the global declarations.
		//("<" "declaration" ">" globalDeclarations=GlobalDeclarations "</" "declaration" ">")? // Parse all the templates.
		//("<" "template" ">" template+=Template "</" "template" ">")+ // Instantiation is not used by UPPAAL anymore.
		//// TODO Support it either way for old files.
		//("<" "instantiation" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "instantiation" ">")? // Parse the system declarations.
		//"<" "system" ">" systemDeclarations=SystemDeclarations "</" "system" ">" "</" "nta" ">"
		public Group getGroup() { return cGroup; }

		//"<?xml version=\"1.0\" encoding=\"utf-8\"?>" | "<?xml version=\'1.0\' encoding=\'utf-8\'?>"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"<?xml version=\"1.0\" encoding=\"utf-8\"?>"
		public Keyword getXmlVersion10EncodingUtf8Keyword_0_0() { return cXmlVersion10EncodingUtf8Keyword_0_0; }

		//"<?xml version=\'1.0\' encoding=\'utf-8\'?>"
		public Keyword getXmlVersion10EncodingUtf8Keyword_0_1() { return cXmlVersion10EncodingUtf8Keyword_0_1; }

		//"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>"
		public Keyword getDOCTYPENtaPUBLICUppaalTeamDTDFlatSystem11ENHttpWwwItUuSeResearchGroupDartsUppaalFlat1_1DtdKeyword_1() { return cDOCTYPENtaPUBLICUppaalTeamDTDFlatSystem11ENHttpWwwItUuSeResearchGroupDartsUppaalFlat1_1DtdKeyword_1; }

		//"<"
		public Keyword getLessThanSignKeyword_2() { return cLessThanSignKeyword_2; }

		//"nta"
		public Keyword getNtaKeyword_3() { return cNtaKeyword_3; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }

		//("<" "imports" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "imports" ">")*
		public Group getGroup_5() { return cGroup_5; }

		//"<"
		public Keyword getLessThanSignKeyword_5_0() { return cLessThanSignKeyword_5_0; }

		//"imports"
		public Keyword getImportsKeyword_5_1() { return cImportsKeyword_5_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_5_2() { return cGreaterThanSignKeyword_5_2; }

		//ANY_TOKEN_BUT_XML_CLOSE*
		public RuleCall getANY_TOKEN_BUT_XML_CLOSEParserRuleCall_5_3() { return cANY_TOKEN_BUT_XML_CLOSEParserRuleCall_5_3; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_5_4() { return cLessThanSignSolidusKeyword_5_4; }

		//"imports"
		public Keyword getImportsKeyword_5_5() { return cImportsKeyword_5_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_5_6() { return cGreaterThanSignKeyword_5_6; }

		//("<" "declaration" ">" globalDeclarations=GlobalDeclarations "</" "declaration" ">")?
		public Group getGroup_6() { return cGroup_6; }

		//"<"
		public Keyword getLessThanSignKeyword_6_0() { return cLessThanSignKeyword_6_0; }

		//"declaration"
		public Keyword getDeclarationKeyword_6_1() { return cDeclarationKeyword_6_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_6_2() { return cGreaterThanSignKeyword_6_2; }

		//globalDeclarations=GlobalDeclarations
		public Assignment getGlobalDeclarationsAssignment_6_3() { return cGlobalDeclarationsAssignment_6_3; }

		//GlobalDeclarations
		public RuleCall getGlobalDeclarationsGlobalDeclarationsParserRuleCall_6_3_0() { return cGlobalDeclarationsGlobalDeclarationsParserRuleCall_6_3_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_6_4() { return cLessThanSignSolidusKeyword_6_4; }

		//"declaration"
		public Keyword getDeclarationKeyword_6_5() { return cDeclarationKeyword_6_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_6_6() { return cGreaterThanSignKeyword_6_6; }

		//("<" "template" ">" template+=Template "</" "template" ">")+
		public Group getGroup_7() { return cGroup_7; }

		//"<"
		public Keyword getLessThanSignKeyword_7_0() { return cLessThanSignKeyword_7_0; }

		//"template"
		public Keyword getTemplateKeyword_7_1() { return cTemplateKeyword_7_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_7_2() { return cGreaterThanSignKeyword_7_2; }

		//template+=Template
		public Assignment getTemplateAssignment_7_3() { return cTemplateAssignment_7_3; }

		//Template
		public RuleCall getTemplateTemplateParserRuleCall_7_3_0() { return cTemplateTemplateParserRuleCall_7_3_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_7_4() { return cLessThanSignSolidusKeyword_7_4; }

		//"template"
		public Keyword getTemplateKeyword_7_5() { return cTemplateKeyword_7_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_7_6() { return cGreaterThanSignKeyword_7_6; }

		//("<" "instantiation" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "instantiation" ">")?
		public Group getGroup_8() { return cGroup_8; }

		//"<"
		public Keyword getLessThanSignKeyword_8_0() { return cLessThanSignKeyword_8_0; }

		//"instantiation"
		public Keyword getInstantiationKeyword_8_1() { return cInstantiationKeyword_8_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_8_2() { return cGreaterThanSignKeyword_8_2; }

		//ANY_TOKEN_BUT_XML_CLOSE*
		public RuleCall getANY_TOKEN_BUT_XML_CLOSEParserRuleCall_8_3() { return cANY_TOKEN_BUT_XML_CLOSEParserRuleCall_8_3; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_8_4() { return cLessThanSignSolidusKeyword_8_4; }

		//"instantiation"
		public Keyword getInstantiationKeyword_8_5() { return cInstantiationKeyword_8_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_8_6() { return cGreaterThanSignKeyword_8_6; }

		//// Parse the system declarations.
		//"<"
		public Keyword getLessThanSignKeyword_9() { return cLessThanSignKeyword_9; }

		//"system"
		public Keyword getSystemKeyword_10() { return cSystemKeyword_10; }

		//">"
		public Keyword getGreaterThanSignKeyword_11() { return cGreaterThanSignKeyword_11; }

		//systemDeclarations=SystemDeclarations
		public Assignment getSystemDeclarationsAssignment_12() { return cSystemDeclarationsAssignment_12; }

		//SystemDeclarations
		public RuleCall getSystemDeclarationsSystemDeclarationsParserRuleCall_12_0() { return cSystemDeclarationsSystemDeclarationsParserRuleCall_12_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_13() { return cLessThanSignSolidusKeyword_13; }

		//"system"
		public Keyword getSystemKeyword_14() { return cSystemKeyword_14; }

		//">"
		public Keyword getGreaterThanSignKeyword_15() { return cGreaterThanSignKeyword_15; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_16() { return cLessThanSignSolidusKeyword_16; }

		//"nta"
		public Keyword getNtaKeyword_17() { return cNtaKeyword_17; }

		//">"
		public Keyword getGreaterThanSignKeyword_18() { return cGreaterThanSignKeyword_18; }
	}

	public class TemplateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Template");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cNameKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_2 = (UnorderedGroup)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cUnorderedGroup_2.eContents().get(0);
		private final Keyword cXKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_2_0_2 = (RuleCall)cGroup_2_0.eContents().get(2);
		private final Group cGroup_2_1 = (Group)cUnorderedGroup_2.eContents().get(1);
		private final Keyword cYKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_2_1_2 = (RuleCall)cGroup_2_1.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameIDTerminalRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cNameKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cGreaterThanSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cLessThanSignKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cParameterKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		private final Group cGroup_8_3 = (Group)cGroup_8.eContents().get(3);
		private final Assignment cParameterAssignment_8_3_0 = (Assignment)cGroup_8_3.eContents().get(0);
		private final RuleCall cParameterParameterContainerParserRuleCall_8_3_0_0 = (RuleCall)cParameterAssignment_8_3_0.eContents().get(0);
		private final Group cGroup_8_3_1 = (Group)cGroup_8_3.eContents().get(1);
		private final Keyword cCommaKeyword_8_3_1_0 = (Keyword)cGroup_8_3_1.eContents().get(0);
		private final Assignment cParameterAssignment_8_3_1_1 = (Assignment)cGroup_8_3_1.eContents().get(1);
		private final RuleCall cParameterParameterContainerParserRuleCall_8_3_1_1_0 = (RuleCall)cParameterAssignment_8_3_1_1.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_8_4 = (Keyword)cGroup_8.eContents().get(4);
		private final Keyword cParameterKeyword_8_5 = (Keyword)cGroup_8.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_8_6 = (Keyword)cGroup_8.eContents().get(6);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cLessThanSignKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Keyword cDeclarationKeyword_9_1 = (Keyword)cGroup_9.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_9_2 = (Keyword)cGroup_9.eContents().get(2);
		private final Assignment cDeclarationsAssignment_9_3 = (Assignment)cGroup_9.eContents().get(3);
		private final RuleCall cDeclarationsLocalDeclarationsParserRuleCall_9_3_0 = (RuleCall)cDeclarationsAssignment_9_3.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_9_4 = (Keyword)cGroup_9.eContents().get(4);
		private final Keyword cDeclarationKeyword_9_5 = (Keyword)cGroup_9.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_9_6 = (Keyword)cGroup_9.eContents().get(6);
		private final Assignment cLocationAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cLocationLocationParserRuleCall_10_0 = (RuleCall)cLocationAssignment_10.eContents().get(0);
		private final Keyword cLessThanSignKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final Keyword cInitKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Keyword cRefKeyword_13 = (Keyword)cGroup.eContents().get(13);
		private final Keyword cEqualsSignKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Assignment cInitAssignment_15 = (Assignment)cGroup.eContents().get(15);
		private final CrossReference cInitLocationCrossReference_15_0 = (CrossReference)cInitAssignment_15.eContents().get(0);
		private final RuleCall cInitLocationSTRINGTerminalRuleCall_15_0_1 = (RuleCall)cInitLocationCrossReference_15_0.eContents().get(1);
		private final Keyword cSolidusGreaterThanSignKeyword_16 = (Keyword)cGroup.eContents().get(16);
		private final Assignment cEdgeAssignment_17 = (Assignment)cGroup.eContents().get(17);
		private final RuleCall cEdgeEdgeParserRuleCall_17_0 = (RuleCall)cEdgeAssignment_17.eContents().get(0);
		
		//Template returns templates::Template hidden(WS): // The name of the template might have x- and y-coordinates for some reason, they must be skipped.
		//	"<" "name" (("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">" // Template parameters.
		//	("<" "parameter" ">" (parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)? "</" "parameter" ">")? // Local declarations.
		//	("<" "declaration" ">" declarations=LocalDeclarations "</" "declaration" ">")? // Get all the locations.
		//	location+=Location+ // Reference the initial location.
		//	"<" "init" "ref" "=" init=[templates::Location|STRING] "/>" // Get the transitions.
		//	edge+=Edge*;
		public ParserRule getRule() { return rule; }

		//// The name of the template might have x- and y-coordinates for some reason, they must be skipped.
		//"<" "name" (("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">" // Template parameters.
		//("<" "parameter" ">" (parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)? "</" "parameter" ">")? // Local declarations.
		//("<" "declaration" ">" declarations=LocalDeclarations "</" "declaration" ">")? // Get all the locations.
		//location+=Location+ // Reference the initial location.
		//"<" "init" "ref" "=" init=[templates::Location|STRING] "/>" // Get the transitions.
		//edge+=Edge*
		public Group getGroup() { return cGroup; }

		//// The name of the template might have x- and y-coordinates for some reason, they must be skipped.
		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//"name"
		public Keyword getNameKeyword_1() { return cNameKeyword_1; }

		//("x" "=" STRING)? & ("y" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_2() { return cUnorderedGroup_2; }

		//("x" "=" STRING)?
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"x"
		public Keyword getXKeyword_2_0_0() { return cXKeyword_2_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_0_1() { return cEqualsSignKeyword_2_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_2_0_2() { return cSTRINGTerminalRuleCall_2_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"y"
		public Keyword getYKeyword_2_1_0() { return cYKeyword_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1_1() { return cEqualsSignKeyword_2_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_2_1_2() { return cSTRINGTerminalRuleCall_2_1_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }

		//name=ID
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_4_0() { return cNameIDTerminalRuleCall_4_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_5() { return cLessThanSignSolidusKeyword_5; }

		//"name"
		public Keyword getNameKeyword_6() { return cNameKeyword_6; }

		//">"
		public Keyword getGreaterThanSignKeyword_7() { return cGreaterThanSignKeyword_7; }

		//("<" "parameter" ">" (parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)? "</" "parameter" ">")?
		public Group getGroup_8() { return cGroup_8; }

		//"<"
		public Keyword getLessThanSignKeyword_8_0() { return cLessThanSignKeyword_8_0; }

		//"parameter"
		public Keyword getParameterKeyword_8_1() { return cParameterKeyword_8_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_8_2() { return cGreaterThanSignKeyword_8_2; }

		//(parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)?
		public Group getGroup_8_3() { return cGroup_8_3; }

		//parameter+=ParameterContainer
		public Assignment getParameterAssignment_8_3_0() { return cParameterAssignment_8_3_0; }

		//ParameterContainer
		public RuleCall getParameterParameterContainerParserRuleCall_8_3_0_0() { return cParameterParameterContainerParserRuleCall_8_3_0_0; }

		//("," parameter+=ParameterContainer)*
		public Group getGroup_8_3_1() { return cGroup_8_3_1; }

		//","
		public Keyword getCommaKeyword_8_3_1_0() { return cCommaKeyword_8_3_1_0; }

		//parameter+=ParameterContainer
		public Assignment getParameterAssignment_8_3_1_1() { return cParameterAssignment_8_3_1_1; }

		//ParameterContainer
		public RuleCall getParameterParameterContainerParserRuleCall_8_3_1_1_0() { return cParameterParameterContainerParserRuleCall_8_3_1_1_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_8_4() { return cLessThanSignSolidusKeyword_8_4; }

		//"parameter"
		public Keyword getParameterKeyword_8_5() { return cParameterKeyword_8_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_8_6() { return cGreaterThanSignKeyword_8_6; }

		//("<" "declaration" ">" declarations=LocalDeclarations "</" "declaration" ">")?
		public Group getGroup_9() { return cGroup_9; }

		//"<"
		public Keyword getLessThanSignKeyword_9_0() { return cLessThanSignKeyword_9_0; }

		//"declaration"
		public Keyword getDeclarationKeyword_9_1() { return cDeclarationKeyword_9_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_9_2() { return cGreaterThanSignKeyword_9_2; }

		//declarations=LocalDeclarations
		public Assignment getDeclarationsAssignment_9_3() { return cDeclarationsAssignment_9_3; }

		//LocalDeclarations
		public RuleCall getDeclarationsLocalDeclarationsParserRuleCall_9_3_0() { return cDeclarationsLocalDeclarationsParserRuleCall_9_3_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_9_4() { return cLessThanSignSolidusKeyword_9_4; }

		//"declaration"
		public Keyword getDeclarationKeyword_9_5() { return cDeclarationKeyword_9_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_9_6() { return cGreaterThanSignKeyword_9_6; }

		//location+=Location+
		public Assignment getLocationAssignment_10() { return cLocationAssignment_10; }

		//Location
		public RuleCall getLocationLocationParserRuleCall_10_0() { return cLocationLocationParserRuleCall_10_0; }

		//// Reference the initial location.
		//"<"
		public Keyword getLessThanSignKeyword_11() { return cLessThanSignKeyword_11; }

		//"init"
		public Keyword getInitKeyword_12() { return cInitKeyword_12; }

		//"ref"
		public Keyword getRefKeyword_13() { return cRefKeyword_13; }

		//"="
		public Keyword getEqualsSignKeyword_14() { return cEqualsSignKeyword_14; }

		//init=[templates::Location|STRING]
		public Assignment getInitAssignment_15() { return cInitAssignment_15; }

		//[templates::Location|STRING]
		public CrossReference getInitLocationCrossReference_15_0() { return cInitLocationCrossReference_15_0; }

		//STRING
		public RuleCall getInitLocationSTRINGTerminalRuleCall_15_0_1() { return cInitLocationSTRINGTerminalRuleCall_15_0_1; }

		//"/>"
		public Keyword getSolidusGreaterThanSignKeyword_16() { return cSolidusGreaterThanSignKeyword_16; }

		//edge+=Edge*
		public Assignment getEdgeAssignment_17() { return cEdgeAssignment_17; }

		//Edge
		public RuleCall getEdgeEdgeParserRuleCall_17_0() { return cEdgeEdgeParserRuleCall_17_0; }
	}

	public class LocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Location");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLocationKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_2 = (UnorderedGroup)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cUnorderedGroup_2.eContents().get(0);
		private final Keyword cIdKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Assignment cIdAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cIdSTRINGTerminalRuleCall_2_0_2_0 = (RuleCall)cIdAssignment_2_0_2.eContents().get(0);
		private final Assignment cPositionAssignment_2_1 = (Assignment)cUnorderedGroup_2.eContents().get(1);
		private final RuleCall cPositionPointParserRuleCall_2_1_0 = (RuleCall)cPositionAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cUnorderedGroup_2.eContents().get(2);
		private final Keyword cColorKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Assignment cColorCodeAssignment_2_2_2 = (Assignment)cGroup_2_2.eContents().get(2);
		private final RuleCall cColorCodeSTRINGTerminalRuleCall_2_2_2_0 = (RuleCall)cColorCodeAssignment_2_2_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Keyword cSolidusGreaterThanSignKeyword_3_0 = (Keyword)cAlternatives_3.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Group cGroup_3_1_1 = (Group)cGroup_3_1.eContents().get(1);
		private final Keyword cLessThanSignKeyword_3_1_1_0 = (Keyword)cGroup_3_1_1.eContents().get(0);
		private final Keyword cNameKeyword_3_1_1_1 = (Keyword)cGroup_3_1_1.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_3_1_1_2 = (UnorderedGroup)cGroup_3_1_1.eContents().get(2);
		private final Group cGroup_3_1_1_2_0 = (Group)cUnorderedGroup_3_1_1_2.eContents().get(0);
		private final Keyword cXKeyword_3_1_1_2_0_0 = (Keyword)cGroup_3_1_1_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_1_2_0_1 = (Keyword)cGroup_3_1_1_2_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_1_2_0_2 = (RuleCall)cGroup_3_1_1_2_0.eContents().get(2);
		private final Group cGroup_3_1_1_2_1 = (Group)cUnorderedGroup_3_1_1_2.eContents().get(1);
		private final Keyword cYKeyword_3_1_1_2_1_0 = (Keyword)cGroup_3_1_1_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_1_2_1_1 = (Keyword)cGroup_3_1_1_2_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_1_2_1_2 = (RuleCall)cGroup_3_1_1_2_1.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_3_1_1_3 = (Keyword)cGroup_3_1_1.eContents().get(3);
		private final Assignment cNameAssignment_3_1_1_4 = (Assignment)cGroup_3_1_1.eContents().get(4);
		private final RuleCall cNameIDTerminalRuleCall_3_1_1_4_0 = (RuleCall)cNameAssignment_3_1_1_4.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_3_1_1_5 = (Keyword)cGroup_3_1_1.eContents().get(5);
		private final Keyword cNameKeyword_3_1_1_6 = (Keyword)cGroup_3_1_1.eContents().get(6);
		private final Keyword cGreaterThanSignKeyword_3_1_1_7 = (Keyword)cGroup_3_1_1.eContents().get(7);
		private final UnorderedGroup cUnorderedGroup_3_1_2 = (UnorderedGroup)cGroup_3_1.eContents().get(2);
		private final Group cGroup_3_1_2_0 = (Group)cUnorderedGroup_3_1_2.eContents().get(0);
		private final Keyword cLessThanSignKeyword_3_1_2_0_0 = (Keyword)cGroup_3_1_2_0.eContents().get(0);
		private final Keyword cLabelKeyword_3_1_2_0_1 = (Keyword)cGroup_3_1_2_0.eContents().get(1);
		private final Keyword cKindKeyword_3_1_2_0_2 = (Keyword)cGroup_3_1_2_0.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3_1_2_0_3 = (Keyword)cGroup_3_1_2_0.eContents().get(3);
		private final Keyword cCommentsKeyword_3_1_2_0_4 = (Keyword)cGroup_3_1_2_0.eContents().get(4);
		private final UnorderedGroup cUnorderedGroup_3_1_2_0_5 = (UnorderedGroup)cGroup_3_1_2_0.eContents().get(5);
		private final Group cGroup_3_1_2_0_5_0 = (Group)cUnorderedGroup_3_1_2_0_5.eContents().get(0);
		private final Keyword cXKeyword_3_1_2_0_5_0_0 = (Keyword)cGroup_3_1_2_0_5_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_2_0_5_0_1 = (Keyword)cGroup_3_1_2_0_5_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_2_0_5_0_2 = (RuleCall)cGroup_3_1_2_0_5_0.eContents().get(2);
		private final Group cGroup_3_1_2_0_5_1 = (Group)cUnorderedGroup_3_1_2_0_5.eContents().get(1);
		private final Keyword cYKeyword_3_1_2_0_5_1_0 = (Keyword)cGroup_3_1_2_0_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_2_0_5_1_1 = (Keyword)cGroup_3_1_2_0_5_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_2_0_5_1_2 = (RuleCall)cGroup_3_1_2_0_5_1.eContents().get(2);
		private final Group cGroup_3_1_2_0_5_2 = (Group)cUnorderedGroup_3_1_2_0_5.eContents().get(2);
		private final Keyword cColorKeyword_3_1_2_0_5_2_0 = (Keyword)cGroup_3_1_2_0_5_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_2_0_5_2_1 = (Keyword)cGroup_3_1_2_0_5_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_2_0_5_2_2 = (RuleCall)cGroup_3_1_2_0_5_2.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_3_1_2_0_6 = (Keyword)cGroup_3_1_2_0.eContents().get(6);
		private final Assignment cCommentAssignment_3_1_2_0_7 = (Assignment)cGroup_3_1_2_0.eContents().get(7);
		private final RuleCall cCommentCommentLabelParserRuleCall_3_1_2_0_7_0 = (RuleCall)cCommentAssignment_3_1_2_0_7.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_3_1_2_0_8 = (Keyword)cGroup_3_1_2_0.eContents().get(8);
		private final Keyword cLabelKeyword_3_1_2_0_9 = (Keyword)cGroup_3_1_2_0.eContents().get(9);
		private final Keyword cGreaterThanSignKeyword_3_1_2_0_10 = (Keyword)cGroup_3_1_2_0.eContents().get(10);
		private final Group cGroup_3_1_2_1 = (Group)cUnorderedGroup_3_1_2.eContents().get(1);
		private final Keyword cLessThanSignKeyword_3_1_2_1_0 = (Keyword)cGroup_3_1_2_1.eContents().get(0);
		private final Keyword cLabelKeyword_3_1_2_1_1 = (Keyword)cGroup_3_1_2_1.eContents().get(1);
		private final Keyword cKindKeyword_3_1_2_1_2 = (Keyword)cGroup_3_1_2_1.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3_1_2_1_3 = (Keyword)cGroup_3_1_2_1.eContents().get(3);
		private final Keyword cInvariantKeyword_3_1_2_1_4 = (Keyword)cGroup_3_1_2_1.eContents().get(4);
		private final UnorderedGroup cUnorderedGroup_3_1_2_1_5 = (UnorderedGroup)cGroup_3_1_2_1.eContents().get(5);
		private final Group cGroup_3_1_2_1_5_0 = (Group)cUnorderedGroup_3_1_2_1_5.eContents().get(0);
		private final Keyword cXKeyword_3_1_2_1_5_0_0 = (Keyword)cGroup_3_1_2_1_5_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_2_1_5_0_1 = (Keyword)cGroup_3_1_2_1_5_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_2_1_5_0_2 = (RuleCall)cGroup_3_1_2_1_5_0.eContents().get(2);
		private final Group cGroup_3_1_2_1_5_1 = (Group)cUnorderedGroup_3_1_2_1_5.eContents().get(1);
		private final Keyword cYKeyword_3_1_2_1_5_1_0 = (Keyword)cGroup_3_1_2_1_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_2_1_5_1_1 = (Keyword)cGroup_3_1_2_1_5_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_2_1_5_1_2 = (RuleCall)cGroup_3_1_2_1_5_1.eContents().get(2);
		private final Group cGroup_3_1_2_1_5_2 = (Group)cUnorderedGroup_3_1_2_1_5.eContents().get(2);
		private final Keyword cColorKeyword_3_1_2_1_5_2_0 = (Keyword)cGroup_3_1_2_1_5_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1_2_1_5_2_1 = (Keyword)cGroup_3_1_2_1_5_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_3_1_2_1_5_2_2 = (RuleCall)cGroup_3_1_2_1_5_2.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_3_1_2_1_6 = (Keyword)cGroup_3_1_2_1.eContents().get(6);
		private final Assignment cInvariantAssignment_3_1_2_1_7 = (Assignment)cGroup_3_1_2_1.eContents().get(7);
		private final RuleCall cInvariantExpressionParserRuleCall_3_1_2_1_7_0 = (RuleCall)cInvariantAssignment_3_1_2_1_7.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_3_1_2_1_8 = (Keyword)cGroup_3_1_2_1.eContents().get(8);
		private final Keyword cLabelKeyword_3_1_2_1_9 = (Keyword)cGroup_3_1_2_1.eContents().get(9);
		private final Keyword cGreaterThanSignKeyword_3_1_2_1_10 = (Keyword)cGroup_3_1_2_1.eContents().get(10);
		private final Assignment cLocationTimeKindAssignment_3_1_3 = (Assignment)cGroup_3_1.eContents().get(3);
		private final RuleCall cLocationTimeKindLocationKindEnumRuleCall_3_1_3_0 = (RuleCall)cLocationTimeKindAssignment_3_1_3.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_3_1_4 = (Keyword)cGroup_3_1.eContents().get(4);
		private final Keyword cLocationKeyword_3_1_5 = (Keyword)cGroup_3_1.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_3_1_6 = (Keyword)cGroup_3_1.eContents().get(6);
		
		//Location returns parsable_templates::IdentifiableLocation hidden(WS):
		//	"<" "location" // Parse the attributes. 
		//	("id" "=" id=STRING & position=Point? & ("color" "=" colorCode=STRING)?) // Locations without any subelements and stuff are also allowed.
		//	("/>" | // Close the tag.
		//	">" // Get the name of the location.
		//	("<" "name" // Discard name location as there is no field for this.
		//	(("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">")? // Parse the labels.
		//	(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//	comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"invariant\"" (("x" "=" STRING)? & ("y" "="
		//	STRING)? & ("color" "=" STRING)?) ">" invariant=Expression "</" "label" ">")?) // Check whether it is an urgent or committed location.
		//	locationTimeKind=LocationKind? "</" "location" ">");
		public ParserRule getRule() { return rule; }

		//"<" "location" // Parse the attributes. 
		//("id" "=" id=STRING & position=Point? & ("color" "=" colorCode=STRING)?) // Locations without any subelements and stuff are also allowed.
		//("/>" | // Close the tag.
		//">" // Get the name of the location.
		//("<" "name" // Discard name location as there is no field for this.
		//(("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">")? // Parse the labels.
		//(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"invariant\"" (("x" "=" STRING)? & ("y" "="
		//STRING)? & ("color" "=" STRING)?) ">" invariant=Expression "</" "label" ">")?) // Check whether it is an urgent or committed location.
		//locationTimeKind=LocationKind? "</" "location" ">")
		public Group getGroup() { return cGroup; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//"location"
		public Keyword getLocationKeyword_1() { return cLocationKeyword_1; }

		//"id" "=" id=STRING & position=Point? & ("color" "=" colorCode=STRING)?
		public UnorderedGroup getUnorderedGroup_2() { return cUnorderedGroup_2; }

		//"id" "=" id=STRING
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"id"
		public Keyword getIdKeyword_2_0_0() { return cIdKeyword_2_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_0_1() { return cEqualsSignKeyword_2_0_1; }

		//id=STRING
		public Assignment getIdAssignment_2_0_2() { return cIdAssignment_2_0_2; }

		//STRING
		public RuleCall getIdSTRINGTerminalRuleCall_2_0_2_0() { return cIdSTRINGTerminalRuleCall_2_0_2_0; }

		//position=Point?
		public Assignment getPositionAssignment_2_1() { return cPositionAssignment_2_1; }

		//Point
		public RuleCall getPositionPointParserRuleCall_2_1_0() { return cPositionPointParserRuleCall_2_1_0; }

		//("color" "=" colorCode=STRING)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"color"
		public Keyword getColorKeyword_2_2_0() { return cColorKeyword_2_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_1() { return cEqualsSignKeyword_2_2_1; }

		//colorCode=STRING
		public Assignment getColorCodeAssignment_2_2_2() { return cColorCodeAssignment_2_2_2; }

		//STRING
		public RuleCall getColorCodeSTRINGTerminalRuleCall_2_2_2_0() { return cColorCodeSTRINGTerminalRuleCall_2_2_2_0; }

		//// Locations without any subelements and stuff are also allowed.
		//"/>" | // Close the tag.
		//">" // Get the name of the location.
		//("<" "name" // Discard name location as there is no field for this.
		//(("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">")? // Parse the labels.
		//(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"invariant\"" (("x" "=" STRING)? & ("y" "="
		//STRING)? & ("color" "=" STRING)?) ">" invariant=Expression "</" "label" ">")?) // Check whether it is an urgent or committed location.
		//locationTimeKind=LocationKind? "</" "location" ">"
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//// Locations without any subelements and stuff are also allowed.
		//"/>"
		public Keyword getSolidusGreaterThanSignKeyword_3_0() { return cSolidusGreaterThanSignKeyword_3_0; }

		//// Close the tag.
		//">" // Get the name of the location.
		//("<" "name" // Discard name location as there is no field for this.
		//(("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">")? // Parse the labels.
		//(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"invariant\"" (("x" "=" STRING)? & ("y" "="
		//STRING)? & ("color" "=" STRING)?) ">" invariant=Expression "</" "label" ">")?) // Check whether it is an urgent or committed location.
		//locationTimeKind=LocationKind? "</" "location" ">"
		public Group getGroup_3_1() { return cGroup_3_1; }

		//// Close the tag.
		//">"
		public Keyword getGreaterThanSignKeyword_3_1_0() { return cGreaterThanSignKeyword_3_1_0; }

		//("<" "name" // Discard name location as there is no field for this.
		//(("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">")?
		public Group getGroup_3_1_1() { return cGroup_3_1_1; }

		//"<"
		public Keyword getLessThanSignKeyword_3_1_1_0() { return cLessThanSignKeyword_3_1_1_0; }

		//"name"
		public Keyword getNameKeyword_3_1_1_1() { return cNameKeyword_3_1_1_1; }

		//("x" "=" STRING)? & ("y" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_3_1_1_2() { return cUnorderedGroup_3_1_1_2; }

		//("x" "=" STRING)?
		public Group getGroup_3_1_1_2_0() { return cGroup_3_1_1_2_0; }

		//"x"
		public Keyword getXKeyword_3_1_1_2_0_0() { return cXKeyword_3_1_1_2_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_1_2_0_1() { return cEqualsSignKeyword_3_1_1_2_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_1_2_0_2() { return cSTRINGTerminalRuleCall_3_1_1_2_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_3_1_1_2_1() { return cGroup_3_1_1_2_1; }

		//"y"
		public Keyword getYKeyword_3_1_1_2_1_0() { return cYKeyword_3_1_1_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_1_2_1_1() { return cEqualsSignKeyword_3_1_1_2_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_1_2_1_2() { return cSTRINGTerminalRuleCall_3_1_1_2_1_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_3_1_1_3() { return cGreaterThanSignKeyword_3_1_1_3; }

		//name=ID
		public Assignment getNameAssignment_3_1_1_4() { return cNameAssignment_3_1_1_4; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_1_1_4_0() { return cNameIDTerminalRuleCall_3_1_1_4_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_3_1_1_5() { return cLessThanSignSolidusKeyword_3_1_1_5; }

		//"name"
		public Keyword getNameKeyword_3_1_1_6() { return cNameKeyword_3_1_1_6; }

		//">"
		public Keyword getGreaterThanSignKeyword_3_1_1_7() { return cGreaterThanSignKeyword_3_1_1_7; }

		//("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"invariant\"" (("x" "=" STRING)? & ("y" "="
		//STRING)? & ("color" "=" STRING)?) ">" invariant=Expression "</" "label" ">")?
		public UnorderedGroup getUnorderedGroup_3_1_2() { return cUnorderedGroup_3_1_2; }

		//("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")?
		public Group getGroup_3_1_2_0() { return cGroup_3_1_2_0; }

		//"<"
		public Keyword getLessThanSignKeyword_3_1_2_0_0() { return cLessThanSignKeyword_3_1_2_0_0; }

		//"label"
		public Keyword getLabelKeyword_3_1_2_0_1() { return cLabelKeyword_3_1_2_0_1; }

		//"kind"
		public Keyword getKindKeyword_3_1_2_0_2() { return cKindKeyword_3_1_2_0_2; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_0_3() { return cEqualsSignKeyword_3_1_2_0_3; }

		//"\"comments\""
		public Keyword getCommentsKeyword_3_1_2_0_4() { return cCommentsKeyword_3_1_2_0_4; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_3_1_2_0_5() { return cUnorderedGroup_3_1_2_0_5; }

		//("x" "=" STRING)?
		public Group getGroup_3_1_2_0_5_0() { return cGroup_3_1_2_0_5_0; }

		//"x"
		public Keyword getXKeyword_3_1_2_0_5_0_0() { return cXKeyword_3_1_2_0_5_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_0_5_0_1() { return cEqualsSignKeyword_3_1_2_0_5_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_2_0_5_0_2() { return cSTRINGTerminalRuleCall_3_1_2_0_5_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_3_1_2_0_5_1() { return cGroup_3_1_2_0_5_1; }

		//"y"
		public Keyword getYKeyword_3_1_2_0_5_1_0() { return cYKeyword_3_1_2_0_5_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_0_5_1_1() { return cEqualsSignKeyword_3_1_2_0_5_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_2_0_5_1_2() { return cSTRINGTerminalRuleCall_3_1_2_0_5_1_2; }

		//("color" "=" STRING)?
		public Group getGroup_3_1_2_0_5_2() { return cGroup_3_1_2_0_5_2; }

		//"color"
		public Keyword getColorKeyword_3_1_2_0_5_2_0() { return cColorKeyword_3_1_2_0_5_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_0_5_2_1() { return cEqualsSignKeyword_3_1_2_0_5_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_2_0_5_2_2() { return cSTRINGTerminalRuleCall_3_1_2_0_5_2_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_3_1_2_0_6() { return cGreaterThanSignKeyword_3_1_2_0_6; }

		//comment=CommentLabel
		public Assignment getCommentAssignment_3_1_2_0_7() { return cCommentAssignment_3_1_2_0_7; }

		//CommentLabel
		public RuleCall getCommentCommentLabelParserRuleCall_3_1_2_0_7_0() { return cCommentCommentLabelParserRuleCall_3_1_2_0_7_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_3_1_2_0_8() { return cLessThanSignSolidusKeyword_3_1_2_0_8; }

		//"label"
		public Keyword getLabelKeyword_3_1_2_0_9() { return cLabelKeyword_3_1_2_0_9; }

		//">"
		public Keyword getGreaterThanSignKeyword_3_1_2_0_10() { return cGreaterThanSignKeyword_3_1_2_0_10; }

		//("<" "label" "kind" "=" "\"invariant\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//invariant=Expression "</" "label" ">")?
		public Group getGroup_3_1_2_1() { return cGroup_3_1_2_1; }

		//"<"
		public Keyword getLessThanSignKeyword_3_1_2_1_0() { return cLessThanSignKeyword_3_1_2_1_0; }

		//"label"
		public Keyword getLabelKeyword_3_1_2_1_1() { return cLabelKeyword_3_1_2_1_1; }

		//"kind"
		public Keyword getKindKeyword_3_1_2_1_2() { return cKindKeyword_3_1_2_1_2; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_1_3() { return cEqualsSignKeyword_3_1_2_1_3; }

		//"\"invariant\""
		public Keyword getInvariantKeyword_3_1_2_1_4() { return cInvariantKeyword_3_1_2_1_4; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_3_1_2_1_5() { return cUnorderedGroup_3_1_2_1_5; }

		//("x" "=" STRING)?
		public Group getGroup_3_1_2_1_5_0() { return cGroup_3_1_2_1_5_0; }

		//"x"
		public Keyword getXKeyword_3_1_2_1_5_0_0() { return cXKeyword_3_1_2_1_5_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_1_5_0_1() { return cEqualsSignKeyword_3_1_2_1_5_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_2_1_5_0_2() { return cSTRINGTerminalRuleCall_3_1_2_1_5_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_3_1_2_1_5_1() { return cGroup_3_1_2_1_5_1; }

		//"y"
		public Keyword getYKeyword_3_1_2_1_5_1_0() { return cYKeyword_3_1_2_1_5_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_1_5_1_1() { return cEqualsSignKeyword_3_1_2_1_5_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_2_1_5_1_2() { return cSTRINGTerminalRuleCall_3_1_2_1_5_1_2; }

		//("color" "=" STRING)?
		public Group getGroup_3_1_2_1_5_2() { return cGroup_3_1_2_1_5_2; }

		//"color"
		public Keyword getColorKeyword_3_1_2_1_5_2_0() { return cColorKeyword_3_1_2_1_5_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1_2_1_5_2_1() { return cEqualsSignKeyword_3_1_2_1_5_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3_1_2_1_5_2_2() { return cSTRINGTerminalRuleCall_3_1_2_1_5_2_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_3_1_2_1_6() { return cGreaterThanSignKeyword_3_1_2_1_6; }

		//invariant=Expression
		public Assignment getInvariantAssignment_3_1_2_1_7() { return cInvariantAssignment_3_1_2_1_7; }

		//Expression
		public RuleCall getInvariantExpressionParserRuleCall_3_1_2_1_7_0() { return cInvariantExpressionParserRuleCall_3_1_2_1_7_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_3_1_2_1_8() { return cLessThanSignSolidusKeyword_3_1_2_1_8; }

		//"label"
		public Keyword getLabelKeyword_3_1_2_1_9() { return cLabelKeyword_3_1_2_1_9; }

		//">"
		public Keyword getGreaterThanSignKeyword_3_1_2_1_10() { return cGreaterThanSignKeyword_3_1_2_1_10; }

		//// Check whether it is an urgent or committed location.
		//locationTimeKind=LocationKind?
		public Assignment getLocationTimeKindAssignment_3_1_3() { return cLocationTimeKindAssignment_3_1_3; }

		//LocationKind
		public RuleCall getLocationTimeKindLocationKindEnumRuleCall_3_1_3_0() { return cLocationTimeKindLocationKindEnumRuleCall_3_1_3_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_3_1_4() { return cLessThanSignSolidusKeyword_3_1_4; }

		//"location"
		public Keyword getLocationKeyword_3_1_5() { return cLocationKeyword_3_1_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_3_1_6() { return cGreaterThanSignKeyword_3_1_6; }
	}

	public class EdgeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Edge");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cTransitionKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_2 = (UnorderedGroup)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cUnorderedGroup_2.eContents().get(0);
		private final Keyword cXKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_2_0_2 = (RuleCall)cGroup_2_0.eContents().get(2);
		private final Group cGroup_2_1 = (Group)cUnorderedGroup_2.eContents().get(1);
		private final Keyword cYKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_2_1_2 = (RuleCall)cGroup_2_1.eContents().get(2);
		private final Group cGroup_2_2 = (Group)cUnorderedGroup_2.eContents().get(2);
		private final Keyword cColorKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Assignment cColorCodeAssignment_2_2_2 = (Assignment)cGroup_2_2.eContents().get(2);
		private final RuleCall cColorCodeSTRINGTerminalRuleCall_2_2_2_0 = (RuleCall)cColorCodeAssignment_2_2_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLessThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSourceKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cRefKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cSourceAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final CrossReference cSourceLocationCrossReference_8_0 = (CrossReference)cSourceAssignment_8.eContents().get(0);
		private final RuleCall cSourceLocationSTRINGTerminalRuleCall_8_0_1 = (RuleCall)cSourceLocationCrossReference_8_0.eContents().get(1);
		private final Keyword cSolidusGreaterThanSignKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cLessThanSignKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cTargetKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final Keyword cRefKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Keyword cEqualsSignKeyword_13 = (Keyword)cGroup.eContents().get(13);
		private final Assignment cTargetAssignment_14 = (Assignment)cGroup.eContents().get(14);
		private final CrossReference cTargetLocationCrossReference_14_0 = (CrossReference)cTargetAssignment_14.eContents().get(0);
		private final RuleCall cTargetLocationSTRINGTerminalRuleCall_14_0_1 = (RuleCall)cTargetLocationCrossReference_14_0.eContents().get(1);
		private final Keyword cSolidusGreaterThanSignKeyword_15 = (Keyword)cGroup.eContents().get(15);
		private final UnorderedGroup cUnorderedGroup_16 = (UnorderedGroup)cGroup.eContents().get(16);
		private final Group cGroup_16_0 = (Group)cUnorderedGroup_16.eContents().get(0);
		private final Keyword cLessThanSignKeyword_16_0_0 = (Keyword)cGroup_16_0.eContents().get(0);
		private final Keyword cLabelKeyword_16_0_1 = (Keyword)cGroup_16_0.eContents().get(1);
		private final Keyword cKindKeyword_16_0_2 = (Keyword)cGroup_16_0.eContents().get(2);
		private final Keyword cEqualsSignKeyword_16_0_3 = (Keyword)cGroup_16_0.eContents().get(3);
		private final Keyword cCommentsKeyword_16_0_4 = (Keyword)cGroup_16_0.eContents().get(4);
		private final UnorderedGroup cUnorderedGroup_16_0_5 = (UnorderedGroup)cGroup_16_0.eContents().get(5);
		private final Group cGroup_16_0_5_0 = (Group)cUnorderedGroup_16_0_5.eContents().get(0);
		private final Keyword cXKeyword_16_0_5_0_0 = (Keyword)cGroup_16_0_5_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_0_5_0_1 = (Keyword)cGroup_16_0_5_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_0_5_0_2 = (RuleCall)cGroup_16_0_5_0.eContents().get(2);
		private final Group cGroup_16_0_5_1 = (Group)cUnorderedGroup_16_0_5.eContents().get(1);
		private final Keyword cYKeyword_16_0_5_1_0 = (Keyword)cGroup_16_0_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_0_5_1_1 = (Keyword)cGroup_16_0_5_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_0_5_1_2 = (RuleCall)cGroup_16_0_5_1.eContents().get(2);
		private final Group cGroup_16_0_5_2 = (Group)cUnorderedGroup_16_0_5.eContents().get(2);
		private final Keyword cColorKeyword_16_0_5_2_0 = (Keyword)cGroup_16_0_5_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_0_5_2_1 = (Keyword)cGroup_16_0_5_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_0_5_2_2 = (RuleCall)cGroup_16_0_5_2.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_16_0_6 = (Keyword)cGroup_16_0.eContents().get(6);
		private final Assignment cCommentAssignment_16_0_7 = (Assignment)cGroup_16_0.eContents().get(7);
		private final RuleCall cCommentCommentLabelParserRuleCall_16_0_7_0 = (RuleCall)cCommentAssignment_16_0_7.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_16_0_8 = (Keyword)cGroup_16_0.eContents().get(8);
		private final Keyword cLabelKeyword_16_0_9 = (Keyword)cGroup_16_0.eContents().get(9);
		private final Keyword cGreaterThanSignKeyword_16_0_10 = (Keyword)cGroup_16_0.eContents().get(10);
		private final Group cGroup_16_1 = (Group)cUnorderedGroup_16.eContents().get(1);
		private final Keyword cLessThanSignKeyword_16_1_0 = (Keyword)cGroup_16_1.eContents().get(0);
		private final Keyword cLabelKeyword_16_1_1 = (Keyword)cGroup_16_1.eContents().get(1);
		private final Keyword cKindKeyword_16_1_2 = (Keyword)cGroup_16_1.eContents().get(2);
		private final Keyword cEqualsSignKeyword_16_1_3 = (Keyword)cGroup_16_1.eContents().get(3);
		private final Keyword cSynchronisationKeyword_16_1_4 = (Keyword)cGroup_16_1.eContents().get(4);
		private final UnorderedGroup cUnorderedGroup_16_1_5 = (UnorderedGroup)cGroup_16_1.eContents().get(5);
		private final Group cGroup_16_1_5_0 = (Group)cUnorderedGroup_16_1_5.eContents().get(0);
		private final Keyword cXKeyword_16_1_5_0_0 = (Keyword)cGroup_16_1_5_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_1_5_0_1 = (Keyword)cGroup_16_1_5_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_1_5_0_2 = (RuleCall)cGroup_16_1_5_0.eContents().get(2);
		private final Group cGroup_16_1_5_1 = (Group)cUnorderedGroup_16_1_5.eContents().get(1);
		private final Keyword cYKeyword_16_1_5_1_0 = (Keyword)cGroup_16_1_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_1_5_1_1 = (Keyword)cGroup_16_1_5_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_1_5_1_2 = (RuleCall)cGroup_16_1_5_1.eContents().get(2);
		private final Group cGroup_16_1_5_2 = (Group)cUnorderedGroup_16_1_5.eContents().get(2);
		private final Keyword cColorKeyword_16_1_5_2_0 = (Keyword)cGroup_16_1_5_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_1_5_2_1 = (Keyword)cGroup_16_1_5_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_1_5_2_2 = (RuleCall)cGroup_16_1_5_2.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_16_1_6 = (Keyword)cGroup_16_1.eContents().get(6);
		private final Assignment cSynchronizationAssignment_16_1_7 = (Assignment)cGroup_16_1.eContents().get(7);
		private final RuleCall cSynchronizationSynchronizationLabelParserRuleCall_16_1_7_0 = (RuleCall)cSynchronizationAssignment_16_1_7.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_16_1_8 = (Keyword)cGroup_16_1.eContents().get(8);
		private final Keyword cLabelKeyword_16_1_9 = (Keyword)cGroup_16_1.eContents().get(9);
		private final Keyword cGreaterThanSignKeyword_16_1_10 = (Keyword)cGroup_16_1.eContents().get(10);
		private final Group cGroup_16_2 = (Group)cUnorderedGroup_16.eContents().get(2);
		private final Keyword cLessThanSignKeyword_16_2_0 = (Keyword)cGroup_16_2.eContents().get(0);
		private final Keyword cLabelKeyword_16_2_1 = (Keyword)cGroup_16_2.eContents().get(1);
		private final Keyword cKindKeyword_16_2_2 = (Keyword)cGroup_16_2.eContents().get(2);
		private final Keyword cEqualsSignKeyword_16_2_3 = (Keyword)cGroup_16_2.eContents().get(3);
		private final Keyword cGuardKeyword_16_2_4 = (Keyword)cGroup_16_2.eContents().get(4);
		private final UnorderedGroup cUnorderedGroup_16_2_5 = (UnorderedGroup)cGroup_16_2.eContents().get(5);
		private final Group cGroup_16_2_5_0 = (Group)cUnorderedGroup_16_2_5.eContents().get(0);
		private final Keyword cXKeyword_16_2_5_0_0 = (Keyword)cGroup_16_2_5_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_2_5_0_1 = (Keyword)cGroup_16_2_5_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_2_5_0_2 = (RuleCall)cGroup_16_2_5_0.eContents().get(2);
		private final Group cGroup_16_2_5_1 = (Group)cUnorderedGroup_16_2_5.eContents().get(1);
		private final Keyword cYKeyword_16_2_5_1_0 = (Keyword)cGroup_16_2_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_2_5_1_1 = (Keyword)cGroup_16_2_5_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_2_5_1_2 = (RuleCall)cGroup_16_2_5_1.eContents().get(2);
		private final Group cGroup_16_2_5_2 = (Group)cUnorderedGroup_16_2_5.eContents().get(2);
		private final Keyword cColorKeyword_16_2_5_2_0 = (Keyword)cGroup_16_2_5_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_2_5_2_1 = (Keyword)cGroup_16_2_5_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_2_5_2_2 = (RuleCall)cGroup_16_2_5_2.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_16_2_6 = (Keyword)cGroup_16_2.eContents().get(6);
		private final Assignment cGuardAssignment_16_2_7 = (Assignment)cGroup_16_2.eContents().get(7);
		private final RuleCall cGuardExpressionParserRuleCall_16_2_7_0 = (RuleCall)cGuardAssignment_16_2_7.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_16_2_8 = (Keyword)cGroup_16_2.eContents().get(8);
		private final Keyword cLabelKeyword_16_2_9 = (Keyword)cGroup_16_2.eContents().get(9);
		private final Keyword cGreaterThanSignKeyword_16_2_10 = (Keyword)cGroup_16_2.eContents().get(10);
		private final Group cGroup_16_3 = (Group)cUnorderedGroup_16.eContents().get(3);
		private final Keyword cLessThanSignKeyword_16_3_0 = (Keyword)cGroup_16_3.eContents().get(0);
		private final Keyword cLabelKeyword_16_3_1 = (Keyword)cGroup_16_3.eContents().get(1);
		private final Keyword cKindKeyword_16_3_2 = (Keyword)cGroup_16_3.eContents().get(2);
		private final Keyword cEqualsSignKeyword_16_3_3 = (Keyword)cGroup_16_3.eContents().get(3);
		private final Keyword cAssignmentKeyword_16_3_4 = (Keyword)cGroup_16_3.eContents().get(4);
		private final UnorderedGroup cUnorderedGroup_16_3_5 = (UnorderedGroup)cGroup_16_3.eContents().get(5);
		private final Group cGroup_16_3_5_0 = (Group)cUnorderedGroup_16_3_5.eContents().get(0);
		private final Keyword cXKeyword_16_3_5_0_0 = (Keyword)cGroup_16_3_5_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_3_5_0_1 = (Keyword)cGroup_16_3_5_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_3_5_0_2 = (RuleCall)cGroup_16_3_5_0.eContents().get(2);
		private final Group cGroup_16_3_5_1 = (Group)cUnorderedGroup_16_3_5.eContents().get(1);
		private final Keyword cYKeyword_16_3_5_1_0 = (Keyword)cGroup_16_3_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_3_5_1_1 = (Keyword)cGroup_16_3_5_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_3_5_1_2 = (RuleCall)cGroup_16_3_5_1.eContents().get(2);
		private final Group cGroup_16_3_5_2 = (Group)cUnorderedGroup_16_3_5.eContents().get(2);
		private final Keyword cColorKeyword_16_3_5_2_0 = (Keyword)cGroup_16_3_5_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_3_5_2_1 = (Keyword)cGroup_16_3_5_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_3_5_2_2 = (RuleCall)cGroup_16_3_5_2.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_16_3_6 = (Keyword)cGroup_16_3.eContents().get(6);
		private final Assignment cUpdateAssignment_16_3_7 = (Assignment)cGroup_16_3.eContents().get(7);
		private final RuleCall cUpdateExpressionParserRuleCall_16_3_7_0 = (RuleCall)cUpdateAssignment_16_3_7.eContents().get(0);
		private final Group cGroup_16_3_8 = (Group)cGroup_16_3.eContents().get(8);
		private final Keyword cCommaKeyword_16_3_8_0 = (Keyword)cGroup_16_3_8.eContents().get(0);
		private final Assignment cUpdateAssignment_16_3_8_1 = (Assignment)cGroup_16_3_8.eContents().get(1);
		private final RuleCall cUpdateExpressionParserRuleCall_16_3_8_1_0 = (RuleCall)cUpdateAssignment_16_3_8_1.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_16_3_9 = (Keyword)cGroup_16_3.eContents().get(9);
		private final Keyword cLabelKeyword_16_3_10 = (Keyword)cGroup_16_3.eContents().get(10);
		private final Keyword cGreaterThanSignKeyword_16_3_11 = (Keyword)cGroup_16_3.eContents().get(11);
		private final Group cGroup_16_4 = (Group)cUnorderedGroup_16.eContents().get(4);
		private final Keyword cLessThanSignKeyword_16_4_0 = (Keyword)cGroup_16_4.eContents().get(0);
		private final Keyword cLabelKeyword_16_4_1 = (Keyword)cGroup_16_4.eContents().get(1);
		private final Keyword cKindKeyword_16_4_2 = (Keyword)cGroup_16_4.eContents().get(2);
		private final Keyword cEqualsSignKeyword_16_4_3 = (Keyword)cGroup_16_4.eContents().get(3);
		private final Keyword cSelectKeyword_16_4_4 = (Keyword)cGroup_16_4.eContents().get(4);
		private final UnorderedGroup cUnorderedGroup_16_4_5 = (UnorderedGroup)cGroup_16_4.eContents().get(5);
		private final Group cGroup_16_4_5_0 = (Group)cUnorderedGroup_16_4_5.eContents().get(0);
		private final Keyword cXKeyword_16_4_5_0_0 = (Keyword)cGroup_16_4_5_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_4_5_0_1 = (Keyword)cGroup_16_4_5_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_4_5_0_2 = (RuleCall)cGroup_16_4_5_0.eContents().get(2);
		private final Group cGroup_16_4_5_1 = (Group)cUnorderedGroup_16_4_5.eContents().get(1);
		private final Keyword cYKeyword_16_4_5_1_0 = (Keyword)cGroup_16_4_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_4_5_1_1 = (Keyword)cGroup_16_4_5_1.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_4_5_1_2 = (RuleCall)cGroup_16_4_5_1.eContents().get(2);
		private final Group cGroup_16_4_5_2 = (Group)cUnorderedGroup_16_4_5.eContents().get(2);
		private final Keyword cColorKeyword_16_4_5_2_0 = (Keyword)cGroup_16_4_5_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_16_4_5_2_1 = (Keyword)cGroup_16_4_5_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_16_4_5_2_2 = (RuleCall)cGroup_16_4_5_2.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_16_4_6 = (Keyword)cGroup_16_4.eContents().get(6);
		private final Assignment cSelectionAssignment_16_4_7 = (Assignment)cGroup_16_4.eContents().get(7);
		private final RuleCall cSelectionSelectionParserRuleCall_16_4_7_0 = (RuleCall)cSelectionAssignment_16_4_7.eContents().get(0);
		private final Group cGroup_16_4_8 = (Group)cGroup_16_4.eContents().get(8);
		private final Keyword cCommaKeyword_16_4_8_0 = (Keyword)cGroup_16_4_8.eContents().get(0);
		private final Assignment cSelectionAssignment_16_4_8_1 = (Assignment)cGroup_16_4_8.eContents().get(1);
		private final RuleCall cSelectionSelectionParserRuleCall_16_4_8_1_0 = (RuleCall)cSelectionAssignment_16_4_8_1.eContents().get(0);
		private final Keyword cLessThanSignSolidusKeyword_16_4_9 = (Keyword)cGroup_16_4.eContents().get(9);
		private final Keyword cLabelKeyword_16_4_10 = (Keyword)cGroup_16_4.eContents().get(10);
		private final Keyword cGreaterThanSignKeyword_16_4_11 = (Keyword)cGroup_16_4.eContents().get(11);
		private final Group cGroup_17 = (Group)cGroup.eContents().get(17);
		private final Keyword cLessThanSignKeyword_17_0 = (Keyword)cGroup_17.eContents().get(0);
		private final Keyword cNailKeyword_17_1 = (Keyword)cGroup_17.eContents().get(1);
		private final Assignment cBendPointAssignment_17_2 = (Assignment)cGroup_17.eContents().get(2);
		private final RuleCall cBendPointPointParserRuleCall_17_2_0 = (RuleCall)cBendPointAssignment_17_2.eContents().get(0);
		private final Keyword cSolidusGreaterThanSignKeyword_17_3 = (Keyword)cGroup_17.eContents().get(3);
		private final Keyword cLessThanSignSolidusKeyword_18 = (Keyword)cGroup.eContents().get(18);
		private final Keyword cTransitionKeyword_19 = (Keyword)cGroup.eContents().get(19);
		private final Keyword cGreaterThanSignKeyword_20 = (Keyword)cGroup.eContents().get(20);
		
		//Edge returns templates::Edge hidden(WS): // Again skip the coordinates.
		//	"<" "transition" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" colorCode=STRING)?) ">" // Source...
		//	"<" "source" "ref" "=" source=[templates::Location|STRING] "/>" // Target...
		//	"<" "target" "ref" "=" target=[templates::Location|STRING] "/>" // Parse the labels.
		//	(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//	comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"synchronisation\"" (("x" "=" STRING)? & ("y" "="
		//	STRING)? & ("color" "=" STRING)?) ">" synchronization=SynchronizationLabel "</" "label" ">")? & ("<" "label" "kind"
		//	"=" "\"guard\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" guard=Expression "</" "label"
		//	">")? & ("<" "label" "kind" "=" "\"assignment\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//	update+=Expression ("," update+=Expression)* "</" "label" ">")? & ("<" "label" "kind" "=" "\"select\"" (("x" "="
		//	STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" selection+=Selection ("," selection+=Selection)* "</"
		//	"label" ">")?) // Get the nails/bendPoints.
		//	("<" "nail" bendPoint+=Point "/>")* // Close the tag.
		//	"</" "transition" ">";
		public ParserRule getRule() { return rule; }

		//// Again skip the coordinates.
		//"<" "transition" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" colorCode=STRING)?) ">" // Source...
		//"<" "source" "ref" "=" source=[templates::Location|STRING] "/>" // Target...
		//"<" "target" "ref" "=" target=[templates::Location|STRING] "/>" // Parse the labels.
		//(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"synchronisation\"" (("x" "=" STRING)? & ("y" "="
		//STRING)? & ("color" "=" STRING)?) ">" synchronization=SynchronizationLabel "</" "label" ">")? & ("<" "label" "kind"
		//"=" "\"guard\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" guard=Expression "</" "label"
		//">")? & ("<" "label" "kind" "=" "\"assignment\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//update+=Expression ("," update+=Expression)* "</" "label" ">")? & ("<" "label" "kind" "=" "\"select\"" (("x" "="
		//STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" selection+=Selection ("," selection+=Selection)* "</"
		//"label" ">")?) // Get the nails/bendPoints.
		//("<" "nail" bendPoint+=Point "/>")* // Close the tag.
		//"</" "transition" ">"
		public Group getGroup() { return cGroup; }

		//// Again skip the coordinates.
		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//"transition"
		public Keyword getTransitionKeyword_1() { return cTransitionKeyword_1; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" colorCode=STRING)?
		public UnorderedGroup getUnorderedGroup_2() { return cUnorderedGroup_2; }

		//("x" "=" STRING)?
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"x"
		public Keyword getXKeyword_2_0_0() { return cXKeyword_2_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_0_1() { return cEqualsSignKeyword_2_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_2_0_2() { return cSTRINGTerminalRuleCall_2_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"y"
		public Keyword getYKeyword_2_1_0() { return cYKeyword_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_1_1() { return cEqualsSignKeyword_2_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_2_1_2() { return cSTRINGTerminalRuleCall_2_1_2; }

		//("color" "=" colorCode=STRING)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"color"
		public Keyword getColorKeyword_2_2_0() { return cColorKeyword_2_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_1() { return cEqualsSignKeyword_2_2_1; }

		//colorCode=STRING
		public Assignment getColorCodeAssignment_2_2_2() { return cColorCodeAssignment_2_2_2; }

		//STRING
		public RuleCall getColorCodeSTRINGTerminalRuleCall_2_2_2_0() { return cColorCodeSTRINGTerminalRuleCall_2_2_2_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }

		//// Source...
		//"<"
		public Keyword getLessThanSignKeyword_4() { return cLessThanSignKeyword_4; }

		//"source"
		public Keyword getSourceKeyword_5() { return cSourceKeyword_5; }

		//"ref"
		public Keyword getRefKeyword_6() { return cRefKeyword_6; }

		//"="
		public Keyword getEqualsSignKeyword_7() { return cEqualsSignKeyword_7; }

		//source=[templates::Location|STRING]
		public Assignment getSourceAssignment_8() { return cSourceAssignment_8; }

		//[templates::Location|STRING]
		public CrossReference getSourceLocationCrossReference_8_0() { return cSourceLocationCrossReference_8_0; }

		//STRING
		public RuleCall getSourceLocationSTRINGTerminalRuleCall_8_0_1() { return cSourceLocationSTRINGTerminalRuleCall_8_0_1; }

		//"/>"
		public Keyword getSolidusGreaterThanSignKeyword_9() { return cSolidusGreaterThanSignKeyword_9; }

		//// Target...
		//"<"
		public Keyword getLessThanSignKeyword_10() { return cLessThanSignKeyword_10; }

		//"target"
		public Keyword getTargetKeyword_11() { return cTargetKeyword_11; }

		//"ref"
		public Keyword getRefKeyword_12() { return cRefKeyword_12; }

		//"="
		public Keyword getEqualsSignKeyword_13() { return cEqualsSignKeyword_13; }

		//target=[templates::Location|STRING]
		public Assignment getTargetAssignment_14() { return cTargetAssignment_14; }

		//[templates::Location|STRING]
		public CrossReference getTargetLocationCrossReference_14_0() { return cTargetLocationCrossReference_14_0; }

		//STRING
		public RuleCall getTargetLocationSTRINGTerminalRuleCall_14_0_1() { return cTargetLocationSTRINGTerminalRuleCall_14_0_1; }

		//"/>"
		public Keyword getSolidusGreaterThanSignKeyword_15() { return cSolidusGreaterThanSignKeyword_15; }

		//("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"synchronisation\"" (("x" "=" STRING)? & ("y" "="
		//STRING)? & ("color" "=" STRING)?) ">" synchronization=SynchronizationLabel "</" "label" ">")? & ("<" "label" "kind"
		//"=" "\"guard\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" guard=Expression "</" "label"
		//">")? & ("<" "label" "kind" "=" "\"assignment\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//update+=Expression ("," update+=Expression)* "</" "label" ">")? & ("<" "label" "kind" "=" "\"select\"" (("x" "="
		//STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" selection+=Selection ("," selection+=Selection)* "</"
		//"label" ">")?
		public UnorderedGroup getUnorderedGroup_16() { return cUnorderedGroup_16; }

		//("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//comment=CommentLabel "</" "label" ">")?
		public Group getGroup_16_0() { return cGroup_16_0; }

		//"<"
		public Keyword getLessThanSignKeyword_16_0_0() { return cLessThanSignKeyword_16_0_0; }

		//"label"
		public Keyword getLabelKeyword_16_0_1() { return cLabelKeyword_16_0_1; }

		//"kind"
		public Keyword getKindKeyword_16_0_2() { return cKindKeyword_16_0_2; }

		//"="
		public Keyword getEqualsSignKeyword_16_0_3() { return cEqualsSignKeyword_16_0_3; }

		//"\"comments\""
		public Keyword getCommentsKeyword_16_0_4() { return cCommentsKeyword_16_0_4; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_16_0_5() { return cUnorderedGroup_16_0_5; }

		//("x" "=" STRING)?
		public Group getGroup_16_0_5_0() { return cGroup_16_0_5_0; }

		//"x"
		public Keyword getXKeyword_16_0_5_0_0() { return cXKeyword_16_0_5_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_0_5_0_1() { return cEqualsSignKeyword_16_0_5_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_0_5_0_2() { return cSTRINGTerminalRuleCall_16_0_5_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_16_0_5_1() { return cGroup_16_0_5_1; }

		//"y"
		public Keyword getYKeyword_16_0_5_1_0() { return cYKeyword_16_0_5_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_0_5_1_1() { return cEqualsSignKeyword_16_0_5_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_0_5_1_2() { return cSTRINGTerminalRuleCall_16_0_5_1_2; }

		//("color" "=" STRING)?
		public Group getGroup_16_0_5_2() { return cGroup_16_0_5_2; }

		//"color"
		public Keyword getColorKeyword_16_0_5_2_0() { return cColorKeyword_16_0_5_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_0_5_2_1() { return cEqualsSignKeyword_16_0_5_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_0_5_2_2() { return cSTRINGTerminalRuleCall_16_0_5_2_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_0_6() { return cGreaterThanSignKeyword_16_0_6; }

		//comment=CommentLabel
		public Assignment getCommentAssignment_16_0_7() { return cCommentAssignment_16_0_7; }

		//CommentLabel
		public RuleCall getCommentCommentLabelParserRuleCall_16_0_7_0() { return cCommentCommentLabelParserRuleCall_16_0_7_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_16_0_8() { return cLessThanSignSolidusKeyword_16_0_8; }

		//"label"
		public Keyword getLabelKeyword_16_0_9() { return cLabelKeyword_16_0_9; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_0_10() { return cGreaterThanSignKeyword_16_0_10; }

		//("<" "label" "kind" "=" "\"synchronisation\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//synchronization=SynchronizationLabel "</" "label" ">")?
		public Group getGroup_16_1() { return cGroup_16_1; }

		//"<"
		public Keyword getLessThanSignKeyword_16_1_0() { return cLessThanSignKeyword_16_1_0; }

		//"label"
		public Keyword getLabelKeyword_16_1_1() { return cLabelKeyword_16_1_1; }

		//"kind"
		public Keyword getKindKeyword_16_1_2() { return cKindKeyword_16_1_2; }

		//"="
		public Keyword getEqualsSignKeyword_16_1_3() { return cEqualsSignKeyword_16_1_3; }

		//"\"synchronisation\""
		public Keyword getSynchronisationKeyword_16_1_4() { return cSynchronisationKeyword_16_1_4; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_16_1_5() { return cUnorderedGroup_16_1_5; }

		//("x" "=" STRING)?
		public Group getGroup_16_1_5_0() { return cGroup_16_1_5_0; }

		//"x"
		public Keyword getXKeyword_16_1_5_0_0() { return cXKeyword_16_1_5_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_1_5_0_1() { return cEqualsSignKeyword_16_1_5_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_1_5_0_2() { return cSTRINGTerminalRuleCall_16_1_5_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_16_1_5_1() { return cGroup_16_1_5_1; }

		//"y"
		public Keyword getYKeyword_16_1_5_1_0() { return cYKeyword_16_1_5_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_1_5_1_1() { return cEqualsSignKeyword_16_1_5_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_1_5_1_2() { return cSTRINGTerminalRuleCall_16_1_5_1_2; }

		//("color" "=" STRING)?
		public Group getGroup_16_1_5_2() { return cGroup_16_1_5_2; }

		//"color"
		public Keyword getColorKeyword_16_1_5_2_0() { return cColorKeyword_16_1_5_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_1_5_2_1() { return cEqualsSignKeyword_16_1_5_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_1_5_2_2() { return cSTRINGTerminalRuleCall_16_1_5_2_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_1_6() { return cGreaterThanSignKeyword_16_1_6; }

		//synchronization=SynchronizationLabel
		public Assignment getSynchronizationAssignment_16_1_7() { return cSynchronizationAssignment_16_1_7; }

		//SynchronizationLabel
		public RuleCall getSynchronizationSynchronizationLabelParserRuleCall_16_1_7_0() { return cSynchronizationSynchronizationLabelParserRuleCall_16_1_7_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_16_1_8() { return cLessThanSignSolidusKeyword_16_1_8; }

		//"label"
		public Keyword getLabelKeyword_16_1_9() { return cLabelKeyword_16_1_9; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_1_10() { return cGreaterThanSignKeyword_16_1_10; }

		//("<" "label" "kind" "=" "\"guard\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" guard=Expression
		//"</" "label" ">")?
		public Group getGroup_16_2() { return cGroup_16_2; }

		//"<"
		public Keyword getLessThanSignKeyword_16_2_0() { return cLessThanSignKeyword_16_2_0; }

		//"label"
		public Keyword getLabelKeyword_16_2_1() { return cLabelKeyword_16_2_1; }

		//"kind"
		public Keyword getKindKeyword_16_2_2() { return cKindKeyword_16_2_2; }

		//"="
		public Keyword getEqualsSignKeyword_16_2_3() { return cEqualsSignKeyword_16_2_3; }

		//"\"guard\""
		public Keyword getGuardKeyword_16_2_4() { return cGuardKeyword_16_2_4; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_16_2_5() { return cUnorderedGroup_16_2_5; }

		//("x" "=" STRING)?
		public Group getGroup_16_2_5_0() { return cGroup_16_2_5_0; }

		//"x"
		public Keyword getXKeyword_16_2_5_0_0() { return cXKeyword_16_2_5_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_2_5_0_1() { return cEqualsSignKeyword_16_2_5_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_2_5_0_2() { return cSTRINGTerminalRuleCall_16_2_5_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_16_2_5_1() { return cGroup_16_2_5_1; }

		//"y"
		public Keyword getYKeyword_16_2_5_1_0() { return cYKeyword_16_2_5_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_2_5_1_1() { return cEqualsSignKeyword_16_2_5_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_2_5_1_2() { return cSTRINGTerminalRuleCall_16_2_5_1_2; }

		//("color" "=" STRING)?
		public Group getGroup_16_2_5_2() { return cGroup_16_2_5_2; }

		//"color"
		public Keyword getColorKeyword_16_2_5_2_0() { return cColorKeyword_16_2_5_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_2_5_2_1() { return cEqualsSignKeyword_16_2_5_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_2_5_2_2() { return cSTRINGTerminalRuleCall_16_2_5_2_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_2_6() { return cGreaterThanSignKeyword_16_2_6; }

		//guard=Expression
		public Assignment getGuardAssignment_16_2_7() { return cGuardAssignment_16_2_7; }

		//Expression
		public RuleCall getGuardExpressionParserRuleCall_16_2_7_0() { return cGuardExpressionParserRuleCall_16_2_7_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_16_2_8() { return cLessThanSignSolidusKeyword_16_2_8; }

		//"label"
		public Keyword getLabelKeyword_16_2_9() { return cLabelKeyword_16_2_9; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_2_10() { return cGreaterThanSignKeyword_16_2_10; }

		//("<" "label" "kind" "=" "\"assignment\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//update+=Expression ("," update+=Expression)* "</" "label" ">")?
		public Group getGroup_16_3() { return cGroup_16_3; }

		//"<"
		public Keyword getLessThanSignKeyword_16_3_0() { return cLessThanSignKeyword_16_3_0; }

		//"label"
		public Keyword getLabelKeyword_16_3_1() { return cLabelKeyword_16_3_1; }

		//"kind"
		public Keyword getKindKeyword_16_3_2() { return cKindKeyword_16_3_2; }

		//"="
		public Keyword getEqualsSignKeyword_16_3_3() { return cEqualsSignKeyword_16_3_3; }

		//"\"assignment\""
		public Keyword getAssignmentKeyword_16_3_4() { return cAssignmentKeyword_16_3_4; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_16_3_5() { return cUnorderedGroup_16_3_5; }

		//("x" "=" STRING)?
		public Group getGroup_16_3_5_0() { return cGroup_16_3_5_0; }

		//"x"
		public Keyword getXKeyword_16_3_5_0_0() { return cXKeyword_16_3_5_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_3_5_0_1() { return cEqualsSignKeyword_16_3_5_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_3_5_0_2() { return cSTRINGTerminalRuleCall_16_3_5_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_16_3_5_1() { return cGroup_16_3_5_1; }

		//"y"
		public Keyword getYKeyword_16_3_5_1_0() { return cYKeyword_16_3_5_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_3_5_1_1() { return cEqualsSignKeyword_16_3_5_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_3_5_1_2() { return cSTRINGTerminalRuleCall_16_3_5_1_2; }

		//("color" "=" STRING)?
		public Group getGroup_16_3_5_2() { return cGroup_16_3_5_2; }

		//"color"
		public Keyword getColorKeyword_16_3_5_2_0() { return cColorKeyword_16_3_5_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_3_5_2_1() { return cEqualsSignKeyword_16_3_5_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_3_5_2_2() { return cSTRINGTerminalRuleCall_16_3_5_2_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_3_6() { return cGreaterThanSignKeyword_16_3_6; }

		//update+=Expression
		public Assignment getUpdateAssignment_16_3_7() { return cUpdateAssignment_16_3_7; }

		//Expression
		public RuleCall getUpdateExpressionParserRuleCall_16_3_7_0() { return cUpdateExpressionParserRuleCall_16_3_7_0; }

		//("," update+=Expression)*
		public Group getGroup_16_3_8() { return cGroup_16_3_8; }

		//","
		public Keyword getCommaKeyword_16_3_8_0() { return cCommaKeyword_16_3_8_0; }

		//update+=Expression
		public Assignment getUpdateAssignment_16_3_8_1() { return cUpdateAssignment_16_3_8_1; }

		//Expression
		public RuleCall getUpdateExpressionParserRuleCall_16_3_8_1_0() { return cUpdateExpressionParserRuleCall_16_3_8_1_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_16_3_9() { return cLessThanSignSolidusKeyword_16_3_9; }

		//"label"
		public Keyword getLabelKeyword_16_3_10() { return cLabelKeyword_16_3_10; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_3_11() { return cGreaterThanSignKeyword_16_3_11; }

		//("<" "label" "kind" "=" "\"select\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
		//selection+=Selection ("," selection+=Selection)* "</" "label" ">")?
		public Group getGroup_16_4() { return cGroup_16_4; }

		//"<"
		public Keyword getLessThanSignKeyword_16_4_0() { return cLessThanSignKeyword_16_4_0; }

		//"label"
		public Keyword getLabelKeyword_16_4_1() { return cLabelKeyword_16_4_1; }

		//"kind"
		public Keyword getKindKeyword_16_4_2() { return cKindKeyword_16_4_2; }

		//"="
		public Keyword getEqualsSignKeyword_16_4_3() { return cEqualsSignKeyword_16_4_3; }

		//"\"select\""
		public Keyword getSelectKeyword_16_4_4() { return cSelectKeyword_16_4_4; }

		//("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?
		public UnorderedGroup getUnorderedGroup_16_4_5() { return cUnorderedGroup_16_4_5; }

		//("x" "=" STRING)?
		public Group getGroup_16_4_5_0() { return cGroup_16_4_5_0; }

		//"x"
		public Keyword getXKeyword_16_4_5_0_0() { return cXKeyword_16_4_5_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_4_5_0_1() { return cEqualsSignKeyword_16_4_5_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_4_5_0_2() { return cSTRINGTerminalRuleCall_16_4_5_0_2; }

		//("y" "=" STRING)?
		public Group getGroup_16_4_5_1() { return cGroup_16_4_5_1; }

		//"y"
		public Keyword getYKeyword_16_4_5_1_0() { return cYKeyword_16_4_5_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_4_5_1_1() { return cEqualsSignKeyword_16_4_5_1_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_4_5_1_2() { return cSTRINGTerminalRuleCall_16_4_5_1_2; }

		//("color" "=" STRING)?
		public Group getGroup_16_4_5_2() { return cGroup_16_4_5_2; }

		//"color"
		public Keyword getColorKeyword_16_4_5_2_0() { return cColorKeyword_16_4_5_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_16_4_5_2_1() { return cEqualsSignKeyword_16_4_5_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_16_4_5_2_2() { return cSTRINGTerminalRuleCall_16_4_5_2_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_4_6() { return cGreaterThanSignKeyword_16_4_6; }

		//selection+=Selection
		public Assignment getSelectionAssignment_16_4_7() { return cSelectionAssignment_16_4_7; }

		//Selection
		public RuleCall getSelectionSelectionParserRuleCall_16_4_7_0() { return cSelectionSelectionParserRuleCall_16_4_7_0; }

		//("," selection+=Selection)*
		public Group getGroup_16_4_8() { return cGroup_16_4_8; }

		//","
		public Keyword getCommaKeyword_16_4_8_0() { return cCommaKeyword_16_4_8_0; }

		//selection+=Selection
		public Assignment getSelectionAssignment_16_4_8_1() { return cSelectionAssignment_16_4_8_1; }

		//Selection
		public RuleCall getSelectionSelectionParserRuleCall_16_4_8_1_0() { return cSelectionSelectionParserRuleCall_16_4_8_1_0; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword_16_4_9() { return cLessThanSignSolidusKeyword_16_4_9; }

		//"label"
		public Keyword getLabelKeyword_16_4_10() { return cLabelKeyword_16_4_10; }

		//">"
		public Keyword getGreaterThanSignKeyword_16_4_11() { return cGreaterThanSignKeyword_16_4_11; }

		//("<" "nail" bendPoint+=Point "/>")*
		public Group getGroup_17() { return cGroup_17; }

		//"<"
		public Keyword getLessThanSignKeyword_17_0() { return cLessThanSignKeyword_17_0; }

		//"nail"
		public Keyword getNailKeyword_17_1() { return cNailKeyword_17_1; }

		//bendPoint+=Point
		public Assignment getBendPointAssignment_17_2() { return cBendPointAssignment_17_2; }

		//Point
		public RuleCall getBendPointPointParserRuleCall_17_2_0() { return cBendPointPointParserRuleCall_17_2_0; }

		//"/>"
		public Keyword getSolidusGreaterThanSignKeyword_17_3() { return cSolidusGreaterThanSignKeyword_17_3; }

		//// Close the tag.
		//"</"
		public Keyword getLessThanSignSolidusKeyword_18() { return cLessThanSignSolidusKeyword_18; }

		//"transition"
		public Keyword getTransitionKeyword_19() { return cTransitionKeyword_19; }

		//">"
		public Keyword getGreaterThanSignKeyword_20() { return cGreaterThanSignKeyword_20; }
	}

	public class CommentLabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CommentLabel");
		private final RuleCall cANY_TOKEN_BUT_XML_CLOSEParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//CommentLabel returns ecore::EString hidden(WS):
		//	ANY_TOKEN_BUT_XML_CLOSE*;
		public ParserRule getRule() { return rule; }

		//ANY_TOKEN_BUT_XML_CLOSE*
		public RuleCall getANY_TOKEN_BUT_XML_CLOSEParserRuleCall() { return cANY_TOKEN_BUT_XML_CLOSEParserRuleCall; }
	}

	public class SynchronizationLabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SynchronizationLabel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cChannelExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cChannelExpressionIdentifierExpressionParserRuleCall_0_0 = (RuleCall)cChannelExpressionAssignment_0.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKindSynchronizationKindEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		
		//SynchronizationLabel returns templates::Synchronization hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
		//	channelExpression=IdentifierExpression kind=SynchronizationKind;
		public ParserRule getRule() { return rule; }

		//channelExpression=IdentifierExpression kind=SynchronizationKind
		public Group getGroup() { return cGroup; }

		//channelExpression=IdentifierExpression
		public Assignment getChannelExpressionAssignment_0() { return cChannelExpressionAssignment_0; }

		//IdentifierExpression
		public RuleCall getChannelExpressionIdentifierExpressionParserRuleCall_0_0() { return cChannelExpressionIdentifierExpressionParserRuleCall_0_0; }

		//kind=SynchronizationKind
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//SynchronizationKind
		public RuleCall getKindSynchronizationKindEnumRuleCall_1_0() { return cKindSynchronizationKindEnumRuleCall_1_0; }
	}

	public class PointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Point");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPointAction_0 = (Action)cGroup.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_1 = (UnorderedGroup)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cUnorderedGroup_1.eContents().get(0);
		private final Keyword cXKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cXAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cXQUOTED_INTParserRuleCall_1_0_2_0 = (RuleCall)cXAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cUnorderedGroup_1.eContents().get(1);
		private final Keyword cYKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cYAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cYQUOTED_INTParserRuleCall_1_1_2_0 = (RuleCall)cYAssignment_1_1_2.eContents().get(0);
		
		//Point returns visuals::Point:
		//	{visuals::Point} (("x" "=" x=QUOTED_INT)? & ("y" "=" y=QUOTED_INT)?);
		public ParserRule getRule() { return rule; }

		//{visuals::Point} (("x" "=" x=QUOTED_INT)? & ("y" "=" y=QUOTED_INT)?)
		public Group getGroup() { return cGroup; }

		//{visuals::Point}
		public Action getPointAction_0() { return cPointAction_0; }

		//("x" "=" x=QUOTED_INT)? & ("y" "=" y=QUOTED_INT)?
		public UnorderedGroup getUnorderedGroup_1() { return cUnorderedGroup_1; }

		//("x" "=" x=QUOTED_INT)?
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"x"
		public Keyword getXKeyword_1_0_0() { return cXKeyword_1_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_0_1() { return cEqualsSignKeyword_1_0_1; }

		//x=QUOTED_INT
		public Assignment getXAssignment_1_0_2() { return cXAssignment_1_0_2; }

		//QUOTED_INT
		public RuleCall getXQUOTED_INTParserRuleCall_1_0_2_0() { return cXQUOTED_INTParserRuleCall_1_0_2_0; }

		//("y" "=" y=QUOTED_INT)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"y"
		public Keyword getYKeyword_1_1_0() { return cYKeyword_1_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_1_1() { return cEqualsSignKeyword_1_1_1; }

		//y=QUOTED_INT
		public Assignment getYAssignment_1_1_2() { return cYAssignment_1_1_2; }

		//QUOTED_INT
		public RuleCall getYQUOTED_INTParserRuleCall_1_1_2_0() { return cYQUOTED_INTParserRuleCall_1_1_2_0; }
	}

	public class SelectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Selection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cElementsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cElementsVariableNameOnlyParserRuleCall_0_0 = (RuleCall)cElementsAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeDefinitionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cTypeDefinitionAlternatives_2_0 = (Alternatives)cTypeDefinitionAssignment_2.eContents().get(0);
		private final RuleCall cTypeDefinitionRangeTypeSpecificationParserRuleCall_2_0_0 = (RuleCall)cTypeDefinitionAlternatives_2_0.eContents().get(0);
		private final RuleCall cTypeDefinitionScalarTypeSpecificationParserRuleCall_2_0_1 = (RuleCall)cTypeDefinitionAlternatives_2_0.eContents().get(1);
		private final RuleCall cTypeDefinitionSimpleIdentifierExpressionParserRuleCall_2_0_2 = (RuleCall)cTypeDefinitionAlternatives_2_0.eContents().get(2);
		
		//Selection returns templates::Selection hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
		//	elements+=VariableNameOnly ":" typeDefinition=(RangeTypeSpecification | ScalarTypeSpecification |
		//	SimpleIdentifierExpression);
		public ParserRule getRule() { return rule; }

		//elements+=VariableNameOnly ":" typeDefinition=(RangeTypeSpecification | ScalarTypeSpecification |
		//SimpleIdentifierExpression)
		public Group getGroup() { return cGroup; }

		//elements+=VariableNameOnly
		public Assignment getElementsAssignment_0() { return cElementsAssignment_0; }

		//VariableNameOnly
		public RuleCall getElementsVariableNameOnlyParserRuleCall_0_0() { return cElementsVariableNameOnlyParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//typeDefinition=(RangeTypeSpecification | ScalarTypeSpecification | SimpleIdentifierExpression)
		public Assignment getTypeDefinitionAssignment_2() { return cTypeDefinitionAssignment_2; }

		//RangeTypeSpecification | ScalarTypeSpecification | SimpleIdentifierExpression
		public Alternatives getTypeDefinitionAlternatives_2_0() { return cTypeDefinitionAlternatives_2_0; }

		//RangeTypeSpecification
		public RuleCall getTypeDefinitionRangeTypeSpecificationParserRuleCall_2_0_0() { return cTypeDefinitionRangeTypeSpecificationParserRuleCall_2_0_0; }

		//ScalarTypeSpecification
		public RuleCall getTypeDefinitionScalarTypeSpecificationParserRuleCall_2_0_1() { return cTypeDefinitionScalarTypeSpecificationParserRuleCall_2_0_1; }

		//SimpleIdentifierExpression
		public RuleCall getTypeDefinitionSimpleIdentifierExpressionParserRuleCall_2_0_2() { return cTypeDefinitionSimpleIdentifierExpressionParserRuleCall_2_0_2; }
	}

	public class GlobalDeclarationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GlobalDeclarations");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGlobalDeclarationsAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cDeclarationAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Alternatives cDeclarationAlternatives_1_0_0 = (Alternatives)cDeclarationAssignment_1_0.eContents().get(0);
		private final RuleCall cDeclarationTypedDeclarationParserRuleCall_1_0_0_0 = (RuleCall)cDeclarationAlternatives_1_0_0.eContents().get(0);
		private final RuleCall cDeclarationTypeDeclarationParserRuleCall_1_0_0_1 = (RuleCall)cDeclarationAlternatives_1_0_0.eContents().get(1);
		private final Assignment cChannelPriorityAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cChannelPriorityChannelPriorityDeclarationParserRuleCall_1_1_0 = (RuleCall)cChannelPriorityAssignment_1_1.eContents().get(0);
		
		////---------------------------------------------------------------------------------------------------------------------------------
		//// DECLARATIONS & TYPES
		////---------------------------------------------------------------------------------------------------------------------------------
		//GlobalDeclarations returns declarations::GlobalDeclarations hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
		//	{declarations::GlobalDeclarations} (declaration+=(TypedDeclaration | TypeDeclaration) | // Problem: Channel priority is only allowed once by UPPAAL. So it is only
		//	// overwritten and the rule allows more input than UPPAAL normally would.
		//	channelPriority=ChannelPriorityDeclaration)*;
		public ParserRule getRule() { return rule; }

		//{declarations::GlobalDeclarations} (declaration+=(TypedDeclaration | TypeDeclaration) | // Problem: Channel priority is only allowed once by UPPAAL. So it is only
		//// overwritten and the rule allows more input than UPPAAL normally would.
		//channelPriority=ChannelPriorityDeclaration)*
		public Group getGroup() { return cGroup; }

		//{declarations::GlobalDeclarations}
		public Action getGlobalDeclarationsAction_0() { return cGlobalDeclarationsAction_0; }

		//(declaration+=(TypedDeclaration | TypeDeclaration) | // Problem: Channel priority is only allowed once by UPPAAL. So it is only
		//// overwritten and the rule allows more input than UPPAAL normally would.
		//channelPriority=ChannelPriorityDeclaration)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//declaration+=(TypedDeclaration | TypeDeclaration)
		public Assignment getDeclarationAssignment_1_0() { return cDeclarationAssignment_1_0; }

		//TypedDeclaration | TypeDeclaration
		public Alternatives getDeclarationAlternatives_1_0_0() { return cDeclarationAlternatives_1_0_0; }

		//TypedDeclaration
		public RuleCall getDeclarationTypedDeclarationParserRuleCall_1_0_0_0() { return cDeclarationTypedDeclarationParserRuleCall_1_0_0_0; }

		//TypeDeclaration
		public RuleCall getDeclarationTypeDeclarationParserRuleCall_1_0_0_1() { return cDeclarationTypeDeclarationParserRuleCall_1_0_0_1; }

		//// Problem: Channel priority is only allowed once by UPPAAL. So it is only
		//// overwritten and the rule allows more input than UPPAAL normally would.
		//channelPriority=ChannelPriorityDeclaration
		public Assignment getChannelPriorityAssignment_1_1() { return cChannelPriorityAssignment_1_1; }

		//ChannelPriorityDeclaration
		public RuleCall getChannelPriorityChannelPriorityDeclarationParserRuleCall_1_1_0() { return cChannelPriorityChannelPriorityDeclarationParserRuleCall_1_1_0; }
	}

	public class LocalDeclarationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalDeclarations");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLocalDeclarationsAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cDeclarationAlternatives_1_0 = (Alternatives)cDeclarationAssignment_1.eContents().get(0);
		private final RuleCall cDeclarationTypedDeclarationParserRuleCall_1_0_0 = (RuleCall)cDeclarationAlternatives_1_0.eContents().get(0);
		private final RuleCall cDeclarationTypeDeclarationParserRuleCall_1_0_1 = (RuleCall)cDeclarationAlternatives_1_0.eContents().get(1);
		
		//LocalDeclarations returns declarations::LocalDeclarations hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
		//	{declarations::LocalDeclarations} declaration+=(TypedDeclaration | TypeDeclaration)*;
		public ParserRule getRule() { return rule; }

		//{declarations::LocalDeclarations} declaration+=(TypedDeclaration | TypeDeclaration)*
		public Group getGroup() { return cGroup; }

		//{declarations::LocalDeclarations}
		public Action getLocalDeclarationsAction_0() { return cLocalDeclarationsAction_0; }

		//declaration+=(TypedDeclaration | TypeDeclaration)*
		public Assignment getDeclarationAssignment_1() { return cDeclarationAssignment_1; }

		//TypedDeclaration | TypeDeclaration
		public Alternatives getDeclarationAlternatives_1_0() { return cDeclarationAlternatives_1_0; }

		//TypedDeclaration
		public RuleCall getDeclarationTypedDeclarationParserRuleCall_1_0_0() { return cDeclarationTypedDeclarationParserRuleCall_1_0_0; }

		//TypeDeclaration
		public RuleCall getDeclarationTypeDeclarationParserRuleCall_1_0_1() { return cDeclarationTypeDeclarationParserRuleCall_1_0_1; }
	}

	public class SystemDeclarationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SystemDeclarations");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSystemDeclarationsAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cDeclarationAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Alternatives cDeclarationAlternatives_1_0_0 = (Alternatives)cDeclarationAssignment_1_0.eContents().get(0);
		private final RuleCall cDeclarationTypedDeclarationParserRuleCall_1_0_0_0 = (RuleCall)cDeclarationAlternatives_1_0_0.eContents().get(0);
		private final RuleCall cDeclarationTypeDeclarationParserRuleCall_1_0_0_1 = (RuleCall)cDeclarationAlternatives_1_0_0.eContents().get(1);
		private final RuleCall cDeclarationTemplateDeclarationParserRuleCall_1_0_0_2 = (RuleCall)cDeclarationAlternatives_1_0_0.eContents().get(2);
		private final Assignment cSystemAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cSystemSystemParserRuleCall_1_1_0 = (RuleCall)cSystemAssignment_1_1.eContents().get(0);
		private final Assignment cProgressMeasureAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final RuleCall cProgressMeasureProgressMeasureParserRuleCall_1_2_0 = (RuleCall)cProgressMeasureAssignment_1_2.eContents().get(0);
		
		//SystemDeclarations returns declarations::SystemDeclarations hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
		//	{declarations::SystemDeclarations} (declaration+=(TypedDeclaration | TypeDeclaration | TemplateDeclaration) | // Same problem as with the ChannelPriority above.
		//	system=System | progressMeasure=ProgressMeasure)*;
		public ParserRule getRule() { return rule; }

		//{declarations::SystemDeclarations} (declaration+=(TypedDeclaration | TypeDeclaration | TemplateDeclaration) | // Same problem as with the ChannelPriority above.
		//system=System | progressMeasure=ProgressMeasure)*
		public Group getGroup() { return cGroup; }

		//{declarations::SystemDeclarations}
		public Action getSystemDeclarationsAction_0() { return cSystemDeclarationsAction_0; }

		//(declaration+=(TypedDeclaration | TypeDeclaration | TemplateDeclaration) | // Same problem as with the ChannelPriority above.
		//system=System | progressMeasure=ProgressMeasure)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//declaration+=(TypedDeclaration | TypeDeclaration | TemplateDeclaration)
		public Assignment getDeclarationAssignment_1_0() { return cDeclarationAssignment_1_0; }

		//TypedDeclaration | TypeDeclaration | TemplateDeclaration
		public Alternatives getDeclarationAlternatives_1_0_0() { return cDeclarationAlternatives_1_0_0; }

		//TypedDeclaration
		public RuleCall getDeclarationTypedDeclarationParserRuleCall_1_0_0_0() { return cDeclarationTypedDeclarationParserRuleCall_1_0_0_0; }

		//TypeDeclaration
		public RuleCall getDeclarationTypeDeclarationParserRuleCall_1_0_0_1() { return cDeclarationTypeDeclarationParserRuleCall_1_0_0_1; }

		//TemplateDeclaration
		public RuleCall getDeclarationTemplateDeclarationParserRuleCall_1_0_0_2() { return cDeclarationTemplateDeclarationParserRuleCall_1_0_0_2; }

		//// Same problem as with the ChannelPriority above.
		//system=System
		public Assignment getSystemAssignment_1_1() { return cSystemAssignment_1_1; }

		//System
		public RuleCall getSystemSystemParserRuleCall_1_1_0() { return cSystemSystemParserRuleCall_1_1_0; }

		//progressMeasure=ProgressMeasure
		public Assignment getProgressMeasureAssignment_1_2() { return cProgressMeasureAssignment_1_2; }

		//ProgressMeasure
		public RuleCall getProgressMeasureProgressMeasureParserRuleCall_1_2_0() { return cProgressMeasureProgressMeasureParserRuleCall_1_2_0; }
	}

	public class ProgressMeasureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProgressMeasure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProgressKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0_0 = (RuleCall)cExpressionAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ProgressMeasure returns system::ProgressMeasure:
		//	"progress" "{" (expression+=Expression ";")+ "}";
		public ParserRule getRule() { return rule; }

		//"progress" "{" (expression+=Expression ";")+ "}"
		public Group getGroup() { return cGroup; }

		//"progress"
		public Keyword getProgressKeyword_0() { return cProgressKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(expression+=Expression ";")+
		public Group getGroup_2() { return cGroup_2; }

		//expression+=Expression
		public Assignment getExpressionAssignment_2_0() { return cExpressionAssignment_2_0; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0_0() { return cExpressionExpressionParserRuleCall_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class TemplateDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TemplateDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeclaredTemplateAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeclaredTemplateRedefinedTemplateParserRuleCall_0_0 = (RuleCall)cDeclaredTemplateAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgumentAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgumentExpressionParserRuleCall_2_0_0 = (RuleCall)cArgumentAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgumentAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgumentExpressionParserRuleCall_2_1_1_0 = (RuleCall)cArgumentAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TemplateDeclaration returns system::TemplateDeclaration:
		//	declaredTemplate=RedefinedTemplate "(" (argument+=Expression ("," argument+=Expression)*)? ")" ";";
		public ParserRule getRule() { return rule; }

		//declaredTemplate=RedefinedTemplate "(" (argument+=Expression ("," argument+=Expression)*)? ")" ";"
		public Group getGroup() { return cGroup; }

		//declaredTemplate=RedefinedTemplate
		public Assignment getDeclaredTemplateAssignment_0() { return cDeclaredTemplateAssignment_0; }

		//RedefinedTemplate
		public RuleCall getDeclaredTemplateRedefinedTemplateParserRuleCall_0_0() { return cDeclaredTemplateRedefinedTemplateParserRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(argument+=Expression ("," argument+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }

		//argument+=Expression
		public Assignment getArgumentAssignment_2_0() { return cArgumentAssignment_2_0; }

		//Expression
		public RuleCall getArgumentExpressionParserRuleCall_2_0_0() { return cArgumentExpressionParserRuleCall_2_0_0; }

		//("," argument+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//argument+=Expression
		public Assignment getArgumentAssignment_2_1_1() { return cArgumentAssignment_2_1_1; }

		//Expression
		public RuleCall getArgumentExpressionParserRuleCall_2_1_1_0() { return cArgumentExpressionParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class RedefinedTemplateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RedefinedTemplate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUPPAAL_IDENTIFIERParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cReferredTemplateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cReferredTemplateTemplateCrossReference_2_0 = (CrossReference)cReferredTemplateAssignment_2.eContents().get(0);
		private final RuleCall cReferredTemplateTemplateIDTerminalRuleCall_2_0_1 = (RuleCall)cReferredTemplateTemplateCrossReference_2_0.eContents().get(1);
		
		//RedefinedTemplate returns templates::RedefinedTemplate:
		//	name=UPPAAL_IDENTIFIER "=" referredTemplate=[templates::Template];
		public ParserRule getRule() { return rule; }

		//name=UPPAAL_IDENTIFIER "=" referredTemplate=[templates::Template]
		public Group getGroup() { return cGroup; }

		//name=UPPAAL_IDENTIFIER
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UPPAAL_IDENTIFIER
		public RuleCall getNameUPPAAL_IDENTIFIERParserRuleCall_0_0() { return cNameUPPAAL_IDENTIFIERParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//referredTemplate=[templates::Template]
		public Assignment getReferredTemplateAssignment_2() { return cReferredTemplateAssignment_2; }

		//[templates::Template]
		public CrossReference getReferredTemplateTemplateCrossReference_2_0() { return cReferredTemplateTemplateCrossReference_2_0; }

		//ID
		public RuleCall getReferredTemplateTemplateIDTerminalRuleCall_2_0_1() { return cReferredTemplateTemplateIDTerminalRuleCall_2_0_1; }
	}

	public class SystemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "System");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSystemKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInstantiationListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInstantiationListInstantiationListParserRuleCall_1_0 = (RuleCall)cInstantiationListAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLtKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInstantiationListAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInstantiationListInstantiationListParserRuleCall_2_1_0 = (RuleCall)cInstantiationListAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//System returns system::System:
		//	"system" instantiationList+=InstantiationList ("&lt;" instantiationList+=InstantiationList)* ";";
		public ParserRule getRule() { return rule; }

		//"system" instantiationList+=InstantiationList ("&lt;" instantiationList+=InstantiationList)* ";"
		public Group getGroup() { return cGroup; }

		//"system"
		public Keyword getSystemKeyword_0() { return cSystemKeyword_0; }

		//instantiationList+=InstantiationList
		public Assignment getInstantiationListAssignment_1() { return cInstantiationListAssignment_1; }

		//InstantiationList
		public RuleCall getInstantiationListInstantiationListParserRuleCall_1_0() { return cInstantiationListInstantiationListParserRuleCall_1_0; }

		//("&lt;" instantiationList+=InstantiationList)*
		public Group getGroup_2() { return cGroup_2; }

		//"&lt;"
		public Keyword getLtKeyword_2_0() { return cLtKeyword_2_0; }

		//instantiationList+=InstantiationList
		public Assignment getInstantiationListAssignment_2_1() { return cInstantiationListAssignment_2_1; }

		//InstantiationList
		public RuleCall getInstantiationListInstantiationListParserRuleCall_2_1_0() { return cInstantiationListInstantiationListParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class InstantiationListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstantiationList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTemplateAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTemplateAbstractTemplateCrossReference_0_0 = (CrossReference)cTemplateAssignment_0.eContents().get(0);
		private final RuleCall cTemplateAbstractTemplateUPPAAL_IDENTIFIERParserRuleCall_0_0_1 = (RuleCall)cTemplateAbstractTemplateCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTemplateAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cTemplateAbstractTemplateCrossReference_1_1_0 = (CrossReference)cTemplateAssignment_1_1.eContents().get(0);
		private final RuleCall cTemplateAbstractTemplateUPPAAL_IDENTIFIERParserRuleCall_1_1_0_1 = (RuleCall)cTemplateAbstractTemplateCrossReference_1_1_0.eContents().get(1);
		
		//InstantiationList returns system::InstantiationList:
		//	template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER] (","
		//	template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER])*;
		public ParserRule getRule() { return rule; }

		//template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER] (","
		//template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER])*
		public Group getGroup() { return cGroup; }

		//template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER]
		public Assignment getTemplateAssignment_0() { return cTemplateAssignment_0; }

		//[templates::AbstractTemplate|UPPAAL_IDENTIFIER]
		public CrossReference getTemplateAbstractTemplateCrossReference_0_0() { return cTemplateAbstractTemplateCrossReference_0_0; }

		//UPPAAL_IDENTIFIER
		public RuleCall getTemplateAbstractTemplateUPPAAL_IDENTIFIERParserRuleCall_0_0_1() { return cTemplateAbstractTemplateUPPAAL_IDENTIFIERParserRuleCall_0_0_1; }

		//("," template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER])*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER]
		public Assignment getTemplateAssignment_1_1() { return cTemplateAssignment_1_1; }

		//[templates::AbstractTemplate|UPPAAL_IDENTIFIER]
		public CrossReference getTemplateAbstractTemplateCrossReference_1_1_0() { return cTemplateAbstractTemplateCrossReference_1_1_0; }

		//UPPAAL_IDENTIFIER
		public RuleCall getTemplateAbstractTemplateUPPAAL_IDENTIFIERParserRuleCall_1_1_0_1() { return cTemplateAbstractTemplateUPPAAL_IDENTIFIERParserRuleCall_1_1_0_1; }
	}

	public class TypedDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeDefinitionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeDefinitionTypeExpressionParserRuleCall_0_0 = (RuleCall)cTypeDefinitionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cElementsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cElementsFunctionParserRuleCall_1_0_0 = (RuleCall)cElementsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cElementsAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cElementsVariableParserRuleCall_1_1_0_0 = (RuleCall)cElementsAssignment_1_1_0.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cElementsAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cElementsVariableParserRuleCall_1_1_1_1_0 = (RuleCall)cElementsAssignment_1_1_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		
		//TypedDeclaration returns declarations::TypedDeclaration:
		//	typeDefinition=TypeExpression (elements+=Function | elements+=Variable ("," elements+=Variable)* ";");
		public ParserRule getRule() { return rule; }

		//typeDefinition=TypeExpression (elements+=Function | elements+=Variable ("," elements+=Variable)* ";")
		public Group getGroup() { return cGroup; }

		//typeDefinition=TypeExpression
		public Assignment getTypeDefinitionAssignment_0() { return cTypeDefinitionAssignment_0; }

		//TypeExpression
		public RuleCall getTypeDefinitionTypeExpressionParserRuleCall_0_0() { return cTypeDefinitionTypeExpressionParserRuleCall_0_0; }

		//elements+=Function | elements+=Variable ("," elements+=Variable)* ";"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//elements+=Function
		public Assignment getElementsAssignment_1_0() { return cElementsAssignment_1_0; }

		//Function
		public RuleCall getElementsFunctionParserRuleCall_1_0_0() { return cElementsFunctionParserRuleCall_1_0_0; }

		//elements+=Variable ("," elements+=Variable)* ";"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//elements+=Variable
		public Assignment getElementsAssignment_1_1_0() { return cElementsAssignment_1_1_0; }

		//Variable
		public RuleCall getElementsVariableParserRuleCall_1_1_0_0() { return cElementsVariableParserRuleCall_1_1_0_0; }

		//("," elements+=Variable)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }

		//elements+=Variable
		public Assignment getElementsAssignment_1_1_1_1() { return cElementsAssignment_1_1_1_1; }

		//Variable
		public RuleCall getElementsVariableParserRuleCall_1_1_1_1_0() { return cElementsVariableParserRuleCall_1_1_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1_2() { return cSemicolonKeyword_1_1_2; }
	}

	public class TypedElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeDefinitionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeDefinitionTypeExpressionParserRuleCall_0_0 = (RuleCall)cTypeDefinitionAssignment_0.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsVariableParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cElementsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cElementsVariableParserRuleCall_2_1_0 = (RuleCall)cElementsAssignment_2_1.eContents().get(0);
		
		//TypedElement returns declarations::TypedDeclaration: //	ChannelVariableDeclaration | ClockVariableDeclaration | DataVariableDeclaration
		////(prefix=DataVariablePrefix)? 
		//	typeDefinition=TypeExpression elements+=Variable ("," elements+=Variable)*;
		public ParserRule getRule() { return rule; }

		////	ChannelVariableDeclaration | ClockVariableDeclaration | DataVariableDeclaration
		////(prefix=DataVariablePrefix)? 
		//typeDefinition=TypeExpression elements+=Variable ("," elements+=Variable)*
		public Group getGroup() { return cGroup; }

		////	ChannelVariableDeclaration | ClockVariableDeclaration | DataVariableDeclaration
		////(prefix=DataVariablePrefix)? 
		//typeDefinition=TypeExpression
		public Assignment getTypeDefinitionAssignment_0() { return cTypeDefinitionAssignment_0; }

		//TypeExpression
		public RuleCall getTypeDefinitionTypeExpressionParserRuleCall_0_0() { return cTypeDefinitionTypeExpressionParserRuleCall_0_0; }

		//elements+=Variable
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//Variable
		public RuleCall getElementsVariableParserRuleCall_1_0() { return cElementsVariableParserRuleCall_1_0; }

		//("," elements+=Variable)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//elements+=Variable
		public Assignment getElementsAssignment_2_1() { return cElementsAssignment_2_1; }

		//Variable
		public RuleCall getElementsVariableParserRuleCall_2_1_0() { return cElementsVariableParserRuleCall_2_1_0; }
	}

	public class VariableNameOnlyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableNameOnly");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPAAL_IDENTIFIERParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VariableNameOnly returns declarations::Variable:
		//	name=UPPAAL_IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//name=UPPAAL_IDENTIFIER
		public Assignment getNameAssignment() { return cNameAssignment; }

		//UPPAAL_IDENTIFIER
		public RuleCall getNameUPPAAL_IDENTIFIERParserRuleCall_0() { return cNameUPPAAL_IDENTIFIERParserRuleCall_0; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUPPAAL_IDENTIFIERParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIndexAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cIndexAlternatives_1_1_0 = (Alternatives)cIndexAssignment_1_1.eContents().get(0);
		private final RuleCall cIndexExpressionParserRuleCall_1_1_0_0 = (RuleCall)cIndexAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cIndexScalarTypeSpecificationParserRuleCall_1_1_0_1 = (RuleCall)cIndexAlternatives_1_1_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInitializerAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitializerInitializerParserRuleCall_2_1_0 = (RuleCall)cInitializerAssignment_2_1.eContents().get(0);
		
		//Variable returns declarations::Variable:
		//	name=UPPAAL_IDENTIFIER // Problem:
		//	// TypeIndex can be a reference to a Type
		//	//   [types::Type|TYPE_REFERENCE]
		//	// while ValueIndex might be a reference to a variable
		//	//   [core::NamedElement|UPPAAL_IDENTIFIER]
		//	// These two rules collide as TYPE_REFERENCE and UPPAAL_IDENTIFIER
		//	// might be ID. In that case we want a Type, though, as references
		//	// to variables are not even allowed here.
		//	// The syntactic predicate => tells ANTLR to favour the first rule.
		//	("[" index+=(Expression | ScalarTypeSpecification) "]")* ("=" initializer=Initializer)?;
		public ParserRule getRule() { return rule; }

		//name=UPPAAL_IDENTIFIER // Problem:
		//// TypeIndex can be a reference to a Type
		////   [types::Type|TYPE_REFERENCE]
		//// while ValueIndex might be a reference to a variable
		////   [core::NamedElement|UPPAAL_IDENTIFIER]
		//// These two rules collide as TYPE_REFERENCE and UPPAAL_IDENTIFIER
		//// might be ID. In that case we want a Type, though, as references
		//// to variables are not even allowed here.
		//// The syntactic predicate => tells ANTLR to favour the first rule.
		//("[" index+=(Expression | ScalarTypeSpecification) "]")* ("=" initializer=Initializer)?
		public Group getGroup() { return cGroup; }

		//name=UPPAAL_IDENTIFIER
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UPPAAL_IDENTIFIER
		public RuleCall getNameUPPAAL_IDENTIFIERParserRuleCall_0_0() { return cNameUPPAAL_IDENTIFIERParserRuleCall_0_0; }

		//("[" index+=(Expression | ScalarTypeSpecification) "]")*
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//index+=(Expression | ScalarTypeSpecification)
		public Assignment getIndexAssignment_1_1() { return cIndexAssignment_1_1; }

		//Expression | ScalarTypeSpecification
		public Alternatives getIndexAlternatives_1_1_0() { return cIndexAlternatives_1_1_0; }

		//Expression
		public RuleCall getIndexExpressionParserRuleCall_1_1_0_0() { return cIndexExpressionParserRuleCall_1_1_0_0; }

		//ScalarTypeSpecification
		public RuleCall getIndexScalarTypeSpecificationParserRuleCall_1_1_0_1() { return cIndexScalarTypeSpecificationParserRuleCall_1_1_0_1; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }

		//("=" initializer=Initializer)?
		public Group getGroup_2() { return cGroup_2; }

		//"="
		public Keyword getEqualsSignKeyword_2_0() { return cEqualsSignKeyword_2_0; }

		//initializer=Initializer
		public Assignment getInitializerAssignment_2_1() { return cInitializerAssignment_2_1; }

		//Initializer
		public RuleCall getInitializerInitializerParserRuleCall_2_1_0() { return cInitializerInitializerParserRuleCall_2_1_0; }
	}

	public class InitializerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Initializer");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrayInitializerParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionInitializerParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Initializer returns declarations::Initializer:
		//	ArrayInitializer | ExpressionInitializer;
		public ParserRule getRule() { return rule; }

		//ArrayInitializer | ExpressionInitializer
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrayInitializer
		public RuleCall getArrayInitializerParserRuleCall_0() { return cArrayInitializerParserRuleCall_0; }

		//ExpressionInitializer
		public RuleCall getExpressionInitializerParserRuleCall_1() { return cExpressionInitializerParserRuleCall_1; }
	}

	public class ExpressionInitializerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionInitializer");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		//ExpressionInitializer returns declarations::ExpressionInitializer:
		//	expression=Expression;
		public ParserRule getRule() { return rule; }

		//expression=Expression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0() { return cExpressionExpressionParserRuleCall_0; }
	}

	public class ArrayInitializerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayInitializer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInitializerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInitializerInitializerParserRuleCall_1_0 = (RuleCall)cInitializerAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInitializerAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitializerInitializerParserRuleCall_2_1_0 = (RuleCall)cInitializerAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ArrayInitializer returns declarations::ArrayInitializer:
		//	"{" initializer+=Initializer ("," initializer+=Initializer)* "}";
		public ParserRule getRule() { return rule; }

		//"{" initializer+=Initializer ("," initializer+=Initializer)* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//initializer+=Initializer
		public Assignment getInitializerAssignment_1() { return cInitializerAssignment_1; }

		//Initializer
		public RuleCall getInitializerInitializerParserRuleCall_1_0() { return cInitializerInitializerParserRuleCall_1_0; }

		//("," initializer+=Initializer)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//initializer+=Initializer
		public Assignment getInitializerAssignment_2_1() { return cInitializerAssignment_2_1; }

		//Initializer
		public RuleCall getInitializerInitializerParserRuleCall_2_1_0() { return cInitializerInitializerParserRuleCall_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class TypeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRangeTypeSpecificationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cScalarTypeSpecificationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStructTypeSpecificationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSimpleIdentifierExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cChannelPrefixExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDataPrefixExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//TypeExpression returns expressions::Expression:
		//	RangeTypeSpecification | ScalarTypeSpecification | StructTypeSpecification | SimpleIdentifierExpression |
		//	ChannelPrefixExpression | DataPrefixExpression;
		public ParserRule getRule() { return rule; }

		//RangeTypeSpecification | ScalarTypeSpecification | StructTypeSpecification | SimpleIdentifierExpression |
		//ChannelPrefixExpression | DataPrefixExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//RangeTypeSpecification
		public RuleCall getRangeTypeSpecificationParserRuleCall_0() { return cRangeTypeSpecificationParserRuleCall_0; }

		//ScalarTypeSpecification
		public RuleCall getScalarTypeSpecificationParserRuleCall_1() { return cScalarTypeSpecificationParserRuleCall_1; }

		//StructTypeSpecification
		public RuleCall getStructTypeSpecificationParserRuleCall_2() { return cStructTypeSpecificationParserRuleCall_2; }

		//SimpleIdentifierExpression
		public RuleCall getSimpleIdentifierExpressionParserRuleCall_3() { return cSimpleIdentifierExpressionParserRuleCall_3; }

		//ChannelPrefixExpression
		public RuleCall getChannelPrefixExpressionParserRuleCall_4() { return cChannelPrefixExpressionParserRuleCall_4; }

		//DataPrefixExpression
		public RuleCall getDataPrefixExpressionParserRuleCall_5() { return cDataPrefixExpressionParserRuleCall_5; }
	}

	public class ChannelPrefixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelPrefixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Assignment cUrgentAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cUrgentChannelPrefixExpression_UrgentParserRuleCall_0_0_0_0 = (RuleCall)cUrgentAssignment_0_0_0.eContents().get(0);
		private final Assignment cBroadcastAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cBroadcastChannelPrefixExpression_BroadcastParserRuleCall_0_0_1_0 = (RuleCall)cBroadcastAssignment_0_0_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Assignment cBroadcastAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final RuleCall cBroadcastChannelPrefixExpression_BroadcastParserRuleCall_0_1_0_0 = (RuleCall)cBroadcastAssignment_0_1_0.eContents().get(0);
		private final Assignment cUrgentAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cUrgentChannelPrefixExpression_UrgentParserRuleCall_0_1_1_0 = (RuleCall)cUrgentAssignment_0_1_1.eContents().get(0);
		private final Assignment cChannelTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cChannelTypeTypeCrossReference_1_0 = (CrossReference)cChannelTypeAssignment_1.eContents().get(0);
		private final RuleCall cChannelTypeTypeCHAN_KEYWORDParserRuleCall_1_0_1 = (RuleCall)cChannelTypeTypeCrossReference_1_0.eContents().get(1);
		
		//ChannelPrefixExpression returns expressions::ChannelPrefixExpression:
		//	(urgent=ChannelPrefixExpression_Urgent broadcast=ChannelPrefixExpression_Broadcast? // Explanation on the strange construction using the DataType
		//	// rules for urgent and broadcast:
		//	// If 'chan' occurs isolated, a SimpleIdentifierExpression should
		//	// be parsed. So in order for the parser to decide for this rule,
		//	// either 'urgent' or 'broadcast' MUST be consumed. This is not
		//	// possible to do with something like urgent?='urgent' and unordered
		//	// lists. This is why a rule is introduced for these cases and a
		//	// custom value converter returns the appropriate bool value.
		//	| broadcast=ChannelPrefixExpression_Broadcast urgent=ChannelPrefixExpression_Urgent?)
		//	channelType=[types::Type|CHAN_KEYWORD];
		public ParserRule getRule() { return rule; }

		//(urgent=ChannelPrefixExpression_Urgent broadcast=ChannelPrefixExpression_Broadcast? // Explanation on the strange construction using the DataType
		//// rules for urgent and broadcast:
		//// If 'chan' occurs isolated, a SimpleIdentifierExpression should
		//// be parsed. So in order for the parser to decide for this rule,
		//// either 'urgent' or 'broadcast' MUST be consumed. This is not
		//// possible to do with something like urgent?='urgent' and unordered
		//// lists. This is why a rule is introduced for these cases and a
		//// custom value converter returns the appropriate bool value.
		//| broadcast=ChannelPrefixExpression_Broadcast urgent=ChannelPrefixExpression_Urgent?)
		//channelType=[types::Type|CHAN_KEYWORD]
		public Group getGroup() { return cGroup; }

		//urgent=ChannelPrefixExpression_Urgent broadcast=ChannelPrefixExpression_Broadcast? // Explanation on the strange construction using the DataType
		//// rules for urgent and broadcast:
		//// If 'chan' occurs isolated, a SimpleIdentifierExpression should
		//// be parsed. So in order for the parser to decide for this rule,
		//// either 'urgent' or 'broadcast' MUST be consumed. This is not
		//// possible to do with something like urgent?='urgent' and unordered
		//// lists. This is why a rule is introduced for these cases and a
		//// custom value converter returns the appropriate bool value.
		//| broadcast=ChannelPrefixExpression_Broadcast urgent=ChannelPrefixExpression_Urgent?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//urgent=ChannelPrefixExpression_Urgent broadcast=ChannelPrefixExpression_Broadcast?
		public Group getGroup_0_0() { return cGroup_0_0; }

		//urgent=ChannelPrefixExpression_Urgent
		public Assignment getUrgentAssignment_0_0_0() { return cUrgentAssignment_0_0_0; }

		//ChannelPrefixExpression_Urgent
		public RuleCall getUrgentChannelPrefixExpression_UrgentParserRuleCall_0_0_0_0() { return cUrgentChannelPrefixExpression_UrgentParserRuleCall_0_0_0_0; }

		//broadcast=ChannelPrefixExpression_Broadcast?
		public Assignment getBroadcastAssignment_0_0_1() { return cBroadcastAssignment_0_0_1; }

		//ChannelPrefixExpression_Broadcast
		public RuleCall getBroadcastChannelPrefixExpression_BroadcastParserRuleCall_0_0_1_0() { return cBroadcastChannelPrefixExpression_BroadcastParserRuleCall_0_0_1_0; }

		//broadcast=ChannelPrefixExpression_Broadcast urgent=ChannelPrefixExpression_Urgent?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//broadcast=ChannelPrefixExpression_Broadcast
		public Assignment getBroadcastAssignment_0_1_0() { return cBroadcastAssignment_0_1_0; }

		//ChannelPrefixExpression_Broadcast
		public RuleCall getBroadcastChannelPrefixExpression_BroadcastParserRuleCall_0_1_0_0() { return cBroadcastChannelPrefixExpression_BroadcastParserRuleCall_0_1_0_0; }

		//urgent=ChannelPrefixExpression_Urgent?
		public Assignment getUrgentAssignment_0_1_1() { return cUrgentAssignment_0_1_1; }

		//ChannelPrefixExpression_Urgent
		public RuleCall getUrgentChannelPrefixExpression_UrgentParserRuleCall_0_1_1_0() { return cUrgentChannelPrefixExpression_UrgentParserRuleCall_0_1_1_0; }

		//channelType=[types::Type|CHAN_KEYWORD]
		public Assignment getChannelTypeAssignment_1() { return cChannelTypeAssignment_1; }

		//[types::Type|CHAN_KEYWORD]
		public CrossReference getChannelTypeTypeCrossReference_1_0() { return cChannelTypeTypeCrossReference_1_0; }

		//CHAN_KEYWORD
		public RuleCall getChannelTypeTypeCHAN_KEYWORDParserRuleCall_1_0_1() { return cChannelTypeTypeCHAN_KEYWORDParserRuleCall_1_0_1; }
	}

	public class CHAN_KEYWORDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CHAN_KEYWORD");
		private final Keyword cChanKeyword = (Keyword)rule.eContents().get(1);
		
		//CHAN_KEYWORD:
		//	"chan";
		public ParserRule getRule() { return rule; }

		//"chan"
		public Keyword getChanKeyword() { return cChanKeyword; }
	}

	public class ChannelPrefixExpression_UrgentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelPrefixExpression_Urgent");
		private final Keyword cUrgentKeyword = (Keyword)rule.eContents().get(1);
		
		//ChannelPrefixExpression_Urgent returns ecore::EBoolean:
		//	"urgent";
		public ParserRule getRule() { return rule; }

		//"urgent"
		public Keyword getUrgentKeyword() { return cUrgentKeyword; }
	}

	public class ChannelPrefixExpression_BroadcastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelPrefixExpression_Broadcast");
		private final Keyword cBroadcastKeyword = (Keyword)rule.eContents().get(1);
		
		//ChannelPrefixExpression_Broadcast returns ecore::EBoolean:
		//	"broadcast";
		public ParserRule getRule() { return rule; }

		//"broadcast"
		public Keyword getBroadcastKeyword() { return cBroadcastKeyword; }
	}

	public class DataPrefixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DataPrefixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPrefixAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPrefixDataVariablePrefixEnumRuleCall_0_0 = (RuleCall)cPrefixAssignment_0.eContents().get(0);
		private final Assignment cDataTypeExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cDataTypeExpressionAlternatives_1_0 = (Alternatives)cDataTypeExpressionAssignment_1.eContents().get(0);
		private final RuleCall cDataTypeExpressionRangeTypeSpecificationParserRuleCall_1_0_0 = (RuleCall)cDataTypeExpressionAlternatives_1_0.eContents().get(0);
		private final RuleCall cDataTypeExpressionScalarTypeSpecificationParserRuleCall_1_0_1 = (RuleCall)cDataTypeExpressionAlternatives_1_0.eContents().get(1);
		private final RuleCall cDataTypeExpressionStructTypeSpecificationParserRuleCall_1_0_2 = (RuleCall)cDataTypeExpressionAlternatives_1_0.eContents().get(2);
		private final RuleCall cDataTypeExpressionSimpleIdentifierExpressionParserRuleCall_1_0_3 = (RuleCall)cDataTypeExpressionAlternatives_1_0.eContents().get(3);
		
		//DataPrefixExpression returns expressions::DataPrefixExpression:
		//	prefix=DataVariablePrefix dataTypeExpression=(RangeTypeSpecification | ScalarTypeSpecification |
		//	StructTypeSpecification | SimpleIdentifierExpression);
		public ParserRule getRule() { return rule; }

		//prefix=DataVariablePrefix dataTypeExpression=(RangeTypeSpecification | ScalarTypeSpecification | StructTypeSpecification
		//| SimpleIdentifierExpression)
		public Group getGroup() { return cGroup; }

		//prefix=DataVariablePrefix
		public Assignment getPrefixAssignment_0() { return cPrefixAssignment_0; }

		//DataVariablePrefix
		public RuleCall getPrefixDataVariablePrefixEnumRuleCall_0_0() { return cPrefixDataVariablePrefixEnumRuleCall_0_0; }

		//dataTypeExpression=(RangeTypeSpecification | ScalarTypeSpecification | StructTypeSpecification |
		//SimpleIdentifierExpression)
		public Assignment getDataTypeExpressionAssignment_1() { return cDataTypeExpressionAssignment_1; }

		//RangeTypeSpecification | ScalarTypeSpecification | StructTypeSpecification | SimpleIdentifierExpression
		public Alternatives getDataTypeExpressionAlternatives_1_0() { return cDataTypeExpressionAlternatives_1_0; }

		//RangeTypeSpecification
		public RuleCall getDataTypeExpressionRangeTypeSpecificationParserRuleCall_1_0_0() { return cDataTypeExpressionRangeTypeSpecificationParserRuleCall_1_0_0; }

		//ScalarTypeSpecification
		public RuleCall getDataTypeExpressionScalarTypeSpecificationParserRuleCall_1_0_1() { return cDataTypeExpressionScalarTypeSpecificationParserRuleCall_1_0_1; }

		//StructTypeSpecification
		public RuleCall getDataTypeExpressionStructTypeSpecificationParserRuleCall_1_0_2() { return cDataTypeExpressionStructTypeSpecificationParserRuleCall_1_0_2; }

		//SimpleIdentifierExpression
		public RuleCall getDataTypeExpressionSimpleIdentifierExpressionParserRuleCall_1_0_3() { return cDataTypeExpressionSimpleIdentifierExpressionParserRuleCall_1_0_3; }
	}

	public class RangeTypeSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeTypeSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIntKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBoundsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBoundsIntegerBoundsParserRuleCall_1_0 = (RuleCall)cBoundsAssignment_1.eContents().get(0);
		
		//RangeTypeSpecification returns types::RangeTypeSpecification:
		//	"int" bounds=IntegerBounds;
		public ParserRule getRule() { return rule; }

		//"int" bounds=IntegerBounds
		public Group getGroup() { return cGroup; }

		//"int"
		public Keyword getIntKeyword_0() { return cIntKeyword_0; }

		//bounds=IntegerBounds
		public Assignment getBoundsAssignment_1() { return cBoundsAssignment_1; }

		//IntegerBounds
		public RuleCall getBoundsIntegerBoundsParserRuleCall_1_0() { return cBoundsIntegerBoundsParserRuleCall_1_0; }
	}

	public class IntegerBoundsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerBounds");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundExpressionParserRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundExpressionParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//IntegerBounds returns types::IntegerBounds:
		//	"[" lowerBound=Expression "," upperBound=Expression "]";
		public ParserRule getRule() { return rule; }

		//"[" lowerBound=Expression "," upperBound=Expression "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//lowerBound=Expression
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }

		//Expression
		public RuleCall getLowerBoundExpressionParserRuleCall_1_0() { return cLowerBoundExpressionParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//upperBound=Expression
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }

		//Expression
		public RuleCall getUpperBoundExpressionParserRuleCall_3_0() { return cUpperBoundExpressionParserRuleCall_3_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}

	public class StructTypeSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructTypeSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cDeclarationAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cDeclarationTypedElementParserRuleCall_2_0_0 = (RuleCall)cDeclarationAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//StructTypeSpecification returns types::StructTypeSpecification:
		//	"struct" "{" (declaration+=TypedElement ";")+ "}";
		public ParserRule getRule() { return rule; }

		//"struct" "{" (declaration+=TypedElement ";")+ "}"
		public Group getGroup() { return cGroup; }

		//"struct"
		public Keyword getStructKeyword_0() { return cStructKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(declaration+=TypedElement ";")+
		public Group getGroup_2() { return cGroup_2; }

		//declaration+=TypedElement
		public Assignment getDeclarationAssignment_2_0() { return cDeclarationAssignment_2_0; }

		//TypedElement
		public RuleCall getDeclarationTypedElementParserRuleCall_2_0_0() { return cDeclarationTypedElementParserRuleCall_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ScalarTypeSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ScalarTypeSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScalarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSizeExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSizeExpressionExpressionParserRuleCall_2_0 = (RuleCall)cSizeExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ScalarTypeSpecification returns types::ScalarTypeSpecification:
		//	"scalar" "[" sizeExpression=Expression "]";
		public ParserRule getRule() { return rule; }

		//"scalar" "[" sizeExpression=Expression "]"
		public Group getGroup() { return cGroup; }

		//"scalar"
		public Keyword getScalarKeyword_0() { return cScalarKeyword_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//sizeExpression=Expression
		public Assignment getSizeExpressionAssignment_2() { return cSizeExpressionAssignment_2; }

		//Expression
		public RuleCall getSizeExpressionExpressionParserRuleCall_2_0() { return cSizeExpressionExpressionParserRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypedefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeDefinitionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeDefinitionTypeExpressionParserRuleCall_1_0 = (RuleCall)cTypeDefinitionAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeDeclaredTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cTypeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cTypeDeclaredTypeParserRuleCall_3_1_0 = (RuleCall)cTypeAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TypeDeclaration returns declarations::TypeDeclaration:
		//	"typedef" typeDefinition=TypeExpression type+=DeclaredType ("," type+=DeclaredType)* ";";
		public ParserRule getRule() { return rule; }

		//"typedef" typeDefinition=TypeExpression type+=DeclaredType ("," type+=DeclaredType)* ";"
		public Group getGroup() { return cGroup; }

		//"typedef"
		public Keyword getTypedefKeyword_0() { return cTypedefKeyword_0; }

		//typeDefinition=TypeExpression
		public Assignment getTypeDefinitionAssignment_1() { return cTypeDefinitionAssignment_1; }

		//TypeExpression
		public RuleCall getTypeDefinitionTypeExpressionParserRuleCall_1_0() { return cTypeDefinitionTypeExpressionParserRuleCall_1_0; }

		//type+=DeclaredType
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//DeclaredType
		public RuleCall getTypeDeclaredTypeParserRuleCall_2_0() { return cTypeDeclaredTypeParserRuleCall_2_0; }

		//("," type+=DeclaredType)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//type+=DeclaredType
		public Assignment getTypeAssignment_3_1() { return cTypeAssignment_3_1; }

		//DeclaredType
		public RuleCall getTypeDeclaredTypeParserRuleCall_3_1_0() { return cTypeDeclaredTypeParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class DeclaredTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclaredType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDeclaredTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUPPAAL_IDENTIFIERParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//DeclaredType returns types::DeclaredType:
		//	{types::DeclaredType} name=UPPAAL_IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//{types::DeclaredType} name=UPPAAL_IDENTIFIER
		public Group getGroup() { return cGroup; }

		//{types::DeclaredType}
		public Action getDeclaredTypeAction_0() { return cDeclaredTypeAction_0; }

		//name=UPPAAL_IDENTIFIER
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UPPAAL_IDENTIFIER
		public RuleCall getNameUPPAAL_IDENTIFIERParserRuleCall_1_0() { return cNameUPPAAL_IDENTIFIERParserRuleCall_1_0; }
	}

	public class ChannelPriorityDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelPriorityDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cChanKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cPriorityKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cGroupsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cGroupsChannelPriorityGroupParserRuleCall_2_0 = (RuleCall)cGroupsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLtKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cGroupsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cGroupsChannelPriorityGroupParserRuleCall_3_1_0 = (RuleCall)cGroupsAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ChannelPriorityDeclaration returns global::ChannelPriorityDeclaration:
		//	"chan" "priority" groups+=ChannelPriorityGroup ("&lt;" groups+=ChannelPriorityGroup)* ";";
		public ParserRule getRule() { return rule; }

		//"chan" "priority" groups+=ChannelPriorityGroup ("&lt;" groups+=ChannelPriorityGroup)* ";"
		public Group getGroup() { return cGroup; }

		//"chan"
		public Keyword getChanKeyword_0() { return cChanKeyword_0; }

		//"priority"
		public Keyword getPriorityKeyword_1() { return cPriorityKeyword_1; }

		//groups+=ChannelPriorityGroup
		public Assignment getGroupsAssignment_2() { return cGroupsAssignment_2; }

		//ChannelPriorityGroup
		public RuleCall getGroupsChannelPriorityGroupParserRuleCall_2_0() { return cGroupsChannelPriorityGroupParserRuleCall_2_0; }

		//("&lt;" groups+=ChannelPriorityGroup)*
		public Group getGroup_3() { return cGroup_3; }

		//"&lt;"
		public Keyword getLtKeyword_3_0() { return cLtKeyword_3_0; }

		//groups+=ChannelPriorityGroup
		public Assignment getGroupsAssignment_3_1() { return cGroupsAssignment_3_1; }

		//ChannelPriorityGroup
		public RuleCall getGroupsChannelPriorityGroupParserRuleCall_3_1_0() { return cGroupsChannelPriorityGroupParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ChannelPriorityGroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelPriorityGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cItemsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cItemsPriorityItemParserRuleCall_0_0 = (RuleCall)cItemsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cItemsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cItemsPriorityItemParserRuleCall_1_1_0 = (RuleCall)cItemsAssignment_1_1.eContents().get(0);
		
		//ChannelPriorityGroup returns global::ChannelPriorityGroup:
		//	items+=PriorityItem ("," items+=PriorityItem)*;
		public ParserRule getRule() { return rule; }

		//items+=PriorityItem ("," items+=PriorityItem)*
		public Group getGroup() { return cGroup; }

		//items+=PriorityItem
		public Assignment getItemsAssignment_0() { return cItemsAssignment_0; }

		//PriorityItem
		public RuleCall getItemsPriorityItemParserRuleCall_0_0() { return cItemsPriorityItemParserRuleCall_0_0; }

		//("," items+=PriorityItem)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//items+=PriorityItem
		public Assignment getItemsAssignment_1_1() { return cItemsAssignment_1_1; }

		//PriorityItem
		public RuleCall getItemsPriorityItemParserRuleCall_1_1_0() { return cItemsPriorityItemParserRuleCall_1_1_0; }
	}

	public class PriorityItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PriorityItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDefaultItemParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cChannelItemParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PriorityItem returns global::PriorityItem:
		//	DefaultItem | ChannelItem;
		public ParserRule getRule() { return rule; }

		//DefaultItem | ChannelItem
		public Alternatives getAlternatives() { return cAlternatives; }

		//DefaultItem
		public RuleCall getDefaultItemParserRuleCall_0() { return cDefaultItemParserRuleCall_0; }

		//ChannelItem
		public RuleCall getChannelItemParserRuleCall_1() { return cChannelItemParserRuleCall_1; }
	}

	public class DefaultItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DefaultItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDefaultItemAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDefaultKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//DefaultItem returns global::DefaultItem:
		//	{global::DefaultItem} "default";
		public ParserRule getRule() { return rule; }

		//{global::DefaultItem} "default"
		public Group getGroup() { return cGroup; }

		//{global::DefaultItem}
		public Action getDefaultItemAction_0() { return cDefaultItemAction_0; }

		//"default"
		public Keyword getDefaultKeyword_1() { return cDefaultKeyword_1; }
	}

	public class ChannelItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelItem");
		private final Assignment cChannelExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cChannelExpressionIdentifierExpressionParserRuleCall_0 = (RuleCall)cChannelExpressionAssignment.eContents().get(0);
		
		//ChannelItem returns global::ChannelItem:
		//	channelExpression=IdentifierExpression;
		public ParserRule getRule() { return rule; }

		//channelExpression=IdentifierExpression
		public Assignment getChannelExpressionAssignment() { return cChannelExpressionAssignment; }

		//IdentifierExpression
		public RuleCall getChannelExpressionIdentifierExpressionParserRuleCall_0() { return cChannelExpressionIdentifierExpressionParserRuleCall_0; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUPPAAL_IDENTIFIERParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterParameterContainerParserRuleCall_2_0_0 = (RuleCall)cParameterAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterParameterContainerParserRuleCall_2_1_1_0 = (RuleCall)cParameterAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		////---------------------------------------------------------------------------------------------------------------------------------
		//// STATEMENTS
		////---------------------------------------------------------------------------------------------------------------------------------
		//Function returns declarations::Function:
		//	name=UPPAAL_IDENTIFIER "(" (parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)? ")" block=Block;
		public ParserRule getRule() { return rule; }

		//name=UPPAAL_IDENTIFIER "(" (parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)? ")" block=Block
		public Group getGroup() { return cGroup; }

		//name=UPPAAL_IDENTIFIER
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UPPAAL_IDENTIFIER
		public RuleCall getNameUPPAAL_IDENTIFIERParserRuleCall_0_0() { return cNameUPPAAL_IDENTIFIERParserRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameter+=ParameterContainer
		public Assignment getParameterAssignment_2_0() { return cParameterAssignment_2_0; }

		//ParameterContainer
		public RuleCall getParameterParameterContainerParserRuleCall_2_0_0() { return cParameterParameterContainerParserRuleCall_2_0_0; }

		//("," parameter+=ParameterContainer)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameter+=ParameterContainer
		public Assignment getParameterAssignment_2_1_1() { return cParameterAssignment_2_1_1; }

		//ParameterContainer
		public RuleCall getParameterParameterContainerParserRuleCall_2_1_1_0() { return cParameterParameterContainerParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//block=Block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}

	public class ParameterContainerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterContainer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeDefinitionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeDefinitionTypeExpressionParserRuleCall_0_0 = (RuleCall)cTypeDefinitionAssignment_0.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsParameterParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		
		//ParameterContainer returns declarations::ParameterContainer hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
		//	typeDefinition=TypeExpression elements+=Parameter;
		public ParserRule getRule() { return rule; }

		//typeDefinition=TypeExpression elements+=Parameter
		public Group getGroup() { return cGroup; }

		//typeDefinition=TypeExpression
		public Assignment getTypeDefinitionAssignment_0() { return cTypeDefinitionAssignment_0; }

		//TypeExpression
		public RuleCall getTypeDefinitionTypeExpressionParserRuleCall_0_0() { return cTypeDefinitionTypeExpressionParserRuleCall_0_0; }

		//elements+=Parameter
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//Parameter
		public RuleCall getElementsParameterParserRuleCall_1_0() { return cElementsParameterParserRuleCall_1_0; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCallTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCallTypeCallTypeEnumRuleCall_0_0 = (RuleCall)cCallTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUPPAAL_IDENTIFIERParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Parameter returns declarations::Parameter:
		//	callType=CallType? name=UPPAAL_IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//callType=CallType? name=UPPAAL_IDENTIFIER
		public Group getGroup() { return cGroup; }

		//callType=CallType?
		public Assignment getCallTypeAssignment_0() { return cCallTypeAssignment_0; }

		//CallType
		public RuleCall getCallTypeCallTypeEnumRuleCall_0_0() { return cCallTypeCallTypeEnumRuleCall_0_0; }

		//name=UPPAAL_IDENTIFIER
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UPPAAL_IDENTIFIER
		public RuleCall getNameUPPAAL_IDENTIFIERParserRuleCall_1_0() { return cNameUPPAAL_IDENTIFIERParserRuleCall_1_0; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEmptyStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cForLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIterationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cWhileLoopParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cDoWhileLoopParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cIfStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cReturnStatementParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		//Statement returns statements::Statement:
		//	Block | EmptyStatement | ExpressionStatement | ForLoop | Iteration | WhileLoop | DoWhileLoop | IfStatement |
		//	ReturnStatement;
		public ParserRule getRule() { return rule; }

		//Block | EmptyStatement | ExpressionStatement | ForLoop | Iteration | WhileLoop | DoWhileLoop | IfStatement |
		//ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//Block
		public RuleCall getBlockParserRuleCall_0() { return cBlockParserRuleCall_0; }

		//EmptyStatement
		public RuleCall getEmptyStatementParserRuleCall_1() { return cEmptyStatementParserRuleCall_1; }

		//ExpressionStatement
		public RuleCall getExpressionStatementParserRuleCall_2() { return cExpressionStatementParserRuleCall_2; }

		//ForLoop
		public RuleCall getForLoopParserRuleCall_3() { return cForLoopParserRuleCall_3; }

		//Iteration
		public RuleCall getIterationParserRuleCall_4() { return cIterationParserRuleCall_4; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_5() { return cWhileLoopParserRuleCall_5; }

		//DoWhileLoop
		public RuleCall getDoWhileLoopParserRuleCall_6() { return cDoWhileLoopParserRuleCall_6; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_7() { return cIfStatementParserRuleCall_7; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_8() { return cReturnStatementParserRuleCall_8; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cBlockAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cDeclarationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDeclarationsBlockDeclarationsParserRuleCall_2_0 = (RuleCall)cDeclarationsAssignment_2.eContents().get(0);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Block returns statements::Block:
		//	"{" {statements::Block} => declarations=BlockDeclarations? statement+=Statement* "}";
		public ParserRule getRule() { return rule; }

		//"{" {statements::Block} => declarations=BlockDeclarations? statement+=Statement* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//{statements::Block}
		public Action getBlockAction_1() { return cBlockAction_1; }

		//=> declarations=BlockDeclarations?
		public Assignment getDeclarationsAssignment_2() { return cDeclarationsAssignment_2; }

		//BlockDeclarations
		public RuleCall getDeclarationsBlockDeclarationsParserRuleCall_2_0() { return cDeclarationsBlockDeclarationsParserRuleCall_2_0; }

		//statement+=Statement*
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class BlockDeclarationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockDeclarations");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLocalDeclarationsAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cDeclarationAlternatives_1_0 = (Alternatives)cDeclarationAssignment_1.eContents().get(0);
		private final RuleCall cDeclarationBlockTypedDeclarationParserRuleCall_1_0_0 = (RuleCall)cDeclarationAlternatives_1_0.eContents().get(0);
		private final RuleCall cDeclarationTypeDeclarationParserRuleCall_1_0_1 = (RuleCall)cDeclarationAlternatives_1_0.eContents().get(1);
		
		//BlockDeclarations returns declarations::LocalDeclarations:
		//	{declarations::LocalDeclarations} // Syntactic predicate is used to give priority to declarations rather
		//	// than expressions like SimpleIdentifierExpression reachable from
		//	// Statement in the Block rule.
		//	=> declaration+=(BlockTypedDeclaration | TypeDeclaration)+;
		public ParserRule getRule() { return rule; }

		//{declarations::LocalDeclarations} // Syntactic predicate is used to give priority to declarations rather
		//// than expressions like SimpleIdentifierExpression reachable from
		//// Statement in the Block rule.
		//=> declaration+=(BlockTypedDeclaration | TypeDeclaration)+
		public Group getGroup() { return cGroup; }

		//{declarations::LocalDeclarations}
		public Action getLocalDeclarationsAction_0() { return cLocalDeclarationsAction_0; }

		//// Syntactic predicate is used to give priority to declarations rather
		//// than expressions like SimpleIdentifierExpression reachable from
		//// Statement in the Block rule.
		//=> declaration+=(BlockTypedDeclaration | TypeDeclaration)+
		public Assignment getDeclarationAssignment_1() { return cDeclarationAssignment_1; }

		//BlockTypedDeclaration | TypeDeclaration
		public Alternatives getDeclarationAlternatives_1_0() { return cDeclarationAlternatives_1_0; }

		//BlockTypedDeclaration
		public RuleCall getDeclarationBlockTypedDeclarationParserRuleCall_1_0_0() { return cDeclarationBlockTypedDeclarationParserRuleCall_1_0_0; }

		//TypeDeclaration
		public RuleCall getDeclarationTypeDeclarationParserRuleCall_1_0_1() { return cDeclarationTypeDeclarationParserRuleCall_1_0_1; }
	}

	public class BlockTypedDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockTypedDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeDefinitionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeDefinitionTypeExpressionParserRuleCall_0_0 = (RuleCall)cTypeDefinitionAssignment_0.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsVariableParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cElementsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cElementsVariableParserRuleCall_2_1_0 = (RuleCall)cElementsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BlockTypedDeclaration returns declarations::TypedDeclaration:
		//	typeDefinition=TypeExpression elements+=Variable ("," elements+=Variable)* ";";
		public ParserRule getRule() { return rule; }

		//typeDefinition=TypeExpression elements+=Variable ("," elements+=Variable)* ";"
		public Group getGroup() { return cGroup; }

		//typeDefinition=TypeExpression
		public Assignment getTypeDefinitionAssignment_0() { return cTypeDefinitionAssignment_0; }

		//TypeExpression
		public RuleCall getTypeDefinitionTypeExpressionParserRuleCall_0_0() { return cTypeDefinitionTypeExpressionParserRuleCall_0_0; }

		//elements+=Variable
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//Variable
		public RuleCall getElementsVariableParserRuleCall_1_0() { return cElementsVariableParserRuleCall_1_0; }

		//("," elements+=Variable)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//elements+=Variable
		public Assignment getElementsAssignment_2_1() { return cElementsAssignment_2_1; }

		//Variable
		public RuleCall getElementsVariableParserRuleCall_2_1_0() { return cElementsVariableParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class EmptyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EmptyStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSemicolonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cEmptyStatementAction_1 = (Action)cGroup.eContents().get(1);
		
		//EmptyStatement returns statements::EmptyStatement:
		//	";" {statements::EmptyStatement};
		public ParserRule getRule() { return rule; }

		//";" {statements::EmptyStatement}
		public Group getGroup() { return cGroup; }

		//";"
		public Keyword getSemicolonKeyword_0() { return cSemicolonKeyword_0; }

		//{statements::EmptyStatement}
		public Action getEmptyStatementAction_1() { return cEmptyStatementAction_1; }
	}

	public class ExpressionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ExpressionStatement returns statements::ExpressionStatement:
		//	expression=Expression ";";
		public ParserRule getRule() { return rule; }

		//expression=Expression ";"
		public Group getGroup() { return cGroup; }

		//expression=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitializationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitializationExpressionParserRuleCall_2_0 = (RuleCall)cInitializationAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConditionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConditionExpressionParserRuleCall_4_0 = (RuleCall)cConditionAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cIterationAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cIterationExpressionParserRuleCall_6_0 = (RuleCall)cIterationAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cStatementAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cStatementStatementParserRuleCall_8_0 = (RuleCall)cStatementAssignment_8.eContents().get(0);
		
		//ForLoop returns statements::ForLoop:
		//	"for" "(" initialization=Expression ";" condition=Expression ";" iteration=Expression ")" statement=Statement;
		public ParserRule getRule() { return rule; }

		//"for" "(" initialization=Expression ";" condition=Expression ";" iteration=Expression ")" statement=Statement
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//initialization=Expression
		public Assignment getInitializationAssignment_2() { return cInitializationAssignment_2; }

		//Expression
		public RuleCall getInitializationExpressionParserRuleCall_2_0() { return cInitializationExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }

		//condition=Expression
		public Assignment getConditionAssignment_4() { return cConditionAssignment_4; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_4_0() { return cConditionExpressionParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }

		//iteration=Expression
		public Assignment getIterationAssignment_6() { return cIterationAssignment_6; }

		//Expression
		public RuleCall getIterationExpressionParserRuleCall_6_0() { return cIterationExpressionParserRuleCall_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }

		//statement=Statement
		public Assignment getStatementAssignment_8() { return cStatementAssignment_8; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_8_0() { return cStatementStatementParserRuleCall_8_0; }
	}

	public class IterationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Iteration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementsVariableNameOnlyParserRuleCall_2_0 = (RuleCall)cElementsAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeDefinitionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeDefinitionTypeExpressionParserRuleCall_4_0 = (RuleCall)cTypeDefinitionAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cStatementAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cStatementStatementParserRuleCall_6_0 = (RuleCall)cStatementAssignment_6.eContents().get(0);
		
		//Iteration returns statements::Iteration:
		//	"for" "(" elements+=VariableNameOnly ":" typeDefinition=TypeExpression ")" statement=Statement;
		public ParserRule getRule() { return rule; }

		//"for" "(" elements+=VariableNameOnly ":" typeDefinition=TypeExpression ")" statement=Statement
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//elements+=VariableNameOnly
		public Assignment getElementsAssignment_2() { return cElementsAssignment_2; }

		//VariableNameOnly
		public RuleCall getElementsVariableNameOnlyParserRuleCall_2_0() { return cElementsVariableNameOnlyParserRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//typeDefinition=TypeExpression
		public Assignment getTypeDefinitionAssignment_4() { return cTypeDefinitionAssignment_4; }

		//TypeExpression
		public RuleCall getTypeDefinitionTypeExpressionParserRuleCall_4_0() { return cTypeDefinitionTypeExpressionParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//statement=Statement
		public Assignment getStatementAssignment_6() { return cStatementAssignment_6; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_6_0() { return cStatementStatementParserRuleCall_6_0; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		
		//WhileLoop returns statements::WhileLoop:
		//	"while" "(" expression=Expression ")" statement=Statement;
		public ParserRule getRule() { return rule; }

		//"while" "(" expression=Expression ")" statement=Statement
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//statement=Statement
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_4_0() { return cStatementStatementParserRuleCall_4_0; }
	}

	public class DoWhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExpressionExpressionParserRuleCall_4_0 = (RuleCall)cExpressionAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//DoWhileLoop returns statements::DoWhileLoop:
		//	"do" statement=Statement "while" "(" expression=Expression ")" ";";
		public ParserRule getRule() { return rule; }

		//"do" statement=Statement "while" "(" expression=Expression ")" ";"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//expression=Expression
		public Assignment getExpressionAssignment_4() { return cExpressionAssignment_4; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_4_0() { return cExpressionExpressionParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIfExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfExpressionExpressionParserRuleCall_2_0 = (RuleCall)cIfExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenStatementStatementParserRuleCall_4_0 = (RuleCall)cThenStatementAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cElseStatementAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cElseStatementStatementParserRuleCall_5_1_0 = (RuleCall)cElseStatementAssignment_5_1.eContents().get(0);
		
		//IfStatement returns statements::IfStatement:
		//	"if" "(" ifExpression=Expression ")" thenStatement=Statement ("else" elseStatement=Statement)?;
		public ParserRule getRule() { return rule; }

		//"if" "(" ifExpression=Expression ")" thenStatement=Statement ("else" elseStatement=Statement)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//ifExpression=Expression
		public Assignment getIfExpressionAssignment_2() { return cIfExpressionAssignment_2; }

		//Expression
		public RuleCall getIfExpressionExpressionParserRuleCall_2_0() { return cIfExpressionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//thenStatement=Statement
		public Assignment getThenStatementAssignment_4() { return cThenStatementAssignment_4; }

		//Statement
		public RuleCall getThenStatementStatementParserRuleCall_4_0() { return cThenStatementStatementParserRuleCall_4_0; }

		//(=> "else" elseStatement=Statement)?
		public Group getGroup_5() { return cGroup_5; }

		//=> "else"
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }

		//elseStatement=Statement
		public Assignment getElseStatementAssignment_5_1() { return cElseStatementAssignment_5_1; }

		//Statement
		public RuleCall getElseStatementStatementParserRuleCall_5_1_0() { return cElseStatementStatementParserRuleCall_5_1_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cReturnExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cReturnExpressionExpressionParserRuleCall_2_0 = (RuleCall)cReturnExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReturnStatement returns statements::ReturnStatement:
		//	{statements::ReturnStatement} "return" returnExpression=Expression? ";";
		public ParserRule getRule() { return rule; }

		//{statements::ReturnStatement} "return" returnExpression=Expression? ";"
		public Group getGroup() { return cGroup; }

		//{statements::ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//"return"
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//returnExpression=Expression?
		public Assignment getReturnExpressionAssignment_2() { return cReturnExpressionAssignment_2; }

		//Expression
		public RuleCall getReturnExpressionExpressionParserRuleCall_2_0() { return cReturnExpressionExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cQuantificationExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////---------------------------------------------------------------------------------------------------------------------------------
		//// EXPRESSIONS
		////---------------------------------------------------------------------------------------------------------------------------------
		//Expression returns expressions::Expression hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
		//	QuantificationExpression;
		public ParserRule getRule() { return rule; }

		//QuantificationExpression
		public RuleCall getQuantificationExpressionParserRuleCall() { return cQuantificationExpressionParserRuleCall; }
	}

	public class QuantificationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantificationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cQuantificationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cQuantifierAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cQuantifierQuantifierEnumRuleCall_0_1_0 = (RuleCall)cQuantifierAssignment_0_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cElementsAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cElementsVariableNameOnlyParserRuleCall_0_3_0 = (RuleCall)cElementsAssignment_0_3.eContents().get(0);
		private final Keyword cColonKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Assignment cTypeDefinitionAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cTypeDefinitionTypeExpressionParserRuleCall_0_5_0 = (RuleCall)cTypeDefinitionAssignment_0_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_6 = (Keyword)cGroup_0.eContents().get(6);
		private final Assignment cExpressionAssignment_0_7 = (Assignment)cGroup_0.eContents().get(7);
		private final RuleCall cExpressionLogicalExpression_OrImplyParserRuleCall_0_7_0 = (RuleCall)cExpressionAssignment_0_7.eContents().get(0);
		private final RuleCall cLogicalExpression_OrImplyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// The following rules are sorted according to the precedence and associativity rules
		//// of UPPAAL: http://www.it.uu.se/research/group/darts/uppaal/help.php?file=System_Descriptions/Expressions.shtml
		//// For a description of the patterns see http://ag-kastens.uni-paderborn.de/material/plac/folien/Folie303a.html
		//// For the concrete pattern: http://blog.efftinge.de/2010/08/parsing-expressions-with-xtext.html
		//// The default is left-recursive and binary if not otherwise noted.
		//// Quantification.
		//// (unary, right-recursive despite of the (wrong?) statement on the website)
		//QuantificationExpression returns expressions::Expression:
		//	{expressions::QuantificationExpression} quantifier=Quantifier "(" elements+=VariableNameOnly ":"
		//	typeDefinition=TypeExpression ")" expression=LogicalExpression_OrImply | LogicalExpression_OrImply;
		public ParserRule getRule() { return rule; }

		//{expressions::QuantificationExpression} quantifier=Quantifier "(" elements+=VariableNameOnly ":"
		//typeDefinition=TypeExpression ")" expression=LogicalExpression_OrImply | LogicalExpression_OrImply
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expressions::QuantificationExpression} quantifier=Quantifier "(" elements+=VariableNameOnly ":"
		//typeDefinition=TypeExpression ")" expression=LogicalExpression_OrImply
		public Group getGroup_0() { return cGroup_0; }

		//{expressions::QuantificationExpression}
		public Action getQuantificationExpressionAction_0_0() { return cQuantificationExpressionAction_0_0; }

		//quantifier=Quantifier
		public Assignment getQuantifierAssignment_0_1() { return cQuantifierAssignment_0_1; }

		//Quantifier
		public RuleCall getQuantifierQuantifierEnumRuleCall_0_1_0() { return cQuantifierQuantifierEnumRuleCall_0_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_2() { return cLeftParenthesisKeyword_0_2; }

		//elements+=VariableNameOnly
		public Assignment getElementsAssignment_0_3() { return cElementsAssignment_0_3; }

		//VariableNameOnly
		public RuleCall getElementsVariableNameOnlyParserRuleCall_0_3_0() { return cElementsVariableNameOnlyParserRuleCall_0_3_0; }

		//":"
		public Keyword getColonKeyword_0_4() { return cColonKeyword_0_4; }

		//typeDefinition=TypeExpression
		public Assignment getTypeDefinitionAssignment_0_5() { return cTypeDefinitionAssignment_0_5; }

		//TypeExpression
		public RuleCall getTypeDefinitionTypeExpressionParserRuleCall_0_5_0() { return cTypeDefinitionTypeExpressionParserRuleCall_0_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_6() { return cRightParenthesisKeyword_0_6; }

		//expression=LogicalExpression_OrImply
		public Assignment getExpressionAssignment_0_7() { return cExpressionAssignment_0_7; }

		//LogicalExpression_OrImply
		public RuleCall getExpressionLogicalExpression_OrImplyParserRuleCall_0_7_0() { return cExpressionLogicalExpression_OrImplyParserRuleCall_0_7_0; }

		//LogicalExpression_OrImply
		public RuleCall getLogicalExpression_OrImplyParserRuleCall_1() { return cLogicalExpression_OrImplyParserRuleCall_1; }
	}

	public class LogicalExpression_OrImplyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression_OrImply");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalExpression_AndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOperator_OrImplyEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprLogicalExpression_AndParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Logical Expression (only 'or' and 'imply')
		//LogicalExpression_OrImply returns expressions::Expression:
		//	LogicalExpression_And ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_OrImply
		//	secondExpr=LogicalExpression_And)*;
		public ParserRule getRule() { return rule; }

		//LogicalExpression_And ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_OrImply
		//secondExpr=LogicalExpression_And)*
		public Group getGroup() { return cGroup; }

		//LogicalExpression_And
		public RuleCall getLogicalExpression_AndParserRuleCall_0() { return cLogicalExpression_AndParserRuleCall_0; }

		//({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_OrImply secondExpr=LogicalExpression_And)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::LogicalExpression.firstExpr=current}
		public Action getLogicalExpressionFirstExprAction_1_0() { return cLogicalExpressionFirstExprAction_1_0; }

		//operator=LogicalOperator_OrImply
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOperator_OrImply
		public RuleCall getOperatorLogicalOperator_OrImplyEnumRuleCall_1_1_0() { return cOperatorLogicalOperator_OrImplyEnumRuleCall_1_1_0; }

		//secondExpr=LogicalExpression_And
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//LogicalExpression_And
		public RuleCall getSecondExprLogicalExpression_AndParserRuleCall_1_2_0() { return cSecondExprLogicalExpression_AndParserRuleCall_1_2_0; }
	}

	public class LogicalExpression_AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression_And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOperator_AndEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprNegationExpressionParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Logical Expression (only 'and')
		//LogicalExpression_And returns expressions::Expression:
		//	NegationExpression ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_And
		//	secondExpr=NegationExpression)*;
		public ParserRule getRule() { return rule; }

		//NegationExpression ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_And
		//secondExpr=NegationExpression)*
		public Group getGroup() { return cGroup; }

		//NegationExpression
		public RuleCall getNegationExpressionParserRuleCall_0() { return cNegationExpressionParserRuleCall_0; }

		//({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_And secondExpr=NegationExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::LogicalExpression.firstExpr=current}
		public Action getLogicalExpressionFirstExprAction_1_0() { return cLogicalExpressionFirstExprAction_1_0; }

		//operator=LogicalOperator_And
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOperator_And
		public RuleCall getOperatorLogicalOperator_AndEnumRuleCall_1_1_0() { return cOperatorLogicalOperator_AndEnumRuleCall_1_1_0; }

		//secondExpr=NegationExpression
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//NegationExpression
		public RuleCall getSecondExprNegationExpressionParserRuleCall_1_2_0() { return cSecondExprNegationExpressionParserRuleCall_1_2_0; }
	}

	public class NegationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NegationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNegationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cNotKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNegatedExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNegatedExpressionAssignmentExpressionParserRuleCall_0_2_0 = (RuleCall)cNegatedExpressionAssignment_0_2.eContents().get(0);
		private final RuleCall cAssignmentExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Negation Expression (logical 'not')
		//// (unary, right-recursive,)
		//NegationExpression returns expressions::Expression:
		//	{expressions::NegationExpression} "not" negatedExpression=AssignmentExpression | AssignmentExpression;
		public ParserRule getRule() { return rule; }

		//{expressions::NegationExpression} "not" negatedExpression=AssignmentExpression | AssignmentExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expressions::NegationExpression} "not" negatedExpression=AssignmentExpression
		public Group getGroup_0() { return cGroup_0; }

		//{expressions::NegationExpression}
		public Action getNegationExpressionAction_0_0() { return cNegationExpressionAction_0_0; }

		//"not"
		public Keyword getNotKeyword_0_1() { return cNotKeyword_0_1; }

		//negatedExpression=AssignmentExpression
		public Assignment getNegatedExpressionAssignment_0_2() { return cNegatedExpressionAssignment_0_2; }

		//AssignmentExpression
		public RuleCall getNegatedExpressionAssignmentExpressionParserRuleCall_0_2_0() { return cNegatedExpressionAssignmentExpressionParserRuleCall_0_2_0; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall_1() { return cAssignmentExpressionParserRuleCall_1; }
	}

	public class AssignmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssignmentExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAssignmentOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprConditionExpressionParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Assignment Expression, includes stuff like <<= noone will ever use.
		//// (right-recursive)
		//AssignmentExpression returns expressions::Expression:
		//	ConditionExpression ({expressions::AssignmentExpression.firstExpr=current} operator=AssignmentOperator
		//	secondExpr=ConditionExpression)?;
		public ParserRule getRule() { return rule; }

		//ConditionExpression ({expressions::AssignmentExpression.firstExpr=current} operator=AssignmentOperator
		//secondExpr=ConditionExpression)?
		public Group getGroup() { return cGroup; }

		//ConditionExpression
		public RuleCall getConditionExpressionParserRuleCall_0() { return cConditionExpressionParserRuleCall_0; }

		//({expressions::AssignmentExpression.firstExpr=current} operator=AssignmentOperator secondExpr=ConditionExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::AssignmentExpression.firstExpr=current}
		public Action getAssignmentExpressionFirstExprAction_1_0() { return cAssignmentExpressionFirstExprAction_1_0; }

		//operator=AssignmentOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AssignmentOperator
		public RuleCall getOperatorAssignmentOperatorEnumRuleCall_1_1_0() { return cOperatorAssignmentOperatorEnumRuleCall_1_1_0; }

		//secondExpr=ConditionExpression
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//ConditionExpression
		public RuleCall getSecondExprConditionExpressionParserRuleCall_1_2_0() { return cSecondExprConditionExpressionParserRuleCall_1_2_0; }
	}

	public class ConditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalExpression_OrAlternativeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConditionExpressionIfExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cThenExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cThenExpressionExpressionParserRuleCall_1_2_0 = (RuleCall)cThenExpressionAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cElseExpressionAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cElseExpressionLogicalExpression_OrAlternativeParserRuleCall_1_4_0 = (RuleCall)cElseExpressionAssignment_1_4.eContents().get(0);
		
		//// Conidition Expression, so (true) ? then : else
		//// (right-recursive, ternary)
		//ConditionExpression returns expressions::Expression:
		//	LogicalExpression_OrAlternative ({expressions::ConditionExpression.ifExpression=current} "?"
		//	thenExpression=Expression ":" elseExpression=LogicalExpression_OrAlternative)?;
		public ParserRule getRule() { return rule; }

		//LogicalExpression_OrAlternative ({expressions::ConditionExpression.ifExpression=current} "?" thenExpression=Expression
		//":" elseExpression=LogicalExpression_OrAlternative)?
		public Group getGroup() { return cGroup; }

		//LogicalExpression_OrAlternative
		public RuleCall getLogicalExpression_OrAlternativeParserRuleCall_0() { return cLogicalExpression_OrAlternativeParserRuleCall_0; }

		//({expressions::ConditionExpression.ifExpression=current} "?" thenExpression=Expression ":"
		//elseExpression=LogicalExpression_OrAlternative)?
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::ConditionExpression.ifExpression=current}
		public Action getConditionExpressionIfExpressionAction_1_0() { return cConditionExpressionIfExpressionAction_1_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }

		//thenExpression=Expression
		public Assignment getThenExpressionAssignment_1_2() { return cThenExpressionAssignment_1_2; }

		//Expression
		public RuleCall getThenExpressionExpressionParserRuleCall_1_2_0() { return cThenExpressionExpressionParserRuleCall_1_2_0; }

		//":"
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }

		//elseExpression=LogicalExpression_OrAlternative
		public Assignment getElseExpressionAssignment_1_4() { return cElseExpressionAssignment_1_4; }

		//LogicalExpression_OrAlternative
		public RuleCall getElseExpressionLogicalExpression_OrAlternativeParserRuleCall_1_4_0() { return cElseExpressionLogicalExpression_OrAlternativeParserRuleCall_1_4_0; }
	}

	public class LogicalExpression_OrAlternativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression_OrAlternative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalExpression_AndAlternativeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOperator_OrAlternativeEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprLogicalExpression_AndAlternativeParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Logical Expression (only '||', alternative notation for 'or')
		//LogicalExpression_OrAlternative returns expressions::Expression:
		//	LogicalExpression_AndAlternative ({expressions::LogicalExpression.firstExpr=current}
		//	operator=LogicalOperator_OrAlternative secondExpr=LogicalExpression_AndAlternative)*;
		public ParserRule getRule() { return rule; }

		//LogicalExpression_AndAlternative ({expressions::LogicalExpression.firstExpr=current}
		//operator=LogicalOperator_OrAlternative secondExpr=LogicalExpression_AndAlternative)*
		public Group getGroup() { return cGroup; }

		//LogicalExpression_AndAlternative
		public RuleCall getLogicalExpression_AndAlternativeParserRuleCall_0() { return cLogicalExpression_AndAlternativeParserRuleCall_0; }

		//({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_OrAlternative
		//secondExpr=LogicalExpression_AndAlternative)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::LogicalExpression.firstExpr=current}
		public Action getLogicalExpressionFirstExprAction_1_0() { return cLogicalExpressionFirstExprAction_1_0; }

		//operator=LogicalOperator_OrAlternative
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOperator_OrAlternative
		public RuleCall getOperatorLogicalOperator_OrAlternativeEnumRuleCall_1_1_0() { return cOperatorLogicalOperator_OrAlternativeEnumRuleCall_1_1_0; }

		//secondExpr=LogicalExpression_AndAlternative
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//LogicalExpression_AndAlternative
		public RuleCall getSecondExprLogicalExpression_AndAlternativeParserRuleCall_1_2_0() { return cSecondExprLogicalExpression_AndAlternativeParserRuleCall_1_2_0; }
	}

	public class LogicalExpression_AndAlternativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression_AndAlternative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitwiseExpression_OrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOperator_AndAlternativeEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprBitwiseExpression_OrParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Logical Expression (only '&&', alternative notation for 'and')
		//LogicalExpression_AndAlternative returns expressions::Expression:
		//	BitwiseExpression_Or ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_AndAlternative
		//	secondExpr=BitwiseExpression_Or)*;
		public ParserRule getRule() { return rule; }

		//BitwiseExpression_Or ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_AndAlternative
		//secondExpr=BitwiseExpression_Or)*
		public Group getGroup() { return cGroup; }

		//BitwiseExpression_Or
		public RuleCall getBitwiseExpression_OrParserRuleCall_0() { return cBitwiseExpression_OrParserRuleCall_0; }

		//({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_AndAlternative
		//secondExpr=BitwiseExpression_Or)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::LogicalExpression.firstExpr=current}
		public Action getLogicalExpressionFirstExprAction_1_0() { return cLogicalExpressionFirstExprAction_1_0; }

		//operator=LogicalOperator_AndAlternative
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOperator_AndAlternative
		public RuleCall getOperatorLogicalOperator_AndAlternativeEnumRuleCall_1_1_0() { return cOperatorLogicalOperator_AndAlternativeEnumRuleCall_1_1_0; }

		//secondExpr=BitwiseExpression_Or
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//BitwiseExpression_Or
		public RuleCall getSecondExprBitwiseExpression_OrParserRuleCall_1_2_0() { return cSecondExprBitwiseExpression_OrParserRuleCall_1_2_0; }
	}

	public class BitwiseExpression_OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseExpression_Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitwiseExpression_XorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBitwiseExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorBitwiseOperator_OrEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprBitwiseExpression_XorParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Bitwise Expression (only '|')
		//BitwiseExpression_Or returns expressions::Expression:
		//	BitwiseExpression_Xor ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Or
		//	secondExpr=BitwiseExpression_Xor)*;
		public ParserRule getRule() { return rule; }

		//BitwiseExpression_Xor ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Or
		//secondExpr=BitwiseExpression_Xor)*
		public Group getGroup() { return cGroup; }

		//BitwiseExpression_Xor
		public RuleCall getBitwiseExpression_XorParserRuleCall_0() { return cBitwiseExpression_XorParserRuleCall_0; }

		//({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Or secondExpr=BitwiseExpression_Xor)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::BitwiseExpression.firstExpr=current}
		public Action getBitwiseExpressionFirstExprAction_1_0() { return cBitwiseExpressionFirstExprAction_1_0; }

		//operator=BitwiseOperator_Or
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//BitwiseOperator_Or
		public RuleCall getOperatorBitwiseOperator_OrEnumRuleCall_1_1_0() { return cOperatorBitwiseOperator_OrEnumRuleCall_1_1_0; }

		//secondExpr=BitwiseExpression_Xor
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//BitwiseExpression_Xor
		public RuleCall getSecondExprBitwiseExpression_XorParserRuleCall_1_2_0() { return cSecondExprBitwiseExpression_XorParserRuleCall_1_2_0; }
	}

	public class BitwiseExpression_XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseExpression_Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitwiseExpression_AndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBitwiseExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorBitwiseOperator_XorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprBitwiseExpression_AndParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Bitwise Expression (only '^')
		//BitwiseExpression_Xor returns expressions::Expression:
		//	BitwiseExpression_And ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Xor
		//	secondExpr=BitwiseExpression_And)*;
		public ParserRule getRule() { return rule; }

		//BitwiseExpression_And ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Xor
		//secondExpr=BitwiseExpression_And)*
		public Group getGroup() { return cGroup; }

		//BitwiseExpression_And
		public RuleCall getBitwiseExpression_AndParserRuleCall_0() { return cBitwiseExpression_AndParserRuleCall_0; }

		//({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Xor secondExpr=BitwiseExpression_And)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::BitwiseExpression.firstExpr=current}
		public Action getBitwiseExpressionFirstExprAction_1_0() { return cBitwiseExpressionFirstExprAction_1_0; }

		//operator=BitwiseOperator_Xor
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//BitwiseOperator_Xor
		public RuleCall getOperatorBitwiseOperator_XorEnumRuleCall_1_1_0() { return cOperatorBitwiseOperator_XorEnumRuleCall_1_1_0; }

		//secondExpr=BitwiseExpression_And
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//BitwiseExpression_And
		public RuleCall getSecondExprBitwiseExpression_AndParserRuleCall_1_2_0() { return cSecondExprBitwiseExpression_AndParserRuleCall_1_2_0; }
	}

	public class BitwiseExpression_AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseExpression_And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCompareExpression_EqualUnequalParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBitwiseExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorBitwiseOperator_AndEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprCompareExpression_EqualUnequalParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Bitwise Expression (only '&')
		//BitwiseExpression_And returns expressions::Expression:
		//	CompareExpression_EqualUnequal ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_And
		//	secondExpr=CompareExpression_EqualUnequal)*;
		public ParserRule getRule() { return rule; }

		//CompareExpression_EqualUnequal ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_And
		//secondExpr=CompareExpression_EqualUnequal)*
		public Group getGroup() { return cGroup; }

		//CompareExpression_EqualUnequal
		public RuleCall getCompareExpression_EqualUnequalParserRuleCall_0() { return cCompareExpression_EqualUnequalParserRuleCall_0; }

		//({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_And
		//secondExpr=CompareExpression_EqualUnequal)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::BitwiseExpression.firstExpr=current}
		public Action getBitwiseExpressionFirstExprAction_1_0() { return cBitwiseExpressionFirstExprAction_1_0; }

		//operator=BitwiseOperator_And
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//BitwiseOperator_And
		public RuleCall getOperatorBitwiseOperator_AndEnumRuleCall_1_1_0() { return cOperatorBitwiseOperator_AndEnumRuleCall_1_1_0; }

		//secondExpr=CompareExpression_EqualUnequal
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//CompareExpression_EqualUnequal
		public RuleCall getSecondExprCompareExpression_EqualUnequalParserRuleCall_1_2_0() { return cSecondExprCompareExpression_EqualUnequalParserRuleCall_1_2_0; }
	}

	public class CompareExpression_EqualUnequalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompareExpression_EqualUnequal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCompareExpression_OtherParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCompareExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorCompareOperator_EqualUnequalEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprCompareExpression_OtherParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Compare Expression (only '==' and '!=')
		//CompareExpression_EqualUnequal returns expressions::Expression:
		//	CompareExpression_Other ({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_EqualUnequal
		//	secondExpr=CompareExpression_Other)*;
		public ParserRule getRule() { return rule; }

		//CompareExpression_Other ({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_EqualUnequal
		//secondExpr=CompareExpression_Other)*
		public Group getGroup() { return cGroup; }

		//CompareExpression_Other
		public RuleCall getCompareExpression_OtherParserRuleCall_0() { return cCompareExpression_OtherParserRuleCall_0; }

		//({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_EqualUnequal
		//secondExpr=CompareExpression_Other)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::CompareExpression.firstExpr=current}
		public Action getCompareExpressionFirstExprAction_1_0() { return cCompareExpressionFirstExprAction_1_0; }

		//operator=CompareOperator_EqualUnequal
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//CompareOperator_EqualUnequal
		public RuleCall getOperatorCompareOperator_EqualUnequalEnumRuleCall_1_1_0() { return cOperatorCompareOperator_EqualUnequalEnumRuleCall_1_1_0; }

		//secondExpr=CompareExpression_Other
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//CompareExpression_Other
		public RuleCall getSecondExprCompareExpression_OtherParserRuleCall_1_2_0() { return cSecondExprCompareExpression_OtherParserRuleCall_1_2_0; }
	}

	public class CompareExpression_OtherElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompareExpression_Other");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMinMaxExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCompareExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorCompareOperator_OtherEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprMinMaxExpressionParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Compare Expression (only '<', '<=', '>=', '>')
		//CompareExpression_Other returns expressions::Expression:
		//	MinMaxExpression ({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_Other
		//	secondExpr=MinMaxExpression)*;
		public ParserRule getRule() { return rule; }

		//MinMaxExpression ({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_Other
		//secondExpr=MinMaxExpression)*
		public Group getGroup() { return cGroup; }

		//MinMaxExpression
		public RuleCall getMinMaxExpressionParserRuleCall_0() { return cMinMaxExpressionParserRuleCall_0; }

		//({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_Other secondExpr=MinMaxExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::CompareExpression.firstExpr=current}
		public Action getCompareExpressionFirstExprAction_1_0() { return cCompareExpressionFirstExprAction_1_0; }

		//operator=CompareOperator_Other
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//CompareOperator_Other
		public RuleCall getOperatorCompareOperator_OtherEnumRuleCall_1_1_0() { return cOperatorCompareOperator_OtherEnumRuleCall_1_1_0; }

		//secondExpr=MinMaxExpression
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//MinMaxExpression
		public RuleCall getSecondExprMinMaxExpressionParserRuleCall_1_2_0() { return cSecondExprMinMaxExpressionParserRuleCall_1_2_0; }
	}

	public class MinMaxExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MinMaxExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitShiftExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMinMaxExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMinMaxOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprBitShiftExpressionParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// MinMax Expression ('<?' and '>?')
		//MinMaxExpression returns expressions::Expression:
		//	BitShiftExpression ({expressions::MinMaxExpression.firstExpr=current} operator=MinMaxOperator
		//	secondExpr=BitShiftExpression)*;
		public ParserRule getRule() { return rule; }

		//BitShiftExpression ({expressions::MinMaxExpression.firstExpr=current} operator=MinMaxOperator
		//secondExpr=BitShiftExpression)*
		public Group getGroup() { return cGroup; }

		//BitShiftExpression
		public RuleCall getBitShiftExpressionParserRuleCall_0() { return cBitShiftExpressionParserRuleCall_0; }

		//({expressions::MinMaxExpression.firstExpr=current} operator=MinMaxOperator secondExpr=BitShiftExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::MinMaxExpression.firstExpr=current}
		public Action getMinMaxExpressionFirstExprAction_1_0() { return cMinMaxExpressionFirstExprAction_1_0; }

		//operator=MinMaxOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//MinMaxOperator
		public RuleCall getOperatorMinMaxOperatorEnumRuleCall_1_1_0() { return cOperatorMinMaxOperatorEnumRuleCall_1_1_0; }

		//secondExpr=BitShiftExpression
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//BitShiftExpression
		public RuleCall getSecondExprBitShiftExpressionParserRuleCall_1_2_0() { return cSecondExprBitShiftExpressionParserRuleCall_1_2_0; }
	}

	public class BitShiftExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitShiftExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArithmeticExpression_PlusMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBitShiftExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorBitShiftOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprArithmeticExpression_PlusMinusParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// BitShift Expression ('<<' and '>>')
		//BitShiftExpression returns expressions::Expression:
		//	ArithmeticExpression_PlusMinus ({expressions::BitShiftExpression.firstExpr=current} operator=BitShiftOperator
		//	secondExpr=ArithmeticExpression_PlusMinus)*;
		public ParserRule getRule() { return rule; }

		//ArithmeticExpression_PlusMinus ({expressions::BitShiftExpression.firstExpr=current} operator=BitShiftOperator
		//secondExpr=ArithmeticExpression_PlusMinus)*
		public Group getGroup() { return cGroup; }

		//ArithmeticExpression_PlusMinus
		public RuleCall getArithmeticExpression_PlusMinusParserRuleCall_0() { return cArithmeticExpression_PlusMinusParserRuleCall_0; }

		//({expressions::BitShiftExpression.firstExpr=current} operator=BitShiftOperator
		//secondExpr=ArithmeticExpression_PlusMinus)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::BitShiftExpression.firstExpr=current}
		public Action getBitShiftExpressionFirstExprAction_1_0() { return cBitShiftExpressionFirstExprAction_1_0; }

		//operator=BitShiftOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//BitShiftOperator
		public RuleCall getOperatorBitShiftOperatorEnumRuleCall_1_1_0() { return cOperatorBitShiftOperatorEnumRuleCall_1_1_0; }

		//secondExpr=ArithmeticExpression_PlusMinus
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//ArithmeticExpression_PlusMinus
		public RuleCall getSecondExprArithmeticExpression_PlusMinusParserRuleCall_1_2_0() { return cSecondExprArithmeticExpression_PlusMinusParserRuleCall_1_2_0; }
	}

	public class ArithmeticExpression_PlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticExpression_PlusMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArithmeticExpression_OtherParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorArithmeticOperator_PlusMinusEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprArithmeticExpression_OtherParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Arithmetic Expression ('+' and '-')
		//ArithmeticExpression_PlusMinus returns expressions::Expression:
		//	ArithmeticExpression_Other ({expressions::ArithmeticExpression.firstExpr=current}
		//	operator=ArithmeticOperator_PlusMinus secondExpr=ArithmeticExpression_Other)*;
		public ParserRule getRule() { return rule; }

		//ArithmeticExpression_Other ({expressions::ArithmeticExpression.firstExpr=current} operator=ArithmeticOperator_PlusMinus
		//secondExpr=ArithmeticExpression_Other)*
		public Group getGroup() { return cGroup; }

		//ArithmeticExpression_Other
		public RuleCall getArithmeticExpression_OtherParserRuleCall_0() { return cArithmeticExpression_OtherParserRuleCall_0; }

		//({expressions::ArithmeticExpression.firstExpr=current} operator=ArithmeticOperator_PlusMinus
		//secondExpr=ArithmeticExpression_Other)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::ArithmeticExpression.firstExpr=current}
		public Action getArithmeticExpressionFirstExprAction_1_0() { return cArithmeticExpressionFirstExprAction_1_0; }

		//operator=ArithmeticOperator_PlusMinus
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ArithmeticOperator_PlusMinus
		public RuleCall getOperatorArithmeticOperator_PlusMinusEnumRuleCall_1_1_0() { return cOperatorArithmeticOperator_PlusMinusEnumRuleCall_1_1_0; }

		//secondExpr=ArithmeticExpression_Other
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//ArithmeticExpression_Other
		public RuleCall getSecondExprArithmeticExpression_OtherParserRuleCall_1_2_0() { return cSecondExprArithmeticExpression_OtherParserRuleCall_1_2_0; }
	}

	public class ArithmeticExpression_OtherElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticExpression_Other");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegationExpression_AlternativeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionFirstExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorArithmeticOperator_OtherEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSecondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSecondExprNegationExpression_AlternativeParserRuleCall_1_2_0 = (RuleCall)cSecondExprAssignment_1_2.eContents().get(0);
		
		//// Arithmetic Expression ('*', '/' and '%')
		//ArithmeticExpression_Other returns expressions::Expression:
		//	NegationExpression_Alternative ({expressions::ArithmeticExpression.firstExpr=current}
		//	operator=ArithmeticOperator_Other secondExpr=NegationExpression_Alternative)*;
		public ParserRule getRule() { return rule; }

		//NegationExpression_Alternative ({expressions::ArithmeticExpression.firstExpr=current} operator=ArithmeticOperator_Other
		//secondExpr=NegationExpression_Alternative)*
		public Group getGroup() { return cGroup; }

		//NegationExpression_Alternative
		public RuleCall getNegationExpression_AlternativeParserRuleCall_0() { return cNegationExpression_AlternativeParserRuleCall_0; }

		//({expressions::ArithmeticExpression.firstExpr=current} operator=ArithmeticOperator_Other
		//secondExpr=NegationExpression_Alternative)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::ArithmeticExpression.firstExpr=current}
		public Action getArithmeticExpressionFirstExprAction_1_0() { return cArithmeticExpressionFirstExprAction_1_0; }

		//operator=ArithmeticOperator_Other
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ArithmeticOperator_Other
		public RuleCall getOperatorArithmeticOperator_OtherEnumRuleCall_1_1_0() { return cOperatorArithmeticOperator_OtherEnumRuleCall_1_1_0; }

		//secondExpr=NegationExpression_Alternative
		public Assignment getSecondExprAssignment_1_2() { return cSecondExprAssignment_1_2; }

		//NegationExpression_Alternative
		public RuleCall getSecondExprNegationExpression_AlternativeParserRuleCall_1_2_0() { return cSecondExprNegationExpression_AlternativeParserRuleCall_1_2_0; }
	}

	public class NegationExpression_AlternativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NegationExpression_Alternative");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNegationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNegatedExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNegatedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0 = (RuleCall)cNegatedExpressionAssignment_0_2.eContents().get(0);
		private final RuleCall cPlusExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// NOTE: From this point on, I just assume that ++ and -- have a higher
		//// precedence than ! and the unary - and +.
		//// Negation Expression Alternative (logical not, '!')
		//// (unary, right-recursive,)
		//NegationExpression_Alternative returns expressions::Expression:
		//	{expressions::NegationExpression} "!" negatedExpression=NegationExpression_Alternative | PlusExpression;
		public ParserRule getRule() { return rule; }

		//{expressions::NegationExpression} "!" negatedExpression=NegationExpression_Alternative | PlusExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expressions::NegationExpression} "!" negatedExpression=NegationExpression_Alternative
		public Group getGroup_0() { return cGroup_0; }

		//{expressions::NegationExpression}
		public Action getNegationExpressionAction_0_0() { return cNegationExpressionAction_0_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_0_1() { return cExclamationMarkKeyword_0_1; }

		//negatedExpression=NegationExpression_Alternative
		public Assignment getNegatedExpressionAssignment_0_2() { return cNegatedExpressionAssignment_0_2; }

		//NegationExpression_Alternative
		public RuleCall getNegatedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0() { return cNegatedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0; }

		//PlusExpression
		public RuleCall getPlusExpressionParserRuleCall_1() { return cPlusExpressionParserRuleCall_1; }
	}

	public class PlusExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cPlusExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cConfirmedExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cConfirmedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0 = (RuleCall)cConfirmedExpressionAssignment_0_2.eContents().get(0);
		private final RuleCall cMinusExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Plus Expression ('+')
		//// (unary, right-recursive,)
		//PlusExpression returns expressions::Expression:
		//	{expressions::PlusExpression} "+" confirmedExpression=NegationExpression_Alternative | MinusExpression;
		public ParserRule getRule() { return rule; }

		//{expressions::PlusExpression} "+" confirmedExpression=NegationExpression_Alternative | MinusExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expressions::PlusExpression} "+" confirmedExpression=NegationExpression_Alternative
		public Group getGroup_0() { return cGroup_0; }

		//{expressions::PlusExpression}
		public Action getPlusExpressionAction_0_0() { return cPlusExpressionAction_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_0_1() { return cPlusSignKeyword_0_1; }

		//confirmedExpression=NegationExpression_Alternative
		public Assignment getConfirmedExpressionAssignment_0_2() { return cConfirmedExpressionAssignment_0_2; }

		//NegationExpression_Alternative
		public RuleCall getConfirmedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0() { return cConfirmedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0; }

		//MinusExpression
		public RuleCall getMinusExpressionParserRuleCall_1() { return cMinusExpressionParserRuleCall_1; }
	}

	public class MinusExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MinusExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cMinusExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cInvertedExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cInvertedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0 = (RuleCall)cInvertedExpressionAssignment_0_2.eContents().get(0);
		private final RuleCall cPreIncrementDecrementExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Minus Expression ('-')
		//// (unary, right-recursive,)
		//MinusExpression returns expressions::Expression:
		//	{expressions::MinusExpression} "-" invertedExpression=NegationExpression_Alternative |
		//	PreIncrementDecrementExpression;
		public ParserRule getRule() { return rule; }

		//{expressions::MinusExpression} "-" invertedExpression=NegationExpression_Alternative | PreIncrementDecrementExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expressions::MinusExpression} "-" invertedExpression=NegationExpression_Alternative
		public Group getGroup_0() { return cGroup_0; }

		//{expressions::MinusExpression}
		public Action getMinusExpressionAction_0_0() { return cMinusExpressionAction_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_0_1() { return cHyphenMinusKeyword_0_1; }

		//invertedExpression=NegationExpression_Alternative
		public Assignment getInvertedExpressionAssignment_0_2() { return cInvertedExpressionAssignment_0_2; }

		//NegationExpression_Alternative
		public RuleCall getInvertedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0() { return cInvertedExpressionNegationExpression_AlternativeParserRuleCall_0_2_0; }

		//PreIncrementDecrementExpression
		public RuleCall getPreIncrementDecrementExpressionParserRuleCall_1() { return cPreIncrementDecrementExpressionParserRuleCall_1; }
	}

	public class PreIncrementDecrementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreIncrementDecrementExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPostIncrementDecrementExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPreIncrementDecrementExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorIncrementDecrementOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPreIncrementDecrementExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		
		//// Pre Increment/Decrement Expression ('++', '--', pre)
		//// (unary, right-recursive)
		//PreIncrementDecrementExpression returns expressions::Expression:
		//	PostIncrementDecrementExpression | {expressions::PreIncrementDecrementExpression} operator=IncrementDecrementOperator
		//	expression=PreIncrementDecrementExpression;
		public ParserRule getRule() { return rule; }

		//PostIncrementDecrementExpression | {expressions::PreIncrementDecrementExpression} operator=IncrementDecrementOperator
		//expression=PreIncrementDecrementExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//PostIncrementDecrementExpression
		public RuleCall getPostIncrementDecrementExpressionParserRuleCall_0() { return cPostIncrementDecrementExpressionParserRuleCall_0; }

		//{expressions::PreIncrementDecrementExpression} operator=IncrementDecrementOperator
		//expression=PreIncrementDecrementExpression
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::PreIncrementDecrementExpression}
		public Action getPreIncrementDecrementExpressionAction_1_0() { return cPreIncrementDecrementExpressionAction_1_0; }

		//operator=IncrementDecrementOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//IncrementDecrementOperator
		public RuleCall getOperatorIncrementDecrementOperatorEnumRuleCall_1_1_0() { return cOperatorIncrementDecrementOperatorEnumRuleCall_1_1_0; }

		//expression=PreIncrementDecrementExpression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }

		//PreIncrementDecrementExpression
		public RuleCall getExpressionPreIncrementDecrementExpressionParserRuleCall_1_2_0() { return cExpressionPreIncrementDecrementExpressionParserRuleCall_1_2_0; }
	}

	public class PostIncrementDecrementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostIncrementDecrementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cScopedIdentifierExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cPostIncrementDecrementExpressionExpressionAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOperatorIncrementDecrementOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOperatorAssignment_1_0_1.eContents().get(0);
		
		//// Post Increment/Decrement Expression ('++', '--', post)
		//// (unary, right-recursive)
		//PostIncrementDecrementExpression returns expressions::Expression:
		//	ScopedIdentifierExpression // Note: For expressions like a+++b, two ways to split them up exist:
		//	//   (a++)+b and a+(++b)
		//	// As UPPAAL uses the former way a syntactic predicate ensures the
		//	// higher precedence of the post-expression.
		//	=> ({expressions::PostIncrementDecrementExpression.expression=current} operator=IncrementDecrementOperator)*;
		public ParserRule getRule() { return rule; }

		//ScopedIdentifierExpression // Note: For expressions like a+++b, two ways to split them up exist:
		////   (a++)+b and a+(++b)
		//// As UPPAAL uses the former way a syntactic predicate ensures the
		//// higher precedence of the post-expression.
		//=> ({expressions::PostIncrementDecrementExpression.expression=current} operator=IncrementDecrementOperator)*
		public Group getGroup() { return cGroup; }

		//ScopedIdentifierExpression
		public RuleCall getScopedIdentifierExpressionParserRuleCall_0() { return cScopedIdentifierExpressionParserRuleCall_0; }

		//// Note: For expressions like a+++b, two ways to split them up exist:
		////   (a++)+b and a+(++b)
		//// As UPPAAL uses the former way a syntactic predicate ensures the
		//// higher precedence of the post-expression.
		//=> ({expressions::PostIncrementDecrementExpression.expression=current} operator=IncrementDecrementOperator)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::PostIncrementDecrementExpression.expression=current} operator=IncrementDecrementOperator
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{expressions::PostIncrementDecrementExpression.expression=current}
		public Action getPostIncrementDecrementExpressionExpressionAction_1_0_0() { return cPostIncrementDecrementExpressionExpressionAction_1_0_0; }

		//operator=IncrementDecrementOperator
		public Assignment getOperatorAssignment_1_0_1() { return cOperatorAssignment_1_0_1; }

		//IncrementDecrementOperator
		public RuleCall getOperatorIncrementDecrementOperatorEnumRuleCall_1_0_1_0() { return cOperatorIncrementDecrementOperatorEnumRuleCall_1_0_1_0; }
	}

	public class ScopedIdentifierExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ScopedIdentifierExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTerminatingExpressionsParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cScopedIdentifierExpressionScopeAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cIdentifierAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIdentifierIdentifierExpressionParserRuleCall_1_2_0 = (RuleCall)cIdentifierAssignment_1_2.eContents().get(0);
		
		//// ScopedIdentifier Expression (identifiers with .)
		//ScopedIdentifierExpression returns expressions::Expression:
		//	TerminatingExpressions ({expressions::ScopedIdentifierExpression.scope=current} "."
		//	identifier=IdentifierExpression)*;
		public ParserRule getRule() { return rule; }

		//TerminatingExpressions ({expressions::ScopedIdentifierExpression.scope=current} "." identifier=IdentifierExpression)*
		public Group getGroup() { return cGroup; }

		//TerminatingExpressions
		public RuleCall getTerminatingExpressionsParserRuleCall_0() { return cTerminatingExpressionsParserRuleCall_0; }

		//({expressions::ScopedIdentifierExpression.scope=current} "." identifier=IdentifierExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{expressions::ScopedIdentifierExpression.scope=current}
		public Action getScopedIdentifierExpressionScopeAction_1_0() { return cScopedIdentifierExpressionScopeAction_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }

		//identifier=IdentifierExpression
		public Assignment getIdentifierAssignment_1_2() { return cIdentifierAssignment_1_2; }

		//IdentifierExpression
		public RuleCall getIdentifierIdentifierExpressionParserRuleCall_1_2_0() { return cIdentifierIdentifierExpressionParserRuleCall_1_2_0; }
	}

	public class TerminatingExpressionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TerminatingExpressions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdentifierExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionCallExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		//// Terminating Expressions
		//TerminatingExpressions returns expressions::Expression:
		//	IdentifierExpression | FunctionCallExpression | LiteralExpression | "(" Expression ")";
		public ParserRule getRule() { return rule; }

		//IdentifierExpression | FunctionCallExpression | LiteralExpression | "(" Expression ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentifierExpression
		public RuleCall getIdentifierExpressionParserRuleCall_0() { return cIdentifierExpressionParserRuleCall_0; }

		//FunctionCallExpression
		public RuleCall getFunctionCallExpressionParserRuleCall_1() { return cFunctionCallExpressionParserRuleCall_1; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_2() { return cLiteralExpressionParserRuleCall_2; }

		//"(" Expression ")"
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_3_1() { return cExpressionParserRuleCall_3_1; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Assignment cTextAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTextLiteralExpressionTextParserRuleCall_0 = (RuleCall)cTextAssignment.eContents().get(0);
		
		//LiteralExpression returns expressions::LiteralExpression:
		//	text=LiteralExpressionText;
		public ParserRule getRule() { return rule; }

		//text=LiteralExpressionText
		public Assignment getTextAssignment() { return cTextAssignment; }

		//LiteralExpressionText
		public RuleCall getTextLiteralExpressionTextParserRuleCall_0() { return cTextLiteralExpressionTextParserRuleCall_0; }
	}

	public class LiteralExpressionTextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpressionText");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//LiteralExpressionText returns ecore::EString:
		//	"true" | "false" | INT;
		public ParserRule getRule() { return rule; }

		//"true" | "false" | INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}

	public class FunctionCallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFunctionFunctionCrossReference_0_0 = (CrossReference)cFunctionAssignment_0.eContents().get(0);
		private final RuleCall cFunctionFunctionUPPAAL_IDENTIFIERParserRuleCall_0_0_1 = (RuleCall)cFunctionFunctionCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgumentAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgumentExpressionParserRuleCall_2_0_0 = (RuleCall)cArgumentAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgumentAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgumentExpressionParserRuleCall_2_1_1_0 = (RuleCall)cArgumentAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Function Calls
		//FunctionCallExpression returns expressions::FunctionCallExpression:
		//	function=[declarations::Function|UPPAAL_IDENTIFIER] "(" (argument+=Expression ("," argument+=Expression)*)? ")";
		public ParserRule getRule() { return rule; }

		//function=[declarations::Function|UPPAAL_IDENTIFIER] "(" (argument+=Expression ("," argument+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//function=[declarations::Function|UPPAAL_IDENTIFIER]
		public Assignment getFunctionAssignment_0() { return cFunctionAssignment_0; }

		//[declarations::Function|UPPAAL_IDENTIFIER]
		public CrossReference getFunctionFunctionCrossReference_0_0() { return cFunctionFunctionCrossReference_0_0; }

		//UPPAAL_IDENTIFIER
		public RuleCall getFunctionFunctionUPPAAL_IDENTIFIERParserRuleCall_0_0_1() { return cFunctionFunctionUPPAAL_IDENTIFIERParserRuleCall_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(argument+=Expression ("," argument+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }

		//argument+=Expression
		public Assignment getArgumentAssignment_2_0() { return cArgumentAssignment_2_0; }

		//Expression
		public RuleCall getArgumentExpressionParserRuleCall_2_0_0() { return cArgumentExpressionParserRuleCall_2_0_0; }

		//("," argument+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//argument+=Expression
		public Assignment getArgumentAssignment_2_1_1() { return cArgumentAssignment_2_1_1; }

		//Expression
		public RuleCall getArgumentExpressionParserRuleCall_2_1_1_0() { return cArgumentExpressionParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class IdentifierExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdentifierExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdentifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cIdentifierNamedElementCrossReference_0_0 = (CrossReference)cIdentifierAssignment_0.eContents().get(0);
		private final RuleCall cIdentifierNamedElementUPPAAL_TYPE_OR_IDENTIFIERParserRuleCall_0_0_1 = (RuleCall)cIdentifierNamedElementCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIndexAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIndexExpressionParserRuleCall_1_1_0 = (RuleCall)cIndexAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//// Identifier Expression (normal identifiers)
		//IdentifierExpression returns expressions::IdentifierExpression:
		//	identifier=[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER] ("[" index+=Expression "]")*;
		public ParserRule getRule() { return rule; }

		//identifier=[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER] ("[" index+=Expression "]")*
		public Group getGroup() { return cGroup; }

		//identifier=[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER]
		public Assignment getIdentifierAssignment_0() { return cIdentifierAssignment_0; }

		//[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER]
		public CrossReference getIdentifierNamedElementCrossReference_0_0() { return cIdentifierNamedElementCrossReference_0_0; }

		//UPPAAL_TYPE_OR_IDENTIFIER
		public RuleCall getIdentifierNamedElementUPPAAL_TYPE_OR_IDENTIFIERParserRuleCall_0_0_1() { return cIdentifierNamedElementUPPAAL_TYPE_OR_IDENTIFIERParserRuleCall_0_0_1; }

		//("[" index+=Expression "]")*
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//index+=Expression
		public Assignment getIndexAssignment_1_1() { return cIndexAssignment_1_1; }

		//Expression
		public RuleCall getIndexExpressionParserRuleCall_1_1_0() { return cIndexExpressionParserRuleCall_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}

	public class SimpleIdentifierExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleIdentifierExpression");
		private final Assignment cIdentifierAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cIdentifierNamedElementCrossReference_0 = (CrossReference)cIdentifierAssignment.eContents().get(0);
		private final RuleCall cIdentifierNamedElementUPPAAL_TYPE_OR_IDENTIFIERParserRuleCall_0_1 = (RuleCall)cIdentifierNamedElementCrossReference_0.eContents().get(1);
		
		//// Only allows simple identifiers without indices.
		//SimpleIdentifierExpression returns expressions::IdentifierExpression:
		//	identifier=[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER];
		public ParserRule getRule() { return rule; }

		//identifier=[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER]
		public Assignment getIdentifierAssignment() { return cIdentifierAssignment; }

		//[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER]
		public CrossReference getIdentifierNamedElementCrossReference_0() { return cIdentifierNamedElementCrossReference_0; }

		//UPPAAL_TYPE_OR_IDENTIFIER
		public RuleCall getIdentifierNamedElementUPPAAL_TYPE_OR_IDENTIFIERParserRuleCall_0_1() { return cIdentifierNamedElementUPPAAL_TYPE_OR_IDENTIFIERParserRuleCall_0_1; }
	}

	public class UPPAAL_TYPE_OR_IDENTIFIERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UPPAAL_TYPE_OR_IDENTIFIER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUPPAAL_IDENTIFIERParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cIntKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBoolKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cVoidKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cChanKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cClockKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		////---------------------------------------------------------------------------------------------------------------------------------
		//// TOKENS
		////---------------------------------------------------------------------------------------------------------------------------------
		//UPPAAL_TYPE_OR_IDENTIFIER:
		//	UPPAAL_IDENTIFIER | "int" | "bool" | "void" | "chan" | "clock";
		public ParserRule getRule() { return rule; }

		//UPPAAL_IDENTIFIER | "int" | "bool" | "void" | "chan" | "clock"
		public Alternatives getAlternatives() { return cAlternatives; }

		//UPPAAL_IDENTIFIER
		public RuleCall getUPPAAL_IDENTIFIERParserRuleCall_0() { return cUPPAAL_IDENTIFIERParserRuleCall_0; }

		//"int"
		public Keyword getIntKeyword_1() { return cIntKeyword_1; }

		//"bool"
		public Keyword getBoolKeyword_2() { return cBoolKeyword_2; }

		//"void"
		public Keyword getVoidKeyword_3() { return cVoidKeyword_3; }

		//"chan"
		public Keyword getChanKeyword_4() { return cChanKeyword_4; }

		//"clock"
		public Keyword getClockKeyword_5() { return cClockKeyword_5; }
	}

	public class UPPAAL_IDENTIFIERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UPPAAL_IDENTIFIER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cXML_KEYWORDSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UPPAAL_IDENTIFIER:
		//	ID | XML_KEYWORDS;
		public ParserRule getRule() { return rule; }

		//ID | XML_KEYWORDS
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//XML_KEYWORDS
		public RuleCall getXML_KEYWORDSParserRuleCall_1() { return cXML_KEYWORDSParserRuleCall_1; }
	}

	public class UPPAAL_KEYWORDSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UPPAAL_KEYWORDS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cChanKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cClockKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBoolKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cIntKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cCommitKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cConstKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cUrgentKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cBroadcastKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cInitKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cProcessKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cStateKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cGuardKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cSyncKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cAssignKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cSystemKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cTransKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cDeadlockKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cAndKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cOrKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cNotKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cImplyKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cTrueKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cFalseKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cForKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cForallKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cExistsKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cWhileKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cDoKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cIfKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cElseKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cReturnKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cTypedefKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Keyword cStructKeyword_32 = (Keyword)cAlternatives.eContents().get(32);
		private final Keyword cRateKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cBefore_updateKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cAfter_updateKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		private final Keyword cMetaKeyword_36 = (Keyword)cAlternatives.eContents().get(36);
		private final Keyword cPriorityKeyword_37 = (Keyword)cAlternatives.eContents().get(37);
		private final Keyword cProgressKeyword_38 = (Keyword)cAlternatives.eContents().get(38);
		private final Keyword cScalarKeyword_39 = (Keyword)cAlternatives.eContents().get(39);
		private final Keyword cSelectKeyword_40 = (Keyword)cAlternatives.eContents().get(40);
		private final Keyword cVoidKeyword_41 = (Keyword)cAlternatives.eContents().get(41);
		private final Keyword cSwitchKeyword_42 = (Keyword)cAlternatives.eContents().get(42);
		private final Keyword cCaseKeyword_43 = (Keyword)cAlternatives.eContents().get(43);
		private final Keyword cContinueKeyword_44 = (Keyword)cAlternatives.eContents().get(44);
		private final Keyword cBreakKeyword_45 = (Keyword)cAlternatives.eContents().get(45);
		private final Keyword cDefaultKeyword_46 = (Keyword)cAlternatives.eContents().get(46);
		
		//UPPAAL_KEYWORDS:
		//	"chan" // End of the list from the website.
		//	| "clock" | "bool" | "int" | "commit" | "const" | "urgent" | "broadcast" | "init" | "process" | "state" | "guard" |
		//	"sync" | "assign" | "system" | "trans" | "deadlock" | "and" | "or" | "not" | "imply" | "true" | "false" | "for" |
		//	"forall" | "exists" | "while" | "do" | "if" | "else" | "return" | "typedef" | "struct" | "rate" | "before_update" |
		//	"after_update" | "meta" | "priority" | "progress" | "scalar" | "select" | "void" | "switch" | "case" | "continue" |
		//	"break" | "default";
		public ParserRule getRule() { return rule; }

		//"chan" // End of the list from the website.
		//| "clock" | "bool" | "int" | "commit" | "const" | "urgent" | "broadcast" | "init" | "process" | "state" | "guard" |
		//"sync" | "assign" | "system" | "trans" | "deadlock" | "and" | "or" | "not" | "imply" | "true" | "false" | "for" |
		//"forall" | "exists" | "while" | "do" | "if" | "else" | "return" | "typedef" | "struct" | "rate" | "before_update" |
		//"after_update" | "meta" | "priority" | "progress" | "scalar" | "select" | "void" | "switch" | "case" | "continue" |
		//"break" | "default"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"chan"
		public Keyword getChanKeyword_0() { return cChanKeyword_0; }

		//"clock"
		public Keyword getClockKeyword_1() { return cClockKeyword_1; }

		//"bool"
		public Keyword getBoolKeyword_2() { return cBoolKeyword_2; }

		//"int"
		public Keyword getIntKeyword_3() { return cIntKeyword_3; }

		//"commit"
		public Keyword getCommitKeyword_4() { return cCommitKeyword_4; }

		//"const"
		public Keyword getConstKeyword_5() { return cConstKeyword_5; }

		//"urgent"
		public Keyword getUrgentKeyword_6() { return cUrgentKeyword_6; }

		//"broadcast"
		public Keyword getBroadcastKeyword_7() { return cBroadcastKeyword_7; }

		//"init"
		public Keyword getInitKeyword_8() { return cInitKeyword_8; }

		//"process"
		public Keyword getProcessKeyword_9() { return cProcessKeyword_9; }

		//"state"
		public Keyword getStateKeyword_10() { return cStateKeyword_10; }

		//"guard"
		public Keyword getGuardKeyword_11() { return cGuardKeyword_11; }

		//"sync"
		public Keyword getSyncKeyword_12() { return cSyncKeyword_12; }

		//"assign"
		public Keyword getAssignKeyword_13() { return cAssignKeyword_13; }

		//"system"
		public Keyword getSystemKeyword_14() { return cSystemKeyword_14; }

		//"trans"
		public Keyword getTransKeyword_15() { return cTransKeyword_15; }

		//"deadlock"
		public Keyword getDeadlockKeyword_16() { return cDeadlockKeyword_16; }

		//"and"
		public Keyword getAndKeyword_17() { return cAndKeyword_17; }

		//"or"
		public Keyword getOrKeyword_18() { return cOrKeyword_18; }

		//"not"
		public Keyword getNotKeyword_19() { return cNotKeyword_19; }

		//"imply"
		public Keyword getImplyKeyword_20() { return cImplyKeyword_20; }

		//"true"
		public Keyword getTrueKeyword_21() { return cTrueKeyword_21; }

		//"false"
		public Keyword getFalseKeyword_22() { return cFalseKeyword_22; }

		//"for"
		public Keyword getForKeyword_23() { return cForKeyword_23; }

		//"forall"
		public Keyword getForallKeyword_24() { return cForallKeyword_24; }

		//"exists"
		public Keyword getExistsKeyword_25() { return cExistsKeyword_25; }

		//"while"
		public Keyword getWhileKeyword_26() { return cWhileKeyword_26; }

		//"do"
		public Keyword getDoKeyword_27() { return cDoKeyword_27; }

		//"if"
		public Keyword getIfKeyword_28() { return cIfKeyword_28; }

		//"else"
		public Keyword getElseKeyword_29() { return cElseKeyword_29; }

		//"return"
		public Keyword getReturnKeyword_30() { return cReturnKeyword_30; }

		//"typedef"
		public Keyword getTypedefKeyword_31() { return cTypedefKeyword_31; }

		//"struct"
		public Keyword getStructKeyword_32() { return cStructKeyword_32; }

		//"rate"
		public Keyword getRateKeyword_33() { return cRateKeyword_33; }

		//"before_update"
		public Keyword getBefore_updateKeyword_34() { return cBefore_updateKeyword_34; }

		//"after_update"
		public Keyword getAfter_updateKeyword_35() { return cAfter_updateKeyword_35; }

		//"meta"
		public Keyword getMetaKeyword_36() { return cMetaKeyword_36; }

		//"priority"
		public Keyword getPriorityKeyword_37() { return cPriorityKeyword_37; }

		//"progress"
		public Keyword getProgressKeyword_38() { return cProgressKeyword_38; }

		//"scalar"
		public Keyword getScalarKeyword_39() { return cScalarKeyword_39; }

		//"select"
		public Keyword getSelectKeyword_40() { return cSelectKeyword_40; }

		//"void"
		public Keyword getVoidKeyword_41() { return cVoidKeyword_41; }

		//"switch"
		public Keyword getSwitchKeyword_42() { return cSwitchKeyword_42; }

		//"case"
		public Keyword getCaseKeyword_43() { return cCaseKeyword_43; }

		//"continue"
		public Keyword getContinueKeyword_44() { return cContinueKeyword_44; }

		//"break"
		public Keyword getBreakKeyword_45() { return cBreakKeyword_45; }

		//"default"
		public Keyword getDefaultKeyword_46() { return cDefaultKeyword_46; }
	}

	public class UPPAAL_STRUCTURE_KEYWORDSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UPPAAL_STRUCTURE_KEYWORDS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLtKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cGtKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cCommaKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLeftParenthesisKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cQuestionMarkKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cExclamationMarkKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cAsteriskKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cPercentSignKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cSolidusKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cPlusSignKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cHyphenMinusKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cPlusSignPlusSignKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cHyphenMinusHyphenMinusKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLtLtKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cGtGtKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cLtKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cGtKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cLtKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cGtKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cEqualsSignEqualsSignKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cExclamationMarkEqualsSignKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cAmpersandKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cAmpKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cCircumflexAccentKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cVerticalLineKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cAmpersandAmpersandKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Keyword cAmpAmpKeyword_32 = (Keyword)cAlternatives.eContents().get(32);
		private final Keyword cVerticalLineVerticalLineKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cEqualsSignKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cPlusSignEqualsSignKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		private final Keyword cHyphenMinusEqualsSignKeyword_36 = (Keyword)cAlternatives.eContents().get(36);
		private final Keyword cAsteriskEqualsSignKeyword_37 = (Keyword)cAlternatives.eContents().get(37);
		private final Keyword cSolidusEqualsSignKeyword_38 = (Keyword)cAlternatives.eContents().get(38);
		private final Keyword cPercentSignEqualsSignKeyword_39 = (Keyword)cAlternatives.eContents().get(39);
		private final Keyword cVerticalLineEqualsSignKeyword_40 = (Keyword)cAlternatives.eContents().get(40);
		private final Keyword cAmpersandEqualsSignKeyword_41 = (Keyword)cAlternatives.eContents().get(41);
		private final Keyword cCircumflexAccentEqualsSignKeyword_42 = (Keyword)cAlternatives.eContents().get(42);
		private final Keyword cLtLtKeyword_43 = (Keyword)cAlternatives.eContents().get(43);
		private final Keyword cGtGtKeyword_44 = (Keyword)cAlternatives.eContents().get(44);
		private final Keyword cColonKeyword_45 = (Keyword)cAlternatives.eContents().get(45);
		
		//UPPAAL_STRUCTURE_KEYWORDS:
		//	"[" | "]" | "&lt;" | "&gt" | ";" | "," | "{" | "}" | "(" | ")" | "?" | "!" | "*" | "%" | "/" | "+" | "-" | "++" |
		//	"--" | "&lt;&lt;" | "&gt;&gt" | "&lt;?" | "&gt;?" | "&lt;=" | "&gt;=" | "==" | "!=" | "&" | "&amp;" | "^" | "|" |
		//	"&&" | "&amp;&amp;" | "||" | "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "|=" | "&=" | "^=" | "&lt;&lt;=" | "&gt;&gt;="
		//	| ":";
		public ParserRule getRule() { return rule; }

		//"[" | "]" | "&lt;" | "&gt" | ";" | "," | "{" | "}" | "(" | ")" | "?" | "!" | "*" | "%" | "/" | "+" | "-" | "++" | "--" |
		//"&lt;&lt;" | "&gt;&gt" | "&lt;?" | "&gt;?" | "&lt;=" | "&gt;=" | "==" | "!=" | "&" | "&amp;" | "^" | "|" | "&&" |
		//"&amp;&amp;" | "||" | "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "|=" | "&=" | "^=" | "&lt;&lt;=" | "&gt;&gt;=" | ":"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1() { return cRightSquareBracketKeyword_1; }

		//"&lt;"
		public Keyword getLtKeyword_2() { return cLtKeyword_2; }

		//"&gt"
		public Keyword getGtKeyword_3() { return cGtKeyword_3; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }

		//"("
		public Keyword getLeftParenthesisKeyword_8() { return cLeftParenthesisKeyword_8; }

		//")"
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }

		//"?"
		public Keyword getQuestionMarkKeyword_10() { return cQuestionMarkKeyword_10; }

		//"!"
		public Keyword getExclamationMarkKeyword_11() { return cExclamationMarkKeyword_11; }

		//"*"
		public Keyword getAsteriskKeyword_12() { return cAsteriskKeyword_12; }

		//"%"
		public Keyword getPercentSignKeyword_13() { return cPercentSignKeyword_13; }

		//"/"
		public Keyword getSolidusKeyword_14() { return cSolidusKeyword_14; }

		//"+"
		public Keyword getPlusSignKeyword_15() { return cPlusSignKeyword_15; }

		//"-"
		public Keyword getHyphenMinusKeyword_16() { return cHyphenMinusKeyword_16; }

		//"++"
		public Keyword getPlusSignPlusSignKeyword_17() { return cPlusSignPlusSignKeyword_17; }

		//"--"
		public Keyword getHyphenMinusHyphenMinusKeyword_18() { return cHyphenMinusHyphenMinusKeyword_18; }

		//"&lt;&lt;"
		public Keyword getLtLtKeyword_19() { return cLtLtKeyword_19; }

		//"&gt;&gt"
		public Keyword getGtGtKeyword_20() { return cGtGtKeyword_20; }

		//"&lt;?"
		public Keyword getLtKeyword_21() { return cLtKeyword_21; }

		//"&gt;?"
		public Keyword getGtKeyword_22() { return cGtKeyword_22; }

		//"&lt;="
		public Keyword getLtKeyword_23() { return cLtKeyword_23; }

		//"&gt;="
		public Keyword getGtKeyword_24() { return cGtKeyword_24; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_25() { return cEqualsSignEqualsSignKeyword_25; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_26() { return cExclamationMarkEqualsSignKeyword_26; }

		//"&"
		public Keyword getAmpersandKeyword_27() { return cAmpersandKeyword_27; }

		//"&amp;"
		public Keyword getAmpKeyword_28() { return cAmpKeyword_28; }

		//"^"
		public Keyword getCircumflexAccentKeyword_29() { return cCircumflexAccentKeyword_29; }

		//"|"
		public Keyword getVerticalLineKeyword_30() { return cVerticalLineKeyword_30; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_31() { return cAmpersandAmpersandKeyword_31; }

		//"&amp;&amp;"
		public Keyword getAmpAmpKeyword_32() { return cAmpAmpKeyword_32; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_33() { return cVerticalLineVerticalLineKeyword_33; }

		//"="
		public Keyword getEqualsSignKeyword_34() { return cEqualsSignKeyword_34; }

		//"+="
		public Keyword getPlusSignEqualsSignKeyword_35() { return cPlusSignEqualsSignKeyword_35; }

		//"-="
		public Keyword getHyphenMinusEqualsSignKeyword_36() { return cHyphenMinusEqualsSignKeyword_36; }

		//"*="
		public Keyword getAsteriskEqualsSignKeyword_37() { return cAsteriskEqualsSignKeyword_37; }

		//"/="
		public Keyword getSolidusEqualsSignKeyword_38() { return cSolidusEqualsSignKeyword_38; }

		//"%="
		public Keyword getPercentSignEqualsSignKeyword_39() { return cPercentSignEqualsSignKeyword_39; }

		//"|="
		public Keyword getVerticalLineEqualsSignKeyword_40() { return cVerticalLineEqualsSignKeyword_40; }

		//"&="
		public Keyword getAmpersandEqualsSignKeyword_41() { return cAmpersandEqualsSignKeyword_41; }

		//"^="
		public Keyword getCircumflexAccentEqualsSignKeyword_42() { return cCircumflexAccentEqualsSignKeyword_42; }

		//"&lt;&lt;="
		public Keyword getLtLtKeyword_43() { return cLtLtKeyword_43; }

		//"&gt;&gt;="
		public Keyword getGtGtKeyword_44() { return cGtGtKeyword_44; }

		//":"
		public Keyword getColonKeyword_45() { return cColonKeyword_45; }
	}

	public class QUOTED_INTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QUOTED_INT");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Represents a quoted integer value of the form
		////   " -? [0-9]+ "
		//// The actual value is calculated via a value conversion.
		//QUOTED_INT returns ecore::EInt:
		//	STRING;
		public ParserRule getRule() { return rule; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}

	public class ANY_TOKEN_BUT_XML_CLOSEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_TOKEN_BUT_XML_CLOSE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cXML_KEYWORDSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cXML_ATTRIBUTE_KEYWORDSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cXML_STRUCTURE_KEYWORDSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUPPAAL_KEYWORDSParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cUPPAAL_STRUCTURE_KEYWORDSParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cSTRINGTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cIDTerminalRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cWSTerminalRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cANY_OTHERTerminalRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cINTTerminalRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cSINGLE_LINE_COMMENTTerminalRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cMULTI_LINE_COMMENTTerminalRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		//// Matches any token but the XML close token '</'. This is needed for parsing the
		//// contents of XML tags until the closing tag occurs.
		//ANY_TOKEN_BUT_XML_CLOSE:
		//	XML_KEYWORDS | XML_ATTRIBUTE_KEYWORDS | XML_STRUCTURE_KEYWORDS | UPPAAL_KEYWORDS | UPPAAL_STRUCTURE_KEYWORDS | STRING
		//	| ID | WS | ANY_OTHER | INT | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT;
		public ParserRule getRule() { return rule; }

		//XML_KEYWORDS | XML_ATTRIBUTE_KEYWORDS | XML_STRUCTURE_KEYWORDS | UPPAAL_KEYWORDS | UPPAAL_STRUCTURE_KEYWORDS | STRING |
		//ID | WS | ANY_OTHER | INT | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT
		public Alternatives getAlternatives() { return cAlternatives; }

		//XML_KEYWORDS
		public RuleCall getXML_KEYWORDSParserRuleCall_0() { return cXML_KEYWORDSParserRuleCall_0; }

		//XML_ATTRIBUTE_KEYWORDS
		public RuleCall getXML_ATTRIBUTE_KEYWORDSParserRuleCall_1() { return cXML_ATTRIBUTE_KEYWORDSParserRuleCall_1; }

		//XML_STRUCTURE_KEYWORDS
		public RuleCall getXML_STRUCTURE_KEYWORDSParserRuleCall_2() { return cXML_STRUCTURE_KEYWORDSParserRuleCall_2; }

		//UPPAAL_KEYWORDS
		public RuleCall getUPPAAL_KEYWORDSParserRuleCall_3() { return cUPPAAL_KEYWORDSParserRuleCall_3; }

		//UPPAAL_STRUCTURE_KEYWORDS
		public RuleCall getUPPAAL_STRUCTURE_KEYWORDSParserRuleCall_4() { return cUPPAAL_STRUCTURE_KEYWORDSParserRuleCall_4; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_5() { return cSTRINGTerminalRuleCall_5; }

		//ID
		public RuleCall getIDTerminalRuleCall_6() { return cIDTerminalRuleCall_6; }

		//WS
		public RuleCall getWSTerminalRuleCall_7() { return cWSTerminalRuleCall_7; }

		//ANY_OTHER
		public RuleCall getANY_OTHERTerminalRuleCall_8() { return cANY_OTHERTerminalRuleCall_8; }

		//INT
		public RuleCall getINTTerminalRuleCall_9() { return cINTTerminalRuleCall_9; }

		//SINGLE_LINE_COMMENT
		public RuleCall getSINGLE_LINE_COMMENTTerminalRuleCall_10() { return cSINGLE_LINE_COMMENTTerminalRuleCall_10; }

		//MULTI_LINE_COMMENT
		public RuleCall getMULTI_LINE_COMMENTTerminalRuleCall_11() { return cMULTI_LINE_COMMENTTerminalRuleCall_11; }
	}

	public class XML_STRUCTURE_KEYWORDSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XML_STRUCTURE_KEYWORDS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSolidusGreaterThanSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cXmlVersion10EncodingUtf8Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cXmlVersion10EncodingUtf8Keyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cDOCTYPENtaPUBLICUppaalTeamDTDFlatSystem11ENHttpWwwItUuSeResearchGroupDartsUppaalFlat1_1DtdKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//// Every token used outside of terminals must occur exactly once in one of the following rules!
		//XML_STRUCTURE_KEYWORDS:
		//	"<" | ">" | "/>" | "<?xml version=\"1.0\" encoding=\"utf-8\"?>" | "<?xml version=\'1.0\' encoding=\'utf-8\'?>" |
		//	"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>";
		public ParserRule getRule() { return rule; }

		//"<" | ">" | "/>" | "<?xml version=\"1.0\" encoding=\"utf-8\"?>" | "<?xml version=\'1.0\' encoding=\'utf-8\'?>" |
		//"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1() { return cGreaterThanSignKeyword_1; }

		//"/>"
		public Keyword getSolidusGreaterThanSignKeyword_2() { return cSolidusGreaterThanSignKeyword_2; }

		//"<?xml version=\"1.0\" encoding=\"utf-8\"?>"
		public Keyword getXmlVersion10EncodingUtf8Keyword_3() { return cXmlVersion10EncodingUtf8Keyword_3; }

		//"<?xml version=\'1.0\' encoding=\'utf-8\'?>"
		public Keyword getXmlVersion10EncodingUtf8Keyword_4() { return cXmlVersion10EncodingUtf8Keyword_4; }

		//"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>"
		public Keyword getDOCTYPENtaPUBLICUppaalTeamDTDFlatSystem11ENHttpWwwItUuSeResearchGroupDartsUppaalFlat1_1DtdKeyword_5() { return cDOCTYPENtaPUBLICUppaalTeamDTDFlatSystem11ENHttpWwwItUuSeResearchGroupDartsUppaalFlat1_1DtdKeyword_5; }
	}

	public class XML_CLOSE_KEYWORDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XML_CLOSE_KEYWORD");
		private final Keyword cLessThanSignSolidusKeyword = (Keyword)rule.eContents().get(1);
		
		//XML_CLOSE_KEYWORD:
		//	"</";
		public ParserRule getRule() { return rule; }

		//"</"
		public Keyword getLessThanSignSolidusKeyword() { return cLessThanSignSolidusKeyword; }
	}

	public class XML_KEYWORDSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XML_KEYWORDS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cImportsKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNtaKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTemplateKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cNameKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cRefKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLocationKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cIdKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cColorKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cTransitionKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cSourceKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cTargetKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cNailKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cLabelKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cKindKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cDeclarationKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cInstantiationKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cParameterKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cCommittedKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cXKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cYKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		
		//// Keywords that collide with UPPAAL_KEYWORDS
		//// 'init' | 'urgent' | 'system'
		//XML_KEYWORDS:
		//	"imports" | "nta" | "template" | "name" | "ref" | "location" | "id" | "color" | "transition" | "source" | "target" |
		//	"nail" | "label" | "kind" | "declaration" | "instantiation" | "parameter" | "committed" | "x" | "y";
		public ParserRule getRule() { return rule; }

		//"imports" | "nta" | "template" | "name" | "ref" | "location" | "id" | "color" | "transition" | "source" | "target" |
		//"nail" | "label" | "kind" | "declaration" | "instantiation" | "parameter" | "committed" | "x" | "y"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"imports"
		public Keyword getImportsKeyword_0() { return cImportsKeyword_0; }

		//"nta"
		public Keyword getNtaKeyword_1() { return cNtaKeyword_1; }

		//"template"
		public Keyword getTemplateKeyword_2() { return cTemplateKeyword_2; }

		//"name"
		public Keyword getNameKeyword_3() { return cNameKeyword_3; }

		//"ref"
		public Keyword getRefKeyword_4() { return cRefKeyword_4; }

		//"location"
		public Keyword getLocationKeyword_5() { return cLocationKeyword_5; }

		//"id"
		public Keyword getIdKeyword_6() { return cIdKeyword_6; }

		//"color"
		public Keyword getColorKeyword_7() { return cColorKeyword_7; }

		//"transition"
		public Keyword getTransitionKeyword_8() { return cTransitionKeyword_8; }

		//"source"
		public Keyword getSourceKeyword_9() { return cSourceKeyword_9; }

		//"target"
		public Keyword getTargetKeyword_10() { return cTargetKeyword_10; }

		//"nail"
		public Keyword getNailKeyword_11() { return cNailKeyword_11; }

		//"label"
		public Keyword getLabelKeyword_12() { return cLabelKeyword_12; }

		//"kind"
		public Keyword getKindKeyword_13() { return cKindKeyword_13; }

		//"declaration"
		public Keyword getDeclarationKeyword_14() { return cDeclarationKeyword_14; }

		//"instantiation"
		public Keyword getInstantiationKeyword_15() { return cInstantiationKeyword_15; }

		//"parameter"
		public Keyword getParameterKeyword_16() { return cParameterKeyword_16; }

		//"committed"
		public Keyword getCommittedKeyword_17() { return cCommittedKeyword_17; }

		//"x"
		public Keyword getXKeyword_18() { return cXKeyword_18; }

		//"y"
		public Keyword getYKeyword_19() { return cYKeyword_19; }
	}

	public class XML_ATTRIBUTE_KEYWORDSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XML_ATTRIBUTE_KEYWORDS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSynchronisationKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cGuardKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAssignmentKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cInvariantKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cCommentsKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//XML_ATTRIBUTE_KEYWORDS:
		//	"\"synchronisation\"" | "\"guard\"" | "\"assignment\"" | "\"invariant\"" | "\"comments\"";
		public ParserRule getRule() { return rule; }

		//"\"synchronisation\"" | "\"guard\"" | "\"assignment\"" | "\"invariant\"" | "\"comments\""
		public Alternatives getAlternatives() { return cAlternatives; }

		//"\"synchronisation\""
		public Keyword getSynchronisationKeyword_0() { return cSynchronisationKeyword_0; }

		//"\"guard\""
		public Keyword getGuardKeyword_1() { return cGuardKeyword_1; }

		//"\"assignment\""
		public Keyword getAssignmentKeyword_2() { return cAssignmentKeyword_2; }

		//"\"invariant\""
		public Keyword getInvariantKeyword_3() { return cInvariantKeyword_3; }

		//"\"comments\""
		public Keyword getCommentsKeyword_4() { return cCommentsKeyword_4; }
	}
	
	
	public class LocationKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LocationKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cURGENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cURGENTUrgentKeyword_0_0 = (Keyword)cURGENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCOMMITEDEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCOMMITEDCommittedKeyword_1_0 = (Keyword)cCOMMITEDEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum LocationKind returns templates::LocationKind:
		//	URGENT="<urgent/>" | COMMITED="<committed/>";
		public EnumRule getRule() { return rule; }

		//URGENT="<urgent/>" | COMMITED="<committed/>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//URGENT="<urgent/>"
		public EnumLiteralDeclaration getURGENTEnumLiteralDeclaration_0() { return cURGENTEnumLiteralDeclaration_0; }

		//"<urgent/>"
		public Keyword getURGENTUrgentKeyword_0_0() { return cURGENTUrgentKeyword_0_0; }

		//COMMITED="<committed/>"
		public EnumLiteralDeclaration getCOMMITEDEnumLiteralDeclaration_1() { return cCOMMITEDEnumLiteralDeclaration_1; }

		//"<committed/>"
		public Keyword getCOMMITEDCommittedKeyword_1_0() { return cCOMMITEDCommittedKeyword_1_0; }
	}

	public class SynchronizationKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "SynchronizationKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSENDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSENDExclamationMarkKeyword_0_0 = (Keyword)cSENDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRECEIVEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRECEIVEQuestionMarkKeyword_1_0 = (Keyword)cRECEIVEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum SynchronizationKind returns templates::SynchronizationKind:
		//	SEND="!" | RECEIVE="?";
		public EnumRule getRule() { return rule; }

		//SEND="!" | RECEIVE="?"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SEND="!"
		public EnumLiteralDeclaration getSENDEnumLiteralDeclaration_0() { return cSENDEnumLiteralDeclaration_0; }

		//"!"
		public Keyword getSENDExclamationMarkKeyword_0_0() { return cSENDExclamationMarkKeyword_0_0; }

		//RECEIVE="?"
		public EnumLiteralDeclaration getRECEIVEEnumLiteralDeclaration_1() { return cRECEIVEEnumLiteralDeclaration_1; }

		//"?"
		public Keyword getRECEIVEQuestionMarkKeyword_1_0() { return cRECEIVEQuestionMarkKeyword_1_0; }
	}

	public class DataVariablePrefixElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "DataVariablePrefix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCONSTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCONSTConstKeyword_0_0 = (Keyword)cCONSTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMETAEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMETAMetaKeyword_1_0 = (Keyword)cMETAEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum DataVariablePrefix returns declarations::DataVariablePrefix:
		//	CONST="const" | META="meta";
		public EnumRule getRule() { return rule; }

		//CONST="const" | META="meta"
		public Alternatives getAlternatives() { return cAlternatives; }

		//CONST="const"
		public EnumLiteralDeclaration getCONSTEnumLiteralDeclaration_0() { return cCONSTEnumLiteralDeclaration_0; }

		//"const"
		public Keyword getCONSTConstKeyword_0_0() { return cCONSTConstKeyword_0_0; }

		//META="meta"
		public EnumLiteralDeclaration getMETAEnumLiteralDeclaration_1() { return cMETAEnumLiteralDeclaration_1; }

		//"meta"
		public Keyword getMETAMetaKeyword_1_0() { return cMETAMetaKeyword_1_0; }
	}

	public class CallTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "CallType");
		private final EnumLiteralDeclaration cCALL_BY_REFERENCEEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cCALL_BY_REFERENCEAmpKeyword_0 = (Keyword)cCALL_BY_REFERENCEEnumLiteralDeclaration.eContents().get(0);
		
		//enum CallType returns declarations::CallType:
		//	CALL_BY_REFERENCE="&amp;";
		public EnumRule getRule() { return rule; }

		//CALL_BY_REFERENCE="&amp;"
		public EnumLiteralDeclaration getCALL_BY_REFERENCEEnumLiteralDeclaration() { return cCALL_BY_REFERENCEEnumLiteralDeclaration; }

		//"&amp;"
		public Keyword getCALL_BY_REFERENCEAmpKeyword_0() { return cCALL_BY_REFERENCEAmpKeyword_0; }
	}

	public class QuantifierElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Quantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cUNIVERSALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cUNIVERSALForallKeyword_0_0 = (Keyword)cUNIVERSALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cEXISTENTIALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cEXISTENTIALExistsKeyword_1_0 = (Keyword)cEXISTENTIALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Quantifier returns expressions::Quantifier:
		//	UNIVERSAL="forall" | EXISTENTIAL="exists";
		public EnumRule getRule() { return rule; }

		//UNIVERSAL="forall" | EXISTENTIAL="exists"
		public Alternatives getAlternatives() { return cAlternatives; }

		//UNIVERSAL="forall"
		public EnumLiteralDeclaration getUNIVERSALEnumLiteralDeclaration_0() { return cUNIVERSALEnumLiteralDeclaration_0; }

		//"forall"
		public Keyword getUNIVERSALForallKeyword_0_0() { return cUNIVERSALForallKeyword_0_0; }

		//EXISTENTIAL="exists"
		public EnumLiteralDeclaration getEXISTENTIALEnumLiteralDeclaration_1() { return cEXISTENTIALEnumLiteralDeclaration_1; }

		//"exists"
		public Keyword getEXISTENTIALExistsKeyword_1_0() { return cEXISTENTIALExistsKeyword_1_0; }
	}

	public class LogicalOperator_OrImplyElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOperator_OrImply");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cOROrKeyword_0_0 = (Keyword)cOREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIMPLYEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIMPLYImplyKeyword_1_0 = (Keyword)cIMPLYEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum LogicalOperator_OrImply returns expressions::LogicalOperator:
		//	OR="or" | IMPLY="imply";
		public EnumRule getRule() { return rule; }

		//OR="or" | IMPLY="imply"
		public Alternatives getAlternatives() { return cAlternatives; }

		//OR="or"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_0() { return cOREnumLiteralDeclaration_0; }

		//"or"
		public Keyword getOROrKeyword_0_0() { return cOROrKeyword_0_0; }

		//IMPLY="imply"
		public EnumLiteralDeclaration getIMPLYEnumLiteralDeclaration_1() { return cIMPLYEnumLiteralDeclaration_1; }

		//"imply"
		public Keyword getIMPLYImplyKeyword_1_0() { return cIMPLYImplyKeyword_1_0; }
	}

	public class LogicalOperator_AndElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOperator_And");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDAndKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalOperator_And returns expressions::LogicalOperator:
		//	AND="and";
		public EnumRule getRule() { return rule; }

		//AND="and"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }

		//"and"
		public Keyword getANDAndKeyword_0() { return cANDAndKeyword_0; }
	}

	public class AssignmentOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cEQUALColonEqualsSignKeyword_1_0 = (Keyword)cEQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPLUS_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPLUS_EQUALPlusSignEqualsSignKeyword_2_0 = (Keyword)cPLUS_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMINUS_EQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0 = (Keyword)cMINUS_EQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cTIMES_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cTIMES_EQUALAsteriskEqualsSignKeyword_4_0 = (Keyword)cTIMES_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDE_EQUALEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cDIVIDE_EQUALSolidusEqualsSignKeyword_5_0 = (Keyword)cDIVIDE_EQUALEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cMODULO_EQUALEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cMODULO_EQUALPercentSignEqualsSignKeyword_6_0 = (Keyword)cMODULO_EQUALEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cBIT_OR_EQUALEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cBIT_OR_EQUALVerticalLineEqualsSignKeyword_7_0 = (Keyword)cBIT_OR_EQUALEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cBIT_AND_EQUALEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cBIT_AND_EQUALAmpersandEqualsSignKeyword_8_0 = (Keyword)cBIT_AND_EQUALEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cBIT_XOR_EQUALEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cBIT_XOR_EQUALCircumflexAccentEqualsSignKeyword_9_0 = (Keyword)cBIT_XOR_EQUALEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cBIT_LEFT_EQUALEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cBIT_LEFT_EQUALLtLtKeyword_10_0 = (Keyword)cBIT_LEFT_EQUALEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cBIT_RIGHT_EQUALEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cBIT_RIGHT_EQUALGtGtKeyword_11_0 = (Keyword)cBIT_RIGHT_EQUALEnumLiteralDeclaration_11.eContents().get(0);
		
		//enum AssignmentOperator returns expressions::AssignmentOperator:
		//	EQUAL="=" | EQUAL=":=" | PLUS_EQUAL="+=" | MINUS_EQUAL="-=" | TIMES_EQUAL="*=" | DIVIDE_EQUAL="/=" |
		//	MODULO_EQUAL="%=" | BIT_OR_EQUAL="|=" | BIT_AND_EQUAL="&=" | BIT_XOR_EQUAL="^=" | BIT_LEFT_EQUAL="&lt;&lt;=" |
		//	BIT_RIGHT_EQUAL="&gt;&gt;=";
		public EnumRule getRule() { return rule; }

		//EQUAL="=" | EQUAL=":=" | PLUS_EQUAL="+=" | MINUS_EQUAL="-=" | TIMES_EQUAL="*=" | DIVIDE_EQUAL="/=" | MODULO_EQUAL="%=" |
		//BIT_OR_EQUAL="|=" | BIT_AND_EQUAL="&=" | BIT_XOR_EQUAL="^=" | BIT_LEFT_EQUAL="&lt;&lt;=" | BIT_RIGHT_EQUAL="&gt;&gt;="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL="="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }

		//"="
		public Keyword getEQUALEqualsSignKeyword_0_0() { return cEQUALEqualsSignKeyword_0_0; }

		//EQUAL=":="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_1() { return cEQUALEnumLiteralDeclaration_1; }

		//":="
		public Keyword getEQUALColonEqualsSignKeyword_1_0() { return cEQUALColonEqualsSignKeyword_1_0; }

		//PLUS_EQUAL="+="
		public EnumLiteralDeclaration getPLUS_EQUALEnumLiteralDeclaration_2() { return cPLUS_EQUALEnumLiteralDeclaration_2; }

		//"+="
		public Keyword getPLUS_EQUALPlusSignEqualsSignKeyword_2_0() { return cPLUS_EQUALPlusSignEqualsSignKeyword_2_0; }

		//MINUS_EQUAL="-="
		public EnumLiteralDeclaration getMINUS_EQUALEnumLiteralDeclaration_3() { return cMINUS_EQUALEnumLiteralDeclaration_3; }

		//"-="
		public Keyword getMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0() { return cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0; }

		//TIMES_EQUAL="*="
		public EnumLiteralDeclaration getTIMES_EQUALEnumLiteralDeclaration_4() { return cTIMES_EQUALEnumLiteralDeclaration_4; }

		//"*="
		public Keyword getTIMES_EQUALAsteriskEqualsSignKeyword_4_0() { return cTIMES_EQUALAsteriskEqualsSignKeyword_4_0; }

		//DIVIDE_EQUAL="/="
		public EnumLiteralDeclaration getDIVIDE_EQUALEnumLiteralDeclaration_5() { return cDIVIDE_EQUALEnumLiteralDeclaration_5; }

		//"/="
		public Keyword getDIVIDE_EQUALSolidusEqualsSignKeyword_5_0() { return cDIVIDE_EQUALSolidusEqualsSignKeyword_5_0; }

		//MODULO_EQUAL="%="
		public EnumLiteralDeclaration getMODULO_EQUALEnumLiteralDeclaration_6() { return cMODULO_EQUALEnumLiteralDeclaration_6; }

		//"%="
		public Keyword getMODULO_EQUALPercentSignEqualsSignKeyword_6_0() { return cMODULO_EQUALPercentSignEqualsSignKeyword_6_0; }

		//BIT_OR_EQUAL="|="
		public EnumLiteralDeclaration getBIT_OR_EQUALEnumLiteralDeclaration_7() { return cBIT_OR_EQUALEnumLiteralDeclaration_7; }

		//"|="
		public Keyword getBIT_OR_EQUALVerticalLineEqualsSignKeyword_7_0() { return cBIT_OR_EQUALVerticalLineEqualsSignKeyword_7_0; }

		//BIT_AND_EQUAL="&="
		public EnumLiteralDeclaration getBIT_AND_EQUALEnumLiteralDeclaration_8() { return cBIT_AND_EQUALEnumLiteralDeclaration_8; }

		//"&="
		public Keyword getBIT_AND_EQUALAmpersandEqualsSignKeyword_8_0() { return cBIT_AND_EQUALAmpersandEqualsSignKeyword_8_0; }

		//BIT_XOR_EQUAL="^="
		public EnumLiteralDeclaration getBIT_XOR_EQUALEnumLiteralDeclaration_9() { return cBIT_XOR_EQUALEnumLiteralDeclaration_9; }

		//"^="
		public Keyword getBIT_XOR_EQUALCircumflexAccentEqualsSignKeyword_9_0() { return cBIT_XOR_EQUALCircumflexAccentEqualsSignKeyword_9_0; }

		//BIT_LEFT_EQUAL="&lt;&lt;="
		public EnumLiteralDeclaration getBIT_LEFT_EQUALEnumLiteralDeclaration_10() { return cBIT_LEFT_EQUALEnumLiteralDeclaration_10; }

		//"&lt;&lt;="
		public Keyword getBIT_LEFT_EQUALLtLtKeyword_10_0() { return cBIT_LEFT_EQUALLtLtKeyword_10_0; }

		//BIT_RIGHT_EQUAL="&gt;&gt;="
		public EnumLiteralDeclaration getBIT_RIGHT_EQUALEnumLiteralDeclaration_11() { return cBIT_RIGHT_EQUALEnumLiteralDeclaration_11; }

		//"&gt;&gt;="
		public Keyword getBIT_RIGHT_EQUALGtGtKeyword_11_0() { return cBIT_RIGHT_EQUALGtGtKeyword_11_0; }
	}

	public class LogicalOperator_OrAlternativeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOperator_OrAlternative");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORVerticalLineVerticalLineKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalOperator_OrAlternative returns expressions::LogicalOperator:
		//	OR="||";
		public EnumRule getRule() { return rule; }

		//OR="||"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }

		//"||"
		public Keyword getORVerticalLineVerticalLineKeyword_0() { return cORVerticalLineVerticalLineKeyword_0; }
	}

	public class LogicalOperator_AndAlternativeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOperator_AndAlternative");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDAmpAmpKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalOperator_AndAlternative returns expressions::LogicalOperator:
		//	AND="&amp;&amp;";
		public EnumRule getRule() { return rule; }

		//AND="&amp;&amp;"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }

		//"&amp;&amp;"
		public Keyword getANDAmpAmpKeyword_0() { return cANDAmpAmpKeyword_0; }
	}

	public class BitwiseOperator_OrElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseOperator_Or");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORVerticalLineKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum BitwiseOperator_Or returns expressions::BitwiseOperator:
		//	OR="|";
		public EnumRule getRule() { return rule; }

		//OR="|"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }

		//"|"
		public Keyword getORVerticalLineKeyword_0() { return cORVerticalLineKeyword_0; }
	}

	public class BitwiseOperator_XorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseOperator_Xor");
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cXORCircumflexAccentKeyword_0 = (Keyword)cXOREnumLiteralDeclaration.eContents().get(0);
		
		//enum BitwiseOperator_Xor returns expressions::BitwiseOperator:
		//	XOR="^";
		public EnumRule getRule() { return rule; }

		//XOR="^"
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration() { return cXOREnumLiteralDeclaration; }

		//"^"
		public Keyword getXORCircumflexAccentKeyword_0() { return cXORCircumflexAccentKeyword_0; }
	}

	public class BitwiseOperator_AndElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseOperator_And");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDAmpKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum BitwiseOperator_And returns expressions::BitwiseOperator:
		//	AND="&amp;";
		public EnumRule getRule() { return rule; }

		//AND="&amp;"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }

		//"&amp;"
		public Keyword getANDAmpKeyword_0() { return cANDAmpKeyword_0; }
	}

	public class CompareOperator_EqualUnequalElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "CompareOperator_EqualUnequal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUNEQUALExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum CompareOperator_EqualUnequal returns expressions::CompareOperator:
		//	EQUAL="==" | UNEQUAL="!=";
		public EnumRule getRule() { return rule; }

		//EQUAL="==" | UNEQUAL="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL="=="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQUALEqualsSignEqualsSignKeyword_0_0() { return cEQUALEqualsSignEqualsSignKeyword_0_0; }

		//UNEQUAL="!="
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_1() { return cUNEQUALEnumLiteralDeclaration_1; }

		//"!="
		public Keyword getUNEQUALExclamationMarkEqualsSignKeyword_1_0() { return cUNEQUALExclamationMarkEqualsSignKeyword_1_0; }
	}

	public class CompareOperator_OtherElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "CompareOperator_Other");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGREATERGtKeyword_0_0 = (Keyword)cGREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATER_OR_EQUALGtKeyword_1_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLESSLtKeyword_2_0 = (Keyword)cLESSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESS_OR_EQUALLtKeyword_3_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum CompareOperator_Other returns expressions::CompareOperator:
		//	GREATER="&gt;" | GREATER_OR_EQUAL="&gt;=" | LESS="&lt;" | LESS_OR_EQUAL="&lt;=";
		public EnumRule getRule() { return rule; }

		//GREATER="&gt;" | GREATER_OR_EQUAL="&gt;=" | LESS="&lt;" | LESS_OR_EQUAL="&lt;="
		public Alternatives getAlternatives() { return cAlternatives; }

		//GREATER="&gt;"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_0() { return cGREATEREnumLiteralDeclaration_0; }

		//"&gt;"
		public Keyword getGREATERGtKeyword_0_0() { return cGREATERGtKeyword_0_0; }

		//GREATER_OR_EQUAL="&gt;="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_1() { return cGREATER_OR_EQUALEnumLiteralDeclaration_1; }

		//"&gt;="
		public Keyword getGREATER_OR_EQUALGtKeyword_1_0() { return cGREATER_OR_EQUALGtKeyword_1_0; }

		//LESS="&lt;"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_2() { return cLESSEnumLiteralDeclaration_2; }

		//"&lt;"
		public Keyword getLESSLtKeyword_2_0() { return cLESSLtKeyword_2_0; }

		//LESS_OR_EQUAL="&lt;="
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_3() { return cLESS_OR_EQUALEnumLiteralDeclaration_3; }

		//"&lt;="
		public Keyword getLESS_OR_EQUALLtKeyword_3_0() { return cLESS_OR_EQUALLtKeyword_3_0; }
	}

	public class MinMaxOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MinMaxOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINLtKeyword_0_0 = (Keyword)cMINEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMAXEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMAXGtKeyword_1_0 = (Keyword)cMAXEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MinMaxOperator returns expressions::MinMaxOperator:
		//	MIN="&lt;?" | MAX="&gt;?";
		public EnumRule getRule() { return rule; }

		//MIN="&lt;?" | MAX="&gt;?"
		public Alternatives getAlternatives() { return cAlternatives; }

		//MIN="&lt;?"
		public EnumLiteralDeclaration getMINEnumLiteralDeclaration_0() { return cMINEnumLiteralDeclaration_0; }

		//"&lt;?"
		public Keyword getMINLtKeyword_0_0() { return cMINLtKeyword_0_0; }

		//MAX="&gt;?"
		public EnumLiteralDeclaration getMAXEnumLiteralDeclaration_1() { return cMAXEnumLiteralDeclaration_1; }

		//"&gt;?"
		public Keyword getMAXGtKeyword_1_0() { return cMAXGtKeyword_1_0; }
	}

	public class BitShiftOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BitShiftOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLEFTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLEFTLtLtKeyword_0_0 = (Keyword)cLEFTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRIGHTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRIGHTGtGtKeyword_1_0 = (Keyword)cRIGHTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BitShiftOperator returns expressions::BitShiftOperator:
		//	LEFT="&lt;&lt;" | RIGHT="&gt;&gt";
		public EnumRule getRule() { return rule; }

		//LEFT="&lt;&lt;" | RIGHT="&gt;&gt"
		public Alternatives getAlternatives() { return cAlternatives; }

		//LEFT="&lt;&lt;"
		public EnumLiteralDeclaration getLEFTEnumLiteralDeclaration_0() { return cLEFTEnumLiteralDeclaration_0; }

		//"&lt;&lt;"
		public Keyword getLEFTLtLtKeyword_0_0() { return cLEFTLtLtKeyword_0_0; }

		//RIGHT="&gt;&gt"
		public EnumLiteralDeclaration getRIGHTEnumLiteralDeclaration_1() { return cRIGHTEnumLiteralDeclaration_1; }

		//"&gt;&gt"
		public Keyword getRIGHTGtGtKeyword_1_0() { return cRIGHTGtGtKeyword_1_0; }
	}

	public class ArithmeticOperator_PlusMinusElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticOperator_PlusMinus");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cADDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cADDPlusSignKeyword_0_0 = (Keyword)cADDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUBTRACTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUBTRACTHyphenMinusKeyword_1_0 = (Keyword)cSUBTRACTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ArithmeticOperator_PlusMinus returns expressions::ArithmeticOperator:
		//	ADD="+" | SUBTRACT="-";
		public EnumRule getRule() { return rule; }

		//ADD="+" | SUBTRACT="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ADD="+"
		public EnumLiteralDeclaration getADDEnumLiteralDeclaration_0() { return cADDEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getADDPlusSignKeyword_0_0() { return cADDPlusSignKeyword_0_0; }

		//SUBTRACT="-"
		public EnumLiteralDeclaration getSUBTRACTEnumLiteralDeclaration_1() { return cSUBTRACTEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getSUBTRACTHyphenMinusKeyword_1_0() { return cSUBTRACTHyphenMinusKeyword_1_0; }
	}

	public class ArithmeticOperator_OtherElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticOperator_Other");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULTIPLICATEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULTIPLICATEAsteriskKeyword_0_0 = (Keyword)cMULTIPLICATEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVIDESolidusKeyword_1_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODULOEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODULOPercentSignKeyword_2_0 = (Keyword)cMODULOEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ArithmeticOperator_Other returns expressions::ArithmeticOperator:
		//	MULTIPLICATE="*" | DIVIDE="/" | MODULO="%";
		public EnumRule getRule() { return rule; }

		//MULTIPLICATE="*" | DIVIDE="/" | MODULO="%"
		public Alternatives getAlternatives() { return cAlternatives; }

		//MULTIPLICATE="*"
		public EnumLiteralDeclaration getMULTIPLICATEEnumLiteralDeclaration_0() { return cMULTIPLICATEEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getMULTIPLICATEAsteriskKeyword_0_0() { return cMULTIPLICATEAsteriskKeyword_0_0; }

		//DIVIDE="/"
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_1() { return cDIVIDEEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDIVIDESolidusKeyword_1_0() { return cDIVIDESolidusKeyword_1_0; }

		//MODULO="%"
		public EnumLiteralDeclaration getMODULOEnumLiteralDeclaration_2() { return cMODULOEnumLiteralDeclaration_2; }

		//"%"
		public Keyword getMODULOPercentSignKeyword_2_0() { return cMODULOPercentSignKeyword_2_0; }
	}

	public class IncrementDecrementOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "IncrementDecrementOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum IncrementDecrementOperator returns expressions::IncrementDecrementOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}
	
	private final NTAElements pNTA;
	private final TemplateElements pTemplate;
	private final LocationElements pLocation;
	private final LocationKindElements unknownRuleLocationKind;
	private final EdgeElements pEdge;
	private final CommentLabelElements pCommentLabel;
	private final SynchronizationLabelElements pSynchronizationLabel;
	private final SynchronizationKindElements unknownRuleSynchronizationKind;
	private final PointElements pPoint;
	private final SelectionElements pSelection;
	private final GlobalDeclarationsElements pGlobalDeclarations;
	private final LocalDeclarationsElements pLocalDeclarations;
	private final SystemDeclarationsElements pSystemDeclarations;
	private final ProgressMeasureElements pProgressMeasure;
	private final TemplateDeclarationElements pTemplateDeclaration;
	private final RedefinedTemplateElements pRedefinedTemplate;
	private final SystemElements pSystem;
	private final InstantiationListElements pInstantiationList;
	private final TypedDeclarationElements pTypedDeclaration;
	private final TypedElementElements pTypedElement;
	private final VariableNameOnlyElements pVariableNameOnly;
	private final VariableElements pVariable;
	private final InitializerElements pInitializer;
	private final ExpressionInitializerElements pExpressionInitializer;
	private final ArrayInitializerElements pArrayInitializer;
	private final TypeExpressionElements pTypeExpression;
	private final ChannelPrefixExpressionElements pChannelPrefixExpression;
	private final CHAN_KEYWORDElements pCHAN_KEYWORD;
	private final ChannelPrefixExpression_UrgentElements pChannelPrefixExpression_Urgent;
	private final ChannelPrefixExpression_BroadcastElements pChannelPrefixExpression_Broadcast;
	private final DataPrefixExpressionElements pDataPrefixExpression;
	private final DataVariablePrefixElements unknownRuleDataVariablePrefix;
	private final RangeTypeSpecificationElements pRangeTypeSpecification;
	private final IntegerBoundsElements pIntegerBounds;
	private final StructTypeSpecificationElements pStructTypeSpecification;
	private final ScalarTypeSpecificationElements pScalarTypeSpecification;
	private final TypeDeclarationElements pTypeDeclaration;
	private final DeclaredTypeElements pDeclaredType;
	private final ChannelPriorityDeclarationElements pChannelPriorityDeclaration;
	private final ChannelPriorityGroupElements pChannelPriorityGroup;
	private final PriorityItemElements pPriorityItem;
	private final DefaultItemElements pDefaultItem;
	private final ChannelItemElements pChannelItem;
	private final FunctionElements pFunction;
	private final ParameterContainerElements pParameterContainer;
	private final ParameterElements pParameter;
	private final CallTypeElements unknownRuleCallType;
	private final StatementElements pStatement;
	private final BlockElements pBlock;
	private final BlockDeclarationsElements pBlockDeclarations;
	private final BlockTypedDeclarationElements pBlockTypedDeclaration;
	private final EmptyStatementElements pEmptyStatement;
	private final ExpressionStatementElements pExpressionStatement;
	private final ForLoopElements pForLoop;
	private final IterationElements pIteration;
	private final WhileLoopElements pWhileLoop;
	private final DoWhileLoopElements pDoWhileLoop;
	private final IfStatementElements pIfStatement;
	private final ReturnStatementElements pReturnStatement;
	private final ExpressionElements pExpression;
	private final QuantificationExpressionElements pQuantificationExpression;
	private final QuantifierElements unknownRuleQuantifier;
	private final LogicalExpression_OrImplyElements pLogicalExpression_OrImply;
	private final LogicalOperator_OrImplyElements unknownRuleLogicalOperator_OrImply;
	private final LogicalExpression_AndElements pLogicalExpression_And;
	private final LogicalOperator_AndElements unknownRuleLogicalOperator_And;
	private final NegationExpressionElements pNegationExpression;
	private final AssignmentExpressionElements pAssignmentExpression;
	private final AssignmentOperatorElements unknownRuleAssignmentOperator;
	private final ConditionExpressionElements pConditionExpression;
	private final LogicalExpression_OrAlternativeElements pLogicalExpression_OrAlternative;
	private final LogicalOperator_OrAlternativeElements unknownRuleLogicalOperator_OrAlternative;
	private final LogicalExpression_AndAlternativeElements pLogicalExpression_AndAlternative;
	private final LogicalOperator_AndAlternativeElements unknownRuleLogicalOperator_AndAlternative;
	private final BitwiseExpression_OrElements pBitwiseExpression_Or;
	private final BitwiseOperator_OrElements unknownRuleBitwiseOperator_Or;
	private final BitwiseExpression_XorElements pBitwiseExpression_Xor;
	private final BitwiseOperator_XorElements unknownRuleBitwiseOperator_Xor;
	private final BitwiseExpression_AndElements pBitwiseExpression_And;
	private final BitwiseOperator_AndElements unknownRuleBitwiseOperator_And;
	private final CompareExpression_EqualUnequalElements pCompareExpression_EqualUnequal;
	private final CompareOperator_EqualUnequalElements unknownRuleCompareOperator_EqualUnequal;
	private final CompareExpression_OtherElements pCompareExpression_Other;
	private final CompareOperator_OtherElements unknownRuleCompareOperator_Other;
	private final MinMaxExpressionElements pMinMaxExpression;
	private final MinMaxOperatorElements unknownRuleMinMaxOperator;
	private final BitShiftExpressionElements pBitShiftExpression;
	private final BitShiftOperatorElements unknownRuleBitShiftOperator;
	private final ArithmeticExpression_PlusMinusElements pArithmeticExpression_PlusMinus;
	private final ArithmeticOperator_PlusMinusElements unknownRuleArithmeticOperator_PlusMinus;
	private final ArithmeticExpression_OtherElements pArithmeticExpression_Other;
	private final ArithmeticOperator_OtherElements unknownRuleArithmeticOperator_Other;
	private final NegationExpression_AlternativeElements pNegationExpression_Alternative;
	private final PlusExpressionElements pPlusExpression;
	private final MinusExpressionElements pMinusExpression;
	private final PreIncrementDecrementExpressionElements pPreIncrementDecrementExpression;
	private final PostIncrementDecrementExpressionElements pPostIncrementDecrementExpression;
	private final IncrementDecrementOperatorElements unknownRuleIncrementDecrementOperator;
	private final ScopedIdentifierExpressionElements pScopedIdentifierExpression;
	private final TerminatingExpressionsElements pTerminatingExpressions;
	private final LiteralExpressionElements pLiteralExpression;
	private final LiteralExpressionTextElements pLiteralExpressionText;
	private final FunctionCallExpressionElements pFunctionCallExpression;
	private final IdentifierExpressionElements pIdentifierExpression;
	private final SimpleIdentifierExpressionElements pSimpleIdentifierExpression;
	private final UPPAAL_TYPE_OR_IDENTIFIERElements pUPPAAL_TYPE_OR_IDENTIFIER;
	private final UPPAAL_IDENTIFIERElements pUPPAAL_IDENTIFIER;
	private final UPPAAL_KEYWORDSElements pUPPAAL_KEYWORDS;
	private final UPPAAL_STRUCTURE_KEYWORDSElements pUPPAAL_STRUCTURE_KEYWORDS;
	private final QUOTED_INTElements pQUOTED_INT;
	private final ANY_TOKEN_BUT_XML_CLOSEElements pANY_TOKEN_BUT_XML_CLOSE;
	private final XML_STRUCTURE_KEYWORDSElements pXML_STRUCTURE_KEYWORDS;
	private final XML_CLOSE_KEYWORDElements pXML_CLOSE_KEYWORD;
	private final XML_KEYWORDSElements pXML_KEYWORDS;
	private final XML_ATTRIBUTE_KEYWORDSElements pXML_ATTRIBUTE_KEYWORDS;
	private final TerminalRule tSTRING;
	private final TerminalRule tID;
	private final TerminalRule tINT;
	private final TerminalRule tSINGLE_LINE_COMMENT;
	private final TerminalRule tMULTI_LINE_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public UppaalXMLGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pNTA = new NTAElements();
		this.pTemplate = new TemplateElements();
		this.pLocation = new LocationElements();
		this.unknownRuleLocationKind = new LocationKindElements();
		this.pEdge = new EdgeElements();
		this.pCommentLabel = new CommentLabelElements();
		this.pSynchronizationLabel = new SynchronizationLabelElements();
		this.unknownRuleSynchronizationKind = new SynchronizationKindElements();
		this.pPoint = new PointElements();
		this.pSelection = new SelectionElements();
		this.pGlobalDeclarations = new GlobalDeclarationsElements();
		this.pLocalDeclarations = new LocalDeclarationsElements();
		this.pSystemDeclarations = new SystemDeclarationsElements();
		this.pProgressMeasure = new ProgressMeasureElements();
		this.pTemplateDeclaration = new TemplateDeclarationElements();
		this.pRedefinedTemplate = new RedefinedTemplateElements();
		this.pSystem = new SystemElements();
		this.pInstantiationList = new InstantiationListElements();
		this.pTypedDeclaration = new TypedDeclarationElements();
		this.pTypedElement = new TypedElementElements();
		this.pVariableNameOnly = new VariableNameOnlyElements();
		this.pVariable = new VariableElements();
		this.pInitializer = new InitializerElements();
		this.pExpressionInitializer = new ExpressionInitializerElements();
		this.pArrayInitializer = new ArrayInitializerElements();
		this.pTypeExpression = new TypeExpressionElements();
		this.pChannelPrefixExpression = new ChannelPrefixExpressionElements();
		this.pCHAN_KEYWORD = new CHAN_KEYWORDElements();
		this.pChannelPrefixExpression_Urgent = new ChannelPrefixExpression_UrgentElements();
		this.pChannelPrefixExpression_Broadcast = new ChannelPrefixExpression_BroadcastElements();
		this.pDataPrefixExpression = new DataPrefixExpressionElements();
		this.unknownRuleDataVariablePrefix = new DataVariablePrefixElements();
		this.pRangeTypeSpecification = new RangeTypeSpecificationElements();
		this.pIntegerBounds = new IntegerBoundsElements();
		this.pStructTypeSpecification = new StructTypeSpecificationElements();
		this.pScalarTypeSpecification = new ScalarTypeSpecificationElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pDeclaredType = new DeclaredTypeElements();
		this.pChannelPriorityDeclaration = new ChannelPriorityDeclarationElements();
		this.pChannelPriorityGroup = new ChannelPriorityGroupElements();
		this.pPriorityItem = new PriorityItemElements();
		this.pDefaultItem = new DefaultItemElements();
		this.pChannelItem = new ChannelItemElements();
		this.pFunction = new FunctionElements();
		this.pParameterContainer = new ParameterContainerElements();
		this.pParameter = new ParameterElements();
		this.unknownRuleCallType = new CallTypeElements();
		this.pStatement = new StatementElements();
		this.pBlock = new BlockElements();
		this.pBlockDeclarations = new BlockDeclarationsElements();
		this.pBlockTypedDeclaration = new BlockTypedDeclarationElements();
		this.pEmptyStatement = new EmptyStatementElements();
		this.pExpressionStatement = new ExpressionStatementElements();
		this.pForLoop = new ForLoopElements();
		this.pIteration = new IterationElements();
		this.pWhileLoop = new WhileLoopElements();
		this.pDoWhileLoop = new DoWhileLoopElements();
		this.pIfStatement = new IfStatementElements();
		this.pReturnStatement = new ReturnStatementElements();
		this.pExpression = new ExpressionElements();
		this.pQuantificationExpression = new QuantificationExpressionElements();
		this.unknownRuleQuantifier = new QuantifierElements();
		this.pLogicalExpression_OrImply = new LogicalExpression_OrImplyElements();
		this.unknownRuleLogicalOperator_OrImply = new LogicalOperator_OrImplyElements();
		this.pLogicalExpression_And = new LogicalExpression_AndElements();
		this.unknownRuleLogicalOperator_And = new LogicalOperator_AndElements();
		this.pNegationExpression = new NegationExpressionElements();
		this.pAssignmentExpression = new AssignmentExpressionElements();
		this.unknownRuleAssignmentOperator = new AssignmentOperatorElements();
		this.pConditionExpression = new ConditionExpressionElements();
		this.pLogicalExpression_OrAlternative = new LogicalExpression_OrAlternativeElements();
		this.unknownRuleLogicalOperator_OrAlternative = new LogicalOperator_OrAlternativeElements();
		this.pLogicalExpression_AndAlternative = new LogicalExpression_AndAlternativeElements();
		this.unknownRuleLogicalOperator_AndAlternative = new LogicalOperator_AndAlternativeElements();
		this.pBitwiseExpression_Or = new BitwiseExpression_OrElements();
		this.unknownRuleBitwiseOperator_Or = new BitwiseOperator_OrElements();
		this.pBitwiseExpression_Xor = new BitwiseExpression_XorElements();
		this.unknownRuleBitwiseOperator_Xor = new BitwiseOperator_XorElements();
		this.pBitwiseExpression_And = new BitwiseExpression_AndElements();
		this.unknownRuleBitwiseOperator_And = new BitwiseOperator_AndElements();
		this.pCompareExpression_EqualUnequal = new CompareExpression_EqualUnequalElements();
		this.unknownRuleCompareOperator_EqualUnequal = new CompareOperator_EqualUnequalElements();
		this.pCompareExpression_Other = new CompareExpression_OtherElements();
		this.unknownRuleCompareOperator_Other = new CompareOperator_OtherElements();
		this.pMinMaxExpression = new MinMaxExpressionElements();
		this.unknownRuleMinMaxOperator = new MinMaxOperatorElements();
		this.pBitShiftExpression = new BitShiftExpressionElements();
		this.unknownRuleBitShiftOperator = new BitShiftOperatorElements();
		this.pArithmeticExpression_PlusMinus = new ArithmeticExpression_PlusMinusElements();
		this.unknownRuleArithmeticOperator_PlusMinus = new ArithmeticOperator_PlusMinusElements();
		this.pArithmeticExpression_Other = new ArithmeticExpression_OtherElements();
		this.unknownRuleArithmeticOperator_Other = new ArithmeticOperator_OtherElements();
		this.pNegationExpression_Alternative = new NegationExpression_AlternativeElements();
		this.pPlusExpression = new PlusExpressionElements();
		this.pMinusExpression = new MinusExpressionElements();
		this.pPreIncrementDecrementExpression = new PreIncrementDecrementExpressionElements();
		this.pPostIncrementDecrementExpression = new PostIncrementDecrementExpressionElements();
		this.unknownRuleIncrementDecrementOperator = new IncrementDecrementOperatorElements();
		this.pScopedIdentifierExpression = new ScopedIdentifierExpressionElements();
		this.pTerminatingExpressions = new TerminatingExpressionsElements();
		this.pLiteralExpression = new LiteralExpressionElements();
		this.pLiteralExpressionText = new LiteralExpressionTextElements();
		this.pFunctionCallExpression = new FunctionCallExpressionElements();
		this.pIdentifierExpression = new IdentifierExpressionElements();
		this.pSimpleIdentifierExpression = new SimpleIdentifierExpressionElements();
		this.pUPPAAL_TYPE_OR_IDENTIFIER = new UPPAAL_TYPE_OR_IDENTIFIERElements();
		this.pUPPAAL_IDENTIFIER = new UPPAAL_IDENTIFIERElements();
		this.pUPPAAL_KEYWORDS = new UPPAAL_KEYWORDSElements();
		this.pUPPAAL_STRUCTURE_KEYWORDS = new UPPAAL_STRUCTURE_KEYWORDSElements();
		this.pQUOTED_INT = new QUOTED_INTElements();
		this.pANY_TOKEN_BUT_XML_CLOSE = new ANY_TOKEN_BUT_XML_CLOSEElements();
		this.pXML_STRUCTURE_KEYWORDS = new XML_STRUCTURE_KEYWORDSElements();
		this.pXML_CLOSE_KEYWORD = new XML_CLOSE_KEYWORDElements();
		this.pXML_KEYWORDS = new XML_KEYWORDSElements();
		this.pXML_ATTRIBUTE_KEYWORDS = new XML_ATTRIBUTE_KEYWORDSElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT");
		this.tSINGLE_LINE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SINGLE_LINE_COMMENT");
		this.tMULTI_LINE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MULTI_LINE_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.uni_paderborn.uppaal.UppaalXML".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	////---------------------------------------------------------------------------------------------------------------------------------
	//// XML STRUCTURE
	////---------------------------------------------------------------------------------------------------------------------------------
	//// Note on hidden terminals:
	//// Except for in the XML part comments are generally accepted ANYWHERE. That's
	//// why every rule referenced directly from any part of the XML rules (NTA, Template,
	//// Location, Edge) needs to be manually complemented with
	////   hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT)
	//// as otherwise the hidden(WS) thingy is inherited.
	//NTA returns uppaal::NTA hidden(WS):
	//	("<?xml version=\"1.0\" encoding=\"utf-8\"?>" | "<?xml version=\'1.0\' encoding=\'utf-8\'?>")
	//	"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>"
	//	"<" "nta" ">" // Imports are not used by UPPAAL currently (at least in 2004).
	//	// Source: https://groups.yahoo.com/neo/groups/uppaal/conversations/messages/546
	//	("<" "imports" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "imports" ">")* // Parse the global declarations.
	//	("<" "declaration" ">" globalDeclarations=GlobalDeclarations "</" "declaration" ">")? // Parse all the templates.
	//	("<" "template" ">" template+=Template "</" "template" ">")+ // Instantiation is not used by UPPAAL anymore.
	//	// TODO Support it either way for old files.
	//	("<" "instantiation" ">" ANY_TOKEN_BUT_XML_CLOSE* "</" "instantiation" ">")? // Parse the system declarations.
	//	"<" "system" ">" systemDeclarations=SystemDeclarations "</" "system" ">" "</" "nta" ">";
	public NTAElements getNTAAccess() {
		return pNTA;
	}
	
	public ParserRule getNTARule() {
		return getNTAAccess().getRule();
	}

	//Template returns templates::Template hidden(WS): // The name of the template might have x- and y-coordinates for some reason, they must be skipped.
	//	"<" "name" (("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">" // Template parameters.
	//	("<" "parameter" ">" (parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)? "</" "parameter" ">")? // Local declarations.
	//	("<" "declaration" ">" declarations=LocalDeclarations "</" "declaration" ">")? // Get all the locations.
	//	location+=Location+ // Reference the initial location.
	//	"<" "init" "ref" "=" init=[templates::Location|STRING] "/>" // Get the transitions.
	//	edge+=Edge*;
	public TemplateElements getTemplateAccess() {
		return pTemplate;
	}
	
	public ParserRule getTemplateRule() {
		return getTemplateAccess().getRule();
	}

	//Location returns parsable_templates::IdentifiableLocation hidden(WS):
	//	"<" "location" // Parse the attributes. 
	//	("id" "=" id=STRING & position=Point? & ("color" "=" colorCode=STRING)?) // Locations without any subelements and stuff are also allowed.
	//	("/>" | // Close the tag.
	//	">" // Get the name of the location.
	//	("<" "name" // Discard name location as there is no field for this.
	//	(("x" "=" STRING)? & ("y" "=" STRING)?) ">" name=ID "</" "name" ">")? // Parse the labels.
	//	(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
	//	comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"invariant\"" (("x" "=" STRING)? & ("y" "="
	//	STRING)? & ("color" "=" STRING)?) ">" invariant=Expression "</" "label" ">")?) // Check whether it is an urgent or committed location.
	//	locationTimeKind=LocationKind? "</" "location" ">");
	public LocationElements getLocationAccess() {
		return pLocation;
	}
	
	public ParserRule getLocationRule() {
		return getLocationAccess().getRule();
	}

	//enum LocationKind returns templates::LocationKind:
	//	URGENT="<urgent/>" | COMMITED="<committed/>";
	public LocationKindElements getLocationKindAccess() {
		return unknownRuleLocationKind;
	}
	
	public EnumRule getLocationKindRule() {
		return getLocationKindAccess().getRule();
	}

	//Edge returns templates::Edge hidden(WS): // Again skip the coordinates.
	//	"<" "transition" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" colorCode=STRING)?) ">" // Source...
	//	"<" "source" "ref" "=" source=[templates::Location|STRING] "/>" // Target...
	//	"<" "target" "ref" "=" target=[templates::Location|STRING] "/>" // Parse the labels.
	//	(("<" "label" "kind" "=" "\"comments\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
	//	comment=CommentLabel "</" "label" ">")? & ("<" "label" "kind" "=" "\"synchronisation\"" (("x" "=" STRING)? & ("y" "="
	//	STRING)? & ("color" "=" STRING)?) ">" synchronization=SynchronizationLabel "</" "label" ">")? & ("<" "label" "kind"
	//	"=" "\"guard\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" guard=Expression "</" "label"
	//	">")? & ("<" "label" "kind" "=" "\"assignment\"" (("x" "=" STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">"
	//	update+=Expression ("," update+=Expression)* "</" "label" ">")? & ("<" "label" "kind" "=" "\"select\"" (("x" "="
	//	STRING)? & ("y" "=" STRING)? & ("color" "=" STRING)?) ">" selection+=Selection ("," selection+=Selection)* "</"
	//	"label" ">")?) // Get the nails/bendPoints.
	//	("<" "nail" bendPoint+=Point "/>")* // Close the tag.
	//	"</" "transition" ">";
	public EdgeElements getEdgeAccess() {
		return pEdge;
	}
	
	public ParserRule getEdgeRule() {
		return getEdgeAccess().getRule();
	}

	//CommentLabel returns ecore::EString hidden(WS):
	//	ANY_TOKEN_BUT_XML_CLOSE*;
	public CommentLabelElements getCommentLabelAccess() {
		return pCommentLabel;
	}
	
	public ParserRule getCommentLabelRule() {
		return getCommentLabelAccess().getRule();
	}

	//SynchronizationLabel returns templates::Synchronization hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
	//	channelExpression=IdentifierExpression kind=SynchronizationKind;
	public SynchronizationLabelElements getSynchronizationLabelAccess() {
		return pSynchronizationLabel;
	}
	
	public ParserRule getSynchronizationLabelRule() {
		return getSynchronizationLabelAccess().getRule();
	}

	//enum SynchronizationKind returns templates::SynchronizationKind:
	//	SEND="!" | RECEIVE="?";
	public SynchronizationKindElements getSynchronizationKindAccess() {
		return unknownRuleSynchronizationKind;
	}
	
	public EnumRule getSynchronizationKindRule() {
		return getSynchronizationKindAccess().getRule();
	}

	//Point returns visuals::Point:
	//	{visuals::Point} (("x" "=" x=QUOTED_INT)? & ("y" "=" y=QUOTED_INT)?);
	public PointElements getPointAccess() {
		return pPoint;
	}
	
	public ParserRule getPointRule() {
		return getPointAccess().getRule();
	}

	//Selection returns templates::Selection hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
	//	elements+=VariableNameOnly ":" typeDefinition=(RangeTypeSpecification | ScalarTypeSpecification |
	//	SimpleIdentifierExpression);
	public SelectionElements getSelectionAccess() {
		return pSelection;
	}
	
	public ParserRule getSelectionRule() {
		return getSelectionAccess().getRule();
	}

	////---------------------------------------------------------------------------------------------------------------------------------
	//// DECLARATIONS & TYPES
	////---------------------------------------------------------------------------------------------------------------------------------
	//GlobalDeclarations returns declarations::GlobalDeclarations hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
	//	{declarations::GlobalDeclarations} (declaration+=(TypedDeclaration | TypeDeclaration) | // Problem: Channel priority is only allowed once by UPPAAL. So it is only
	//	// overwritten and the rule allows more input than UPPAAL normally would.
	//	channelPriority=ChannelPriorityDeclaration)*;
	public GlobalDeclarationsElements getGlobalDeclarationsAccess() {
		return pGlobalDeclarations;
	}
	
	public ParserRule getGlobalDeclarationsRule() {
		return getGlobalDeclarationsAccess().getRule();
	}

	//LocalDeclarations returns declarations::LocalDeclarations hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
	//	{declarations::LocalDeclarations} declaration+=(TypedDeclaration | TypeDeclaration)*;
	public LocalDeclarationsElements getLocalDeclarationsAccess() {
		return pLocalDeclarations;
	}
	
	public ParserRule getLocalDeclarationsRule() {
		return getLocalDeclarationsAccess().getRule();
	}

	//SystemDeclarations returns declarations::SystemDeclarations hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
	//	{declarations::SystemDeclarations} (declaration+=(TypedDeclaration | TypeDeclaration | TemplateDeclaration) | // Same problem as with the ChannelPriority above.
	//	system=System | progressMeasure=ProgressMeasure)*;
	public SystemDeclarationsElements getSystemDeclarationsAccess() {
		return pSystemDeclarations;
	}
	
	public ParserRule getSystemDeclarationsRule() {
		return getSystemDeclarationsAccess().getRule();
	}

	//ProgressMeasure returns system::ProgressMeasure:
	//	"progress" "{" (expression+=Expression ";")+ "}";
	public ProgressMeasureElements getProgressMeasureAccess() {
		return pProgressMeasure;
	}
	
	public ParserRule getProgressMeasureRule() {
		return getProgressMeasureAccess().getRule();
	}

	//TemplateDeclaration returns system::TemplateDeclaration:
	//	declaredTemplate=RedefinedTemplate "(" (argument+=Expression ("," argument+=Expression)*)? ")" ";";
	public TemplateDeclarationElements getTemplateDeclarationAccess() {
		return pTemplateDeclaration;
	}
	
	public ParserRule getTemplateDeclarationRule() {
		return getTemplateDeclarationAccess().getRule();
	}

	//RedefinedTemplate returns templates::RedefinedTemplate:
	//	name=UPPAAL_IDENTIFIER "=" referredTemplate=[templates::Template];
	public RedefinedTemplateElements getRedefinedTemplateAccess() {
		return pRedefinedTemplate;
	}
	
	public ParserRule getRedefinedTemplateRule() {
		return getRedefinedTemplateAccess().getRule();
	}

	//System returns system::System:
	//	"system" instantiationList+=InstantiationList ("&lt;" instantiationList+=InstantiationList)* ";";
	public SystemElements getSystemAccess() {
		return pSystem;
	}
	
	public ParserRule getSystemRule() {
		return getSystemAccess().getRule();
	}

	//InstantiationList returns system::InstantiationList:
	//	template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER] (","
	//	template+=[templates::AbstractTemplate|UPPAAL_IDENTIFIER])*;
	public InstantiationListElements getInstantiationListAccess() {
		return pInstantiationList;
	}
	
	public ParserRule getInstantiationListRule() {
		return getInstantiationListAccess().getRule();
	}

	//TypedDeclaration returns declarations::TypedDeclaration:
	//	typeDefinition=TypeExpression (elements+=Function | elements+=Variable ("," elements+=Variable)* ";");
	public TypedDeclarationElements getTypedDeclarationAccess() {
		return pTypedDeclaration;
	}
	
	public ParserRule getTypedDeclarationRule() {
		return getTypedDeclarationAccess().getRule();
	}

	//TypedElement returns declarations::TypedDeclaration: //	ChannelVariableDeclaration | ClockVariableDeclaration | DataVariableDeclaration
	////(prefix=DataVariablePrefix)? 
	//	typeDefinition=TypeExpression elements+=Variable ("," elements+=Variable)*;
	public TypedElementElements getTypedElementAccess() {
		return pTypedElement;
	}
	
	public ParserRule getTypedElementRule() {
		return getTypedElementAccess().getRule();
	}

	//VariableNameOnly returns declarations::Variable:
	//	name=UPPAAL_IDENTIFIER;
	public VariableNameOnlyElements getVariableNameOnlyAccess() {
		return pVariableNameOnly;
	}
	
	public ParserRule getVariableNameOnlyRule() {
		return getVariableNameOnlyAccess().getRule();
	}

	//Variable returns declarations::Variable:
	//	name=UPPAAL_IDENTIFIER // Problem:
	//	// TypeIndex can be a reference to a Type
	//	//   [types::Type|TYPE_REFERENCE]
	//	// while ValueIndex might be a reference to a variable
	//	//   [core::NamedElement|UPPAAL_IDENTIFIER]
	//	// These two rules collide as TYPE_REFERENCE and UPPAAL_IDENTIFIER
	//	// might be ID. In that case we want a Type, though, as references
	//	// to variables are not even allowed here.
	//	// The syntactic predicate => tells ANTLR to favour the first rule.
	//	("[" index+=(Expression | ScalarTypeSpecification) "]")* ("=" initializer=Initializer)?;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//Initializer returns declarations::Initializer:
	//	ArrayInitializer | ExpressionInitializer;
	public InitializerElements getInitializerAccess() {
		return pInitializer;
	}
	
	public ParserRule getInitializerRule() {
		return getInitializerAccess().getRule();
	}

	//ExpressionInitializer returns declarations::ExpressionInitializer:
	//	expression=Expression;
	public ExpressionInitializerElements getExpressionInitializerAccess() {
		return pExpressionInitializer;
	}
	
	public ParserRule getExpressionInitializerRule() {
		return getExpressionInitializerAccess().getRule();
	}

	//ArrayInitializer returns declarations::ArrayInitializer:
	//	"{" initializer+=Initializer ("," initializer+=Initializer)* "}";
	public ArrayInitializerElements getArrayInitializerAccess() {
		return pArrayInitializer;
	}
	
	public ParserRule getArrayInitializerRule() {
		return getArrayInitializerAccess().getRule();
	}

	//TypeExpression returns expressions::Expression:
	//	RangeTypeSpecification | ScalarTypeSpecification | StructTypeSpecification | SimpleIdentifierExpression |
	//	ChannelPrefixExpression | DataPrefixExpression;
	public TypeExpressionElements getTypeExpressionAccess() {
		return pTypeExpression;
	}
	
	public ParserRule getTypeExpressionRule() {
		return getTypeExpressionAccess().getRule();
	}

	//ChannelPrefixExpression returns expressions::ChannelPrefixExpression:
	//	(urgent=ChannelPrefixExpression_Urgent broadcast=ChannelPrefixExpression_Broadcast? // Explanation on the strange construction using the DataType
	//	// rules for urgent and broadcast:
	//	// If 'chan' occurs isolated, a SimpleIdentifierExpression should
	//	// be parsed. So in order for the parser to decide for this rule,
	//	// either 'urgent' or 'broadcast' MUST be consumed. This is not
	//	// possible to do with something like urgent?='urgent' and unordered
	//	// lists. This is why a rule is introduced for these cases and a
	//	// custom value converter returns the appropriate bool value.
	//	| broadcast=ChannelPrefixExpression_Broadcast urgent=ChannelPrefixExpression_Urgent?)
	//	channelType=[types::Type|CHAN_KEYWORD];
	public ChannelPrefixExpressionElements getChannelPrefixExpressionAccess() {
		return pChannelPrefixExpression;
	}
	
	public ParserRule getChannelPrefixExpressionRule() {
		return getChannelPrefixExpressionAccess().getRule();
	}

	//CHAN_KEYWORD:
	//	"chan";
	public CHAN_KEYWORDElements getCHAN_KEYWORDAccess() {
		return pCHAN_KEYWORD;
	}
	
	public ParserRule getCHAN_KEYWORDRule() {
		return getCHAN_KEYWORDAccess().getRule();
	}

	//ChannelPrefixExpression_Urgent returns ecore::EBoolean:
	//	"urgent";
	public ChannelPrefixExpression_UrgentElements getChannelPrefixExpression_UrgentAccess() {
		return pChannelPrefixExpression_Urgent;
	}
	
	public ParserRule getChannelPrefixExpression_UrgentRule() {
		return getChannelPrefixExpression_UrgentAccess().getRule();
	}

	//ChannelPrefixExpression_Broadcast returns ecore::EBoolean:
	//	"broadcast";
	public ChannelPrefixExpression_BroadcastElements getChannelPrefixExpression_BroadcastAccess() {
		return pChannelPrefixExpression_Broadcast;
	}
	
	public ParserRule getChannelPrefixExpression_BroadcastRule() {
		return getChannelPrefixExpression_BroadcastAccess().getRule();
	}

	//DataPrefixExpression returns expressions::DataPrefixExpression:
	//	prefix=DataVariablePrefix dataTypeExpression=(RangeTypeSpecification | ScalarTypeSpecification |
	//	StructTypeSpecification | SimpleIdentifierExpression);
	public DataPrefixExpressionElements getDataPrefixExpressionAccess() {
		return pDataPrefixExpression;
	}
	
	public ParserRule getDataPrefixExpressionRule() {
		return getDataPrefixExpressionAccess().getRule();
	}

	//enum DataVariablePrefix returns declarations::DataVariablePrefix:
	//	CONST="const" | META="meta";
	public DataVariablePrefixElements getDataVariablePrefixAccess() {
		return unknownRuleDataVariablePrefix;
	}
	
	public EnumRule getDataVariablePrefixRule() {
		return getDataVariablePrefixAccess().getRule();
	}

	//RangeTypeSpecification returns types::RangeTypeSpecification:
	//	"int" bounds=IntegerBounds;
	public RangeTypeSpecificationElements getRangeTypeSpecificationAccess() {
		return pRangeTypeSpecification;
	}
	
	public ParserRule getRangeTypeSpecificationRule() {
		return getRangeTypeSpecificationAccess().getRule();
	}

	//IntegerBounds returns types::IntegerBounds:
	//	"[" lowerBound=Expression "," upperBound=Expression "]";
	public IntegerBoundsElements getIntegerBoundsAccess() {
		return pIntegerBounds;
	}
	
	public ParserRule getIntegerBoundsRule() {
		return getIntegerBoundsAccess().getRule();
	}

	//StructTypeSpecification returns types::StructTypeSpecification:
	//	"struct" "{" (declaration+=TypedElement ";")+ "}";
	public StructTypeSpecificationElements getStructTypeSpecificationAccess() {
		return pStructTypeSpecification;
	}
	
	public ParserRule getStructTypeSpecificationRule() {
		return getStructTypeSpecificationAccess().getRule();
	}

	//ScalarTypeSpecification returns types::ScalarTypeSpecification:
	//	"scalar" "[" sizeExpression=Expression "]";
	public ScalarTypeSpecificationElements getScalarTypeSpecificationAccess() {
		return pScalarTypeSpecification;
	}
	
	public ParserRule getScalarTypeSpecificationRule() {
		return getScalarTypeSpecificationAccess().getRule();
	}

	//TypeDeclaration returns declarations::TypeDeclaration:
	//	"typedef" typeDefinition=TypeExpression type+=DeclaredType ("," type+=DeclaredType)* ";";
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	//DeclaredType returns types::DeclaredType:
	//	{types::DeclaredType} name=UPPAAL_IDENTIFIER;
	public DeclaredTypeElements getDeclaredTypeAccess() {
		return pDeclaredType;
	}
	
	public ParserRule getDeclaredTypeRule() {
		return getDeclaredTypeAccess().getRule();
	}

	//ChannelPriorityDeclaration returns global::ChannelPriorityDeclaration:
	//	"chan" "priority" groups+=ChannelPriorityGroup ("&lt;" groups+=ChannelPriorityGroup)* ";";
	public ChannelPriorityDeclarationElements getChannelPriorityDeclarationAccess() {
		return pChannelPriorityDeclaration;
	}
	
	public ParserRule getChannelPriorityDeclarationRule() {
		return getChannelPriorityDeclarationAccess().getRule();
	}

	//ChannelPriorityGroup returns global::ChannelPriorityGroup:
	//	items+=PriorityItem ("," items+=PriorityItem)*;
	public ChannelPriorityGroupElements getChannelPriorityGroupAccess() {
		return pChannelPriorityGroup;
	}
	
	public ParserRule getChannelPriorityGroupRule() {
		return getChannelPriorityGroupAccess().getRule();
	}

	//PriorityItem returns global::PriorityItem:
	//	DefaultItem | ChannelItem;
	public PriorityItemElements getPriorityItemAccess() {
		return pPriorityItem;
	}
	
	public ParserRule getPriorityItemRule() {
		return getPriorityItemAccess().getRule();
	}

	//DefaultItem returns global::DefaultItem:
	//	{global::DefaultItem} "default";
	public DefaultItemElements getDefaultItemAccess() {
		return pDefaultItem;
	}
	
	public ParserRule getDefaultItemRule() {
		return getDefaultItemAccess().getRule();
	}

	//ChannelItem returns global::ChannelItem:
	//	channelExpression=IdentifierExpression;
	public ChannelItemElements getChannelItemAccess() {
		return pChannelItem;
	}
	
	public ParserRule getChannelItemRule() {
		return getChannelItemAccess().getRule();
	}

	////---------------------------------------------------------------------------------------------------------------------------------
	//// STATEMENTS
	////---------------------------------------------------------------------------------------------------------------------------------
	//Function returns declarations::Function:
	//	name=UPPAAL_IDENTIFIER "(" (parameter+=ParameterContainer ("," parameter+=ParameterContainer)*)? ")" block=Block;
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//ParameterContainer returns declarations::ParameterContainer hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
	//	typeDefinition=TypeExpression elements+=Parameter;
	public ParameterContainerElements getParameterContainerAccess() {
		return pParameterContainer;
	}
	
	public ParserRule getParameterContainerRule() {
		return getParameterContainerAccess().getRule();
	}

	//Parameter returns declarations::Parameter:
	//	callType=CallType? name=UPPAAL_IDENTIFIER;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//enum CallType returns declarations::CallType:
	//	CALL_BY_REFERENCE="&amp;";
	public CallTypeElements getCallTypeAccess() {
		return unknownRuleCallType;
	}
	
	public EnumRule getCallTypeRule() {
		return getCallTypeAccess().getRule();
	}

	//Statement returns statements::Statement:
	//	Block | EmptyStatement | ExpressionStatement | ForLoop | Iteration | WhileLoop | DoWhileLoop | IfStatement |
	//	ReturnStatement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//Block returns statements::Block:
	//	"{" {statements::Block} => declarations=BlockDeclarations? statement+=Statement* "}";
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//BlockDeclarations returns declarations::LocalDeclarations:
	//	{declarations::LocalDeclarations} // Syntactic predicate is used to give priority to declarations rather
	//	// than expressions like SimpleIdentifierExpression reachable from
	//	// Statement in the Block rule.
	//	=> declaration+=(BlockTypedDeclaration | TypeDeclaration)+;
	public BlockDeclarationsElements getBlockDeclarationsAccess() {
		return pBlockDeclarations;
	}
	
	public ParserRule getBlockDeclarationsRule() {
		return getBlockDeclarationsAccess().getRule();
	}

	//BlockTypedDeclaration returns declarations::TypedDeclaration:
	//	typeDefinition=TypeExpression elements+=Variable ("," elements+=Variable)* ";";
	public BlockTypedDeclarationElements getBlockTypedDeclarationAccess() {
		return pBlockTypedDeclaration;
	}
	
	public ParserRule getBlockTypedDeclarationRule() {
		return getBlockTypedDeclarationAccess().getRule();
	}

	//EmptyStatement returns statements::EmptyStatement:
	//	";" {statements::EmptyStatement};
	public EmptyStatementElements getEmptyStatementAccess() {
		return pEmptyStatement;
	}
	
	public ParserRule getEmptyStatementRule() {
		return getEmptyStatementAccess().getRule();
	}

	//ExpressionStatement returns statements::ExpressionStatement:
	//	expression=Expression ";";
	public ExpressionStatementElements getExpressionStatementAccess() {
		return pExpressionStatement;
	}
	
	public ParserRule getExpressionStatementRule() {
		return getExpressionStatementAccess().getRule();
	}

	//ForLoop returns statements::ForLoop:
	//	"for" "(" initialization=Expression ";" condition=Expression ";" iteration=Expression ")" statement=Statement;
	public ForLoopElements getForLoopAccess() {
		return pForLoop;
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}

	//Iteration returns statements::Iteration:
	//	"for" "(" elements+=VariableNameOnly ":" typeDefinition=TypeExpression ")" statement=Statement;
	public IterationElements getIterationAccess() {
		return pIteration;
	}
	
	public ParserRule getIterationRule() {
		return getIterationAccess().getRule();
	}

	//WhileLoop returns statements::WhileLoop:
	//	"while" "(" expression=Expression ")" statement=Statement;
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//DoWhileLoop returns statements::DoWhileLoop:
	//	"do" statement=Statement "while" "(" expression=Expression ")" ";";
	public DoWhileLoopElements getDoWhileLoopAccess() {
		return pDoWhileLoop;
	}
	
	public ParserRule getDoWhileLoopRule() {
		return getDoWhileLoopAccess().getRule();
	}

	//IfStatement returns statements::IfStatement:
	//	"if" "(" ifExpression=Expression ")" thenStatement=Statement ("else" elseStatement=Statement)?;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//ReturnStatement returns statements::ReturnStatement:
	//	{statements::ReturnStatement} "return" returnExpression=Expression? ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return pReturnStatement;
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	////---------------------------------------------------------------------------------------------------------------------------------
	//// EXPRESSIONS
	////---------------------------------------------------------------------------------------------------------------------------------
	//Expression returns expressions::Expression hidden(WS, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT):
	//	QuantificationExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// The following rules are sorted according to the precedence and associativity rules
	//// of UPPAAL: http://www.it.uu.se/research/group/darts/uppaal/help.php?file=System_Descriptions/Expressions.shtml
	//// For a description of the patterns see http://ag-kastens.uni-paderborn.de/material/plac/folien/Folie303a.html
	//// For the concrete pattern: http://blog.efftinge.de/2010/08/parsing-expressions-with-xtext.html
	//// The default is left-recursive and binary if not otherwise noted.
	//// Quantification.
	//// (unary, right-recursive despite of the (wrong?) statement on the website)
	//QuantificationExpression returns expressions::Expression:
	//	{expressions::QuantificationExpression} quantifier=Quantifier "(" elements+=VariableNameOnly ":"
	//	typeDefinition=TypeExpression ")" expression=LogicalExpression_OrImply | LogicalExpression_OrImply;
	public QuantificationExpressionElements getQuantificationExpressionAccess() {
		return pQuantificationExpression;
	}
	
	public ParserRule getQuantificationExpressionRule() {
		return getQuantificationExpressionAccess().getRule();
	}

	//enum Quantifier returns expressions::Quantifier:
	//	UNIVERSAL="forall" | EXISTENTIAL="exists";
	public QuantifierElements getQuantifierAccess() {
		return unknownRuleQuantifier;
	}
	
	public EnumRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}

	//// Logical Expression (only 'or' and 'imply')
	//LogicalExpression_OrImply returns expressions::Expression:
	//	LogicalExpression_And ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_OrImply
	//	secondExpr=LogicalExpression_And)*;
	public LogicalExpression_OrImplyElements getLogicalExpression_OrImplyAccess() {
		return pLogicalExpression_OrImply;
	}
	
	public ParserRule getLogicalExpression_OrImplyRule() {
		return getLogicalExpression_OrImplyAccess().getRule();
	}

	//enum LogicalOperator_OrImply returns expressions::LogicalOperator:
	//	OR="or" | IMPLY="imply";
	public LogicalOperator_OrImplyElements getLogicalOperator_OrImplyAccess() {
		return unknownRuleLogicalOperator_OrImply;
	}
	
	public EnumRule getLogicalOperator_OrImplyRule() {
		return getLogicalOperator_OrImplyAccess().getRule();
	}

	//// Logical Expression (only 'and')
	//LogicalExpression_And returns expressions::Expression:
	//	NegationExpression ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_And
	//	secondExpr=NegationExpression)*;
	public LogicalExpression_AndElements getLogicalExpression_AndAccess() {
		return pLogicalExpression_And;
	}
	
	public ParserRule getLogicalExpression_AndRule() {
		return getLogicalExpression_AndAccess().getRule();
	}

	//enum LogicalOperator_And returns expressions::LogicalOperator:
	//	AND="and";
	public LogicalOperator_AndElements getLogicalOperator_AndAccess() {
		return unknownRuleLogicalOperator_And;
	}
	
	public EnumRule getLogicalOperator_AndRule() {
		return getLogicalOperator_AndAccess().getRule();
	}

	//// Negation Expression (logical 'not')
	//// (unary, right-recursive,)
	//NegationExpression returns expressions::Expression:
	//	{expressions::NegationExpression} "not" negatedExpression=AssignmentExpression | AssignmentExpression;
	public NegationExpressionElements getNegationExpressionAccess() {
		return pNegationExpression;
	}
	
	public ParserRule getNegationExpressionRule() {
		return getNegationExpressionAccess().getRule();
	}

	//// Assignment Expression, includes stuff like <<= noone will ever use.
	//// (right-recursive)
	//AssignmentExpression returns expressions::Expression:
	//	ConditionExpression ({expressions::AssignmentExpression.firstExpr=current} operator=AssignmentOperator
	//	secondExpr=ConditionExpression)?;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return pAssignmentExpression;
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	//enum AssignmentOperator returns expressions::AssignmentOperator:
	//	EQUAL="=" | EQUAL=":=" | PLUS_EQUAL="+=" | MINUS_EQUAL="-=" | TIMES_EQUAL="*=" | DIVIDE_EQUAL="/=" |
	//	MODULO_EQUAL="%=" | BIT_OR_EQUAL="|=" | BIT_AND_EQUAL="&=" | BIT_XOR_EQUAL="^=" | BIT_LEFT_EQUAL="&lt;&lt;=" |
	//	BIT_RIGHT_EQUAL="&gt;&gt;=";
	public AssignmentOperatorElements getAssignmentOperatorAccess() {
		return unknownRuleAssignmentOperator;
	}
	
	public EnumRule getAssignmentOperatorRule() {
		return getAssignmentOperatorAccess().getRule();
	}

	//// Conidition Expression, so (true) ? then : else
	//// (right-recursive, ternary)
	//ConditionExpression returns expressions::Expression:
	//	LogicalExpression_OrAlternative ({expressions::ConditionExpression.ifExpression=current} "?"
	//	thenExpression=Expression ":" elseExpression=LogicalExpression_OrAlternative)?;
	public ConditionExpressionElements getConditionExpressionAccess() {
		return pConditionExpression;
	}
	
	public ParserRule getConditionExpressionRule() {
		return getConditionExpressionAccess().getRule();
	}

	//// Logical Expression (only '||', alternative notation for 'or')
	//LogicalExpression_OrAlternative returns expressions::Expression:
	//	LogicalExpression_AndAlternative ({expressions::LogicalExpression.firstExpr=current}
	//	operator=LogicalOperator_OrAlternative secondExpr=LogicalExpression_AndAlternative)*;
	public LogicalExpression_OrAlternativeElements getLogicalExpression_OrAlternativeAccess() {
		return pLogicalExpression_OrAlternative;
	}
	
	public ParserRule getLogicalExpression_OrAlternativeRule() {
		return getLogicalExpression_OrAlternativeAccess().getRule();
	}

	//enum LogicalOperator_OrAlternative returns expressions::LogicalOperator:
	//	OR="||";
	public LogicalOperator_OrAlternativeElements getLogicalOperator_OrAlternativeAccess() {
		return unknownRuleLogicalOperator_OrAlternative;
	}
	
	public EnumRule getLogicalOperator_OrAlternativeRule() {
		return getLogicalOperator_OrAlternativeAccess().getRule();
	}

	//// Logical Expression (only '&&', alternative notation for 'and')
	//LogicalExpression_AndAlternative returns expressions::Expression:
	//	BitwiseExpression_Or ({expressions::LogicalExpression.firstExpr=current} operator=LogicalOperator_AndAlternative
	//	secondExpr=BitwiseExpression_Or)*;
	public LogicalExpression_AndAlternativeElements getLogicalExpression_AndAlternativeAccess() {
		return pLogicalExpression_AndAlternative;
	}
	
	public ParserRule getLogicalExpression_AndAlternativeRule() {
		return getLogicalExpression_AndAlternativeAccess().getRule();
	}

	//enum LogicalOperator_AndAlternative returns expressions::LogicalOperator:
	//	AND="&amp;&amp;";
	public LogicalOperator_AndAlternativeElements getLogicalOperator_AndAlternativeAccess() {
		return unknownRuleLogicalOperator_AndAlternative;
	}
	
	public EnumRule getLogicalOperator_AndAlternativeRule() {
		return getLogicalOperator_AndAlternativeAccess().getRule();
	}

	//// Bitwise Expression (only '|')
	//BitwiseExpression_Or returns expressions::Expression:
	//	BitwiseExpression_Xor ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Or
	//	secondExpr=BitwiseExpression_Xor)*;
	public BitwiseExpression_OrElements getBitwiseExpression_OrAccess() {
		return pBitwiseExpression_Or;
	}
	
	public ParserRule getBitwiseExpression_OrRule() {
		return getBitwiseExpression_OrAccess().getRule();
	}

	//enum BitwiseOperator_Or returns expressions::BitwiseOperator:
	//	OR="|";
	public BitwiseOperator_OrElements getBitwiseOperator_OrAccess() {
		return unknownRuleBitwiseOperator_Or;
	}
	
	public EnumRule getBitwiseOperator_OrRule() {
		return getBitwiseOperator_OrAccess().getRule();
	}

	//// Bitwise Expression (only '^')
	//BitwiseExpression_Xor returns expressions::Expression:
	//	BitwiseExpression_And ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_Xor
	//	secondExpr=BitwiseExpression_And)*;
	public BitwiseExpression_XorElements getBitwiseExpression_XorAccess() {
		return pBitwiseExpression_Xor;
	}
	
	public ParserRule getBitwiseExpression_XorRule() {
		return getBitwiseExpression_XorAccess().getRule();
	}

	//enum BitwiseOperator_Xor returns expressions::BitwiseOperator:
	//	XOR="^";
	public BitwiseOperator_XorElements getBitwiseOperator_XorAccess() {
		return unknownRuleBitwiseOperator_Xor;
	}
	
	public EnumRule getBitwiseOperator_XorRule() {
		return getBitwiseOperator_XorAccess().getRule();
	}

	//// Bitwise Expression (only '&')
	//BitwiseExpression_And returns expressions::Expression:
	//	CompareExpression_EqualUnequal ({expressions::BitwiseExpression.firstExpr=current} operator=BitwiseOperator_And
	//	secondExpr=CompareExpression_EqualUnequal)*;
	public BitwiseExpression_AndElements getBitwiseExpression_AndAccess() {
		return pBitwiseExpression_And;
	}
	
	public ParserRule getBitwiseExpression_AndRule() {
		return getBitwiseExpression_AndAccess().getRule();
	}

	//enum BitwiseOperator_And returns expressions::BitwiseOperator:
	//	AND="&amp;";
	public BitwiseOperator_AndElements getBitwiseOperator_AndAccess() {
		return unknownRuleBitwiseOperator_And;
	}
	
	public EnumRule getBitwiseOperator_AndRule() {
		return getBitwiseOperator_AndAccess().getRule();
	}

	//// Compare Expression (only '==' and '!=')
	//CompareExpression_EqualUnequal returns expressions::Expression:
	//	CompareExpression_Other ({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_EqualUnequal
	//	secondExpr=CompareExpression_Other)*;
	public CompareExpression_EqualUnequalElements getCompareExpression_EqualUnequalAccess() {
		return pCompareExpression_EqualUnequal;
	}
	
	public ParserRule getCompareExpression_EqualUnequalRule() {
		return getCompareExpression_EqualUnequalAccess().getRule();
	}

	//enum CompareOperator_EqualUnequal returns expressions::CompareOperator:
	//	EQUAL="==" | UNEQUAL="!=";
	public CompareOperator_EqualUnequalElements getCompareOperator_EqualUnequalAccess() {
		return unknownRuleCompareOperator_EqualUnequal;
	}
	
	public EnumRule getCompareOperator_EqualUnequalRule() {
		return getCompareOperator_EqualUnequalAccess().getRule();
	}

	//// Compare Expression (only '<', '<=', '>=', '>')
	//CompareExpression_Other returns expressions::Expression:
	//	MinMaxExpression ({expressions::CompareExpression.firstExpr=current} operator=CompareOperator_Other
	//	secondExpr=MinMaxExpression)*;
	public CompareExpression_OtherElements getCompareExpression_OtherAccess() {
		return pCompareExpression_Other;
	}
	
	public ParserRule getCompareExpression_OtherRule() {
		return getCompareExpression_OtherAccess().getRule();
	}

	//enum CompareOperator_Other returns expressions::CompareOperator:
	//	GREATER="&gt;" | GREATER_OR_EQUAL="&gt;=" | LESS="&lt;" | LESS_OR_EQUAL="&lt;=";
	public CompareOperator_OtherElements getCompareOperator_OtherAccess() {
		return unknownRuleCompareOperator_Other;
	}
	
	public EnumRule getCompareOperator_OtherRule() {
		return getCompareOperator_OtherAccess().getRule();
	}

	//// MinMax Expression ('<?' and '>?')
	//MinMaxExpression returns expressions::Expression:
	//	BitShiftExpression ({expressions::MinMaxExpression.firstExpr=current} operator=MinMaxOperator
	//	secondExpr=BitShiftExpression)*;
	public MinMaxExpressionElements getMinMaxExpressionAccess() {
		return pMinMaxExpression;
	}
	
	public ParserRule getMinMaxExpressionRule() {
		return getMinMaxExpressionAccess().getRule();
	}

	//enum MinMaxOperator returns expressions::MinMaxOperator:
	//	MIN="&lt;?" | MAX="&gt;?";
	public MinMaxOperatorElements getMinMaxOperatorAccess() {
		return unknownRuleMinMaxOperator;
	}
	
	public EnumRule getMinMaxOperatorRule() {
		return getMinMaxOperatorAccess().getRule();
	}

	//// BitShift Expression ('<<' and '>>')
	//BitShiftExpression returns expressions::Expression:
	//	ArithmeticExpression_PlusMinus ({expressions::BitShiftExpression.firstExpr=current} operator=BitShiftOperator
	//	secondExpr=ArithmeticExpression_PlusMinus)*;
	public BitShiftExpressionElements getBitShiftExpressionAccess() {
		return pBitShiftExpression;
	}
	
	public ParserRule getBitShiftExpressionRule() {
		return getBitShiftExpressionAccess().getRule();
	}

	//enum BitShiftOperator returns expressions::BitShiftOperator:
	//	LEFT="&lt;&lt;" | RIGHT="&gt;&gt";
	public BitShiftOperatorElements getBitShiftOperatorAccess() {
		return unknownRuleBitShiftOperator;
	}
	
	public EnumRule getBitShiftOperatorRule() {
		return getBitShiftOperatorAccess().getRule();
	}

	//// Arithmetic Expression ('+' and '-')
	//ArithmeticExpression_PlusMinus returns expressions::Expression:
	//	ArithmeticExpression_Other ({expressions::ArithmeticExpression.firstExpr=current}
	//	operator=ArithmeticOperator_PlusMinus secondExpr=ArithmeticExpression_Other)*;
	public ArithmeticExpression_PlusMinusElements getArithmeticExpression_PlusMinusAccess() {
		return pArithmeticExpression_PlusMinus;
	}
	
	public ParserRule getArithmeticExpression_PlusMinusRule() {
		return getArithmeticExpression_PlusMinusAccess().getRule();
	}

	//enum ArithmeticOperator_PlusMinus returns expressions::ArithmeticOperator:
	//	ADD="+" | SUBTRACT="-";
	public ArithmeticOperator_PlusMinusElements getArithmeticOperator_PlusMinusAccess() {
		return unknownRuleArithmeticOperator_PlusMinus;
	}
	
	public EnumRule getArithmeticOperator_PlusMinusRule() {
		return getArithmeticOperator_PlusMinusAccess().getRule();
	}

	//// Arithmetic Expression ('*', '/' and '%')
	//ArithmeticExpression_Other returns expressions::Expression:
	//	NegationExpression_Alternative ({expressions::ArithmeticExpression.firstExpr=current}
	//	operator=ArithmeticOperator_Other secondExpr=NegationExpression_Alternative)*;
	public ArithmeticExpression_OtherElements getArithmeticExpression_OtherAccess() {
		return pArithmeticExpression_Other;
	}
	
	public ParserRule getArithmeticExpression_OtherRule() {
		return getArithmeticExpression_OtherAccess().getRule();
	}

	//enum ArithmeticOperator_Other returns expressions::ArithmeticOperator:
	//	MULTIPLICATE="*" | DIVIDE="/" | MODULO="%";
	public ArithmeticOperator_OtherElements getArithmeticOperator_OtherAccess() {
		return unknownRuleArithmeticOperator_Other;
	}
	
	public EnumRule getArithmeticOperator_OtherRule() {
		return getArithmeticOperator_OtherAccess().getRule();
	}

	//// NOTE: From this point on, I just assume that ++ and -- have a higher
	//// precedence than ! and the unary - and +.
	//// Negation Expression Alternative (logical not, '!')
	//// (unary, right-recursive,)
	//NegationExpression_Alternative returns expressions::Expression:
	//	{expressions::NegationExpression} "!" negatedExpression=NegationExpression_Alternative | PlusExpression;
	public NegationExpression_AlternativeElements getNegationExpression_AlternativeAccess() {
		return pNegationExpression_Alternative;
	}
	
	public ParserRule getNegationExpression_AlternativeRule() {
		return getNegationExpression_AlternativeAccess().getRule();
	}

	//// Plus Expression ('+')
	//// (unary, right-recursive,)
	//PlusExpression returns expressions::Expression:
	//	{expressions::PlusExpression} "+" confirmedExpression=NegationExpression_Alternative | MinusExpression;
	public PlusExpressionElements getPlusExpressionAccess() {
		return pPlusExpression;
	}
	
	public ParserRule getPlusExpressionRule() {
		return getPlusExpressionAccess().getRule();
	}

	//// Minus Expression ('-')
	//// (unary, right-recursive,)
	//MinusExpression returns expressions::Expression:
	//	{expressions::MinusExpression} "-" invertedExpression=NegationExpression_Alternative |
	//	PreIncrementDecrementExpression;
	public MinusExpressionElements getMinusExpressionAccess() {
		return pMinusExpression;
	}
	
	public ParserRule getMinusExpressionRule() {
		return getMinusExpressionAccess().getRule();
	}

	//// Pre Increment/Decrement Expression ('++', '--', pre)
	//// (unary, right-recursive)
	//PreIncrementDecrementExpression returns expressions::Expression:
	//	PostIncrementDecrementExpression | {expressions::PreIncrementDecrementExpression} operator=IncrementDecrementOperator
	//	expression=PreIncrementDecrementExpression;
	public PreIncrementDecrementExpressionElements getPreIncrementDecrementExpressionAccess() {
		return pPreIncrementDecrementExpression;
	}
	
	public ParserRule getPreIncrementDecrementExpressionRule() {
		return getPreIncrementDecrementExpressionAccess().getRule();
	}

	//// Post Increment/Decrement Expression ('++', '--', post)
	//// (unary, right-recursive)
	//PostIncrementDecrementExpression returns expressions::Expression:
	//	ScopedIdentifierExpression // Note: For expressions like a+++b, two ways to split them up exist:
	//	//   (a++)+b and a+(++b)
	//	// As UPPAAL uses the former way a syntactic predicate ensures the
	//	// higher precedence of the post-expression.
	//	=> ({expressions::PostIncrementDecrementExpression.expression=current} operator=IncrementDecrementOperator)*;
	public PostIncrementDecrementExpressionElements getPostIncrementDecrementExpressionAccess() {
		return pPostIncrementDecrementExpression;
	}
	
	public ParserRule getPostIncrementDecrementExpressionRule() {
		return getPostIncrementDecrementExpressionAccess().getRule();
	}

	//enum IncrementDecrementOperator returns expressions::IncrementDecrementOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public IncrementDecrementOperatorElements getIncrementDecrementOperatorAccess() {
		return unknownRuleIncrementDecrementOperator;
	}
	
	public EnumRule getIncrementDecrementOperatorRule() {
		return getIncrementDecrementOperatorAccess().getRule();
	}

	//// ScopedIdentifier Expression (identifiers with .)
	//ScopedIdentifierExpression returns expressions::Expression:
	//	TerminatingExpressions ({expressions::ScopedIdentifierExpression.scope=current} "."
	//	identifier=IdentifierExpression)*;
	public ScopedIdentifierExpressionElements getScopedIdentifierExpressionAccess() {
		return pScopedIdentifierExpression;
	}
	
	public ParserRule getScopedIdentifierExpressionRule() {
		return getScopedIdentifierExpressionAccess().getRule();
	}

	//// Terminating Expressions
	//TerminatingExpressions returns expressions::Expression:
	//	IdentifierExpression | FunctionCallExpression | LiteralExpression | "(" Expression ")";
	public TerminatingExpressionsElements getTerminatingExpressionsAccess() {
		return pTerminatingExpressions;
	}
	
	public ParserRule getTerminatingExpressionsRule() {
		return getTerminatingExpressionsAccess().getRule();
	}

	//LiteralExpression returns expressions::LiteralExpression:
	//	text=LiteralExpressionText;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//LiteralExpressionText returns ecore::EString:
	//	"true" | "false" | INT;
	public LiteralExpressionTextElements getLiteralExpressionTextAccess() {
		return pLiteralExpressionText;
	}
	
	public ParserRule getLiteralExpressionTextRule() {
		return getLiteralExpressionTextAccess().getRule();
	}

	//// Function Calls
	//FunctionCallExpression returns expressions::FunctionCallExpression:
	//	function=[declarations::Function|UPPAAL_IDENTIFIER] "(" (argument+=Expression ("," argument+=Expression)*)? ")";
	public FunctionCallExpressionElements getFunctionCallExpressionAccess() {
		return pFunctionCallExpression;
	}
	
	public ParserRule getFunctionCallExpressionRule() {
		return getFunctionCallExpressionAccess().getRule();
	}

	//// Identifier Expression (normal identifiers)
	//IdentifierExpression returns expressions::IdentifierExpression:
	//	identifier=[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER] ("[" index+=Expression "]")*;
	public IdentifierExpressionElements getIdentifierExpressionAccess() {
		return pIdentifierExpression;
	}
	
	public ParserRule getIdentifierExpressionRule() {
		return getIdentifierExpressionAccess().getRule();
	}

	//// Only allows simple identifiers without indices.
	//SimpleIdentifierExpression returns expressions::IdentifierExpression:
	//	identifier=[core::NamedElement|UPPAAL_TYPE_OR_IDENTIFIER];
	public SimpleIdentifierExpressionElements getSimpleIdentifierExpressionAccess() {
		return pSimpleIdentifierExpression;
	}
	
	public ParserRule getSimpleIdentifierExpressionRule() {
		return getSimpleIdentifierExpressionAccess().getRule();
	}

	////---------------------------------------------------------------------------------------------------------------------------------
	//// TOKENS
	////---------------------------------------------------------------------------------------------------------------------------------
	//UPPAAL_TYPE_OR_IDENTIFIER:
	//	UPPAAL_IDENTIFIER | "int" | "bool" | "void" | "chan" | "clock";
	public UPPAAL_TYPE_OR_IDENTIFIERElements getUPPAAL_TYPE_OR_IDENTIFIERAccess() {
		return pUPPAAL_TYPE_OR_IDENTIFIER;
	}
	
	public ParserRule getUPPAAL_TYPE_OR_IDENTIFIERRule() {
		return getUPPAAL_TYPE_OR_IDENTIFIERAccess().getRule();
	}

	//UPPAAL_IDENTIFIER:
	//	ID | XML_KEYWORDS;
	public UPPAAL_IDENTIFIERElements getUPPAAL_IDENTIFIERAccess() {
		return pUPPAAL_IDENTIFIER;
	}
	
	public ParserRule getUPPAAL_IDENTIFIERRule() {
		return getUPPAAL_IDENTIFIERAccess().getRule();
	}

	//UPPAAL_KEYWORDS:
	//	"chan" // End of the list from the website.
	//	| "clock" | "bool" | "int" | "commit" | "const" | "urgent" | "broadcast" | "init" | "process" | "state" | "guard" |
	//	"sync" | "assign" | "system" | "trans" | "deadlock" | "and" | "or" | "not" | "imply" | "true" | "false" | "for" |
	//	"forall" | "exists" | "while" | "do" | "if" | "else" | "return" | "typedef" | "struct" | "rate" | "before_update" |
	//	"after_update" | "meta" | "priority" | "progress" | "scalar" | "select" | "void" | "switch" | "case" | "continue" |
	//	"break" | "default";
	public UPPAAL_KEYWORDSElements getUPPAAL_KEYWORDSAccess() {
		return pUPPAAL_KEYWORDS;
	}
	
	public ParserRule getUPPAAL_KEYWORDSRule() {
		return getUPPAAL_KEYWORDSAccess().getRule();
	}

	//UPPAAL_STRUCTURE_KEYWORDS:
	//	"[" | "]" | "&lt;" | "&gt" | ";" | "," | "{" | "}" | "(" | ")" | "?" | "!" | "*" | "%" | "/" | "+" | "-" | "++" |
	//	"--" | "&lt;&lt;" | "&gt;&gt" | "&lt;?" | "&gt;?" | "&lt;=" | "&gt;=" | "==" | "!=" | "&" | "&amp;" | "^" | "|" |
	//	"&&" | "&amp;&amp;" | "||" | "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "|=" | "&=" | "^=" | "&lt;&lt;=" | "&gt;&gt;="
	//	| ":";
	public UPPAAL_STRUCTURE_KEYWORDSElements getUPPAAL_STRUCTURE_KEYWORDSAccess() {
		return pUPPAAL_STRUCTURE_KEYWORDS;
	}
	
	public ParserRule getUPPAAL_STRUCTURE_KEYWORDSRule() {
		return getUPPAAL_STRUCTURE_KEYWORDSAccess().getRule();
	}

	//// Represents a quoted integer value of the form
	////   " -? [0-9]+ "
	//// The actual value is calculated via a value conversion.
	//QUOTED_INT returns ecore::EInt:
	//	STRING;
	public QUOTED_INTElements getQUOTED_INTAccess() {
		return pQUOTED_INT;
	}
	
	public ParserRule getQUOTED_INTRule() {
		return getQUOTED_INTAccess().getRule();
	}

	//// Matches any token but the XML close token '</'. This is needed for parsing the
	//// contents of XML tags until the closing tag occurs.
	//ANY_TOKEN_BUT_XML_CLOSE:
	//	XML_KEYWORDS | XML_ATTRIBUTE_KEYWORDS | XML_STRUCTURE_KEYWORDS | UPPAAL_KEYWORDS | UPPAAL_STRUCTURE_KEYWORDS | STRING
	//	| ID | WS | ANY_OTHER | INT | SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT;
	public ANY_TOKEN_BUT_XML_CLOSEElements getANY_TOKEN_BUT_XML_CLOSEAccess() {
		return pANY_TOKEN_BUT_XML_CLOSE;
	}
	
	public ParserRule getANY_TOKEN_BUT_XML_CLOSERule() {
		return getANY_TOKEN_BUT_XML_CLOSEAccess().getRule();
	}

	//// Every token used outside of terminals must occur exactly once in one of the following rules!
	//XML_STRUCTURE_KEYWORDS:
	//	"<" | ">" | "/>" | "<?xml version=\"1.0\" encoding=\"utf-8\"?>" | "<?xml version=\'1.0\' encoding=\'utf-8\'?>" |
	//	"<!DOCTYPE nta PUBLIC \'-//Uppaal Team//DTD Flat System 1.1//EN\' \'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'>";
	public XML_STRUCTURE_KEYWORDSElements getXML_STRUCTURE_KEYWORDSAccess() {
		return pXML_STRUCTURE_KEYWORDS;
	}
	
	public ParserRule getXML_STRUCTURE_KEYWORDSRule() {
		return getXML_STRUCTURE_KEYWORDSAccess().getRule();
	}

	//XML_CLOSE_KEYWORD:
	//	"</";
	public XML_CLOSE_KEYWORDElements getXML_CLOSE_KEYWORDAccess() {
		return pXML_CLOSE_KEYWORD;
	}
	
	public ParserRule getXML_CLOSE_KEYWORDRule() {
		return getXML_CLOSE_KEYWORDAccess().getRule();
	}

	//// Keywords that collide with UPPAAL_KEYWORDS
	//// 'init' | 'urgent' | 'system'
	//XML_KEYWORDS:
	//	"imports" | "nta" | "template" | "name" | "ref" | "location" | "id" | "color" | "transition" | "source" | "target" |
	//	"nail" | "label" | "kind" | "declaration" | "instantiation" | "parameter" | "committed" | "x" | "y";
	public XML_KEYWORDSElements getXML_KEYWORDSAccess() {
		return pXML_KEYWORDS;
	}
	
	public ParserRule getXML_KEYWORDSRule() {
		return getXML_KEYWORDSAccess().getRule();
	}

	//XML_ATTRIBUTE_KEYWORDS:
	//	"\"synchronisation\"" | "\"guard\"" | "\"assignment\"" | "\"invariant\"" | "\"comments\"";
	public XML_ATTRIBUTE_KEYWORDSElements getXML_ATTRIBUTE_KEYWORDSAccess() {
		return pXML_ATTRIBUTE_KEYWORDS;
	}
	
	public ParserRule getXML_ATTRIBUTE_KEYWORDSRule() {
		return getXML_ATTRIBUTE_KEYWORDSAccess().getRule();
	}

	////---------------------------------------------------------------------------------------------------------------------------------
	//// TERMINALS
	////---------------------------------------------------------------------------------------------------------------------------------
	//terminal STRING:
	//	"\"" ("\\" . | !("\\" | "\""))* "\"" | "\'" ("\\" . | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal ID:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal INT:
	//	"0" | "1".."9" "0".."9"*;
	public TerminalRule getINTRule() {
		return tINT;
	} 

	//terminal SINGLE_LINE_COMMENT:
	//	"//" !("<" | "\r" | "\n")*;
	public TerminalRule getSINGLE_LINE_COMMENTRule() {
		return tSINGLE_LINE_COMMENT;
	} 

	//terminal MULTI_LINE_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getMULTI_LINE_COMMENTRule() {
		return tMULTI_LINE_COMMENT;
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return tWS;
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	} 
}
