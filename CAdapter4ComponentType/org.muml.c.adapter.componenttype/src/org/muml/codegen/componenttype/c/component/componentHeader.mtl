[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate_rtsc.
 */]
[module componentHeader('http://www.muml.org/pim/connector/1.0.0',
				'http://www.muml.org/pim/behavior/1.0.0',
				'http://www.muml.org/core/1.0.0',
				'http://www.muml.org/pim/actionlanguage/1.0.0',
				'http://www.muml.org/pim/msgtype/1.0.0',
				'http://www.muml.org/pim/types/1.0.0',
				'http://www.muml.org/modelinstance/1.0.0',
				'http://www.muml.org/pim/component/1.0.0',
				'http://www.muml.org/pim/instance/1.0.0',
				'http://www.muml.org/pim/realtimestatechart/1.0.0')/]
[import org::muml::codegen::componenttype::c::queries::stringQueries/]
[import org::muml::codegen::componenttype::c::queries::modelQueries/]
[import org::muml::codegen::componenttype::c::actionlanguage::expression/]


[**
 * Generates the function defitions for the given component.
 * 
 * @param component The component for which the class will be generated.
 * @param statechart The behaviour of the component, if one exist otherwise null.
 */]
[template public generate_ComponentHeader(component : Component, useSubDir : Boolean)]
/**
 * @file 
 * @author generated by Fraunhofer IEM 
 * @brief Specification of Component of Type: [component.getName()/]
 * @details This files contains a description of the [component.getName()/] in form of the [getClassName(component)/]
 * 			and all methods which can be executed on an Instance of this Component
 */
	
			[variables(component)/]
		
			[initialize(component)/]
	
			[constructor(component)/]
	
			[destroy(component)/]
			
			[processStep(component)/]
	




			[getterAndSetter(component)/]
		
			[queueMethods(component)/]
[/template]


[**
 * Generates the member variables.
 * 
 * @param component
 * @param statechart
*/]
[template private variables (component : Component) post (trim())]
[if component.oclIsKindOf(AtomicComponent) and (component.componentKind = ComponentKind::SOFTWARE_COMPONENT) ]
/**
 * @brief Forward Declaration of the struct [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] which describes the behavior of [getClassName(component)/]
 * 
 */
 typedef struct [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/];
[/if]
/**
 * @brief Forward Declaration of the struct [getClassName(component)/]
 */
	typedef struct [getClassName(component)/] [getClassName(component)/];

/**
*  
* @brief Description for a ComponentInstance of Type: [component.getName()/]
* @details This struct describes a specific Component Instances which is typed over the Component: [component.getName()/]
*/
struct [getClassName(component)/] {

		uint8_T ID;	

		[comment if structured component, list all embedded components/]
		[if component.oclIsKindOf(StructuredComponent)]
		[for (cpart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts)]
			[getClassName(cpart)/]* [getVariableName(cpart)/];
		[/for]
		[/if]

		[comment if atomic, list the RTSC of the component/]
		[if (component.oclIsKindOf(AtomicComponent) and (componentKind=ComponentKind::SOFTWARE_COMPONENT))]
			[getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/]* stateChart;	/**< The [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] of the Component [component.getName()/] */
		[/if]
	
		[comment list all ports of the component/]
		[for (port : Port | component.ports)]
				Port [getVariableName(port)/]; /**< A  Component's Port: [port.getName()/] */
		[/for]
		[for (port : DirectedTypedPort | component.ports->filter(DirectedTypedPort))]
				Clock [getVariableName(port)/]Clock; /**< A  Hybrid/ Continuous Port's Clock: [getVariableName(port)/]Clock */
		[/for]
		
		[for (port : ContinuousPort | component.ports->filter(ContinuousPort))]
			void (*[getVariableName(port)/]AccessFunction) ([port.dataType.getTypeName()/]*); /**access function pointer for continuous port */
			/*FIXME: Add InitFunction and Destory Funcion */
		[/for]

		[comment Continious Component Implementation/]
		[if component.oclIsKindOf(AtomicComponent) and component.componentKind=ComponentKind::CONTINUOUS_COMPONENT]
		[for (port : DirectedTypedPort | component.ports->filter(DirectedTypedPort))]
			[port.dataType.getTypeName()/] [getStructVariableName(port)/]; /*A Ports Data Variable*/
		[/for]
		[/if]
		
		

		[comment add list pointer/]
		[component.getClassName()/] * next;/**< A Pointer to the next component part, if this component ist part of a multipart in the CIC */
		
	};

[/template]

[**
 * @param component
 * @param statechart
*/]
[template private initialize (component : Component) post (trim())]
/**
* @brief This Methodes intializes the Component: [component.getName()/]
* @details All struct members of the struct [getClassName(component)/] are initialized
* 
* @param component The [getClassName(component)/] to be initialized
*/	
	[getVoidTypeString(component)/] [getInitializeMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the constructor.
 * 
 * @param component
 * @param statechart
*/]
[template public constructor (component : Component) post (trim())]
/**
* @brief Creates a Instance of the Component: [component.getName()/]
* @details Allocates Memory for the struct [getClassName(component)/]
* @return A Pointer to the new created [getClassName(component)/]
*/
	[getClassName(component)/] [getCreateMethodName(component)/]();
[/template]

[**
 * 
*/]
[template private destroy(component : Component)]
/**
 * @brief Destroys a Component: [component.getName()/]
 * @details Frees the Memory for the struct [getClassName(component)/]
 * 
* @param component The specific [getClassName(component)/] to be destroyed
 */
	[getVoidTypeString(component)/] [getDestroyMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the isTerminated method.
 * 
 * @param component
 * @param statechart
*/]
[template private isTerminated (component : Component) post (trim())]
/**
* @brief Checks if the execution of the Component: [component.getName()/]  is terminated
* @details To Check if the execution is terminated the Method is terminated of the stateChart is called
*		
* @param component The specific [getClassName(component)/] which shall be checked
* @return True, if the Component is terminated, otherwise false
*/
	bool_t [getTerminateMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generated the processStep method.
 * 
 * @param component
 * @param statechart
*/]
[template private processStep (component : Component) post (trim())]
/**
* @brief Executes the next Step of the behavior an Instance of the Component: [component.getName()/]
* @details The behavior of the Component:  [component.getName()/] is executed.
*			
* @param component The [getClassName(component)/] whose behavior shall be checked
*/
	[getVoidTypeString(component)/] [getProcessMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the getter methods for the statechart and all ports.
 * 
 * @param component
 * @param statechart
*/]
[template private getterAndSetter (component : Component) post (trim())]
	/*Getter and Setter for Sending Values of Hybrid/Continuous ports*/
	[for (port : DirectedTypedPort | component.ports->filter(DirectedTypedPort))]
	[if port.outPort]
			[getVoidTypeString(component)/] setterOf_[port.getName()/]([getClassName(port)/]* [getVariableName(port)/], [port.dataType.getTypeName()/]* [port.getName()/]);/**< A Pointer to the setter function of the port: [port.getName()/] */
	[else]
		[getBooleanTypeString(component)/] getterOf_[port.getName()/]([getClassName(port)/]* [getVariableName(port)/], [port.dataType.getTypeName()/]* [port.getName()/]);/**< A Pointer to the getter function of the port: [port.getName()/] */
	[/if]
	[/for]
	[if (component.componentKind=ComponentKind::SOFTWARE_COMPONENT)]
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior]
		[getClassName(rtsc)/]* [getGetterName(component)/]([getClassName(component)/]* component);
	[/let]
	[/if]

	[for (port : Port | component.ports)]
	[if (port.oclIsKindOf(DiscretePort))]
/**
		 * @brief Get the Port: [port.getName()/] of an Instance of the Component: [component.getName()/]
		 * @details The Pointer [getClassName(component)/]::[getVariableName(port)/] is returned
		 * 
		 * @param component The specific Instance [getClassName(component)/]  of the Component: [component.getName()/] whose Port shall be returned
		 * @return A Pointer to the Port [port.getName()/] of the struct [getClassName(component)/]
		 */
		[getClassName(port)/]* [getGetterName(port)/]([getClassName(component)/]* component);
	[/if]
	[/for]
[/template]

[**
 * 
 * @param component
*/]
[template private queueMethods(component : Component) post (trim())]
[if (component.oclIsKindOf(StructuredComponent))]
[for (compPart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts->asSet())]
//Queue methods for component parts of type '[getName(compPart)/]'
[getVoidTypeString(component)/] [getAddMethodName(component,compPart)/]([getClassName(component)/]* component, [getClassName(compPart)/]* multiPart);		
[getVoidTypeString(component)/] [getRemoveMethodName(component,compPart)/]([getClassName(compPart)/]* component, [getClassName(compPart)/]* multiPart);
[/for]
[/if]
[/template]

