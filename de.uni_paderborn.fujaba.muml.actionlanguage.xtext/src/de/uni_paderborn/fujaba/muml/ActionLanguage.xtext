// automatically generated by Xtext
grammar de.uni_paderborn.fujaba.muml.ActionLanguage with org.eclipse.xtext.common.Terminals 

import "platform:/resource/de.uni_paderborn.fujaba.muml.actionlanguage/model/actionlanguage.ecore" as actionlanguage

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

import "platform:/resource/org.storydriven.core/model/core.ecore" as modeling

import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//realtimestatechart" as rtsc

import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//behavior" as behavior

import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//types" as types

import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//msgtype" as msgtype

import "platform:/resource/org.storydriven.core/model/core.ecore#//expressions" as expressions

import "platform:/resource/org.storydriven.core/model/core.ecore#//expressions/common" as commonExpressions


Block returns actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	{actionlanguage::Block}
	'{'(expressions+=ExpressionStartRule*)'}' | expressions+=Expression
;

// TODO: clarify if it makes sense to allow arbitrary expressions for
// the initializeExpression and countingExpression
ForLoop returns actionlanguage::ForLoop:
	'for' '(' initializeExpression=Assignment  loopTest=Expression';'  countingExpression=ForLoopCountingExpression ')' 
		block=Block
;

ForLoopCountingExpression returns actionlanguage::Assignment:
	lhs_typedNamedElementExpression=TypedNamedElementExpression
	(
		incrementDecrementOperator=IncrementDecrementOperator
		| (assignOperator=AssignOperator rhs_assignExpression=Expression)
	)
;

WhileLoop returns actionlanguage::WhileLoop:
	'while' '('  loopTest=Expression ')' 
		block=Block
;

DoWhileLoop returns actionlanguage::DoWhileLoop:
	'do'  
		block=Block
	'while' '('  loopTest=Expression ');'
;

IfStatement returns actionlanguage::IfStatement:
	'if' '(' ifCondition=Expression ')'
		ifBlock=Block
	('elseif' '(' elseIfConditions+=Expression ')'
		elseIfBlocks+=Block
	)*
	('else' elseBlock=Block)?
;

ReturnStatement returns actionlanguage::ReturnStatement:
	{actionlanguage::ReturnStatement}
	'return' expression=Expression ';'
;

OperationCallStatement returns actionlanguage::OperationCall:
	OperationCall ';'
;
	
ExpressionStartRule returns expressions::Expression:
	Assignment |  ForLoop | 
	WhileLoop | DoWhileLoop | 
	IfStatement | ReturnStatement | LocalVariableDeclarationStatement |
	OperationCallStatement
;

enum IncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
	INCREMENT='++' | DECREMENT='--'
;

// Assignment
	
Assignment returns actionlanguage::Assignment:
	lhs_typedNamedElementExpression=TypedNamedElementExpression
	assignOperator=AssignOperator rhs_assignExpression=InitializeExpression ';'
;

enum AssignOperator returns actionlanguage::AssignOperator:
	ASSIGN=':=' | PLUS_EQUAL='+='| EQUAL_PLUS='=+' | MINUS_EQUAL='-='| EQUAL_MINUS='=-'
;

// end of assignment

// initialize expression

InitializeExpression returns expressions::Expression:
	ArrayInitializeExpression | Expression
;

// end of initialize expression

// array initialization

ArrayInitializeExpression returns actionlanguage::ArrayInitializeExpression:
	'{' expressions+=InitializeExpression
		(',' expressions+=InitializeExpression)*
	'}'
;

// end of array initialization

// local variable declaration

LocalVariableDeclarationStatement returns actionlanguage::LocalVariableDeclarationStatement:
	variable=LocalVariableDeclaration
;

LocalVariableDeclaration returns behavior::Variable:
	dataType=[types::DataType|DATATYPE] name=ID (':=' initializeExpression=InitializeExpression)? ';'
;

// end of local variable declaration

Expression returns expressions::Expression:
	LogicalExpression
;

// LogicalExpression

LogicalExpression returns expressions::Expression:
	LogicalOrExpression
;

LogicalOrExpression returns expressions::Expression:
	LogicalAndExpression
	(
		{commonExpressions::LogicalExpression.leftExpression=current}
		operator=LogicalOrOperator
		rightExpression=LogicalAndExpression
	)*
;

enum LogicalOrOperator returns commonExpressions::LogicOperator:
	OR='||'
;

LogicalAndExpression returns expressions::Expression:
	ComparisonExpression
	(
		{commonExpressions::LogicalExpression.leftExpression=current}
		operator=LogicalAndOperator
		rightExpression=ComparisonExpression
	)*
;

enum LogicalAndOperator returns commonExpressions::LogicOperator:
	AND='&&'
;

// end of LogicalExpression

// ComparisonExpression

ComparisonExpression returns expressions::Expression:
	ComparisonHigherOpExpression
	(	
		{commonExpressions::ComparisonExpression.leftExpression=current}
		operator=ComparingEQNEQOperator
		rightExpression=ComparisonHigherOpExpression
	)?
;

ComparisonHigherOpExpression returns expressions::Expression:
	ArithmeticExpression
	(	{commonExpressions::ComparisonExpression.leftExpression=current}
		operator=ComparingRelOperator
		rightExpression=ArithmeticExpression
	)?
;

enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
	EQUAL='==' | UNEQUAL='<>' 
;

enum ComparingRelOperator returns commonExpressions::ComparingOperator:
	LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>'
;  

// end of ComparisonExpression

// ArithmeticExpression	
	
ArithmeticExpression returns expressions::Expression:
	AdditionExpression
;

AdditionExpression returns expressions::Expression:
	MultiplicationExpression
	(
		{commonExpressions::ArithmeticExpression.leftExpression=current}
		operator=AdditionOperator rightExpression=MultiplicationExpression
	)*
;

enum AdditionOperator returns commonExpressions::ArithmeticOperator:
	PLUS='+' | MINUS='-'
;

MultiplicationExpression returns expressions::Expression:
	UnaryPreExpression | UnaryPostExpression
	(	{commonExpressions::ArithmeticExpression.leftExpression=current}
		operator=MultiplicationOperator rightExpression=(UnaryPreExpression | UnaryPostExpression)
	)*
;

enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
	TIMES='*' | DIVIDE='/'
;

// end of ArithmeticExpression

// UnaryPreExpression

UnaryPreExpression returns expressions::Expression:
	{commonExpressions::UnaryExpression}
	operator=UnaryPreOperator enclosedExpression=Operand
;

enum UnaryPreOperator returns commonExpressions::UnaryOperator:
	NOT='not' | MINUS='-' | PLUS='+'
;

// end of UnaryPreExpression

// UnaryPostExpression

UnaryPostExpression returns expressions::Expression:
	Operand
	(
		{commonExpressions::UnaryExpression.enclosedExpression=current}
		operator=UnaryPostOperator
	)?
;

enum UnaryPostOperator returns commonExpressions::UnaryOperator:
	INCREMENT='++' | DECREMENT='--'
;

// end of UnaryPostExpression

// Operand

Operand returns expressions::Expression:
	'(' Expression ')' | LiteralExpression | ExtendedTypedNamedElementExpression
	| OperationCall | TriggerMessageExpression | NoAttributeSelectorExpression
;

// end of Operand

LiteralExpression returns commonExpressions::LiteralExpression:
	{commonExpressions::LiteralExpression} value=Literal
;

Literal returns ecore::EString:
	NUMBER | BOOLEAN | INT | STRING
;

ExtendedTypedNamedElementExpression returns expressions::Expression:
	TypedNamedElementExpression
	(
		{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression = current}
		'.' position=PositionSelectorExpression
	)?
;

TypedNamedElementExpression returns actionlanguage::TypedNamedElementExpression:
	typedNamedElement=[behavior::TypedNamedElement]('['indices+=ArithmeticExpression']')*
;

NoAttributeSelectorExpression returns actionlanguage::DiscreteInteractionEndpointReference:
	position=PositionSelectorExpression
;

PositionSelectorExpression returns actionlanguage::PositionSelector:
	kind=PositionSelectorKind ('.' successor=PositionSelectorExpression)?
;

enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
	SELF='self' | FIRST='first' | LAST='last' | PREV='prev' | NEXT='next'
;

OperationCall returns actionlanguage::OperationCall:
	operation=[behavior::Operation] '('
		(parameterBinding+=ParamaterBinding (',' parameterBinding+=ParamaterBinding)* )?
	')'
;

ParamaterBinding returns behavior::ParameterBinding:
	{behavior::ParameterBinding}parameter=[behavior::Parameter] ':=' value=Expression
;	

// TriggerMessageExpression

TriggerMessageExpression returns actionlanguage::TriggerMessageExpression:
	messageType=[msgtype::MessageType] '.' parameter=[behavior::Parameter]
;

// end of TriggerMessageExpression

terminal NUMBER returns ecore::EBigDecimal:
	INT'.' INT
;

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

terminal ID:
	'^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;

DATATYPE returns ecore::EString:
	ID ('['INT']')*
;