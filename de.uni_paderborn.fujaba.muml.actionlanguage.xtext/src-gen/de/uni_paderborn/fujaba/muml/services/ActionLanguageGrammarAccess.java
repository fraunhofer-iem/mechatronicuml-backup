/*
* generated by Xtext
*/
package de.uni_paderborn.fujaba.muml.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ActionLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class EntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Entry");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Entry returns expressions::Expression:
		//	Block | Expression;
		public ParserRule getRule() { return rule; }

		//Block | Expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//Block
		public RuleCall getBlockParserRuleCall_0() { return cBlockParserRuleCall_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionsExpressionStartRuleParserRuleCall_2_0 = (RuleCall)cExpressionsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block returns actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
		//	{actionlanguage::Block} "{" expressions+=ExpressionStartRule* "}";
		public ParserRule getRule() { return rule; }

		//{actionlanguage::Block} "{" expressions+=ExpressionStartRule* "}"
		public Group getGroup() { return cGroup; }

		//{actionlanguage::Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//expressions+=ExpressionStartRule*
		public Assignment getExpressionsAssignment_2() { return cExpressionsAssignment_2; }

		//ExpressionStartRule
		public RuleCall getExpressionsExpressionStartRuleParserRuleCall_2_0() { return cExpressionsExpressionStartRuleParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitializeExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitializeExpressionAssignmentParserRuleCall_2_0 = (RuleCall)cInitializeExpressionAssignment_2.eContents().get(0);
		private final Assignment cLoopTestAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopTestExpressionParserRuleCall_3_0 = (RuleCall)cLoopTestAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCountingExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0 = (RuleCall)cCountingExpressionAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBlockAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBlockBlockParserRuleCall_7_0 = (RuleCall)cBlockAssignment_7.eContents().get(0);
		
		//// TODO: clarify if it makes sense to allow arbitrary expressions for
		//// the initializeExpression and countingExpression
		//ForLoop returns actionlanguage::ForLoop:
		//	"for" "(" initializeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//	block=Block;
		public ParserRule getRule() { return rule; }

		//"for" "(" initializeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//block=Block
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//initializeExpression=Assignment
		public Assignment getInitializeExpressionAssignment_2() { return cInitializeExpressionAssignment_2; }

		//Assignment
		public RuleCall getInitializeExpressionAssignmentParserRuleCall_2_0() { return cInitializeExpressionAssignmentParserRuleCall_2_0; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_3() { return cLoopTestAssignment_3; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_3_0() { return cLoopTestExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }

		//countingExpression=ForLoopCountingExpression
		public Assignment getCountingExpressionAssignment_5() { return cCountingExpressionAssignment_5; }

		//ForLoopCountingExpression
		public RuleCall getCountingExpressionForLoopCountingExpressionParserRuleCall_5_0() { return cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//block=Block
		public Assignment getBlockAssignment_7() { return cBlockAssignment_7; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_7_0() { return cBlockBlockParserRuleCall_7_0; }
	}

	public class ForLoopCountingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoopCountingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_typedNamedElementExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0 = (RuleCall)cLhs_typedNamedElementExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIncrementDecrementOperatorAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cAssignOperatorAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0 = (RuleCall)cAssignOperatorAssignment_1_1_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_1_1.eContents().get(0);
		
		//ForLoopCountingExpression returns actionlanguage::Assignment:
		//	lhs_typedNamedElementExpression=TypedNamedElementExpression
		//	(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//	rhs_assignExpression=Expression);
		public ParserRule getRule() { return rule; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		//(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//rhs_assignExpression=Expression)
		public Group getGroup() { return cGroup; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		public Assignment getLhs_typedNamedElementExpressionAssignment_0() { return cLhs_typedNamedElementExpressionAssignment_0; }

		//TypedNamedElementExpression
		public RuleCall getLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0() { return cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//rhs_assignExpression=Expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_0() { return cIncrementDecrementOperatorAssignment_1_0; }

		//UnaryPostIncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0() { return cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_1_0() { return cAssignOperatorAssignment_1_1_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0; }

		//rhs_assignExpression=Expression
		public Assignment getRhs_assignExpressionAssignment_1_1_1() { return cRhs_assignExpressionAssignment_1_1_1; }

		//Expression
		public RuleCall getRhs_assignExpressionExpressionParserRuleCall_1_1_1_0() { return cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLoopTestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLoopTestExpressionParserRuleCall_2_0 = (RuleCall)cLoopTestAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		//WhileLoop returns actionlanguage::WhileLoop:
		//	"while" "(" loopTest=Expression ")" block=Block;
		public ParserRule getRule() { return rule; }

		//"while" "(" loopTest=Expression ")" block=Block
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_2() { return cLoopTestAssignment_2; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_2_0() { return cLoopTestExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//block=Block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}

	public class DoWhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLoopTestAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopTestExpressionParserRuleCall_4_0 = (RuleCall)cLoopTestAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//DoWhileLoop returns actionlanguage::DoWhileLoop:
		//	"do" block=Block "while" "(" loopTest=Expression ");";
		public ParserRule getRule() { return rule; }

		//"do" block=Block "while" "(" loopTest=Expression ");"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//block=Block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_4() { return cLoopTestAssignment_4; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_4_0() { return cLoopTestExpressionParserRuleCall_4_0; }

		//");"
		public Keyword getRightParenthesisSemicolonKeyword_5() { return cRightParenthesisSemicolonKeyword_5; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIfConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfConditionExpressionParserRuleCall_2_0 = (RuleCall)cIfConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockBlockParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseifKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cElseIfConditionsAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cElseIfConditionsExpressionParserRuleCall_5_2_0 = (RuleCall)cElseIfConditionsAssignment_5_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		private final Assignment cElseIfBlocksAssignment_5_4 = (Assignment)cGroup_5.eContents().get(4);
		private final RuleCall cElseIfBlocksBlockParserRuleCall_5_4_0 = (RuleCall)cElseIfBlocksAssignment_5_4.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cElseKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cElseBlockAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cElseBlockBlockParserRuleCall_6_1_0 = (RuleCall)cElseBlockAssignment_6_1.eContents().get(0);
		
		//IfStatement returns actionlanguage::IfStatement:
		//	"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		//	("else" elseBlock=Block)?;
		public ParserRule getRule() { return rule; }

		//"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		//("else" elseBlock=Block)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//ifCondition=Expression
		public Assignment getIfConditionAssignment_2() { return cIfConditionAssignment_2; }

		//Expression
		public RuleCall getIfConditionExpressionParserRuleCall_2_0() { return cIfConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//ifBlock=Block
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }

		//Block
		public RuleCall getIfBlockBlockParserRuleCall_4_0() { return cIfBlockBlockParserRuleCall_4_0; }

		//("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		public Group getGroup_5() { return cGroup_5; }

		//"elseif"
		public Keyword getElseifKeyword_5_0() { return cElseifKeyword_5_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_5_1() { return cLeftParenthesisKeyword_5_1; }

		//elseIfConditions+=Expression
		public Assignment getElseIfConditionsAssignment_5_2() { return cElseIfConditionsAssignment_5_2; }

		//Expression
		public RuleCall getElseIfConditionsExpressionParserRuleCall_5_2_0() { return cElseIfConditionsExpressionParserRuleCall_5_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5_3() { return cRightParenthesisKeyword_5_3; }

		//elseIfBlocks+=Block
		public Assignment getElseIfBlocksAssignment_5_4() { return cElseIfBlocksAssignment_5_4; }

		//Block
		public RuleCall getElseIfBlocksBlockParserRuleCall_5_4_0() { return cElseIfBlocksBlockParserRuleCall_5_4_0; }

		//("else" elseBlock=Block)?
		public Group getGroup_6() { return cGroup_6; }

		//"else"
		public Keyword getElseKeyword_6_0() { return cElseKeyword_6_0; }

		//elseBlock=Block
		public Assignment getElseBlockAssignment_6_1() { return cElseBlockAssignment_6_1; }

		//Block
		public RuleCall getElseBlockBlockParserRuleCall_6_1_0() { return cElseBlockBlockParserRuleCall_6_1_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReturnStatement returns actionlanguage::ReturnStatement:
		//	{actionlanguage::ReturnStatement} "return" expression=Expression ";";
		public ParserRule getRule() { return rule; }

		//{actionlanguage::ReturnStatement} "return" expression=Expression ";"
		public Group getGroup() { return cGroup; }

		//{actionlanguage::ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//"return"
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class OperationCallStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCallStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOperationCallParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//OperationCallStatement returns actionlanguage::OperationCall:
		//	OperationCall ";";
		public ParserRule getRule() { return rule; }

		//OperationCall ";"
		public Group getGroup() { return cGroup; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_0() { return cOperationCallParserRuleCall_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class ExpressionStartRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionStartRule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDoWhileLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIfStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cReturnStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLocalVariableDeclarationStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cOperationCallStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//ExpressionStartRule returns expressions::Expression:
		//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement | LocalVariableDeclarationStatement |
		//	OperationCallStatement;
		public ParserRule getRule() { return rule; }

		//Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement | LocalVariableDeclarationStatement |
		//OperationCallStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_0() { return cAssignmentParserRuleCall_0; }

		//ForLoop
		public RuleCall getForLoopParserRuleCall_1() { return cForLoopParserRuleCall_1; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_2() { return cWhileLoopParserRuleCall_2; }

		//DoWhileLoop
		public RuleCall getDoWhileLoopParserRuleCall_3() { return cDoWhileLoopParserRuleCall_3; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_4() { return cIfStatementParserRuleCall_4; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_5() { return cReturnStatementParserRuleCall_5; }

		//LocalVariableDeclarationStatement
		public RuleCall getLocalVariableDeclarationStatementParserRuleCall_6() { return cLocalVariableDeclarationStatementParserRuleCall_6; }

		//OperationCallStatement
		public RuleCall getOperationCallStatementParserRuleCall_7() { return cOperationCallStatementParserRuleCall_7; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_typedNamedElementExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0 = (RuleCall)cLhs_typedNamedElementExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cAssignOperatorAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0 = (RuleCall)cAssignOperatorAssignment_1_0_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_0_1.eContents().get(0);
		private final Assignment cIncrementDecrementOperatorAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Assignment
		//Assignment returns actionlanguage::Assignment:
		//	lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
		//	rhs_assignExpression=InitializeExpression | incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ";";
		public ParserRule getRule() { return rule; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
		//rhs_assignExpression=InitializeExpression | incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ";"
		public Group getGroup() { return cGroup; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		public Assignment getLhs_typedNamedElementExpressionAssignment_0() { return cLhs_typedNamedElementExpressionAssignment_0; }

		//TypedNamedElementExpression
		public RuleCall getLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0() { return cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=InitializeExpression |
		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//assignOperator=AssignOperator rhs_assignExpression=InitializeExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_0_0() { return cAssignOperatorAssignment_1_0_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0; }

		//rhs_assignExpression=InitializeExpression
		public Assignment getRhs_assignExpressionAssignment_1_0_1() { return cRhs_assignExpressionAssignment_1_0_1; }

		//InitializeExpression
		public RuleCall getRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0() { return cRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_1() { return cIncrementDecrementOperatorAssignment_1_1; }

		//UnaryPostIncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0() { return cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class InitializeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InitializeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrayInitializeExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNondeterministicChoiceExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// end of assignment
		//// initialize expression
		//InitializeExpression returns expressions::Expression:
		//	ArrayInitializeExpression | NondeterministicChoiceExpression | Expression;
		public ParserRule getRule() { return rule; }

		//ArrayInitializeExpression | NondeterministicChoiceExpression | Expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrayInitializeExpression
		public RuleCall getArrayInitializeExpressionParserRuleCall_0() { return cArrayInitializeExpressionParserRuleCall_0; }

		//NondeterministicChoiceExpression
		public RuleCall getNondeterministicChoiceExpressionParserRuleCall_1() { return cNondeterministicChoiceExpressionParserRuleCall_1; }

		//Expression
		public RuleCall getExpressionParserRuleCall_2() { return cExpressionParserRuleCall_2; }
	}

	public class ArrayInitializeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayInitializeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsInitializeExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsInitializeExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// end of initialize expression
		//// array initialization
		//ArrayInitializeExpression returns actionlanguage::ArrayInitializeExpression:
		//	"{" expressions+=InitializeExpression ("," expressions+=InitializeExpression)* "}";
		public ParserRule getRule() { return rule; }

		//"{" expressions+=InitializeExpression ("," expressions+=InitializeExpression)* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//expressions+=InitializeExpression
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }

		//InitializeExpression
		public RuleCall getExpressionsInitializeExpressionParserRuleCall_1_0() { return cExpressionsInitializeExpressionParserRuleCall_1_0; }

		//("," expressions+=InitializeExpression)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//expressions+=InitializeExpression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }

		//InitializeExpression
		public RuleCall getExpressionsInitializeExpressionParserRuleCall_2_1_0() { return cExpressionsInitializeExpressionParserRuleCall_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class LocalVariableDeclarationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariableDeclarationStatement");
		private final Assignment cVariableAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVariableLocalVariableDeclarationParserRuleCall_0 = (RuleCall)cVariableAssignment.eContents().get(0);
		
		//// end of array initialization
		//// local variable declaration
		//LocalVariableDeclarationStatement returns actionlanguage::LocalVariableDeclarationStatement:
		//	variable=LocalVariableDeclaration;
		public ParserRule getRule() { return rule; }

		//variable=LocalVariableDeclaration
		public Assignment getVariableAssignment() { return cVariableAssignment; }

		//LocalVariableDeclaration
		public RuleCall getVariableLocalVariableDeclarationParserRuleCall_0() { return cVariableLocalVariableDeclarationParserRuleCall_0; }
	}

	public class LocalVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDataTypeDataTypeCrossReference_0_0 = (CrossReference)cDataTypeAssignment_0.eContents().get(0);
		private final RuleCall cDataTypeDataTypeDATATYPEParserRuleCall_0_0_1 = (RuleCall)cDataTypeDataTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInitializeExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitializeExpressionInitializeExpressionParserRuleCall_2_1_0 = (RuleCall)cInitializeExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//LocalVariableDeclaration returns behavior::Variable:
		//	dataType=[types::DataType|DATATYPE] name=ID (":=" initializeExpression=InitializeExpression)? ";";
		public ParserRule getRule() { return rule; }

		//dataType=[types::DataType|DATATYPE] name=ID (":=" initializeExpression=InitializeExpression)? ";"
		public Group getGroup() { return cGroup; }

		//dataType=[types::DataType|DATATYPE]
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//[types::DataType|DATATYPE]
		public CrossReference getDataTypeDataTypeCrossReference_0_0() { return cDataTypeDataTypeCrossReference_0_0; }

		//DATATYPE
		public RuleCall getDataTypeDataTypeDATATYPEParserRuleCall_0_0_1() { return cDataTypeDataTypeDATATYPEParserRuleCall_0_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//(":=" initializeExpression=InitializeExpression)?
		public Group getGroup_2() { return cGroup_2; }

		//":="
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//initializeExpression=InitializeExpression
		public Assignment getInitializeExpressionAssignment_2_1() { return cInitializeExpressionAssignment_2_1; }

		//InitializeExpression
		public RuleCall getInitializeExpressionInitializeExpressionParserRuleCall_2_1_0() { return cInitializeExpressionInitializeExpressionParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class NondeterministicChoiceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NondeterministicChoiceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDataTypePrimitiveDataTypeCrossReference_0_0 = (CrossReference)cDataTypeAssignment_0.eContents().get(0);
		private final RuleCall cDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cDataTypePrimitiveDataTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cRangeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRangeRangeParserRuleCall_1_0 = (RuleCall)cRangeAssignment_1.eContents().get(0);
		
		//// end of local variable declaration
		//// nondeterministic choice expression
		//NondeterministicChoiceExpression returns actionlanguage::NondeterministicChoiceExpression:
		//	dataType=[types::PrimitiveDataType] range=Range;
		public ParserRule getRule() { return rule; }

		//dataType=[types::PrimitiveDataType] range=Range
		public Group getGroup() { return cGroup; }

		//dataType=[types::PrimitiveDataType]
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//[types::PrimitiveDataType]
		public CrossReference getDataTypePrimitiveDataTypeCrossReference_0_0() { return cDataTypePrimitiveDataTypeCrossReference_0_0; }

		//ID
		public RuleCall getDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1() { return cDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1; }

		//range=Range
		public Assignment getRangeAssignment_1() { return cRangeAssignment_1; }

		//Range
		public RuleCall getRangeRangeParserRuleCall_1_0() { return cRangeRangeParserRuleCall_1_0; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundLONGParserRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundLONGParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Range returns valuetype::Range:
		//	"<" lowerBound=LONG "," upperBound=LONG ">";
		public ParserRule getRule() { return rule; }

		//"<" lowerBound=LONG "," upperBound=LONG ">"
		public Group getGroup() { return cGroup; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//lowerBound=LONG
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }

		//LONG
		public RuleCall getLowerBoundLONGParserRuleCall_1_0() { return cLowerBoundLONGParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//upperBound=LONG
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }

		//LONG
		public RuleCall getUpperBoundLONGParserRuleCall_3_0() { return cUpperBoundLONGParserRuleCall_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class LONGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LONG");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LONG returns ecore::ELong:
		//	INT;
		public ParserRule getRule() { return rule; }

		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLogicalExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of nondeterministic choice expression
		//Expression returns expressions::Expression:
		//	LogicalExpression;
		public ParserRule getRule() { return rule; }

		//LogicalExpression
		public RuleCall getLogicalExpressionParserRuleCall() { return cLogicalExpressionParserRuleCall; }
	}

	public class LogicalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression");
		private final RuleCall cLogicalOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// LogicalExpression
		//LogicalExpression returns expressions::Expression:
		//	LogicalOrExpression;
		public ParserRule getRule() { return rule; }

		//LogicalOrExpression
		public RuleCall getLogicalOrExpressionParserRuleCall() { return cLogicalOrExpressionParserRuleCall; }
	}

	public class LogicalOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOrOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalOrExpression returns expressions::Expression:
		//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//	rightExpression=LogicalAndExpression)*;
		public ParserRule getRule() { return rule; }

		//LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup() { return cGroup; }

		//LogicalAndExpression
		public RuleCall getLogicalAndExpressionParserRuleCall_0() { return cLogicalAndExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalOrOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOrOperator
		public RuleCall getOperatorLogicalOrOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalOrOperatorEnumRuleCall_1_1_0; }

		//rightExpression=LogicalAndExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//LogicalAndExpression
		public RuleCall getRightExpressionLogicalAndExpressionParserRuleCall_1_2_0() { return cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0; }
	}

	public class LogicalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalAndOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalAndExpression returns expressions::Expression:
		//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//	rightExpression=ComparisonExpression)*;
		public ParserRule getRule() { return rule; }

		//ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalAndOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalAndOperator
		public RuleCall getOperatorLogicalAndOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalAndOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightExpressionComparisonExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonHigherOpExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//// end of LogicalExpression
		//// ComparisonExpression
		//ComparisonExpression returns expressions::Expression:
		//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//	operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?;
		public ParserRule getRule() { return rule; }

		//ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup() { return cGroup; }

		//ComparisonHigherOpExpression
		public RuleCall getComparisonHigherOpExpressionParserRuleCall_0() { return cComparisonHigherOpExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingEQNEQOperator
		//rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingEQNEQOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingEQNEQOperator
		public RuleCall getOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0() { return cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonHigherOpExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonHigherOpExpression
		public RuleCall getRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonHigherOpExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonHigherOpExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArithmeticExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingRelOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionArithmeticExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//ComparisonHigherOpExpression returns expressions::Expression:
		//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//	rightExpression=ArithmeticExpression)?;
		public ParserRule getRule() { return rule; }

		//ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup() { return cGroup; }

		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall_0() { return cArithmeticExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingRelOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingRelOperator
		public RuleCall getOperatorComparingRelOperatorEnumRuleCall_1_1_0() { return cOperatorComparingRelOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ArithmeticExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ArithmeticExpression
		public RuleCall getRightExpressionArithmeticExpressionParserRuleCall_1_2_0() { return cRightExpressionArithmeticExpressionParserRuleCall_1_2_0; }
	}

	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticExpression");
		private final RuleCall cAdditionExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of ComparisonExpression
		//// ArithmeticExpression	
		//ArithmeticExpression returns expressions::Expression:
		//	AdditionExpression;
		public ParserRule getRule() { return rule; }

		//AdditionExpression
		public RuleCall getAdditionExpressionParserRuleCall() { return cAdditionExpressionParserRuleCall; }
	}

	public class AdditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditionOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//AdditionExpression returns expressions::Expression:
		//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//	rightExpression=MultiplicationExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicationExpression
		public RuleCall getMultiplicationExpressionParserRuleCall_0() { return cMultiplicationExpressionParserRuleCall_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=AdditionOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditionOperator
		public RuleCall getOperatorAdditionOperatorEnumRuleCall_1_1_0() { return cOperatorAdditionOperatorEnumRuleCall_1_1_0; }

		//rightExpression=MultiplicationExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//MultiplicationExpression
		public RuleCall getRightExpressionMultiplicationExpressionParserRuleCall_1_2_0() { return cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryPreExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cOperandParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0 = (RuleCall)cOperatorAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final Alternatives cRightExpressionAlternatives_1_1_2_0 = (Alternatives)cRightExpressionAssignment_1_1_2.eContents().get(0);
		private final RuleCall cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(0);
		private final RuleCall cRightExpressionOperandParserRuleCall_1_1_2_0_1 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(1);
		
		//MultiplicationExpression returns expressions::Expression:
		//	UnaryPreExpression | Operand ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | Operand))*;
		public ParserRule getRule() { return rule; }

		//UnaryPreExpression | Operand ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//operator=MultiplicationOperator rightExpression=(UnaryPreExpression | Operand))*
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnaryPreExpression
		public RuleCall getUnaryPreExpressionParserRuleCall_0() { return cUnaryPreExpressionParserRuleCall_0; }

		//Operand ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | Operand))*
		public Group getGroup_1() { return cGroup_1; }

		//Operand
		public RuleCall getOperandParserRuleCall_1_0() { return cOperandParserRuleCall_1_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | Operand))*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_1_0() { return cArithmeticExpressionLeftExpressionAction_1_1_0; }

		//operator=MultiplicationOperator
		public Assignment getOperatorAssignment_1_1_1() { return cOperatorAssignment_1_1_1; }

		//MultiplicationOperator
		public RuleCall getOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0() { return cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0; }

		//rightExpression=(UnaryPreExpression | Operand)
		public Assignment getRightExpressionAssignment_1_1_2() { return cRightExpressionAssignment_1_1_2; }

		//UnaryPreExpression | Operand
		public Alternatives getRightExpressionAlternatives_1_1_2_0() { return cRightExpressionAlternatives_1_1_2_0; }

		//UnaryPreExpression
		public RuleCall getRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0() { return cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0; }

		//Operand
		public RuleCall getRightExpressionOperandParserRuleCall_1_1_2_0_1() { return cRightExpressionOperandParserRuleCall_1_1_2_0_1; }
	}

	public class UnaryPreExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPreExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnaryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorUnaryPreOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cEnclosedExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEnclosedExpressionOperandParserRuleCall_2_0 = (RuleCall)cEnclosedExpressionAssignment_2.eContents().get(0);
		
		//// end of ArithmeticExpression
		//// UnaryPreExpression
		//UnaryPreExpression returns expressions::Expression:
		//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=Operand;
		public ParserRule getRule() { return rule; }

		//{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=Operand
		public Group getGroup() { return cGroup; }

		//{commonExpressions::UnaryExpression}
		public Action getUnaryExpressionAction_0() { return cUnaryExpressionAction_0; }

		//operator=UnaryPreOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//UnaryPreOperator
		public RuleCall getOperatorUnaryPreOperatorEnumRuleCall_1_0() { return cOperatorUnaryPreOperatorEnumRuleCall_1_0; }

		//enclosedExpression=Operand
		public Assignment getEnclosedExpressionAssignment_2() { return cEnclosedExpressionAssignment_2; }

		//Operand
		public RuleCall getEnclosedExpressionOperandParserRuleCall_2_0() { return cEnclosedExpressionOperandParserRuleCall_2_0; }
	}

	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendedTypedNamedElementExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cOperationCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTriggerMessageExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cNoAttributeSelectorExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//// end of UnaryPreExpression
		//// Operand
		//Operand returns expressions::Expression:
		//	"(" Expression ")" | LiteralExpression | ExtendedTypedNamedElementExpression | OperationCall |
		//	TriggerMessageExpression | NoAttributeSelectorExpression;
		public ParserRule getRule() { return rule; }

		//"(" Expression ")" | LiteralExpression | ExtendedTypedNamedElementExpression | OperationCall | TriggerMessageExpression
		//| NoAttributeSelectorExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_1() { return cLiteralExpressionParserRuleCall_1; }

		//ExtendedTypedNamedElementExpression
		public RuleCall getExtendedTypedNamedElementExpressionParserRuleCall_2() { return cExtendedTypedNamedElementExpressionParserRuleCall_2; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_3() { return cOperationCallParserRuleCall_3; }

		//TriggerMessageExpression
		public RuleCall getTriggerMessageExpressionParserRuleCall_4() { return cTriggerMessageExpressionParserRuleCall_4; }

		//NoAttributeSelectorExpression
		public RuleCall getNoAttributeSelectorExpressionParserRuleCall_5() { return cNoAttributeSelectorExpressionParserRuleCall_5; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//// end of Operand
		//LiteralExpression returns commonExpressions::LiteralExpression:
		//	{commonExpressions::LiteralExpression} value=Literal;
		public ParserRule getRule() { return rule; }

		//{commonExpressions::LiteralExpression} value=Literal
		public Group getGroup() { return cGroup; }

		//{commonExpressions::LiteralExpression}
		public Action getLiteralExpressionAction_0() { return cLiteralExpressionAction_0; }

		//value=Literal
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_0() { return cValueLiteralParserRuleCall_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNUMBERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBOOLEANTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSTRINGTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Literal returns ecore::EString:
		//	NUMBER | BOOLEAN | INT | STRING;
		public ParserRule getRule() { return rule; }

		//NUMBER | BOOLEAN | INT | STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_0() { return cNUMBERTerminalRuleCall_0; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_1() { return cBOOLEANTerminalRuleCall_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3() { return cSTRINGTerminalRuleCall_3; }
	}

	public class ExtendedTypedNamedElementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExtendedTypedNamedElementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTypedNamedElementExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cPositionAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cPositionPositionSelectorExpressionParserRuleCall_1_0_2_0 = (RuleCall)cPositionAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cAssignmentLhs_typedNamedElementExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cIncrementDecrementOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_1_1.eContents().get(0);
		
		//ExtendedTypedNamedElementExpression returns expressions::Expression:
		//	TypedNamedElementExpression
		//	({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "."
		//	position=PositionSelectorExpression | // unary post increment/decrement			
		//	{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//	incrementDecrementOperator=IncrementDecrementOperatorExpression)?;
		public ParserRule getRule() { return rule; }

		//TypedNamedElementExpression ({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
		//"." position=PositionSelectorExpression | // unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression)?
		public Group getGroup() { return cGroup; }

		//TypedNamedElementExpression
		public RuleCall getTypedNamedElementExpressionParserRuleCall_0() { return cTypedNamedElementExpressionParserRuleCall_0; }

		//({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "."
		//position=PositionSelectorExpression | // unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "."
		//position=PositionSelectorExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
		public Action getDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0() { return cDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0; }

		//"."
		public Keyword getFullStopKeyword_1_0_1() { return cFullStopKeyword_1_0_1; }

		//position=PositionSelectorExpression
		public Assignment getPositionAssignment_1_0_2() { return cPositionAssignment_1_0_2; }

		//PositionSelectorExpression
		public RuleCall getPositionPositionSelectorExpressionParserRuleCall_1_0_2_0() { return cPositionPositionSelectorExpressionParserRuleCall_1_0_2_0; }

		//// unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//// unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		public Action getAssignmentLhs_typedNamedElementExpressionAction_1_1_0() { return cAssignmentLhs_typedNamedElementExpressionAction_1_1_0; }

		//incrementDecrementOperator=IncrementDecrementOperatorExpression
		public Assignment getIncrementDecrementOperatorAssignment_1_1_1() { return cIncrementDecrementOperatorAssignment_1_1_1; }

		//IncrementDecrementOperatorExpression
		public RuleCall getIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0() { return cIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0; }
	}

	public class TypedNamedElementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedNamedElementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypedNamedElementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypedNamedElementTypedNamedElementCrossReference_0_0 = (CrossReference)cTypedNamedElementAssignment_0.eContents().get(0);
		private final RuleCall cTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1 = (RuleCall)cTypedNamedElementTypedNamedElementCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIndicesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIndicesArithmeticExpressionParserRuleCall_1_1_0 = (RuleCall)cIndicesAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//TypedNamedElementExpression returns actionlanguage::TypedNamedElementExpression:
		//	typedNamedElement=[behavior::TypedNamedElement] ("[" indices+=ArithmeticExpression "]")*;
		public ParserRule getRule() { return rule; }

		//typedNamedElement=[behavior::TypedNamedElement] ("[" indices+=ArithmeticExpression "]")*
		public Group getGroup() { return cGroup; }

		//typedNamedElement=[behavior::TypedNamedElement]
		public Assignment getTypedNamedElementAssignment_0() { return cTypedNamedElementAssignment_0; }

		//[behavior::TypedNamedElement]
		public CrossReference getTypedNamedElementTypedNamedElementCrossReference_0_0() { return cTypedNamedElementTypedNamedElementCrossReference_0_0; }

		//ID
		public RuleCall getTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1() { return cTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1; }

		//("[" indices+=ArithmeticExpression "]")*
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//indices+=ArithmeticExpression
		public Assignment getIndicesAssignment_1_1() { return cIndicesAssignment_1_1; }

		//ArithmeticExpression
		public RuleCall getIndicesArithmeticExpressionParserRuleCall_1_1_0() { return cIndicesArithmeticExpressionParserRuleCall_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}

	public class NoAttributeSelectorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NoAttributeSelectorExpression");
		private final Assignment cPositionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPositionPositionSelectorExpressionParserRuleCall_0 = (RuleCall)cPositionAssignment.eContents().get(0);
		
		//NoAttributeSelectorExpression returns actionlanguage::DiscreteInteractionEndpointReference:
		//	position=PositionSelectorExpression;
		public ParserRule getRule() { return rule; }

		//position=PositionSelectorExpression
		public Assignment getPositionAssignment() { return cPositionAssignment; }

		//PositionSelectorExpression
		public RuleCall getPositionPositionSelectorExpressionParserRuleCall_0() { return cPositionPositionSelectorExpressionParserRuleCall_0; }
	}

	public class PositionSelectorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PositionSelectorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKindPositionSelectorKindEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSuccessorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSuccessorPositionSelectorExpressionParserRuleCall_1_1_0 = (RuleCall)cSuccessorAssignment_1_1.eContents().get(0);
		
		//PositionSelectorExpression returns actionlanguage::PositionSelector:
		//	kind=PositionSelectorKind ("." successor=PositionSelectorExpression)?;
		public ParserRule getRule() { return rule; }

		//kind=PositionSelectorKind ("." successor=PositionSelectorExpression)?
		public Group getGroup() { return cGroup; }

		//kind=PositionSelectorKind
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }

		//PositionSelectorKind
		public RuleCall getKindPositionSelectorKindEnumRuleCall_0_0() { return cKindPositionSelectorKindEnumRuleCall_0_0; }

		//("." successor=PositionSelectorExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//successor=PositionSelectorExpression
		public Assignment getSuccessorAssignment_1_1() { return cSuccessorAssignment_1_1; }

		//PositionSelectorExpression
		public RuleCall getSuccessorPositionSelectorExpressionParserRuleCall_1_1_0() { return cSuccessorPositionSelectorExpressionParserRuleCall_1_1_0; }
	}

	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cOperationOperationCrossReference_0_0 = (CrossReference)cOperationAssignment_0.eContents().get(0);
		private final RuleCall cOperationOperationIDTerminalRuleCall_0_0_1 = (RuleCall)cOperationOperationCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterBindingAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_0_0 = (RuleCall)cParameterBindingAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterBindingAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_1_1_0 = (RuleCall)cParameterBindingAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//OperationCall returns actionlanguage::OperationCall:
		//	operation=[behavior::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)?
		//	")";
		public ParserRule getRule() { return rule; }

		//operation=[behavior::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)? ")"
		public Group getGroup() { return cGroup; }

		//operation=[behavior::Operation]
		public Assignment getOperationAssignment_0() { return cOperationAssignment_0; }

		//[behavior::Operation]
		public CrossReference getOperationOperationCrossReference_0_0() { return cOperationOperationCrossReference_0_0; }

		//ID
		public RuleCall getOperationOperationIDTerminalRuleCall_0_0_1() { return cOperationOperationIDTerminalRuleCall_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_0() { return cParameterBindingAssignment_2_0; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_0_0() { return cParameterBindingParamaterBindingParserRuleCall_2_0_0; }

		//("," parameterBinding+=ParamaterBinding)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_1_1() { return cParameterBindingAssignment_2_1_1; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_1_1_0() { return cParameterBindingParamaterBindingParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ParamaterBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParamaterBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterBindingAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cParameterParameterCrossReference_1_0 = (CrossReference)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_1_0_1 = (RuleCall)cParameterParameterCrossReference_1_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ParamaterBinding returns behavior::ParameterBinding:
		//	{behavior::ParameterBinding} parameter=[behavior::Parameter] ":=" value=Expression;
		public ParserRule getRule() { return rule; }

		//{behavior::ParameterBinding} parameter=[behavior::Parameter] ":=" value=Expression
		public Group getGroup() { return cGroup; }

		//{behavior::ParameterBinding}
		public Action getParameterBindingAction_0() { return cParameterBindingAction_0; }

		//parameter=[behavior::Parameter]
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }

		//[behavior::Parameter]
		public CrossReference getParameterParameterCrossReference_1_0() { return cParameterParameterCrossReference_1_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_1_0_1() { return cParameterParameterIDTerminalRuleCall_1_0_1; }

		//":="
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class TriggerMessageExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TriggerMessageExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMessageTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cMessageTypeMessageTypeCrossReference_0_0 = (CrossReference)cMessageTypeAssignment_0.eContents().get(0);
		private final RuleCall cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cMessageTypeMessageTypeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParameterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cParameterParameterCrossReference_2_0 = (CrossReference)cParameterAssignment_2.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_2_0_1 = (RuleCall)cParameterParameterCrossReference_2_0.eContents().get(1);
		
		//// TriggerMessageExpression
		//TriggerMessageExpression returns actionlanguage::TriggerMessageExpression:
		//	messageType=[msgtype::MessageType] "." parameter=[behavior::Parameter];
		public ParserRule getRule() { return rule; }

		//messageType=[msgtype::MessageType] "." parameter=[behavior::Parameter]
		public Group getGroup() { return cGroup; }

		//messageType=[msgtype::MessageType]
		public Assignment getMessageTypeAssignment_0() { return cMessageTypeAssignment_0; }

		//[msgtype::MessageType]
		public CrossReference getMessageTypeMessageTypeCrossReference_0_0() { return cMessageTypeMessageTypeCrossReference_0_0; }

		//ID
		public RuleCall getMessageTypeMessageTypeIDTerminalRuleCall_0_0_1() { return cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//parameter=[behavior::Parameter]
		public Assignment getParameterAssignment_2() { return cParameterAssignment_2; }

		//[behavior::Parameter]
		public CrossReference getParameterParameterCrossReference_2_0() { return cParameterParameterCrossReference_2_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_2_0_1() { return cParameterParameterIDTerminalRuleCall_2_0_1; }
	}

	public class DATATYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DATATYPE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//DATATYPE returns ecore::EString:
		//	ID ("[" INT "]")*;
		public ParserRule getRule() { return rule; }

		//ID ("[" INT "]")*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("[" INT "]")*
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	
	
	public class UnaryPostIncrementDecrementOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPostIncrementDecrementOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryPostIncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class IncrementDecrementOperatorExpressionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "IncrementDecrementOperatorExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum IncrementDecrementOperatorExpression returns actionlanguage::IncrementDecrementOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class AssignOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cASSIGNEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cASSIGNColonEqualsSignKeyword_0_0 = (Keyword)cASSIGNEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUS_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUS_EQUALPlusSignEqualsSignKeyword_1_0 = (Keyword)cPLUS_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUAL_PLUSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUAL_PLUSEqualsSignPlusSignKeyword_2_0 = (Keyword)cEQUAL_PLUSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMINUS_EQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0 = (Keyword)cMINUS_EQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEQUAL_MINUSEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0 = (Keyword)cEQUAL_MINUSEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum AssignOperator returns actionlanguage::AssignOperator:
		//	ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-";
		public EnumRule getRule() { return rule; }

		//ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASSIGN=":="
		public EnumLiteralDeclaration getASSIGNEnumLiteralDeclaration_0() { return cASSIGNEnumLiteralDeclaration_0; }

		//":="
		public Keyword getASSIGNColonEqualsSignKeyword_0_0() { return cASSIGNColonEqualsSignKeyword_0_0; }

		//PLUS_EQUAL="+="
		public EnumLiteralDeclaration getPLUS_EQUALEnumLiteralDeclaration_1() { return cPLUS_EQUALEnumLiteralDeclaration_1; }

		//"+="
		public Keyword getPLUS_EQUALPlusSignEqualsSignKeyword_1_0() { return cPLUS_EQUALPlusSignEqualsSignKeyword_1_0; }

		//EQUAL_PLUS="=+"
		public EnumLiteralDeclaration getEQUAL_PLUSEnumLiteralDeclaration_2() { return cEQUAL_PLUSEnumLiteralDeclaration_2; }

		//"=+"
		public Keyword getEQUAL_PLUSEqualsSignPlusSignKeyword_2_0() { return cEQUAL_PLUSEqualsSignPlusSignKeyword_2_0; }

		//MINUS_EQUAL="-="
		public EnumLiteralDeclaration getMINUS_EQUALEnumLiteralDeclaration_3() { return cMINUS_EQUALEnumLiteralDeclaration_3; }

		//"-="
		public Keyword getMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0() { return cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0; }

		//EQUAL_MINUS="=-"
		public EnumLiteralDeclaration getEQUAL_MINUSEnumLiteralDeclaration_4() { return cEQUAL_MINUSEnumLiteralDeclaration_4; }

		//"=-"
		public Keyword getEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0() { return cEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0; }
	}

	public class LogicalOrOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOrOperator");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORVerticalLineVerticalLineKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalOrOperator returns commonExpressions::LogicOperator:
		//	OR="||";
		public EnumRule getRule() { return rule; }

		//OR="||"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }

		//"||"
		public Keyword getORVerticalLineVerticalLineKeyword_0() { return cORVerticalLineVerticalLineKeyword_0; }
	}

	public class LogicalAndOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAndOperator");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDAmpersandAmpersandKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalAndOperator returns commonExpressions::LogicOperator:
		//	AND="&&";
		public EnumRule getRule() { return rule; }

		//AND="&&"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }

		//"&&"
		public Keyword getANDAmpersandAmpersandKeyword_0() { return cANDAmpersandAmpersandKeyword_0; }
	}

	public class ComparingEQNEQOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingEQNEQOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUNEQUALLessThanSignGreaterThanSignKeyword_1_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
		//	EQUAL="==" | UNEQUAL="<>";
		public EnumRule getRule() { return rule; }

		//EQUAL="==" | UNEQUAL="<>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL="=="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQUALEqualsSignEqualsSignKeyword_0_0() { return cEQUALEqualsSignEqualsSignKeyword_0_0; }

		//UNEQUAL="<>"
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_1() { return cUNEQUALEnumLiteralDeclaration_1; }

		//"<>"
		public Keyword getUNEQUALLessThanSignGreaterThanSignKeyword_1_0() { return cUNEQUALLessThanSignGreaterThanSignKeyword_1_0; }
	}

	public class ComparingRelOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingRelOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLESSLessThanSignKeyword_0_0 = (Keyword)cLESSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGREATERGreaterThanSignKeyword_3_0 = (Keyword)cGREATEREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
		//	LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">";
		public EnumRule getRule() { return rule; }

		//LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">"
		public Alternatives getAlternatives() { return cAlternatives; }

		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_0() { return cLESSEnumLiteralDeclaration_0; }

		//"<"
		public Keyword getLESSLessThanSignKeyword_0_0() { return cLESSLessThanSignKeyword_0_0; }

		//LESS_OR_EQUAL="<="
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_1() { return cLESS_OR_EQUALEnumLiteralDeclaration_1; }

		//"<="
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0; }

		//GREATER_OR_EQUAL=">="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_2() { return cGREATER_OR_EQUALEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0; }

		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_3() { return cGREATEREnumLiteralDeclaration_3; }

		//">"
		public Keyword getGREATERGreaterThanSignKeyword_3_0() { return cGREATERGreaterThanSignKeyword_3_0; }
	}

	public class AdditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
		//	PLUS="+" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class MultiplicationOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTIMESAsteriskKeyword_0_0 = (Keyword)cTIMESEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVIDESolidusKeyword_1_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
		//	TIMES="*" | DIVIDE="/";
		public EnumRule getRule() { return rule; }

		//TIMES="*" | DIVIDE="/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//TIMES="*"
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration_0() { return cTIMESEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getTIMESAsteriskKeyword_0_0() { return cTIMESAsteriskKeyword_0_0; }

		//DIVIDE="/"
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_1() { return cDIVIDEEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDIVIDESolidusKeyword_1_0() { return cDIVIDESolidusKeyword_1_0; }
	}

	public class UnaryPreOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPreOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNOTNotKeyword_0_0 = (Keyword)cNOTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
		//	NOT="not" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//NOT="not" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT="not"
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_0() { return cNOTEnumLiteralDeclaration_0; }

		//"not"
		public Keyword getNOTNotKeyword_0_0() { return cNOTNotKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class PositionSelectorKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "PositionSelectorKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSELFEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSELFSelfKeyword_0_0 = (Keyword)cSELFEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFIRSTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFIRSTFirstKeyword_1_0 = (Keyword)cFIRSTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLASTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLASTLastKeyword_2_0 = (Keyword)cLASTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cPREVEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cPREVPrevKeyword_3_0 = (Keyword)cPREVEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cNEXTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cNEXTNextKeyword_4_0 = (Keyword)cNEXTEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
		//	SELF="self" | FIRST="first" | LAST="last" | PREV="prev" | NEXT="next";
		public EnumRule getRule() { return rule; }

		//SELF="self" | FIRST="first" | LAST="last" | PREV="prev" | NEXT="next"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SELF="self"
		public EnumLiteralDeclaration getSELFEnumLiteralDeclaration_0() { return cSELFEnumLiteralDeclaration_0; }

		//"self"
		public Keyword getSELFSelfKeyword_0_0() { return cSELFSelfKeyword_0_0; }

		//FIRST="first"
		public EnumLiteralDeclaration getFIRSTEnumLiteralDeclaration_1() { return cFIRSTEnumLiteralDeclaration_1; }

		//"first"
		public Keyword getFIRSTFirstKeyword_1_0() { return cFIRSTFirstKeyword_1_0; }

		//LAST="last"
		public EnumLiteralDeclaration getLASTEnumLiteralDeclaration_2() { return cLASTEnumLiteralDeclaration_2; }

		//"last"
		public Keyword getLASTLastKeyword_2_0() { return cLASTLastKeyword_2_0; }

		//PREV="prev"
		public EnumLiteralDeclaration getPREVEnumLiteralDeclaration_3() { return cPREVEnumLiteralDeclaration_3; }

		//"prev"
		public Keyword getPREVPrevKeyword_3_0() { return cPREVPrevKeyword_3_0; }

		//NEXT="next"
		public EnumLiteralDeclaration getNEXTEnumLiteralDeclaration_4() { return cNEXTEnumLiteralDeclaration_4; }

		//"next"
		public Keyword getNEXTNextKeyword_4_0() { return cNEXTNextKeyword_4_0; }
	}
	
	private EntryElements pEntry;
	private BlockElements pBlock;
	private ForLoopElements pForLoop;
	private ForLoopCountingExpressionElements pForLoopCountingExpression;
	private WhileLoopElements pWhileLoop;
	private DoWhileLoopElements pDoWhileLoop;
	private IfStatementElements pIfStatement;
	private ReturnStatementElements pReturnStatement;
	private OperationCallStatementElements pOperationCallStatement;
	private ExpressionStartRuleElements pExpressionStartRule;
	private UnaryPostIncrementDecrementOperatorElements unknownRuleUnaryPostIncrementDecrementOperator;
	private AssignmentElements pAssignment;
	private IncrementDecrementOperatorExpressionElements unknownRuleIncrementDecrementOperatorExpression;
	private AssignOperatorElements unknownRuleAssignOperator;
	private InitializeExpressionElements pInitializeExpression;
	private ArrayInitializeExpressionElements pArrayInitializeExpression;
	private LocalVariableDeclarationStatementElements pLocalVariableDeclarationStatement;
	private LocalVariableDeclarationElements pLocalVariableDeclaration;
	private NondeterministicChoiceExpressionElements pNondeterministicChoiceExpression;
	private RangeElements pRange;
	private LONGElements pLONG;
	private ExpressionElements pExpression;
	private LogicalExpressionElements pLogicalExpression;
	private LogicalOrExpressionElements pLogicalOrExpression;
	private LogicalOrOperatorElements unknownRuleLogicalOrOperator;
	private LogicalAndExpressionElements pLogicalAndExpression;
	private LogicalAndOperatorElements unknownRuleLogicalAndOperator;
	private ComparisonExpressionElements pComparisonExpression;
	private ComparisonHigherOpExpressionElements pComparisonHigherOpExpression;
	private ComparingEQNEQOperatorElements unknownRuleComparingEQNEQOperator;
	private ComparingRelOperatorElements unknownRuleComparingRelOperator;
	private ArithmeticExpressionElements pArithmeticExpression;
	private AdditionExpressionElements pAdditionExpression;
	private AdditionOperatorElements unknownRuleAdditionOperator;
	private MultiplicationExpressionElements pMultiplicationExpression;
	private MultiplicationOperatorElements unknownRuleMultiplicationOperator;
	private UnaryPreExpressionElements pUnaryPreExpression;
	private UnaryPreOperatorElements unknownRuleUnaryPreOperator;
	private OperandElements pOperand;
	private LiteralExpressionElements pLiteralExpression;
	private LiteralElements pLiteral;
	private ExtendedTypedNamedElementExpressionElements pExtendedTypedNamedElementExpression;
	private TypedNamedElementExpressionElements pTypedNamedElementExpression;
	private NoAttributeSelectorExpressionElements pNoAttributeSelectorExpression;
	private PositionSelectorExpressionElements pPositionSelectorExpression;
	private PositionSelectorKindElements unknownRulePositionSelectorKind;
	private OperationCallElements pOperationCall;
	private ParamaterBindingElements pParamaterBinding;
	private TriggerMessageExpressionElements pTriggerMessageExpression;
	private TerminalRule tNUMBER;
	private TerminalRule tBOOLEAN;
	private TerminalRule tID;
	private DATATYPEElements pDATATYPE;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public ActionLanguageGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.uni_paderborn.fujaba.muml.ActionLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Entry returns expressions::Expression:
	//	Block | Expression;
	public EntryElements getEntryAccess() {
		return (pEntry != null) ? pEntry : (pEntry = new EntryElements());
	}
	
	public ParserRule getEntryRule() {
		return getEntryAccess().getRule();
	}

	//Block returns actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	//	{actionlanguage::Block} "{" expressions+=ExpressionStartRule* "}";
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// TODO: clarify if it makes sense to allow arbitrary expressions for
	//// the initializeExpression and countingExpression
	//ForLoop returns actionlanguage::ForLoop:
	//	"for" "(" initializeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
	//	block=Block;
	public ForLoopElements getForLoopAccess() {
		return (pForLoop != null) ? pForLoop : (pForLoop = new ForLoopElements());
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}

	//ForLoopCountingExpression returns actionlanguage::Assignment:
	//	lhs_typedNamedElementExpression=TypedNamedElementExpression
	//	(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
	//	rhs_assignExpression=Expression);
	public ForLoopCountingExpressionElements getForLoopCountingExpressionAccess() {
		return (pForLoopCountingExpression != null) ? pForLoopCountingExpression : (pForLoopCountingExpression = new ForLoopCountingExpressionElements());
	}
	
	public ParserRule getForLoopCountingExpressionRule() {
		return getForLoopCountingExpressionAccess().getRule();
	}

	//WhileLoop returns actionlanguage::WhileLoop:
	//	"while" "(" loopTest=Expression ")" block=Block;
	public WhileLoopElements getWhileLoopAccess() {
		return (pWhileLoop != null) ? pWhileLoop : (pWhileLoop = new WhileLoopElements());
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//DoWhileLoop returns actionlanguage::DoWhileLoop:
	//	"do" block=Block "while" "(" loopTest=Expression ");";
	public DoWhileLoopElements getDoWhileLoopAccess() {
		return (pDoWhileLoop != null) ? pDoWhileLoop : (pDoWhileLoop = new DoWhileLoopElements());
	}
	
	public ParserRule getDoWhileLoopRule() {
		return getDoWhileLoopAccess().getRule();
	}

	//IfStatement returns actionlanguage::IfStatement:
	//	"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
	//	("else" elseBlock=Block)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//ReturnStatement returns actionlanguage::ReturnStatement:
	//	{actionlanguage::ReturnStatement} "return" expression=Expression ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//OperationCallStatement returns actionlanguage::OperationCall:
	//	OperationCall ";";
	public OperationCallStatementElements getOperationCallStatementAccess() {
		return (pOperationCallStatement != null) ? pOperationCallStatement : (pOperationCallStatement = new OperationCallStatementElements());
	}
	
	public ParserRule getOperationCallStatementRule() {
		return getOperationCallStatementAccess().getRule();
	}

	//ExpressionStartRule returns expressions::Expression:
	//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement | LocalVariableDeclarationStatement |
	//	OperationCallStatement;
	public ExpressionStartRuleElements getExpressionStartRuleAccess() {
		return (pExpressionStartRule != null) ? pExpressionStartRule : (pExpressionStartRule = new ExpressionStartRuleElements());
	}
	
	public ParserRule getExpressionStartRuleRule() {
		return getExpressionStartRuleAccess().getRule();
	}

	//enum UnaryPostIncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public UnaryPostIncrementDecrementOperatorElements getUnaryPostIncrementDecrementOperatorAccess() {
		return (unknownRuleUnaryPostIncrementDecrementOperator != null) ? unknownRuleUnaryPostIncrementDecrementOperator : (unknownRuleUnaryPostIncrementDecrementOperator = new UnaryPostIncrementDecrementOperatorElements());
	}
	
	public EnumRule getUnaryPostIncrementDecrementOperatorRule() {
		return getUnaryPostIncrementDecrementOperatorAccess().getRule();
	}

	//// Assignment
	//Assignment returns actionlanguage::Assignment:
	//	lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
	//	rhs_assignExpression=InitializeExpression | incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ";";
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//enum IncrementDecrementOperatorExpression returns actionlanguage::IncrementDecrementOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public IncrementDecrementOperatorExpressionElements getIncrementDecrementOperatorExpressionAccess() {
		return (unknownRuleIncrementDecrementOperatorExpression != null) ? unknownRuleIncrementDecrementOperatorExpression : (unknownRuleIncrementDecrementOperatorExpression = new IncrementDecrementOperatorExpressionElements());
	}
	
	public EnumRule getIncrementDecrementOperatorExpressionRule() {
		return getIncrementDecrementOperatorExpressionAccess().getRule();
	}

	//enum AssignOperator returns actionlanguage::AssignOperator:
	//	ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-";
	public AssignOperatorElements getAssignOperatorAccess() {
		return (unknownRuleAssignOperator != null) ? unknownRuleAssignOperator : (unknownRuleAssignOperator = new AssignOperatorElements());
	}
	
	public EnumRule getAssignOperatorRule() {
		return getAssignOperatorAccess().getRule();
	}

	//// end of assignment
	//// initialize expression
	//InitializeExpression returns expressions::Expression:
	//	ArrayInitializeExpression | NondeterministicChoiceExpression | Expression;
	public InitializeExpressionElements getInitializeExpressionAccess() {
		return (pInitializeExpression != null) ? pInitializeExpression : (pInitializeExpression = new InitializeExpressionElements());
	}
	
	public ParserRule getInitializeExpressionRule() {
		return getInitializeExpressionAccess().getRule();
	}

	//// end of initialize expression
	//// array initialization
	//ArrayInitializeExpression returns actionlanguage::ArrayInitializeExpression:
	//	"{" expressions+=InitializeExpression ("," expressions+=InitializeExpression)* "}";
	public ArrayInitializeExpressionElements getArrayInitializeExpressionAccess() {
		return (pArrayInitializeExpression != null) ? pArrayInitializeExpression : (pArrayInitializeExpression = new ArrayInitializeExpressionElements());
	}
	
	public ParserRule getArrayInitializeExpressionRule() {
		return getArrayInitializeExpressionAccess().getRule();
	}

	//// end of array initialization
	//// local variable declaration
	//LocalVariableDeclarationStatement returns actionlanguage::LocalVariableDeclarationStatement:
	//	variable=LocalVariableDeclaration;
	public LocalVariableDeclarationStatementElements getLocalVariableDeclarationStatementAccess() {
		return (pLocalVariableDeclarationStatement != null) ? pLocalVariableDeclarationStatement : (pLocalVariableDeclarationStatement = new LocalVariableDeclarationStatementElements());
	}
	
	public ParserRule getLocalVariableDeclarationStatementRule() {
		return getLocalVariableDeclarationStatementAccess().getRule();
	}

	//LocalVariableDeclaration returns behavior::Variable:
	//	dataType=[types::DataType|DATATYPE] name=ID (":=" initializeExpression=InitializeExpression)? ";";
	public LocalVariableDeclarationElements getLocalVariableDeclarationAccess() {
		return (pLocalVariableDeclaration != null) ? pLocalVariableDeclaration : (pLocalVariableDeclaration = new LocalVariableDeclarationElements());
	}
	
	public ParserRule getLocalVariableDeclarationRule() {
		return getLocalVariableDeclarationAccess().getRule();
	}

	//// end of local variable declaration
	//// nondeterministic choice expression
	//NondeterministicChoiceExpression returns actionlanguage::NondeterministicChoiceExpression:
	//	dataType=[types::PrimitiveDataType] range=Range;
	public NondeterministicChoiceExpressionElements getNondeterministicChoiceExpressionAccess() {
		return (pNondeterministicChoiceExpression != null) ? pNondeterministicChoiceExpression : (pNondeterministicChoiceExpression = new NondeterministicChoiceExpressionElements());
	}
	
	public ParserRule getNondeterministicChoiceExpressionRule() {
		return getNondeterministicChoiceExpressionAccess().getRule();
	}

	//Range returns valuetype::Range:
	//	"<" lowerBound=LONG "," upperBound=LONG ">";
	public RangeElements getRangeAccess() {
		return (pRange != null) ? pRange : (pRange = new RangeElements());
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//LONG returns ecore::ELong:
	//	INT;
	public LONGElements getLONGAccess() {
		return (pLONG != null) ? pLONG : (pLONG = new LONGElements());
	}
	
	public ParserRule getLONGRule() {
		return getLONGAccess().getRule();
	}

	//// end of nondeterministic choice expression
	//Expression returns expressions::Expression:
	//	LogicalExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// LogicalExpression
	//LogicalExpression returns expressions::Expression:
	//	LogicalOrExpression;
	public LogicalExpressionElements getLogicalExpressionAccess() {
		return (pLogicalExpression != null) ? pLogicalExpression : (pLogicalExpression = new LogicalExpressionElements());
	}
	
	public ParserRule getLogicalExpressionRule() {
		return getLogicalExpressionAccess().getRule();
	}

	//LogicalOrExpression returns expressions::Expression:
	//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
	//	rightExpression=LogicalAndExpression)*;
	public LogicalOrExpressionElements getLogicalOrExpressionAccess() {
		return (pLogicalOrExpression != null) ? pLogicalOrExpression : (pLogicalOrExpression = new LogicalOrExpressionElements());
	}
	
	public ParserRule getLogicalOrExpressionRule() {
		return getLogicalOrExpressionAccess().getRule();
	}

	//enum LogicalOrOperator returns commonExpressions::LogicOperator:
	//	OR="||";
	public LogicalOrOperatorElements getLogicalOrOperatorAccess() {
		return (unknownRuleLogicalOrOperator != null) ? unknownRuleLogicalOrOperator : (unknownRuleLogicalOrOperator = new LogicalOrOperatorElements());
	}
	
	public EnumRule getLogicalOrOperatorRule() {
		return getLogicalOrOperatorAccess().getRule();
	}

	//LogicalAndExpression returns expressions::Expression:
	//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
	//	rightExpression=ComparisonExpression)*;
	public LogicalAndExpressionElements getLogicalAndExpressionAccess() {
		return (pLogicalAndExpression != null) ? pLogicalAndExpression : (pLogicalAndExpression = new LogicalAndExpressionElements());
	}
	
	public ParserRule getLogicalAndExpressionRule() {
		return getLogicalAndExpressionAccess().getRule();
	}

	//enum LogicalAndOperator returns commonExpressions::LogicOperator:
	//	AND="&&";
	public LogicalAndOperatorElements getLogicalAndOperatorAccess() {
		return (unknownRuleLogicalAndOperator != null) ? unknownRuleLogicalAndOperator : (unknownRuleLogicalAndOperator = new LogicalAndOperatorElements());
	}
	
	public EnumRule getLogicalAndOperatorRule() {
		return getLogicalAndOperatorAccess().getRule();
	}

	//// end of LogicalExpression
	//// ComparisonExpression
	//ComparisonExpression returns expressions::Expression:
	//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
	//	operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//ComparisonHigherOpExpression returns expressions::Expression:
	//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
	//	rightExpression=ArithmeticExpression)?;
	public ComparisonHigherOpExpressionElements getComparisonHigherOpExpressionAccess() {
		return (pComparisonHigherOpExpression != null) ? pComparisonHigherOpExpression : (pComparisonHigherOpExpression = new ComparisonHigherOpExpressionElements());
	}
	
	public ParserRule getComparisonHigherOpExpressionRule() {
		return getComparisonHigherOpExpressionAccess().getRule();
	}

	//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
	//	EQUAL="==" | UNEQUAL="<>";
	public ComparingEQNEQOperatorElements getComparingEQNEQOperatorAccess() {
		return (unknownRuleComparingEQNEQOperator != null) ? unknownRuleComparingEQNEQOperator : (unknownRuleComparingEQNEQOperator = new ComparingEQNEQOperatorElements());
	}
	
	public EnumRule getComparingEQNEQOperatorRule() {
		return getComparingEQNEQOperatorAccess().getRule();
	}

	//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
	//	LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">";
	public ComparingRelOperatorElements getComparingRelOperatorAccess() {
		return (unknownRuleComparingRelOperator != null) ? unknownRuleComparingRelOperator : (unknownRuleComparingRelOperator = new ComparingRelOperatorElements());
	}
	
	public EnumRule getComparingRelOperatorRule() {
		return getComparingRelOperatorAccess().getRule();
	}

	//// end of ComparisonExpression
	//// ArithmeticExpression	
	//ArithmeticExpression returns expressions::Expression:
	//	AdditionExpression;
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return (pArithmeticExpression != null) ? pArithmeticExpression : (pArithmeticExpression = new ArithmeticExpressionElements());
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}

	//AdditionExpression returns expressions::Expression:
	//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
	//	rightExpression=MultiplicationExpression)*;
	public AdditionExpressionElements getAdditionExpressionAccess() {
		return (pAdditionExpression != null) ? pAdditionExpression : (pAdditionExpression = new AdditionExpressionElements());
	}
	
	public ParserRule getAdditionExpressionRule() {
		return getAdditionExpressionAccess().getRule();
	}

	//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
	//	PLUS="+" | MINUS="-";
	public AdditionOperatorElements getAdditionOperatorAccess() {
		return (unknownRuleAdditionOperator != null) ? unknownRuleAdditionOperator : (unknownRuleAdditionOperator = new AdditionOperatorElements());
	}
	
	public EnumRule getAdditionOperatorRule() {
		return getAdditionOperatorAccess().getRule();
	}

	//MultiplicationExpression returns expressions::Expression:
	//	UnaryPreExpression | Operand ({commonExpressions::ArithmeticExpression.leftExpression=current}
	//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | Operand))*;
	public MultiplicationExpressionElements getMultiplicationExpressionAccess() {
		return (pMultiplicationExpression != null) ? pMultiplicationExpression : (pMultiplicationExpression = new MultiplicationExpressionElements());
	}
	
	public ParserRule getMultiplicationExpressionRule() {
		return getMultiplicationExpressionAccess().getRule();
	}

	//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
	//	TIMES="*" | DIVIDE="/";
	public MultiplicationOperatorElements getMultiplicationOperatorAccess() {
		return (unknownRuleMultiplicationOperator != null) ? unknownRuleMultiplicationOperator : (unknownRuleMultiplicationOperator = new MultiplicationOperatorElements());
	}
	
	public EnumRule getMultiplicationOperatorRule() {
		return getMultiplicationOperatorAccess().getRule();
	}

	//// end of ArithmeticExpression
	//// UnaryPreExpression
	//UnaryPreExpression returns expressions::Expression:
	//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=Operand;
	public UnaryPreExpressionElements getUnaryPreExpressionAccess() {
		return (pUnaryPreExpression != null) ? pUnaryPreExpression : (pUnaryPreExpression = new UnaryPreExpressionElements());
	}
	
	public ParserRule getUnaryPreExpressionRule() {
		return getUnaryPreExpressionAccess().getRule();
	}

	//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
	//	NOT="not" | MINUS="-";
	public UnaryPreOperatorElements getUnaryPreOperatorAccess() {
		return (unknownRuleUnaryPreOperator != null) ? unknownRuleUnaryPreOperator : (unknownRuleUnaryPreOperator = new UnaryPreOperatorElements());
	}
	
	public EnumRule getUnaryPreOperatorRule() {
		return getUnaryPreOperatorAccess().getRule();
	}

	//// end of UnaryPreExpression
	//// Operand
	//Operand returns expressions::Expression:
	//	"(" Expression ")" | LiteralExpression | ExtendedTypedNamedElementExpression | OperationCall |
	//	TriggerMessageExpression | NoAttributeSelectorExpression;
	public OperandElements getOperandAccess() {
		return (pOperand != null) ? pOperand : (pOperand = new OperandElements());
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}

	//// end of Operand
	//LiteralExpression returns commonExpressions::LiteralExpression:
	//	{commonExpressions::LiteralExpression} value=Literal;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return (pLiteralExpression != null) ? pLiteralExpression : (pLiteralExpression = new LiteralExpressionElements());
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//Literal returns ecore::EString:
	//	NUMBER | BOOLEAN | INT | STRING;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//ExtendedTypedNamedElementExpression returns expressions::Expression:
	//	TypedNamedElementExpression
	//	({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "."
	//	position=PositionSelectorExpression | // unary post increment/decrement			
	//	{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
	//	incrementDecrementOperator=IncrementDecrementOperatorExpression)?;
	public ExtendedTypedNamedElementExpressionElements getExtendedTypedNamedElementExpressionAccess() {
		return (pExtendedTypedNamedElementExpression != null) ? pExtendedTypedNamedElementExpression : (pExtendedTypedNamedElementExpression = new ExtendedTypedNamedElementExpressionElements());
	}
	
	public ParserRule getExtendedTypedNamedElementExpressionRule() {
		return getExtendedTypedNamedElementExpressionAccess().getRule();
	}

	//TypedNamedElementExpression returns actionlanguage::TypedNamedElementExpression:
	//	typedNamedElement=[behavior::TypedNamedElement] ("[" indices+=ArithmeticExpression "]")*;
	public TypedNamedElementExpressionElements getTypedNamedElementExpressionAccess() {
		return (pTypedNamedElementExpression != null) ? pTypedNamedElementExpression : (pTypedNamedElementExpression = new TypedNamedElementExpressionElements());
	}
	
	public ParserRule getTypedNamedElementExpressionRule() {
		return getTypedNamedElementExpressionAccess().getRule();
	}

	//NoAttributeSelectorExpression returns actionlanguage::DiscreteInteractionEndpointReference:
	//	position=PositionSelectorExpression;
	public NoAttributeSelectorExpressionElements getNoAttributeSelectorExpressionAccess() {
		return (pNoAttributeSelectorExpression != null) ? pNoAttributeSelectorExpression : (pNoAttributeSelectorExpression = new NoAttributeSelectorExpressionElements());
	}
	
	public ParserRule getNoAttributeSelectorExpressionRule() {
		return getNoAttributeSelectorExpressionAccess().getRule();
	}

	//PositionSelectorExpression returns actionlanguage::PositionSelector:
	//	kind=PositionSelectorKind ("." successor=PositionSelectorExpression)?;
	public PositionSelectorExpressionElements getPositionSelectorExpressionAccess() {
		return (pPositionSelectorExpression != null) ? pPositionSelectorExpression : (pPositionSelectorExpression = new PositionSelectorExpressionElements());
	}
	
	public ParserRule getPositionSelectorExpressionRule() {
		return getPositionSelectorExpressionAccess().getRule();
	}

	//enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
	//	SELF="self" | FIRST="first" | LAST="last" | PREV="prev" | NEXT="next";
	public PositionSelectorKindElements getPositionSelectorKindAccess() {
		return (unknownRulePositionSelectorKind != null) ? unknownRulePositionSelectorKind : (unknownRulePositionSelectorKind = new PositionSelectorKindElements());
	}
	
	public EnumRule getPositionSelectorKindRule() {
		return getPositionSelectorKindAccess().getRule();
	}

	//OperationCall returns actionlanguage::OperationCall:
	//	operation=[behavior::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)?
	//	")";
	public OperationCallElements getOperationCallAccess() {
		return (pOperationCall != null) ? pOperationCall : (pOperationCall = new OperationCallElements());
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}

	//ParamaterBinding returns behavior::ParameterBinding:
	//	{behavior::ParameterBinding} parameter=[behavior::Parameter] ":=" value=Expression;
	public ParamaterBindingElements getParamaterBindingAccess() {
		return (pParamaterBinding != null) ? pParamaterBinding : (pParamaterBinding = new ParamaterBindingElements());
	}
	
	public ParserRule getParamaterBindingRule() {
		return getParamaterBindingAccess().getRule();
	}

	//// TriggerMessageExpression
	//TriggerMessageExpression returns actionlanguage::TriggerMessageExpression:
	//	messageType=[msgtype::MessageType] "." parameter=[behavior::Parameter];
	public TriggerMessageExpressionElements getTriggerMessageExpressionAccess() {
		return (pTriggerMessageExpression != null) ? pTriggerMessageExpression : (pTriggerMessageExpression = new TriggerMessageExpressionElements());
	}
	
	public ParserRule getTriggerMessageExpressionRule() {
		return getTriggerMessageExpressionAccess().getRule();
	}

	//// end of TriggerMessageExpression
	//terminal NUMBER returns ecore::EBigDecimal:
	//	INT "." INT;
	public TerminalRule getNUMBERRule() {
		return (tNUMBER != null) ? tNUMBER : (tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER"));
	} 

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//DATATYPE returns ecore::EString:
	//	ID ("[" INT "]")*;
	public DATATYPEElements getDATATYPEAccess() {
		return (pDATATYPE != null) ? pDATATYPE : (pDATATYPE = new DATATYPEElements());
	}
	
	public ParserRule getDATATYPERule() {
		return getDATATYPEAccess().getRule();
	}

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
