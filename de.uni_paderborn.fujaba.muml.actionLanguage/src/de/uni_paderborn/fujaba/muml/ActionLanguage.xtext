// automatically generated by Xtext
grammar de.uni_paderborn.fujaba.muml.ActionLanguage with org.eclipse.xtext.common.Terminals 

import "platform:/resource/de.uni_paderborn.fujaba.muml.model.actionLanguage/model/actionLanguage.ecore" as actionLanguage

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

import "platform:/resource/org.storydriven.core/model/core.ecore" as modeling

import "platform:/resource/de.uni_paderborn.fujaba.muml.model/model/muml.ecore#//model/realtimestatechart" as rtsc

import "platform:/resource/de.uni_paderborn.fujaba.muml.model/model/muml.ecore#//model/behavior" as behavior

import "platform:/resource/de.uni_paderborn.fujaba.muml.model/model/muml.ecore#//model/msgtype" as msgtype

import "platform:/resource/org.storydriven.core/model/core.ecore#//expressions" as expressions

import "platform:/resource/org.storydriven.core/model/core.ecore#//expressions/common" as commonExpressions


Block returns actionLanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	{actionLanguage::Block}
	'{'(expressions+=ExpressionStartRule*)'}' | expressions+=Expression
;

// TODO: clarify if it makes sense to allow arbitrary expressions for
// the initializeExpression and countingExpression
ForLoop returns actionLanguage::ForLoop:
	'for' '(' initializeExpression=Assignment  loopTest=Expression';'  countingExpression=ForLoopCountingExpression ')' 
		block=Block
;

ForLoopCountingExpression returns actionLanguage::Assignment:
	lhs_typedNamedElementExpression=TypedNamedElementExpression
	(
		incrementDecrementOperator=IncrementDecrementOperator
		| (assignOperator=AssignOperator rhs_assignExpression=Expression)
	)
;

WhileLoop returns actionLanguage::WhileLoop:
	'while' '('  loopTest=Expression ')' 
		block=Block
;

DoWhileLoop returns actionLanguage::DoWhileLoop:
	'do'  
		block=Block
	'while' '('  loopTest=Expression ');'
;

IfStatement returns actionLanguage::IfStatement:
	'if' '(' ifCondition=Expression ')'
		ifBlock=Block
	('elseif' '(' elseIfConditions+=Expression ')'
		elseIfBlocks+=Block
	)*
	('else' elseBlock=Block)?
;

ReturnStatement returns actionLanguage::ReturnStatement:
	{actionLanguage::ReturnStatement}
	'return' expression=Expression ';'
;
	
ExpressionStartRule returns expressions::Expression:
	Assignment |  ForLoop | 
	WhileLoop | DoWhileLoop | 
	IfStatement | ReturnStatement
;

enum IncrementDecrementOperator returns actionLanguage::IncrementDecrementOperator:
	INCREMENT='++' | DECREMENT='--'
;

// Assignment
	
Assignment returns actionLanguage::Assignment:
	lhs_typedNamedElementExpression=TypedNamedElementExpression
	assignOperator=AssignOperator rhs_assignExpression=Expression ';'
;

enum AssignOperator returns actionLanguage::AssignOperator:
	ASSIGN=':=' | PLUS_EQUAL='+='| EQUAL_PLUS='=+' | MINUS_EQUAL='-='| EQUAL_MINUS='=-'
;	

// end of assignment

Expression returns expressions::Expression:
	LogicalExpression
;

// LogicalExpression

LogicalExpression returns expressions::Expression:
	LogicalOrExpression
;

LogicalOrExpression returns expressions::Expression:
	LogicalAndExpression
	(
		{commonExpressions::LogicalExpression.leftExpression=current}
		operator=LogicalOrOperator
		rightExpression=LogicalAndExpression
	)*
;

enum LogicalOrOperator returns commonExpressions::LogicOperator:
	OR='||'
;

LogicalAndExpression returns expressions::Expression:
	ComparisonExpression
	(
		{commonExpressions::LogicalExpression.leftExpression=current}
		operator=LogicalAndOperator
		rightExpression=ComparisonExpression
	)*
;

enum LogicalAndOperator returns commonExpressions::LogicOperator:
	AND='&&'
;

// end of LogicalExpression

// ComparisonExpression

ComparisonExpression returns expressions::Expression:
	ComparisonHigherOpExpression
	(	
		{commonExpressions::ComparisonExpression.leftExpression=current}
		operator=ComparingEQNEQOperator
		rightExpression=ComparisonHigherOpExpression
	)?
;

ComparisonHigherOpExpression returns expressions::Expression:
	ArithmeticExpression
	(	{commonExpressions::ComparisonExpression.leftExpression=current}
		operator=ComparingRelOperator
		rightExpression=ArithmeticExpression
	)?
;

enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
	EQUAL='==' | UNEQUAL='<>' 
;

enum ComparingRelOperator returns commonExpressions::ComparingOperator:
	LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>'
;  

// end of ComparisonExpression

// ArithmeticExpression	
	
ArithmeticExpression returns expressions::Expression:
	AdditionExpression
;

AdditionExpression returns expressions::Expression:
	MultiplicationExpression
	(
		{commonExpressions::ArithmeticExpression.leftExpression=current}
		operator=AdditionOperator rightExpression=MultiplicationExpression
	)*
;

enum AdditionOperator returns commonExpressions::ArithmeticOperator:
	PLUS='+' | MINUS='-'
;

MultiplicationExpression returns expressions::Expression:
	UnaryPreExpression | UnaryPostExpression
	(	{commonExpressions::ArithmeticExpression.leftExpression=current}
		operator=MultiplicationOperator rightExpression=(UnaryPreExpression | UnaryPostExpression)
	)*
;

enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
	TIMES='*' | DIVIDE='/'
;

// end of ArithmeticExpression

// UnaryPreExpression

UnaryPreExpression returns expressions::Expression:
	{commonExpressions::UnaryExpression}
	operator=UnaryPreOperator enclosedExpression=Operand
;

enum UnaryPreOperator returns commonExpressions::UnaryOperator:
	NOT='not' | MINUS='-' | PLUS='+'
;

// end of UnaryPreExpression

// UnaryPostExpression

UnaryPostExpression returns expressions::Expression:
	Operand
	(
		{commonExpressions::UnaryExpression.enclosedExpression=current}
		operator=UnaryPostOperator
	)?
;

enum UnaryPostOperator returns commonExpressions::UnaryOperator:
	INCREMENT='++' | DECREMENT='--'
;

// end of UnaryPostExpression

// Operand

Operand returns expressions::Expression:
	'(' Expression ')' | LiteralExpression | ExtendedTypedNamedElementExpression
	| OperationCall | TriggerMessageExpression | NoAttributeSelectorExpression
;

// end of Operand

LiteralExpression returns commonExpressions::LiteralExpression:
	{commonExpressions::LiteralExpression} value=Literal
;

Literal returns ecore::EString:
	NUMBER | BOOLEAN | INT | STRING
;

ExtendedTypedNamedElementExpression returns expressions::Expression:
	TypedNamedElementExpression
	(
		{actionLanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression = current}
		'.' position=PositionSelectorExpression
	)?
;

TypedNamedElementExpression returns actionLanguage::TypedNamedElementExpression:
	typedNamedElement=[behavior::TypedNamedElement]('['indices+=ArithmeticExpression']')*
;

NoAttributeSelectorExpression returns actionLanguage::DiscreteInteractionEndpointReference:
	position=PositionSelectorExpression
;

PositionSelectorExpression returns actionLanguage::PositionSelector:
	kind=PositionSelectorKind ('.' successor=PositionSelectorExpression)?
;

enum PositionSelectorKind returns actionLanguage::PositionSelectorKind:
	SELF='self' | FIRST='first' | LAST='last' | PREV='prev' | NEXT='next'
;

OperationCall returns actionLanguage::OperationCall:
	operation=[behavior::Operation] '('
		(parameterBinding+=ParamaterBinding (',' parameterBinding+=ParamaterBinding)* )?
	')'
;

ParamaterBinding returns behavior::ParameterBinding:
	{behavior::ParameterBinding}parameter=[behavior::Parameter] ':=' value=Expression
;	

// TriggerMessageExpression

TriggerMessageExpression returns actionLanguage::TriggerMessageExpression:
	messageType=[msgtype::MessageType] '.' parameter=[behavior::Parameter]
;

// end of TriggerMessageExpression
	
	
IdentifierOrValue returns ecore::EString:
	NUMBER | BOOLEAN | INT | STRING
;	

terminal NUMBER returns ecore::EBigDecimal:
	INT'.' INT
;

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;	