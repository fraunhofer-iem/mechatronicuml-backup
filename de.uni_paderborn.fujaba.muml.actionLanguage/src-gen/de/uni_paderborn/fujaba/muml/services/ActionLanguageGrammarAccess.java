/*
* generated by Xtext
*/

package de.uni_paderborn.fujaba.muml.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ActionLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBlockAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExpressionsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionsExpressionStartRuleParserRuleCall_0_2_0 = (RuleCall)cExpressionsAssignment_0_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		
		//Block returns actionLanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
		//	{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}" | expressions+=Expression;
		public ParserRule getRule() { return rule; }

		//{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}" | expressions+=Expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}"
		public Group getGroup_0() { return cGroup_0; }

		//{actionLanguage::Block}
		public Action getBlockAction_0_0() { return cBlockAction_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0_1() { return cLeftCurlyBracketKeyword_0_1; }

		//expressions+=ExpressionStartRule*
		public Assignment getExpressionsAssignment_0_2() { return cExpressionsAssignment_0_2; }

		//ExpressionStartRule
		public RuleCall getExpressionsExpressionStartRuleParserRuleCall_0_2_0() { return cExpressionsExpressionStartRuleParserRuleCall_0_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_0_3() { return cRightCurlyBracketKeyword_0_3; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_0() { return cExpressionsExpressionParserRuleCall_1_0; }
	}

	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitalizeExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitalizeExpressionAssignmentParserRuleCall_2_0 = (RuleCall)cInitalizeExpressionAssignment_2.eContents().get(0);
		private final Assignment cLoopTestAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopTestExpressionParserRuleCall_3_0 = (RuleCall)cLoopTestAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCountingExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0 = (RuleCall)cCountingExpressionAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBlockAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBlockBlockParserRuleCall_7_0 = (RuleCall)cBlockAssignment_7.eContents().get(0);
		
		//// TODO: clarify if it makes sense to allow arbitrary expressions for
		//// the initializeExpression and countingExpression
		//ForLoop returns actionLanguage::ForLoop:
		//	"for" "(" initalizeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//	block=Block;
		public ParserRule getRule() { return rule; }

		//"for" "(" initalizeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//block=Block
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//initalizeExpression=Assignment
		public Assignment getInitalizeExpressionAssignment_2() { return cInitalizeExpressionAssignment_2; }

		//Assignment
		public RuleCall getInitalizeExpressionAssignmentParserRuleCall_2_0() { return cInitalizeExpressionAssignmentParserRuleCall_2_0; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_3() { return cLoopTestAssignment_3; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_3_0() { return cLoopTestExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }

		//countingExpression=ForLoopCountingExpression
		public Assignment getCountingExpressionAssignment_5() { return cCountingExpressionAssignment_5; }

		//ForLoopCountingExpression
		public RuleCall getCountingExpressionForLoopCountingExpressionParserRuleCall_5_0() { return cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//block=Block
		public Assignment getBlockAssignment_7() { return cBlockAssignment_7; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_7_0() { return cBlockBlockParserRuleCall_7_0; }
	}

	public class ForLoopCountingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoopCountingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_attributeExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_attributeExpressionAttributeExpressionParserRuleCall_0_0 = (RuleCall)cLhs_attributeExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIncrementDecrementOperatorAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_0_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cAssignOperatorAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0 = (RuleCall)cAssignOperatorAssignment_1_1_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_1_1.eContents().get(0);
		
		//ForLoopCountingExpression returns actionLanguage::Assignment:
		//	lhs_attributeExpression=AttributeExpression (incrementDecrementOperator=IncrementDecrementOperator |
		//	assignOperator=AssignOperator rhs_assignExpression=Expression);
		public ParserRule getRule() { return rule; }

		//lhs_attributeExpression=AttributeExpression (incrementDecrementOperator=IncrementDecrementOperator |
		//assignOperator=AssignOperator rhs_assignExpression=Expression)
		public Group getGroup() { return cGroup; }

		//lhs_attributeExpression=AttributeExpression
		public Assignment getLhs_attributeExpressionAssignment_0() { return cLhs_attributeExpressionAssignment_0; }

		//AttributeExpression
		public RuleCall getLhs_attributeExpressionAttributeExpressionParserRuleCall_0_0() { return cLhs_attributeExpressionAttributeExpressionParserRuleCall_0_0; }

		//incrementDecrementOperator=IncrementDecrementOperator | assignOperator=AssignOperator rhs_assignExpression=Expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//incrementDecrementOperator=IncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_0() { return cIncrementDecrementOperatorAssignment_1_0; }

		//IncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_0_0() { return cIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_1_0() { return cAssignOperatorAssignment_1_1_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0; }

		//rhs_assignExpression=Expression
		public Assignment getRhs_assignExpressionAssignment_1_1_1() { return cRhs_assignExpressionAssignment_1_1_1; }

		//Expression
		public RuleCall getRhs_assignExpressionExpressionParserRuleCall_1_1_1_0() { return cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLoopTestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLoopTestExpressionParserRuleCall_2_0 = (RuleCall)cLoopTestAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		//WhileLoop returns actionLanguage::WhileLoop:
		//	"while" "(" loopTest=Expression ")" block=Block;
		public ParserRule getRule() { return rule; }

		//"while" "(" loopTest=Expression ")" block=Block
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_2() { return cLoopTestAssignment_2; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_2_0() { return cLoopTestExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//block=Block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}

	public class DoWhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLoopTestAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopTestExpressionParserRuleCall_4_0 = (RuleCall)cLoopTestAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//DoWhileLoop returns actionLanguage::DoWhileLoop:
		//	"do" block=Block "while" "(" loopTest=Expression ");";
		public ParserRule getRule() { return rule; }

		//"do" block=Block "while" "(" loopTest=Expression ");"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//block=Block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_4() { return cLoopTestAssignment_4; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_4_0() { return cLoopTestExpressionParserRuleCall_4_0; }

		//");"
		public Keyword getRightParenthesisSemicolonKeyword_5() { return cRightParenthesisSemicolonKeyword_5; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIfConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfConditionExpressionParserRuleCall_2_0 = (RuleCall)cIfConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockBlockParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseifKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cElseIfConditionsAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cElseIfConditionsExpressionParserRuleCall_5_2_0 = (RuleCall)cElseIfConditionsAssignment_5_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		private final Assignment cElseIfBlocksAssignment_5_4 = (Assignment)cGroup_5.eContents().get(4);
		private final RuleCall cElseIfBlocksBlockParserRuleCall_5_4_0 = (RuleCall)cElseIfBlocksAssignment_5_4.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cElseKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cElseBlockAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cElseBlockBlockParserRuleCall_6_1_0 = (RuleCall)cElseBlockAssignment_6_1.eContents().get(0);
		
		//IfStatement returns actionLanguage::IfStatement:
		//	"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		//	("else" elseBlock=Block)?;
		public ParserRule getRule() { return rule; }

		//"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		//("else" elseBlock=Block)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//ifCondition=Expression
		public Assignment getIfConditionAssignment_2() { return cIfConditionAssignment_2; }

		//Expression
		public RuleCall getIfConditionExpressionParserRuleCall_2_0() { return cIfConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//ifBlock=Block
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }

		//Block
		public RuleCall getIfBlockBlockParserRuleCall_4_0() { return cIfBlockBlockParserRuleCall_4_0; }

		//("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		public Group getGroup_5() { return cGroup_5; }

		//"elseif"
		public Keyword getElseifKeyword_5_0() { return cElseifKeyword_5_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_5_1() { return cLeftParenthesisKeyword_5_1; }

		//elseIfConditions+=Expression
		public Assignment getElseIfConditionsAssignment_5_2() { return cElseIfConditionsAssignment_5_2; }

		//Expression
		public RuleCall getElseIfConditionsExpressionParserRuleCall_5_2_0() { return cElseIfConditionsExpressionParserRuleCall_5_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5_3() { return cRightParenthesisKeyword_5_3; }

		//elseIfBlocks+=Block
		public Assignment getElseIfBlocksAssignment_5_4() { return cElseIfBlocksAssignment_5_4; }

		//Block
		public RuleCall getElseIfBlocksBlockParserRuleCall_5_4_0() { return cElseIfBlocksBlockParserRuleCall_5_4_0; }

		//("else" elseBlock=Block)?
		public Group getGroup_6() { return cGroup_6; }

		//"else"
		public Keyword getElseKeyword_6_0() { return cElseKeyword_6_0; }

		//elseBlock=Block
		public Assignment getElseBlockAssignment_6_1() { return cElseBlockAssignment_6_1; }

		//Block
		public RuleCall getElseBlockBlockParserRuleCall_6_1_0() { return cElseBlockBlockParserRuleCall_6_1_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReturnStatement returns actionLanguage::ReturnStatement:
		//	{actionLanguage::ReturnStatement} "return" expression=Expression ";";
		public ParserRule getRule() { return rule; }

		//{actionLanguage::ReturnStatement} "return" expression=Expression ";"
		public Group getGroup() { return cGroup; }

		//{actionLanguage::ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//"return"
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ExpressionStartRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionStartRule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDoWhileLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIfStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cReturnStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//ExpressionStartRule returns expressions::Expression:
		//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement;
		public ParserRule getRule() { return rule; }

		//Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_0() { return cAssignmentParserRuleCall_0; }

		//ForLoop
		public RuleCall getForLoopParserRuleCall_1() { return cForLoopParserRuleCall_1; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_2() { return cWhileLoopParserRuleCall_2; }

		//DoWhileLoop
		public RuleCall getDoWhileLoopParserRuleCall_3() { return cDoWhileLoopParserRuleCall_3; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_4() { return cIfStatementParserRuleCall_4; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_5() { return cReturnStatementParserRuleCall_5; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_attributeExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_attributeExpressionAttributeExpressionParserRuleCall_0_0 = (RuleCall)cLhs_attributeExpressionAssignment_0.eContents().get(0);
		private final Assignment cAssignOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_0 = (RuleCall)cAssignOperatorAssignment_1.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhs_assignExpressionExpressionParserRuleCall_2_0 = (RuleCall)cRhs_assignExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Assignment
		//Assignment returns actionLanguage::Assignment:
		//	lhs_attributeExpression=AttributeExpression assignOperator=AssignOperator rhs_assignExpression=Expression ";";
		public ParserRule getRule() { return rule; }

		//lhs_attributeExpression=AttributeExpression assignOperator=AssignOperator rhs_assignExpression=Expression ";"
		public Group getGroup() { return cGroup; }

		//lhs_attributeExpression=AttributeExpression
		public Assignment getLhs_attributeExpressionAssignment_0() { return cLhs_attributeExpressionAssignment_0; }

		//AttributeExpression
		public RuleCall getLhs_attributeExpressionAttributeExpressionParserRuleCall_0_0() { return cLhs_attributeExpressionAttributeExpressionParserRuleCall_0_0; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1() { return cAssignOperatorAssignment_1; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_0; }

		//rhs_assignExpression=Expression
		public Assignment getRhs_assignExpressionAssignment_2() { return cRhs_assignExpressionAssignment_2; }

		//Expression
		public RuleCall getRhs_assignExpressionExpressionParserRuleCall_2_0() { return cRhs_assignExpressionExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLogicalExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of assignment
		//Expression returns expressions::Expression:
		//	LogicalExpression;
		public ParserRule getRule() { return rule; }

		//LogicalExpression
		public RuleCall getLogicalExpressionParserRuleCall() { return cLogicalExpressionParserRuleCall; }
	}

	public class LogicalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression");
		private final RuleCall cLogicalOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// LogicalExpression
		//LogicalExpression returns expressions::Expression:
		//	LogicalOrExpression;
		public ParserRule getRule() { return rule; }

		//LogicalOrExpression
		public RuleCall getLogicalOrExpressionParserRuleCall() { return cLogicalOrExpressionParserRuleCall; }
	}

	public class LogicalOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOrOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalOrExpression returns expressions::Expression:
		//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//	rightExpression=LogicalAndExpression)*;
		public ParserRule getRule() { return rule; }

		//LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup() { return cGroup; }

		//LogicalAndExpression
		public RuleCall getLogicalAndExpressionParserRuleCall_0() { return cLogicalAndExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalOrOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOrOperator
		public RuleCall getOperatorLogicalOrOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalOrOperatorEnumRuleCall_1_1_0; }

		//rightExpression=LogicalAndExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//LogicalAndExpression
		public RuleCall getRightExpressionLogicalAndExpressionParserRuleCall_1_2_0() { return cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0; }
	}

	public class LogicalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalAndOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalAndExpression returns expressions::Expression:
		//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//	rightExpression=ComparisonExpression)*;
		public ParserRule getRule() { return rule; }

		//ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalAndOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalAndOperator
		public RuleCall getOperatorLogicalAndOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalAndOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightExpressionComparisonExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonHigherOpExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//// end of LogicalExpression
		//// ComparisonExpression
		//ComparisonExpression returns expressions::Expression:
		//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//	operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?;
		public ParserRule getRule() { return rule; }

		//ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup() { return cGroup; }

		//ComparisonHigherOpExpression
		public RuleCall getComparisonHigherOpExpressionParserRuleCall_0() { return cComparisonHigherOpExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingEQNEQOperator
		//rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingEQNEQOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingEQNEQOperator
		public RuleCall getOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0() { return cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonHigherOpExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonHigherOpExpression
		public RuleCall getRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonHigherOpExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonHigherOpExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArithmeticExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingRelOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionArithmeticExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//ComparisonHigherOpExpression returns expressions::Expression:
		//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//	rightExpression=ArithmeticExpression)?;
		public ParserRule getRule() { return rule; }

		//ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup() { return cGroup; }

		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall_0() { return cArithmeticExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingRelOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingRelOperator
		public RuleCall getOperatorComparingRelOperatorEnumRuleCall_1_1_0() { return cOperatorComparingRelOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ArithmeticExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ArithmeticExpression
		public RuleCall getRightExpressionArithmeticExpressionParserRuleCall_1_2_0() { return cRightExpressionArithmeticExpressionParserRuleCall_1_2_0; }
	}

	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticExpression");
		private final RuleCall cAdditionExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of ComparisonExpression
		//// ArithmeticExpression	
		//ArithmeticExpression returns expressions::Expression:
		//	AdditionExpression;
		public ParserRule getRule() { return rule; }

		//AdditionExpression
		public RuleCall getAdditionExpressionParserRuleCall() { return cAdditionExpressionParserRuleCall; }
	}

	public class AdditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditionOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//AdditionExpression returns expressions::Expression:
		//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//	rightExpression=MultiplicationExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicationExpression
		public RuleCall getMultiplicationExpressionParserRuleCall_0() { return cMultiplicationExpressionParserRuleCall_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=AdditionOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditionOperator
		public RuleCall getOperatorAdditionOperatorEnumRuleCall_1_1_0() { return cOperatorAdditionOperatorEnumRuleCall_1_1_0; }

		//rightExpression=MultiplicationExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//MultiplicationExpression
		public RuleCall getRightExpressionMultiplicationExpressionParserRuleCall_1_2_0() { return cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryPreExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cUnaryPostExpressionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0 = (RuleCall)cOperatorAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final Alternatives cRightExpressionAlternatives_1_1_2_0 = (Alternatives)cRightExpressionAssignment_1_1_2.eContents().get(0);
		private final RuleCall cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(0);
		private final RuleCall cRightExpressionUnaryPostExpressionParserRuleCall_1_1_2_0_1 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(1);
		
		//MultiplicationExpression returns expressions::Expression:
		//	UnaryPreExpression | UnaryPostExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | UnaryPostExpression))*;
		public ParserRule getRule() { return rule; }

		//UnaryPreExpression | UnaryPostExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//operator=MultiplicationOperator rightExpression=(UnaryPreExpression | UnaryPostExpression))*
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnaryPreExpression
		public RuleCall getUnaryPreExpressionParserRuleCall_0() { return cUnaryPreExpressionParserRuleCall_0; }

		//UnaryPostExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | UnaryPostExpression))*
		public Group getGroup_1() { return cGroup_1; }

		//UnaryPostExpression
		public RuleCall getUnaryPostExpressionParserRuleCall_1_0() { return cUnaryPostExpressionParserRuleCall_1_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | UnaryPostExpression))*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_1_0() { return cArithmeticExpressionLeftExpressionAction_1_1_0; }

		//operator=MultiplicationOperator
		public Assignment getOperatorAssignment_1_1_1() { return cOperatorAssignment_1_1_1; }

		//MultiplicationOperator
		public RuleCall getOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0() { return cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0; }

		//rightExpression=(UnaryPreExpression | UnaryPostExpression)
		public Assignment getRightExpressionAssignment_1_1_2() { return cRightExpressionAssignment_1_1_2; }

		//UnaryPreExpression | UnaryPostExpression
		public Alternatives getRightExpressionAlternatives_1_1_2_0() { return cRightExpressionAlternatives_1_1_2_0; }

		//UnaryPreExpression
		public RuleCall getRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0() { return cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0; }

		//UnaryPostExpression
		public RuleCall getRightExpressionUnaryPostExpressionParserRuleCall_1_1_2_0_1() { return cRightExpressionUnaryPostExpressionParserRuleCall_1_1_2_0_1; }
	}

	public class UnaryPreExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPreExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnaryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorUnaryPreOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cEnclosedExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEnclosedExpressionOperandParserRuleCall_2_0 = (RuleCall)cEnclosedExpressionAssignment_2.eContents().get(0);
		
		//// end of ArithmeticExpression
		//// UnaryPreExpression
		//UnaryPreExpression returns expressions::Expression:
		//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=Operand;
		public ParserRule getRule() { return rule; }

		//{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=Operand
		public Group getGroup() { return cGroup; }

		//{commonExpressions::UnaryExpression}
		public Action getUnaryExpressionAction_0() { return cUnaryExpressionAction_0; }

		//operator=UnaryPreOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//UnaryPreOperator
		public RuleCall getOperatorUnaryPreOperatorEnumRuleCall_1_0() { return cOperatorUnaryPreOperatorEnumRuleCall_1_0; }

		//enclosedExpression=Operand
		public Assignment getEnclosedExpressionAssignment_2() { return cEnclosedExpressionAssignment_2; }

		//Operand
		public RuleCall getEnclosedExpressionOperandParserRuleCall_2_0() { return cEnclosedExpressionOperandParserRuleCall_2_0; }
	}

	public class UnaryPostExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPostExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOperandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUnaryExpressionEnclosedExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorUnaryPostOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		
		//// end of UnaryPreExpression
		//// UnaryPostExpression
		//UnaryPostExpression returns expressions::Expression:
		//	Operand ({commonExpressions::UnaryExpression.enclosedExpression=current} operator=UnaryPostOperator)?;
		public ParserRule getRule() { return rule; }

		//Operand ({commonExpressions::UnaryExpression.enclosedExpression=current} operator=UnaryPostOperator)?
		public Group getGroup() { return cGroup; }

		//Operand
		public RuleCall getOperandParserRuleCall_0() { return cOperandParserRuleCall_0; }

		//({commonExpressions::UnaryExpression.enclosedExpression=current} operator=UnaryPostOperator)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::UnaryExpression.enclosedExpression=current}
		public Action getUnaryExpressionEnclosedExpressionAction_1_0() { return cUnaryExpressionEnclosedExpressionAction_1_0; }

		//operator=UnaryPostOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//UnaryPostOperator
		public RuleCall getOperatorUnaryPostOperatorEnumRuleCall_1_1_0() { return cOperatorUnaryPostOperatorEnumRuleCall_1_1_0; }
	}

	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAttributeExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cOperationCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTriggerMessageExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// end of UnaryPostExpression
		//// Operand
		//Operand returns expressions::Expression:
		//	"(" Expression ")" | LiteralExpression | AttributeExpression | OperationCall | TriggerMessageExpression;
		public ParserRule getRule() { return rule; }

		//"(" Expression ")" | LiteralExpression | AttributeExpression | OperationCall | TriggerMessageExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_1() { return cLiteralExpressionParserRuleCall_1; }

		//AttributeExpression
		public RuleCall getAttributeExpressionParserRuleCall_2() { return cAttributeExpressionParserRuleCall_2; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_3() { return cOperationCallParserRuleCall_3; }

		//TriggerMessageExpression
		public RuleCall getTriggerMessageExpressionParserRuleCall_4() { return cTriggerMessageExpressionParserRuleCall_4; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//// end of Operand
		//LiteralExpression returns commonExpressions::LiteralExpression:
		//	{commonExpressions::LiteralExpression} value=Literal;
		public ParserRule getRule() { return rule; }

		//{commonExpressions::LiteralExpression} value=Literal
		public Group getGroup() { return cGroup; }

		//{commonExpressions::LiteralExpression}
		public Action getLiteralExpressionAction_0() { return cLiteralExpressionAction_0; }

		//value=Literal
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_0() { return cValueLiteralParserRuleCall_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNUMBERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBOOLEANTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSTRINGTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Literal returns ecore::EString:
		//	NUMBER | BOOLEAN | INT | STRING;
		public ParserRule getRule() { return rule; }

		//NUMBER | BOOLEAN | INT | STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_0() { return cNUMBERTerminalRuleCall_0; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_1() { return cBOOLEANTerminalRuleCall_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3() { return cSTRINGTerminalRuleCall_3; }
	}

	public class AttributeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAttributeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cAttributeAttributeCrossReference_0_0 = (CrossReference)cAttributeAssignment_0.eContents().get(0);
		private final RuleCall cAttributeAttributeIDTerminalRuleCall_0_0_1 = (RuleCall)cAttributeAttributeCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIndicesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIndicesArithmeticExpressionParserRuleCall_1_1_0 = (RuleCall)cIndicesAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//AttributeExpression returns actionLanguage::AttributeExpression:
		//	attribute=[core::Attribute] ("[" indices+=ArithmeticExpression "]")*;
		public ParserRule getRule() { return rule; }

		//attribute=[core::Attribute] ("[" indices+=ArithmeticExpression "]")*
		public Group getGroup() { return cGroup; }

		//attribute=[core::Attribute]
		public Assignment getAttributeAssignment_0() { return cAttributeAssignment_0; }

		//[core::Attribute]
		public CrossReference getAttributeAttributeCrossReference_0_0() { return cAttributeAttributeCrossReference_0_0; }

		//ID
		public RuleCall getAttributeAttributeIDTerminalRuleCall_0_0_1() { return cAttributeAttributeIDTerminalRuleCall_0_0_1; }

		//("[" indices+=ArithmeticExpression "]")*
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//indices+=ArithmeticExpression
		public Assignment getIndicesAssignment_1_1() { return cIndicesAssignment_1_1; }

		//ArithmeticExpression
		public RuleCall getIndicesArithmeticExpressionParserRuleCall_1_1_0() { return cIndicesArithmeticExpressionParserRuleCall_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}

	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cOperationOperationCrossReference_0_0 = (CrossReference)cOperationAssignment_0.eContents().get(0);
		private final RuleCall cOperationOperationIDTerminalRuleCall_0_0_1 = (RuleCall)cOperationOperationCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterBindingAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_0_0 = (RuleCall)cParameterBindingAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterBindingAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_1_1_0 = (RuleCall)cParameterBindingAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//OperationCall returns actionLanguage::OperationCall:
		//	operation=[core::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)? ")";
		public ParserRule getRule() { return rule; }

		//operation=[core::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)? ")"
		public Group getGroup() { return cGroup; }

		//operation=[core::Operation]
		public Assignment getOperationAssignment_0() { return cOperationAssignment_0; }

		//[core::Operation]
		public CrossReference getOperationOperationCrossReference_0_0() { return cOperationOperationCrossReference_0_0; }

		//ID
		public RuleCall getOperationOperationIDTerminalRuleCall_0_0_1() { return cOperationOperationIDTerminalRuleCall_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_0() { return cParameterBindingAssignment_2_0; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_0_0() { return cParameterBindingParamaterBindingParserRuleCall_2_0_0; }

		//("," parameterBinding+=ParamaterBinding)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_1_1() { return cParameterBindingAssignment_2_1_1; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_1_1_0() { return cParameterBindingParamaterBindingParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ParamaterBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParamaterBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterBindingAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cParameterParameterCrossReference_1_0 = (CrossReference)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_1_0_1 = (RuleCall)cParameterParameterCrossReference_1_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ParamaterBinding returns core::ParameterBinding:
		//	{core::ParameterBinding} parameter=[core::Parameter] ":=" value=Expression;
		public ParserRule getRule() { return rule; }

		//{core::ParameterBinding} parameter=[core::Parameter] ":=" value=Expression
		public Group getGroup() { return cGroup; }

		//{core::ParameterBinding}
		public Action getParameterBindingAction_0() { return cParameterBindingAction_0; }

		//parameter=[core::Parameter]
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }

		//[core::Parameter]
		public CrossReference getParameterParameterCrossReference_1_0() { return cParameterParameterCrossReference_1_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_1_0_1() { return cParameterParameterIDTerminalRuleCall_1_0_1; }

		//":="
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class TriggerMessageExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TriggerMessageExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMessageTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cMessageTypeMessageTypeCrossReference_0_0 = (CrossReference)cMessageTypeAssignment_0.eContents().get(0);
		private final RuleCall cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cMessageTypeMessageTypeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParameterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cParameterParameterCrossReference_2_0 = (CrossReference)cParameterAssignment_2.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_2_0_1 = (RuleCall)cParameterParameterCrossReference_2_0.eContents().get(1);
		
		//// TriggerMessageExpression
		//TriggerMessageExpression returns actionLanguage::TriggerMessageExpression:
		//	messageType=[msgtype::MessageType] "." parameter=[core::Parameter];
		public ParserRule getRule() { return rule; }

		//messageType=[msgtype::MessageType] "." parameter=[core::Parameter]
		public Group getGroup() { return cGroup; }

		//messageType=[msgtype::MessageType]
		public Assignment getMessageTypeAssignment_0() { return cMessageTypeAssignment_0; }

		//[msgtype::MessageType]
		public CrossReference getMessageTypeMessageTypeCrossReference_0_0() { return cMessageTypeMessageTypeCrossReference_0_0; }

		//ID
		public RuleCall getMessageTypeMessageTypeIDTerminalRuleCall_0_0_1() { return cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//parameter=[core::Parameter]
		public Assignment getParameterAssignment_2() { return cParameterAssignment_2; }

		//[core::Parameter]
		public CrossReference getParameterParameterCrossReference_2_0() { return cParameterParameterCrossReference_2_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_2_0_1() { return cParameterParameterIDTerminalRuleCall_2_0_1; }
	}

	public class IdentifierOrValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdentifierOrValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNUMBERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBOOLEANTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSTRINGTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// end of TriggerMessageExpression
		//IdentifierOrValue returns ecore::EString:
		//	NUMBER | BOOLEAN | INT | STRING;
		public ParserRule getRule() { return rule; }

		//NUMBER | BOOLEAN | INT | STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_0() { return cNUMBERTerminalRuleCall_0; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_1() { return cBOOLEANTerminalRuleCall_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3() { return cSTRINGTerminalRuleCall_3; }
	}
	
	
	public class IncrementDecrementOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "IncrementDecrementOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum IncrementDecrementOperator returns actionLanguage::IncrementDecrementOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class AssignOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cASSIGNEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cASSIGNColonEqualsSignKeyword_0_0 = (Keyword)cASSIGNEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUS_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUS_EQUALPlusSignEqualsSignKeyword_1_0 = (Keyword)cPLUS_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUAL_PLUSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUAL_PLUSEqualsSignPlusSignKeyword_2_0 = (Keyword)cEQUAL_PLUSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMINUS_EQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0 = (Keyword)cMINUS_EQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEQUAL_MINUSEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0 = (Keyword)cEQUAL_MINUSEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum AssignOperator returns actionLanguage::AssignOperator:
		//	ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-";
		public EnumRule getRule() { return rule; }

		//ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASSIGN=":="
		public EnumLiteralDeclaration getASSIGNEnumLiteralDeclaration_0() { return cASSIGNEnumLiteralDeclaration_0; }

		//":="
		public Keyword getASSIGNColonEqualsSignKeyword_0_0() { return cASSIGNColonEqualsSignKeyword_0_0; }

		//PLUS_EQUAL="+="
		public EnumLiteralDeclaration getPLUS_EQUALEnumLiteralDeclaration_1() { return cPLUS_EQUALEnumLiteralDeclaration_1; }

		//"+="
		public Keyword getPLUS_EQUALPlusSignEqualsSignKeyword_1_0() { return cPLUS_EQUALPlusSignEqualsSignKeyword_1_0; }

		//EQUAL_PLUS="=+"
		public EnumLiteralDeclaration getEQUAL_PLUSEnumLiteralDeclaration_2() { return cEQUAL_PLUSEnumLiteralDeclaration_2; }

		//"=+"
		public Keyword getEQUAL_PLUSEqualsSignPlusSignKeyword_2_0() { return cEQUAL_PLUSEqualsSignPlusSignKeyword_2_0; }

		//MINUS_EQUAL="-="
		public EnumLiteralDeclaration getMINUS_EQUALEnumLiteralDeclaration_3() { return cMINUS_EQUALEnumLiteralDeclaration_3; }

		//"-="
		public Keyword getMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0() { return cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0; }

		//EQUAL_MINUS="=-"
		public EnumLiteralDeclaration getEQUAL_MINUSEnumLiteralDeclaration_4() { return cEQUAL_MINUSEnumLiteralDeclaration_4; }

		//"=-"
		public Keyword getEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0() { return cEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0; }
	}

	public class LogicalOrOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOrOperator");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORVerticalLineVerticalLineKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalOrOperator returns commonExpressions::LogicOperator:
		//	OR="||";
		public EnumRule getRule() { return rule; }

		//OR="||"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }

		//"||"
		public Keyword getORVerticalLineVerticalLineKeyword_0() { return cORVerticalLineVerticalLineKeyword_0; }
	}

	public class LogicalAndOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAndOperator");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDAmpersandAmpersandKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalAndOperator returns commonExpressions::LogicOperator:
		//	AND="&&";
		public EnumRule getRule() { return rule; }

		//AND="&&"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }

		//"&&"
		public Keyword getANDAmpersandAmpersandKeyword_0() { return cANDAmpersandAmpersandKeyword_0; }
	}

	public class ComparingEQNEQOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingEQNEQOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUNEQUALLessThanSignGreaterThanSignKeyword_1_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
		//	EQUAL="==" | UNEQUAL="<>";
		public EnumRule getRule() { return rule; }

		//EQUAL="==" | UNEQUAL="<>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL="=="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQUALEqualsSignEqualsSignKeyword_0_0() { return cEQUALEqualsSignEqualsSignKeyword_0_0; }

		//UNEQUAL="<>"
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_1() { return cUNEQUALEnumLiteralDeclaration_1; }

		//"<>"
		public Keyword getUNEQUALLessThanSignGreaterThanSignKeyword_1_0() { return cUNEQUALLessThanSignGreaterThanSignKeyword_1_0; }
	}

	public class ComparingRelOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingRelOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLESSLessThanSignKeyword_0_0 = (Keyword)cLESSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGREATERGreaterThanSignKeyword_3_0 = (Keyword)cGREATEREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
		//	LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">";
		public EnumRule getRule() { return rule; }

		//LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">"
		public Alternatives getAlternatives() { return cAlternatives; }

		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_0() { return cLESSEnumLiteralDeclaration_0; }

		//"<"
		public Keyword getLESSLessThanSignKeyword_0_0() { return cLESSLessThanSignKeyword_0_0; }

		//LESS_OR_EQUAL="<="
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_1() { return cLESS_OR_EQUALEnumLiteralDeclaration_1; }

		//"<="
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0; }

		//GREATER_OR_EQUAL=">="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_2() { return cGREATER_OR_EQUALEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0; }

		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_3() { return cGREATEREnumLiteralDeclaration_3; }

		//">"
		public Keyword getGREATERGreaterThanSignKeyword_3_0() { return cGREATERGreaterThanSignKeyword_3_0; }
	}

	public class AdditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
		//	PLUS="+" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class MultiplicationOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTIMESAsteriskKeyword_0_0 = (Keyword)cTIMESEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVIDESolidusKeyword_1_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
		//	TIMES="*" | DIVIDE="/";
		public EnumRule getRule() { return rule; }

		//TIMES="*" | DIVIDE="/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//TIMES="*"
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration_0() { return cTIMESEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getTIMESAsteriskKeyword_0_0() { return cTIMESAsteriskKeyword_0_0; }

		//DIVIDE="/"
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_1() { return cDIVIDEEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDIVIDESolidusKeyword_1_0() { return cDIVIDESolidusKeyword_1_0; }
	}

	public class UnaryPreOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPreOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNOTNotKeyword_0_0 = (Keyword)cNOTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPLUSPlusSignKeyword_2_0 = (Keyword)cPLUSEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
		//	NOT="not" | MINUS="-" | PLUS="+";
		public EnumRule getRule() { return rule; }

		//NOT="not" | MINUS="-" | PLUS="+"
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT="not"
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_0() { return cNOTEnumLiteralDeclaration_0; }

		//"not"
		public Keyword getNOTNotKeyword_0_0() { return cNOTNotKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_2() { return cPLUSEnumLiteralDeclaration_2; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_2_0() { return cPLUSPlusSignKeyword_2_0; }
	}

	public class UnaryPostOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPostOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryPostOperator returns commonExpressions::UnaryOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}
	
	private BlockElements pBlock;
	private ForLoopElements pForLoop;
	private ForLoopCountingExpressionElements pForLoopCountingExpression;
	private WhileLoopElements pWhileLoop;
	private DoWhileLoopElements pDoWhileLoop;
	private IfStatementElements pIfStatement;
	private ReturnStatementElements pReturnStatement;
	private ExpressionStartRuleElements pExpressionStartRule;
	private IncrementDecrementOperatorElements unknownRuleIncrementDecrementOperator;
	private AssignmentElements pAssignment;
	private AssignOperatorElements unknownRuleAssignOperator;
	private ExpressionElements pExpression;
	private LogicalExpressionElements pLogicalExpression;
	private LogicalOrExpressionElements pLogicalOrExpression;
	private LogicalOrOperatorElements unknownRuleLogicalOrOperator;
	private LogicalAndExpressionElements pLogicalAndExpression;
	private LogicalAndOperatorElements unknownRuleLogicalAndOperator;
	private ComparisonExpressionElements pComparisonExpression;
	private ComparisonHigherOpExpressionElements pComparisonHigherOpExpression;
	private ComparingEQNEQOperatorElements unknownRuleComparingEQNEQOperator;
	private ComparingRelOperatorElements unknownRuleComparingRelOperator;
	private ArithmeticExpressionElements pArithmeticExpression;
	private AdditionExpressionElements pAdditionExpression;
	private AdditionOperatorElements unknownRuleAdditionOperator;
	private MultiplicationExpressionElements pMultiplicationExpression;
	private MultiplicationOperatorElements unknownRuleMultiplicationOperator;
	private UnaryPreExpressionElements pUnaryPreExpression;
	private UnaryPreOperatorElements unknownRuleUnaryPreOperator;
	private UnaryPostExpressionElements pUnaryPostExpression;
	private UnaryPostOperatorElements unknownRuleUnaryPostOperator;
	private OperandElements pOperand;
	private LiteralExpressionElements pLiteralExpression;
	private LiteralElements pLiteral;
	private AttributeExpressionElements pAttributeExpression;
	private OperationCallElements pOperationCall;
	private ParamaterBindingElements pParamaterBinding;
	private TriggerMessageExpressionElements pTriggerMessageExpression;
	private IdentifierOrValueElements pIdentifierOrValue;
	private TerminalRule tNUMBER;
	private TerminalRule tBOOLEAN;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public ActionLanguageGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Block returns actionLanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	//	{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}" | expressions+=Expression;
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// TODO: clarify if it makes sense to allow arbitrary expressions for
	//// the initializeExpression and countingExpression
	//ForLoop returns actionLanguage::ForLoop:
	//	"for" "(" initalizeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
	//	block=Block;
	public ForLoopElements getForLoopAccess() {
		return (pForLoop != null) ? pForLoop : (pForLoop = new ForLoopElements());
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}

	//ForLoopCountingExpression returns actionLanguage::Assignment:
	//	lhs_attributeExpression=AttributeExpression (incrementDecrementOperator=IncrementDecrementOperator |
	//	assignOperator=AssignOperator rhs_assignExpression=Expression);
	public ForLoopCountingExpressionElements getForLoopCountingExpressionAccess() {
		return (pForLoopCountingExpression != null) ? pForLoopCountingExpression : (pForLoopCountingExpression = new ForLoopCountingExpressionElements());
	}
	
	public ParserRule getForLoopCountingExpressionRule() {
		return getForLoopCountingExpressionAccess().getRule();
	}

	//WhileLoop returns actionLanguage::WhileLoop:
	//	"while" "(" loopTest=Expression ")" block=Block;
	public WhileLoopElements getWhileLoopAccess() {
		return (pWhileLoop != null) ? pWhileLoop : (pWhileLoop = new WhileLoopElements());
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//DoWhileLoop returns actionLanguage::DoWhileLoop:
	//	"do" block=Block "while" "(" loopTest=Expression ");";
	public DoWhileLoopElements getDoWhileLoopAccess() {
		return (pDoWhileLoop != null) ? pDoWhileLoop : (pDoWhileLoop = new DoWhileLoopElements());
	}
	
	public ParserRule getDoWhileLoopRule() {
		return getDoWhileLoopAccess().getRule();
	}

	//IfStatement returns actionLanguage::IfStatement:
	//	"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
	//	("else" elseBlock=Block)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//ReturnStatement returns actionLanguage::ReturnStatement:
	//	{actionLanguage::ReturnStatement} "return" expression=Expression ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//ExpressionStartRule returns expressions::Expression:
	//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement;
	public ExpressionStartRuleElements getExpressionStartRuleAccess() {
		return (pExpressionStartRule != null) ? pExpressionStartRule : (pExpressionStartRule = new ExpressionStartRuleElements());
	}
	
	public ParserRule getExpressionStartRuleRule() {
		return getExpressionStartRuleAccess().getRule();
	}

	//enum IncrementDecrementOperator returns actionLanguage::IncrementDecrementOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public IncrementDecrementOperatorElements getIncrementDecrementOperatorAccess() {
		return (unknownRuleIncrementDecrementOperator != null) ? unknownRuleIncrementDecrementOperator : (unknownRuleIncrementDecrementOperator = new IncrementDecrementOperatorElements());
	}
	
	public EnumRule getIncrementDecrementOperatorRule() {
		return getIncrementDecrementOperatorAccess().getRule();
	}

	//// Assignment
	//Assignment returns actionLanguage::Assignment:
	//	lhs_attributeExpression=AttributeExpression assignOperator=AssignOperator rhs_assignExpression=Expression ";";
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//enum AssignOperator returns actionLanguage::AssignOperator:
	//	ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-";
	public AssignOperatorElements getAssignOperatorAccess() {
		return (unknownRuleAssignOperator != null) ? unknownRuleAssignOperator : (unknownRuleAssignOperator = new AssignOperatorElements());
	}
	
	public EnumRule getAssignOperatorRule() {
		return getAssignOperatorAccess().getRule();
	}

	//// end of assignment
	//Expression returns expressions::Expression:
	//	LogicalExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// LogicalExpression
	//LogicalExpression returns expressions::Expression:
	//	LogicalOrExpression;
	public LogicalExpressionElements getLogicalExpressionAccess() {
		return (pLogicalExpression != null) ? pLogicalExpression : (pLogicalExpression = new LogicalExpressionElements());
	}
	
	public ParserRule getLogicalExpressionRule() {
		return getLogicalExpressionAccess().getRule();
	}

	//LogicalOrExpression returns expressions::Expression:
	//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
	//	rightExpression=LogicalAndExpression)*;
	public LogicalOrExpressionElements getLogicalOrExpressionAccess() {
		return (pLogicalOrExpression != null) ? pLogicalOrExpression : (pLogicalOrExpression = new LogicalOrExpressionElements());
	}
	
	public ParserRule getLogicalOrExpressionRule() {
		return getLogicalOrExpressionAccess().getRule();
	}

	//enum LogicalOrOperator returns commonExpressions::LogicOperator:
	//	OR="||";
	public LogicalOrOperatorElements getLogicalOrOperatorAccess() {
		return (unknownRuleLogicalOrOperator != null) ? unknownRuleLogicalOrOperator : (unknownRuleLogicalOrOperator = new LogicalOrOperatorElements());
	}
	
	public EnumRule getLogicalOrOperatorRule() {
		return getLogicalOrOperatorAccess().getRule();
	}

	//LogicalAndExpression returns expressions::Expression:
	//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
	//	rightExpression=ComparisonExpression)*;
	public LogicalAndExpressionElements getLogicalAndExpressionAccess() {
		return (pLogicalAndExpression != null) ? pLogicalAndExpression : (pLogicalAndExpression = new LogicalAndExpressionElements());
	}
	
	public ParserRule getLogicalAndExpressionRule() {
		return getLogicalAndExpressionAccess().getRule();
	}

	//enum LogicalAndOperator returns commonExpressions::LogicOperator:
	//	AND="&&";
	public LogicalAndOperatorElements getLogicalAndOperatorAccess() {
		return (unknownRuleLogicalAndOperator != null) ? unknownRuleLogicalAndOperator : (unknownRuleLogicalAndOperator = new LogicalAndOperatorElements());
	}
	
	public EnumRule getLogicalAndOperatorRule() {
		return getLogicalAndOperatorAccess().getRule();
	}

	//// end of LogicalExpression
	//// ComparisonExpression
	//ComparisonExpression returns expressions::Expression:
	//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
	//	operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//ComparisonHigherOpExpression returns expressions::Expression:
	//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
	//	rightExpression=ArithmeticExpression)?;
	public ComparisonHigherOpExpressionElements getComparisonHigherOpExpressionAccess() {
		return (pComparisonHigherOpExpression != null) ? pComparisonHigherOpExpression : (pComparisonHigherOpExpression = new ComparisonHigherOpExpressionElements());
	}
	
	public ParserRule getComparisonHigherOpExpressionRule() {
		return getComparisonHigherOpExpressionAccess().getRule();
	}

	//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
	//	EQUAL="==" | UNEQUAL="<>";
	public ComparingEQNEQOperatorElements getComparingEQNEQOperatorAccess() {
		return (unknownRuleComparingEQNEQOperator != null) ? unknownRuleComparingEQNEQOperator : (unknownRuleComparingEQNEQOperator = new ComparingEQNEQOperatorElements());
	}
	
	public EnumRule getComparingEQNEQOperatorRule() {
		return getComparingEQNEQOperatorAccess().getRule();
	}

	//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
	//	LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">";
	public ComparingRelOperatorElements getComparingRelOperatorAccess() {
		return (unknownRuleComparingRelOperator != null) ? unknownRuleComparingRelOperator : (unknownRuleComparingRelOperator = new ComparingRelOperatorElements());
	}
	
	public EnumRule getComparingRelOperatorRule() {
		return getComparingRelOperatorAccess().getRule();
	}

	//// end of ComparisonExpression
	//// ArithmeticExpression	
	//ArithmeticExpression returns expressions::Expression:
	//	AdditionExpression;
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return (pArithmeticExpression != null) ? pArithmeticExpression : (pArithmeticExpression = new ArithmeticExpressionElements());
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}

	//AdditionExpression returns expressions::Expression:
	//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
	//	rightExpression=MultiplicationExpression)*;
	public AdditionExpressionElements getAdditionExpressionAccess() {
		return (pAdditionExpression != null) ? pAdditionExpression : (pAdditionExpression = new AdditionExpressionElements());
	}
	
	public ParserRule getAdditionExpressionRule() {
		return getAdditionExpressionAccess().getRule();
	}

	//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
	//	PLUS="+" | MINUS="-";
	public AdditionOperatorElements getAdditionOperatorAccess() {
		return (unknownRuleAdditionOperator != null) ? unknownRuleAdditionOperator : (unknownRuleAdditionOperator = new AdditionOperatorElements());
	}
	
	public EnumRule getAdditionOperatorRule() {
		return getAdditionOperatorAccess().getRule();
	}

	//MultiplicationExpression returns expressions::Expression:
	//	UnaryPreExpression | UnaryPostExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
	//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | UnaryPostExpression))*;
	public MultiplicationExpressionElements getMultiplicationExpressionAccess() {
		return (pMultiplicationExpression != null) ? pMultiplicationExpression : (pMultiplicationExpression = new MultiplicationExpressionElements());
	}
	
	public ParserRule getMultiplicationExpressionRule() {
		return getMultiplicationExpressionAccess().getRule();
	}

	//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
	//	TIMES="*" | DIVIDE="/";
	public MultiplicationOperatorElements getMultiplicationOperatorAccess() {
		return (unknownRuleMultiplicationOperator != null) ? unknownRuleMultiplicationOperator : (unknownRuleMultiplicationOperator = new MultiplicationOperatorElements());
	}
	
	public EnumRule getMultiplicationOperatorRule() {
		return getMultiplicationOperatorAccess().getRule();
	}

	//// end of ArithmeticExpression
	//// UnaryPreExpression
	//UnaryPreExpression returns expressions::Expression:
	//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=Operand;
	public UnaryPreExpressionElements getUnaryPreExpressionAccess() {
		return (pUnaryPreExpression != null) ? pUnaryPreExpression : (pUnaryPreExpression = new UnaryPreExpressionElements());
	}
	
	public ParserRule getUnaryPreExpressionRule() {
		return getUnaryPreExpressionAccess().getRule();
	}

	//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
	//	NOT="not" | MINUS="-" | PLUS="+";
	public UnaryPreOperatorElements getUnaryPreOperatorAccess() {
		return (unknownRuleUnaryPreOperator != null) ? unknownRuleUnaryPreOperator : (unknownRuleUnaryPreOperator = new UnaryPreOperatorElements());
	}
	
	public EnumRule getUnaryPreOperatorRule() {
		return getUnaryPreOperatorAccess().getRule();
	}

	//// end of UnaryPreExpression
	//// UnaryPostExpression
	//UnaryPostExpression returns expressions::Expression:
	//	Operand ({commonExpressions::UnaryExpression.enclosedExpression=current} operator=UnaryPostOperator)?;
	public UnaryPostExpressionElements getUnaryPostExpressionAccess() {
		return (pUnaryPostExpression != null) ? pUnaryPostExpression : (pUnaryPostExpression = new UnaryPostExpressionElements());
	}
	
	public ParserRule getUnaryPostExpressionRule() {
		return getUnaryPostExpressionAccess().getRule();
	}

	//enum UnaryPostOperator returns commonExpressions::UnaryOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public UnaryPostOperatorElements getUnaryPostOperatorAccess() {
		return (unknownRuleUnaryPostOperator != null) ? unknownRuleUnaryPostOperator : (unknownRuleUnaryPostOperator = new UnaryPostOperatorElements());
	}
	
	public EnumRule getUnaryPostOperatorRule() {
		return getUnaryPostOperatorAccess().getRule();
	}

	//// end of UnaryPostExpression
	//// Operand
	//Operand returns expressions::Expression:
	//	"(" Expression ")" | LiteralExpression | AttributeExpression | OperationCall | TriggerMessageExpression;
	public OperandElements getOperandAccess() {
		return (pOperand != null) ? pOperand : (pOperand = new OperandElements());
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}

	//// end of Operand
	//LiteralExpression returns commonExpressions::LiteralExpression:
	//	{commonExpressions::LiteralExpression} value=Literal;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return (pLiteralExpression != null) ? pLiteralExpression : (pLiteralExpression = new LiteralExpressionElements());
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//Literal returns ecore::EString:
	//	NUMBER | BOOLEAN | INT | STRING;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//AttributeExpression returns actionLanguage::AttributeExpression:
	//	attribute=[core::Attribute] ("[" indices+=ArithmeticExpression "]")*;
	public AttributeExpressionElements getAttributeExpressionAccess() {
		return (pAttributeExpression != null) ? pAttributeExpression : (pAttributeExpression = new AttributeExpressionElements());
	}
	
	public ParserRule getAttributeExpressionRule() {
		return getAttributeExpressionAccess().getRule();
	}

	//OperationCall returns actionLanguage::OperationCall:
	//	operation=[core::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)? ")";
	public OperationCallElements getOperationCallAccess() {
		return (pOperationCall != null) ? pOperationCall : (pOperationCall = new OperationCallElements());
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}

	//ParamaterBinding returns core::ParameterBinding:
	//	{core::ParameterBinding} parameter=[core::Parameter] ":=" value=Expression;
	public ParamaterBindingElements getParamaterBindingAccess() {
		return (pParamaterBinding != null) ? pParamaterBinding : (pParamaterBinding = new ParamaterBindingElements());
	}
	
	public ParserRule getParamaterBindingRule() {
		return getParamaterBindingAccess().getRule();
	}

	//// TriggerMessageExpression
	//TriggerMessageExpression returns actionLanguage::TriggerMessageExpression:
	//	messageType=[msgtype::MessageType] "." parameter=[core::Parameter];
	public TriggerMessageExpressionElements getTriggerMessageExpressionAccess() {
		return (pTriggerMessageExpression != null) ? pTriggerMessageExpression : (pTriggerMessageExpression = new TriggerMessageExpressionElements());
	}
	
	public ParserRule getTriggerMessageExpressionRule() {
		return getTriggerMessageExpressionAccess().getRule();
	}

	//// end of TriggerMessageExpression
	//IdentifierOrValue returns ecore::EString:
	//	NUMBER | BOOLEAN | INT | STRING;
	public IdentifierOrValueElements getIdentifierOrValueAccess() {
		return (pIdentifierOrValue != null) ? pIdentifierOrValue : (pIdentifierOrValue = new IdentifierOrValueElements());
	}
	
	public ParserRule getIdentifierOrValueRule() {
		return getIdentifierOrValueAccess().getRule();
	}

	//terminal NUMBER returns ecore::EBigDecimal:
	//	INT "." INT;
	public TerminalRule getNUMBERRule() {
		return (tNUMBER != null) ? tNUMBER : (tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER"));
	} 

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
