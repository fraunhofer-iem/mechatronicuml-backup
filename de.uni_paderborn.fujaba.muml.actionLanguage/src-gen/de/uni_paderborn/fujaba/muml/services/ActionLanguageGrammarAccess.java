/*
* generated by Xtext
*/

package de.uni_paderborn.fujaba.muml.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ActionLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBlockAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExpressionsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionsExpressionStartRuleParserRuleCall_0_2_0 = (RuleCall)cExpressionsAssignment_0_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionsArithmeticExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		
		//Block returns actionLanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
		//	{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}" | expressions+=ArithmeticExpression;
		public ParserRule getRule() { return rule; }

		//{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}" | expressions+=ArithmeticExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}"
		public Group getGroup_0() { return cGroup_0; }

		//{actionLanguage::Block}
		public Action getBlockAction_0_0() { return cBlockAction_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0_1() { return cLeftCurlyBracketKeyword_0_1; }

		//expressions+=ExpressionStartRule*
		public Assignment getExpressionsAssignment_0_2() { return cExpressionsAssignment_0_2; }

		//ExpressionStartRule
		public RuleCall getExpressionsExpressionStartRuleParserRuleCall_0_2_0() { return cExpressionsExpressionStartRuleParserRuleCall_0_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_0_3() { return cRightCurlyBracketKeyword_0_3; }

		//expressions+=ArithmeticExpression
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }

		//ArithmeticExpression
		public RuleCall getExpressionsArithmeticExpressionParserRuleCall_1_0() { return cExpressionsArithmeticExpressionParserRuleCall_1_0; }
	}

	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitalizeExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitalizeExpressionAssignmentParserRuleCall_2_0 = (RuleCall)cInitalizeExpressionAssignment_2.eContents().get(0);
		private final Assignment cLoopTestAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopTestExpressionParserRuleCall_3_0 = (RuleCall)cLoopTestAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCountingExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0 = (RuleCall)cCountingExpressionAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBlockAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBlockBlockParserRuleCall_7_0 = (RuleCall)cBlockAssignment_7.eContents().get(0);
		
		//ForLoop returns actionLanguage::ForLoop:
		//	"for" "(" initalizeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//	block=Block;
		public ParserRule getRule() { return rule; }

		//"for" "(" initalizeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//block=Block
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//initalizeExpression=Assignment
		public Assignment getInitalizeExpressionAssignment_2() { return cInitalizeExpressionAssignment_2; }

		//Assignment
		public RuleCall getInitalizeExpressionAssignmentParserRuleCall_2_0() { return cInitalizeExpressionAssignmentParserRuleCall_2_0; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_3() { return cLoopTestAssignment_3; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_3_0() { return cLoopTestExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }

		//countingExpression=ForLoopCountingExpression
		public Assignment getCountingExpressionAssignment_5() { return cCountingExpressionAssignment_5; }

		//ForLoopCountingExpression
		public RuleCall getCountingExpressionForLoopCountingExpressionParserRuleCall_5_0() { return cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//block=Block
		public Assignment getBlockAssignment_7() { return cBlockAssignment_7; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_7_0() { return cBlockBlockParserRuleCall_7_0; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLoopTestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLoopTestExpressionParserRuleCall_2_0 = (RuleCall)cLoopTestAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		//WhileLoop returns actionLanguage::WhileLoop:
		//	"while" "(" loopTest=Expression ")" block=Block;
		public ParserRule getRule() { return rule; }

		//"while" "(" loopTest=Expression ")" block=Block
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_2() { return cLoopTestAssignment_2; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_2_0() { return cLoopTestExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//block=Block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}

	public class DoWhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLoopTestAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopTestExpressionParserRuleCall_4_0 = (RuleCall)cLoopTestAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//DoWhileLoop returns actionLanguage::DoWhileLoop:
		//	"do" block=Block "while" "(" loopTest=Expression ");";
		public ParserRule getRule() { return rule; }

		//"do" block=Block "while" "(" loopTest=Expression ");"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//block=Block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_4() { return cLoopTestAssignment_4; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_4_0() { return cLoopTestExpressionParserRuleCall_4_0; }

		//");"
		public Keyword getRightParenthesisSemicolonKeyword_5() { return cRightParenthesisSemicolonKeyword_5; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIfConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfConditionExpressionParserRuleCall_2_0 = (RuleCall)cIfConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockBlockParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseifKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cElseIfConditionsAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cElseIfConditionsExpressionParserRuleCall_5_2_0 = (RuleCall)cElseIfConditionsAssignment_5_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		private final Assignment cElseIfBlocksAssignment_5_4 = (Assignment)cGroup_5.eContents().get(4);
		private final RuleCall cElseIfBlocksBlockParserRuleCall_5_4_0 = (RuleCall)cElseIfBlocksAssignment_5_4.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cElseKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cElseBlockAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cElseBlockBlockParserRuleCall_6_1_0 = (RuleCall)cElseBlockAssignment_6_1.eContents().get(0);
		
		//IfStatement returns actionLanguage::IfStatement:
		//	"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		//	("else" elseBlock=Block)?;
		public ParserRule getRule() { return rule; }

		//"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		//("else" elseBlock=Block)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//ifCondition=Expression
		public Assignment getIfConditionAssignment_2() { return cIfConditionAssignment_2; }

		//Expression
		public RuleCall getIfConditionExpressionParserRuleCall_2_0() { return cIfConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//ifBlock=Block
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }

		//Block
		public RuleCall getIfBlockBlockParserRuleCall_4_0() { return cIfBlockBlockParserRuleCall_4_0; }

		//("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
		public Group getGroup_5() { return cGroup_5; }

		//"elseif"
		public Keyword getElseifKeyword_5_0() { return cElseifKeyword_5_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_5_1() { return cLeftParenthesisKeyword_5_1; }

		//elseIfConditions+=Expression
		public Assignment getElseIfConditionsAssignment_5_2() { return cElseIfConditionsAssignment_5_2; }

		//Expression
		public RuleCall getElseIfConditionsExpressionParserRuleCall_5_2_0() { return cElseIfConditionsExpressionParserRuleCall_5_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5_3() { return cRightParenthesisKeyword_5_3; }

		//elseIfBlocks+=Block
		public Assignment getElseIfBlocksAssignment_5_4() { return cElseIfBlocksAssignment_5_4; }

		//Block
		public RuleCall getElseIfBlocksBlockParserRuleCall_5_4_0() { return cElseIfBlocksBlockParserRuleCall_5_4_0; }

		//("else" elseBlock=Block)?
		public Group getGroup_6() { return cGroup_6; }

		//"else"
		public Keyword getElseKeyword_6_0() { return cElseKeyword_6_0; }

		//elseBlock=Block
		public Assignment getElseBlockAssignment_6_1() { return cElseBlockAssignment_6_1; }

		//Block
		public RuleCall getElseBlockBlockParserRuleCall_6_1_0() { return cElseBlockBlockParserRuleCall_6_1_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionArithmeticExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReturnStatement returns actionLanguage::ReturnStatement:
		//	{actionLanguage::ReturnStatement} "return" expression=ArithmeticExpression ";";
		public ParserRule getRule() { return rule; }

		//{actionLanguage::ReturnStatement} "return" expression=ArithmeticExpression ";"
		public Group getGroup() { return cGroup; }

		//{actionLanguage::ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//"return"
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//expression=ArithmeticExpression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//ArithmeticExpression
		public RuleCall getExpressionArithmeticExpressionParserRuleCall_2_0() { return cExpressionArithmeticExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ExpressionStartRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionStartRule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDoWhileLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIfStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cReturnStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//ExpressionStartRule returns expressions::Expression:
		//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement;
		public ParserRule getRule() { return rule; }

		//Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_0() { return cAssignmentParserRuleCall_0; }

		//ForLoop
		public RuleCall getForLoopParserRuleCall_1() { return cForLoopParserRuleCall_1; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_2() { return cWhileLoopParserRuleCall_2; }

		//DoWhileLoop
		public RuleCall getDoWhileLoopParserRuleCall_3() { return cDoWhileLoopParserRuleCall_3; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_4() { return cIfStatementParserRuleCall_4; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_5() { return cReturnStatementParserRuleCall_5; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_attributeExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_attributeExpressionAttributeLeafExpressionParserRuleCall_0_0 = (RuleCall)cLhs_attributeExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cAssignOperatorAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0 = (RuleCall)cAssignOperatorAssignment_1_0_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRhs_assignExpressionExpressionParserRuleCall_1_0_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_0_1.eContents().get(0);
		private final Assignment cIncrementDecrementOperatorAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_1_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Assignment returns actionLanguage::Assignment:
		//	lhs_attributeExpression=AttributeLeafExpression (assignOperator=AssignOperator rhs_assignExpression=Expression |
		//	incrementDecrementOperator=IncrementDecrementOperator) ";";
		public ParserRule getRule() { return rule; }

		//lhs_attributeExpression=AttributeLeafExpression (assignOperator=AssignOperator rhs_assignExpression=Expression |
		//incrementDecrementOperator=IncrementDecrementOperator) ";"
		public Group getGroup() { return cGroup; }

		//lhs_attributeExpression=AttributeLeafExpression
		public Assignment getLhs_attributeExpressionAssignment_0() { return cLhs_attributeExpressionAssignment_0; }

		//AttributeLeafExpression
		public RuleCall getLhs_attributeExpressionAttributeLeafExpressionParserRuleCall_0_0() { return cLhs_attributeExpressionAttributeLeafExpressionParserRuleCall_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=Expression | incrementDecrementOperator=IncrementDecrementOperator
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//assignOperator=AssignOperator rhs_assignExpression=Expression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_0_0() { return cAssignOperatorAssignment_1_0_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0; }

		//rhs_assignExpression=Expression
		public Assignment getRhs_assignExpressionAssignment_1_0_1() { return cRhs_assignExpressionAssignment_1_0_1; }

		//Expression
		public RuleCall getRhs_assignExpressionExpressionParserRuleCall_1_0_1_0() { return cRhs_assignExpressionExpressionParserRuleCall_1_0_1_0; }

		//incrementDecrementOperator=IncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_1() { return cIncrementDecrementOperatorAssignment_1_1; }

		//IncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_1_0() { return cIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class ForLoopCountingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoopCountingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_attributeExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_attributeExpressionAttributeLeafExpressionParserRuleCall_0_0 = (RuleCall)cLhs_attributeExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIncrementDecrementOperatorAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_0_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cAssignOperatorAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0 = (RuleCall)cAssignOperatorAssignment_1_1_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_1_1.eContents().get(0);
		
		//ForLoopCountingExpression returns actionLanguage::Assignment:
		//	lhs_attributeExpression=AttributeLeafExpression (incrementDecrementOperator=IncrementDecrementOperator |
		//	assignOperator=AssignOperator rhs_assignExpression=Expression);
		public ParserRule getRule() { return rule; }

		//lhs_attributeExpression=AttributeLeafExpression (incrementDecrementOperator=IncrementDecrementOperator |
		//assignOperator=AssignOperator rhs_assignExpression=Expression)
		public Group getGroup() { return cGroup; }

		//lhs_attributeExpression=AttributeLeafExpression
		public Assignment getLhs_attributeExpressionAssignment_0() { return cLhs_attributeExpressionAssignment_0; }

		//AttributeLeafExpression
		public RuleCall getLhs_attributeExpressionAttributeLeafExpressionParserRuleCall_0_0() { return cLhs_attributeExpressionAttributeLeafExpressionParserRuleCall_0_0; }

		//incrementDecrementOperator=IncrementDecrementOperator | assignOperator=AssignOperator rhs_assignExpression=Expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//incrementDecrementOperator=IncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_0() { return cIncrementDecrementOperatorAssignment_1_0; }

		//IncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_0_0() { return cIncrementDecrementOperatorIncrementDecrementOperatorEnumRuleCall_1_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_1_0() { return cAssignOperatorAssignment_1_1_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0; }

		//rhs_assignExpression=Expression
		public Assignment getRhs_assignExpressionAssignment_1_1_1() { return cRhs_assignExpressionAssignment_1_1_1; }

		//Expression
		public RuleCall getRhs_assignExpressionExpressionParserRuleCall_1_1_1_0() { return cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cArithmeticExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression returns expressions::Expression:
		//	ArithmeticExpression;
		public ParserRule getRule() { return rule; }

		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall() { return cArithmeticExpressionParserRuleCall; }
	}

	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorArithmeticOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//ArithmeticExpression returns expressions::Expression:
		//	ComparisonExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=ArithmeticOperator
		//	rightExpression=ComparisonExpression)*;
		public ParserRule getRule() { return rule; }

		//ComparisonExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=ArithmeticOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=ArithmeticOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=ArithmeticOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ArithmeticOperator
		public RuleCall getOperatorArithmeticOperatorEnumRuleCall_1_1_0() { return cOperatorArithmeticOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightExpressionComparisonExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cComparisonExpressionLeftExpressionAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOperatorComparingOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOperatorAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightExpressionLogicalExpressionParserRuleCall_1_1_0 = (RuleCall)cRightExpressionAssignment_1_1.eContents().get(0);
		
		//ComparisonExpression returns expressions::Expression:
		//	LogicalExpression (({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingOperator)
		//	rightExpression=LogicalExpression)*;
		public ParserRule getRule() { return rule; }

		//LogicalExpression (({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingOperator)
		//rightExpression=LogicalExpression)*
		public Group getGroup() { return cGroup; }

		//LogicalExpression
		public RuleCall getLogicalExpressionParserRuleCall_0() { return cLogicalExpressionParserRuleCall_0; }

		//(({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingOperator)
		//rightExpression=LogicalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingOperator
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0_0() { return cComparisonExpressionLeftExpressionAction_1_0_0; }

		//operator=ComparingOperator
		public Assignment getOperatorAssignment_1_0_1() { return cOperatorAssignment_1_0_1; }

		//ComparingOperator
		public RuleCall getOperatorComparingOperatorEnumRuleCall_1_0_1_0() { return cOperatorComparingOperatorEnumRuleCall_1_0_1_0; }

		//rightExpression=LogicalExpression
		public Assignment getRightExpressionAssignment_1_1() { return cRightExpressionAssignment_1_1; }

		//LogicalExpression
		public RuleCall getRightExpressionLogicalExpressionParserRuleCall_1_1_0() { return cRightExpressionLogicalExpressionParserRuleCall_1_1_0; }
	}

	public class LogicalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cUnaryExpressionParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cAttributeExpressionParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cLogicalExpressionLeftExpressionAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOperatorLogicOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOperatorAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cRightExpressionAlternatives_1_1_0 = (Alternatives)cRightExpressionAssignment_1_1.eContents().get(0);
		private final RuleCall cRightExpressionUnaryExpressionParserRuleCall_1_1_0_0 = (RuleCall)cRightExpressionAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cRightExpressionAttributeExpressionParserRuleCall_1_1_0_1 = (RuleCall)cRightExpressionAlternatives_1_1_0.eContents().get(1);
		
		//LogicalExpression returns expressions::Expression:
		//	(UnaryExpression | AttributeExpression) (({commonExpressions::LogicalExpression.leftExpression=current}
		//	operator=LogicOperator) rightExpression=(UnaryExpression | AttributeExpression))*;
		public ParserRule getRule() { return rule; }

		//(UnaryExpression | AttributeExpression) (({commonExpressions::LogicalExpression.leftExpression=current}
		//operator=LogicOperator) rightExpression=(UnaryExpression | AttributeExpression))*
		public Group getGroup() { return cGroup; }

		//UnaryExpression | AttributeExpression
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0_0() { return cUnaryExpressionParserRuleCall_0_0; }

		//AttributeExpression
		public RuleCall getAttributeExpressionParserRuleCall_0_1() { return cAttributeExpressionParserRuleCall_0_1; }

		//(({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicOperator) rightExpression=(UnaryExpression
		//| AttributeExpression))*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current} operator=LogicOperator
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0_0() { return cLogicalExpressionLeftExpressionAction_1_0_0; }

		//operator=LogicOperator
		public Assignment getOperatorAssignment_1_0_1() { return cOperatorAssignment_1_0_1; }

		//LogicOperator
		public RuleCall getOperatorLogicOperatorEnumRuleCall_1_0_1_0() { return cOperatorLogicOperatorEnumRuleCall_1_0_1_0; }

		//rightExpression=(UnaryExpression | AttributeExpression)
		public Assignment getRightExpressionAssignment_1_1() { return cRightExpressionAssignment_1_1; }

		//UnaryExpression | AttributeExpression
		public Alternatives getRightExpressionAlternatives_1_1_0() { return cRightExpressionAlternatives_1_1_0; }

		//UnaryExpression
		public RuleCall getRightExpressionUnaryExpressionParserRuleCall_1_1_0_0() { return cRightExpressionUnaryExpressionParserRuleCall_1_1_0_0; }

		//AttributeExpression
		public RuleCall getRightExpressionAttributeExpressionParserRuleCall_1_1_0_1() { return cRightExpressionAttributeExpressionParserRuleCall_1_1_0_1; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnaryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorUnaryOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cEnclosedExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEnclosedExpressionAttributeExpressionParserRuleCall_2_0 = (RuleCall)cEnclosedExpressionAssignment_2.eContents().get(0);
		
		//UnaryExpression returns expressions::Expression:
		//	{commonExpressions::UnaryExpression} operator=UnaryOperator enclosedExpression=AttributeExpression;
		public ParserRule getRule() { return rule; }

		//{commonExpressions::UnaryExpression} operator=UnaryOperator enclosedExpression=AttributeExpression
		public Group getGroup() { return cGroup; }

		//{commonExpressions::UnaryExpression}
		public Action getUnaryExpressionAction_0() { return cUnaryExpressionAction_0; }

		//operator=UnaryOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//UnaryOperator
		public RuleCall getOperatorUnaryOperatorEnumRuleCall_1_0() { return cOperatorUnaryOperatorEnumRuleCall_1_0; }

		//enclosedExpression=AttributeExpression
		public Assignment getEnclosedExpressionAssignment_2() { return cEnclosedExpressionAssignment_2; }

		//AttributeExpression
		public RuleCall getEnclosedExpressionAttributeExpressionParserRuleCall_2_0() { return cEnclosedExpressionAttributeExpressionParserRuleCall_2_0; }
	}

	public class AttributeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOperationCallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cAttributeExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cAttributeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cAttributeAttributeCrossReference_1_1_0 = (CrossReference)cAttributeAssignment_1_1.eContents().get(0);
		private final RuleCall cAttributeAttributeIDTerminalRuleCall_1_1_0_1 = (RuleCall)cAttributeAttributeCrossReference_1_1_0.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cIndicesAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cIndicesExpressionParserRuleCall_1_2_1_0 = (RuleCall)cIndicesAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2_2 = (Keyword)cGroup_1_2.eContents().get(2);
		
		//AttributeExpression returns expressions::Expression:
		//	OperationCall | {actionLanguage::AttributeExpression} attribute=[core::Attribute] ("[" indices+=Expression "]")*;
		public ParserRule getRule() { return rule; }

		//OperationCall | {actionLanguage::AttributeExpression} attribute=[core::Attribute] ("[" indices+=Expression "]")*
		public Alternatives getAlternatives() { return cAlternatives; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_0() { return cOperationCallParserRuleCall_0; }

		//{actionLanguage::AttributeExpression} attribute=[core::Attribute] ("[" indices+=Expression "]")*
		public Group getGroup_1() { return cGroup_1; }

		//{actionLanguage::AttributeExpression}
		public Action getAttributeExpressionAction_1_0() { return cAttributeExpressionAction_1_0; }

		//attribute=[core::Attribute]
		public Assignment getAttributeAssignment_1_1() { return cAttributeAssignment_1_1; }

		//[core::Attribute]
		public CrossReference getAttributeAttributeCrossReference_1_1_0() { return cAttributeAttributeCrossReference_1_1_0; }

		//ID
		public RuleCall getAttributeAttributeIDTerminalRuleCall_1_1_0_1() { return cAttributeAttributeIDTerminalRuleCall_1_1_0_1; }

		//("[" indices+=Expression "]")*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_2_0() { return cLeftSquareBracketKeyword_1_2_0; }

		//indices+=Expression
		public Assignment getIndicesAssignment_1_2_1() { return cIndicesAssignment_1_2_1; }

		//Expression
		public RuleCall getIndicesExpressionParserRuleCall_1_2_1_0() { return cIndicesExpressionParserRuleCall_1_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2_2() { return cRightSquareBracketKeyword_1_2_2; }
	}

	public class AttributeLeafExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeLeafExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAttributeExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cAttributeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cAttributeAttributeCrossReference_1_0 = (CrossReference)cAttributeAssignment_1.eContents().get(0);
		private final RuleCall cAttributeAttributeIDTerminalRuleCall_1_0_1 = (RuleCall)cAttributeAttributeCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIndicesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIndicesExpressionParserRuleCall_2_1_0 = (RuleCall)cIndicesAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//AttributeLeafExpression returns actionLanguage::AttributeExpression:
		//	{actionLanguage::AttributeExpression} attribute=[core::Attribute] ("[" indices+=Expression "]")*;
		public ParserRule getRule() { return rule; }

		//{actionLanguage::AttributeExpression} attribute=[core::Attribute] ("[" indices+=Expression "]")*
		public Group getGroup() { return cGroup; }

		//{actionLanguage::AttributeExpression}
		public Action getAttributeExpressionAction_0() { return cAttributeExpressionAction_0; }

		//attribute=[core::Attribute]
		public Assignment getAttributeAssignment_1() { return cAttributeAssignment_1; }

		//[core::Attribute]
		public CrossReference getAttributeAttributeCrossReference_1_0() { return cAttributeAttributeCrossReference_1_0; }

		//ID
		public RuleCall getAttributeAttributeIDTerminalRuleCall_1_0_1() { return cAttributeAttributeIDTerminalRuleCall_1_0_1; }

		//("[" indices+=Expression "]")*
		public Group getGroup_2() { return cGroup_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }

		//indices+=Expression
		public Assignment getIndicesAssignment_2_1() { return cIndicesAssignment_2_1; }

		//Expression
		public RuleCall getIndicesExpressionParserRuleCall_2_1_0() { return cIndicesExpressionParserRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }
	}

	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCall");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cOperationCallAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cOperationAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final CrossReference cOperationOperationCrossReference_1_1_0_0 = (CrossReference)cOperationAssignment_1_1_0.eContents().get(0);
		private final RuleCall cOperationOperationIDTerminalRuleCall_1_1_0_0_1 = (RuleCall)cOperationOperationCrossReference_1_1_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cParameterBindingAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_1_1_2_0 = (RuleCall)cParameterBindingAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_1_3 = (Group)cGroup_1_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_1_3_0 = (Keyword)cGroup_1_1_3.eContents().get(0);
		private final Assignment cParameterBindingAssignment_1_1_3_1 = (Assignment)cGroup_1_1_3.eContents().get(1);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_1_1_3_1_0 = (RuleCall)cParameterBindingAssignment_1_1_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1_4 = (Keyword)cGroup_1_1.eContents().get(4);
		
		//OperationCall returns expressions::Expression:
		//	LiteralExpression | {actionLanguage::OperationCall} (operation=[core::Operation] "("
		//	parameterBinding+=ParamaterBinding? ("," parameterBinding+=ParamaterBinding)* ")");
		public ParserRule getRule() { return rule; }

		//LiteralExpression | {actionLanguage::OperationCall} (operation=[core::Operation] "(" parameterBinding+=ParamaterBinding?
		//("," parameterBinding+=ParamaterBinding)* ")")
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_0() { return cLiteralExpressionParserRuleCall_0; }

		//{actionLanguage::OperationCall} (operation=[core::Operation] "(" parameterBinding+=ParamaterBinding? (","
		//parameterBinding+=ParamaterBinding)* ")")
		public Group getGroup_1() { return cGroup_1; }

		//{actionLanguage::OperationCall}
		public Action getOperationCallAction_1_0() { return cOperationCallAction_1_0; }

		//operation=[core::Operation] "(" parameterBinding+=ParamaterBinding? ("," parameterBinding+=ParamaterBinding)* ")"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//operation=[core::Operation]
		public Assignment getOperationAssignment_1_1_0() { return cOperationAssignment_1_1_0; }

		//[core::Operation]
		public CrossReference getOperationOperationCrossReference_1_1_0_0() { return cOperationOperationCrossReference_1_1_0_0; }

		//ID
		public RuleCall getOperationOperationIDTerminalRuleCall_1_1_0_0_1() { return cOperationOperationIDTerminalRuleCall_1_1_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1_1() { return cLeftParenthesisKeyword_1_1_1; }

		//parameterBinding+=ParamaterBinding?
		public Assignment getParameterBindingAssignment_1_1_2() { return cParameterBindingAssignment_1_1_2; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_1_1_2_0() { return cParameterBindingParamaterBindingParserRuleCall_1_1_2_0; }

		//("," parameterBinding+=ParamaterBinding)*
		public Group getGroup_1_1_3() { return cGroup_1_1_3; }

		//","
		public Keyword getCommaKeyword_1_1_3_0() { return cCommaKeyword_1_1_3_0; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_1_1_3_1() { return cParameterBindingAssignment_1_1_3_1; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_1_1_3_1_0() { return cParameterBindingParamaterBindingParserRuleCall_1_1_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_1_4() { return cRightParenthesisKeyword_1_1_4; }
	}

	public class ParamaterBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParamaterBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterBindingAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cParameterParameterCrossReference_1_0 = (CrossReference)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_1_0_1 = (RuleCall)cParameterParameterCrossReference_1_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ParamaterBinding returns core::ParameterBinding:
		//	{core::ParameterBinding} parameter=[core::Parameter] ":=" value=Expression;
		public ParserRule getRule() { return rule; }

		//{core::ParameterBinding} parameter=[core::Parameter] ":=" value=Expression
		public Group getGroup() { return cGroup; }

		//{core::ParameterBinding}
		public Action getParameterBindingAction_0() { return cParameterBindingAction_0; }

		//parameter=[core::Parameter]
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }

		//[core::Parameter]
		public CrossReference getParameterParameterCrossReference_1_0() { return cParameterParameterCrossReference_1_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_1_0_1() { return cParameterParameterIDTerminalRuleCall_1_0_1; }

		//":="
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cLiteralExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueIdentifierOrValueParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//LiteralExpression returns expressions::Expression:
		//	"(" Expression ")" | {commonExpressions::LiteralExpression} value=IdentifierOrValue;
		public ParserRule getRule() { return rule; }

		//"(" Expression ")" | {commonExpressions::LiteralExpression} value=IdentifierOrValue
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//{commonExpressions::LiteralExpression} value=IdentifierOrValue
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LiteralExpression}
		public Action getLiteralExpressionAction_1_0() { return cLiteralExpressionAction_1_0; }

		//value=IdentifierOrValue
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//IdentifierOrValue
		public RuleCall getValueIdentifierOrValueParserRuleCall_1_1_0() { return cValueIdentifierOrValueParserRuleCall_1_1_0; }
	}

	public class IdentifierOrValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdentifierOrValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNUMBERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBOOLEANTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//IdentifierOrValue returns ecore::EString:
		//	NUMBER | BOOLEAN | INT;
		public ParserRule getRule() { return rule; }

		//NUMBER | BOOLEAN | INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_0() { return cNUMBERTerminalRuleCall_0; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_1() { return cBOOLEANTerminalRuleCall_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	
	
	public class AssignOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cASSIGNEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cASSIGNColonEqualsSignKeyword_0_0 = (Keyword)cASSIGNEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUS_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUS_EQUALPlusSignEqualsSignKeyword_1_0 = (Keyword)cPLUS_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUAL_PLUSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUAL_PLUSEqualsSignPlusSignKeyword_2_0 = (Keyword)cEQUAL_PLUSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMINUS_EQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0 = (Keyword)cMINUS_EQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEQUAL_MINUSEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0 = (Keyword)cEQUAL_MINUSEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum AssignOperator returns actionLanguage::AssignOperator:
		//	ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-";
		public EnumRule getRule() { return rule; }

		//ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASSIGN=":="
		public EnumLiteralDeclaration getASSIGNEnumLiteralDeclaration_0() { return cASSIGNEnumLiteralDeclaration_0; }

		//":="
		public Keyword getASSIGNColonEqualsSignKeyword_0_0() { return cASSIGNColonEqualsSignKeyword_0_0; }

		//PLUS_EQUAL="+="
		public EnumLiteralDeclaration getPLUS_EQUALEnumLiteralDeclaration_1() { return cPLUS_EQUALEnumLiteralDeclaration_1; }

		//"+="
		public Keyword getPLUS_EQUALPlusSignEqualsSignKeyword_1_0() { return cPLUS_EQUALPlusSignEqualsSignKeyword_1_0; }

		//EQUAL_PLUS="=+"
		public EnumLiteralDeclaration getEQUAL_PLUSEnumLiteralDeclaration_2() { return cEQUAL_PLUSEnumLiteralDeclaration_2; }

		//"=+"
		public Keyword getEQUAL_PLUSEqualsSignPlusSignKeyword_2_0() { return cEQUAL_PLUSEqualsSignPlusSignKeyword_2_0; }

		//MINUS_EQUAL="-="
		public EnumLiteralDeclaration getMINUS_EQUALEnumLiteralDeclaration_3() { return cMINUS_EQUALEnumLiteralDeclaration_3; }

		//"-="
		public Keyword getMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0() { return cMINUS_EQUALHyphenMinusEqualsSignKeyword_3_0; }

		//EQUAL_MINUS="=-"
		public EnumLiteralDeclaration getEQUAL_MINUSEnumLiteralDeclaration_4() { return cEQUAL_MINUSEnumLiteralDeclaration_4; }

		//"=-"
		public Keyword getEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0() { return cEQUAL_MINUSEqualsSignHyphenMinusKeyword_4_0; }
	}

	public class IncrementDecrementOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "IncrementDecrementOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum IncrementDecrementOperator returns actionLanguage::IncrementDecrementOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class LogicOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDAmpersandKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cORVerticalLineKeyword_1_0 = (Keyword)cOREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cXORXorKeyword_2_0 = (Keyword)cXOREnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cIMPLYEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cIMPLYEqualsSignGreaterThanSignKeyword_3_0 = (Keyword)cIMPLYEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEQUIVALENTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEQUIVALENTLessThanSignEqualsSignGreaterThanSignKeyword_4_0 = (Keyword)cEQUIVALENTEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum LogicOperator returns commonExpressions::LogicOperator:
		//	AND="&" | OR="|" | XOR="xor" | IMPLY="=>" | EQUIVALENT="<=>";
		public EnumRule getRule() { return rule; }

		//AND="&" | OR="|" | XOR="xor" | IMPLY="=>" | EQUIVALENT="<=>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//AND="&"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }

		//"&"
		public Keyword getANDAmpersandKeyword_0_0() { return cANDAmpersandKeyword_0_0; }

		//OR="|"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_1() { return cOREnumLiteralDeclaration_1; }

		//"|"
		public Keyword getORVerticalLineKeyword_1_0() { return cORVerticalLineKeyword_1_0; }

		//XOR="xor"
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration_2() { return cXOREnumLiteralDeclaration_2; }

		//"xor"
		public Keyword getXORXorKeyword_2_0() { return cXORXorKeyword_2_0; }

		//IMPLY="=>"
		public EnumLiteralDeclaration getIMPLYEnumLiteralDeclaration_3() { return cIMPLYEnumLiteralDeclaration_3; }

		//"=>"
		public Keyword getIMPLYEqualsSignGreaterThanSignKeyword_3_0() { return cIMPLYEqualsSignGreaterThanSignKeyword_3_0; }

		//EQUIVALENT="<=>"
		public EnumLiteralDeclaration getEQUIVALENTEnumLiteralDeclaration_4() { return cEQUIVALENTEnumLiteralDeclaration_4; }

		//"<=>"
		public Keyword getEQUIVALENTLessThanSignEqualsSignGreaterThanSignKeyword_4_0() { return cEQUIVALENTLessThanSignEqualsSignGreaterThanSignKeyword_4_0; }
	}

	public class ArithmeticOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cTIMESAsteriskKeyword_2_0 = (Keyword)cTIMESEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cDIVIDESolidusKeyword_3_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMODULOEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMODULOPercentSignKeyword_4_0 = (Keyword)cMODULOEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum ArithmeticOperator returns commonExpressions::ArithmeticOperator:
		//	PLUS="+" | MINUS="-" | TIMES="*" | DIVIDE="/" | MODULO="%";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-" | TIMES="*" | DIVIDE="/" | MODULO="%"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }

		//TIMES="*"
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration_2() { return cTIMESEnumLiteralDeclaration_2; }

		//"*"
		public Keyword getTIMESAsteriskKeyword_2_0() { return cTIMESAsteriskKeyword_2_0; }

		//DIVIDE="/"
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_3() { return cDIVIDEEnumLiteralDeclaration_3; }

		//"/"
		public Keyword getDIVIDESolidusKeyword_3_0() { return cDIVIDESolidusKeyword_3_0; }

		//MODULO="%"
		public EnumLiteralDeclaration getMODULOEnumLiteralDeclaration_4() { return cMODULOEnumLiteralDeclaration_4; }

		//"%"
		public Keyword getMODULOPercentSignKeyword_4_0() { return cMODULOPercentSignKeyword_4_0; }
	}

	public class ComparingOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLESSLessThanSignKeyword_0_0 = (Keyword)cLESSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_3_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGREATERGreaterThanSignKeyword_4_0 = (Keyword)cGREATEREnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cUNEQUALLessThanSignGreaterThanSignKeyword_5_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum ComparingOperator returns commonExpressions::ComparingOperator:
		//	LESS="<" | LESS_OR_EQUAL="<=" | EQUAL="==" | GREATER_OR_EQUAL=">=" | GREATER=">" | UNEQUAL="<>";
		public EnumRule getRule() { return rule; }

		//LESS="<" | LESS_OR_EQUAL="<=" | EQUAL="==" | GREATER_OR_EQUAL=">=" | GREATER=">" | UNEQUAL="<>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_0() { return cLESSEnumLiteralDeclaration_0; }

		//"<"
		public Keyword getLESSLessThanSignKeyword_0_0() { return cLESSLessThanSignKeyword_0_0; }

		//LESS_OR_EQUAL="<="
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_1() { return cLESS_OR_EQUALEnumLiteralDeclaration_1; }

		//"<="
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0; }

		//EQUAL="=="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_2() { return cEQUALEnumLiteralDeclaration_2; }

		//"=="
		public Keyword getEQUALEqualsSignEqualsSignKeyword_2_0() { return cEQUALEqualsSignEqualsSignKeyword_2_0; }

		//GREATER_OR_EQUAL=">="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_3() { return cGREATER_OR_EQUALEnumLiteralDeclaration_3; }

		//">="
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_3_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_3_0; }

		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_4() { return cGREATEREnumLiteralDeclaration_4; }

		//">"
		public Keyword getGREATERGreaterThanSignKeyword_4_0() { return cGREATERGreaterThanSignKeyword_4_0; }

		//UNEQUAL="<>"
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_5() { return cUNEQUALEnumLiteralDeclaration_5; }

		//"<>"
		public Keyword getUNEQUALLessThanSignGreaterThanSignKeyword_5_0() { return cUNEQUALLessThanSignGreaterThanSignKeyword_5_0; }
	}

	public class UnaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNOTNotKeyword_0_0 = (Keyword)cNOTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPLUSPlusSignKeyword_2_0 = (Keyword)cPLUSEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum UnaryOperator returns commonExpressions::UnaryOperator:
		//	NOT="not" | MINUS="-" | PLUS="+";
		public EnumRule getRule() { return rule; }

		//NOT="not" | MINUS="-" | PLUS="+"
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT="not"
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_0() { return cNOTEnumLiteralDeclaration_0; }

		//"not"
		public Keyword getNOTNotKeyword_0_0() { return cNOTNotKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_2() { return cPLUSEnumLiteralDeclaration_2; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_2_0() { return cPLUSPlusSignKeyword_2_0; }
	}
	
	private BlockElements pBlock;
	private ForLoopElements pForLoop;
	private WhileLoopElements pWhileLoop;
	private DoWhileLoopElements pDoWhileLoop;
	private IfStatementElements pIfStatement;
	private ReturnStatementElements pReturnStatement;
	private ExpressionStartRuleElements pExpressionStartRule;
	private AssignmentElements pAssignment;
	private ForLoopCountingExpressionElements pForLoopCountingExpression;
	private ExpressionElements pExpression;
	private ArithmeticExpressionElements pArithmeticExpression;
	private ComparisonExpressionElements pComparisonExpression;
	private LogicalExpressionElements pLogicalExpression;
	private UnaryExpressionElements pUnaryExpression;
	private AttributeExpressionElements pAttributeExpression;
	private AttributeLeafExpressionElements pAttributeLeafExpression;
	private OperationCallElements pOperationCall;
	private ParamaterBindingElements pParamaterBinding;
	private LiteralExpressionElements pLiteralExpression;
	private IdentifierOrValueElements pIdentifierOrValue;
	private AssignOperatorElements unknownRuleAssignOperator;
	private IncrementDecrementOperatorElements unknownRuleIncrementDecrementOperator;
	private LogicOperatorElements unknownRuleLogicOperator;
	private ArithmeticOperatorElements unknownRuleArithmeticOperator;
	private ComparingOperatorElements unknownRuleComparingOperator;
	private UnaryOperatorElements unknownRuleUnaryOperator;
	private TerminalRule tNUMBER;
	private TerminalRule tBOOLEAN;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public ActionLanguageGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Block returns actionLanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	//	{actionLanguage::Block} "{" expressions+=ExpressionStartRule* "}" | expressions+=ArithmeticExpression;
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//ForLoop returns actionLanguage::ForLoop:
	//	"for" "(" initalizeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
	//	block=Block;
	public ForLoopElements getForLoopAccess() {
		return (pForLoop != null) ? pForLoop : (pForLoop = new ForLoopElements());
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}

	//WhileLoop returns actionLanguage::WhileLoop:
	//	"while" "(" loopTest=Expression ")" block=Block;
	public WhileLoopElements getWhileLoopAccess() {
		return (pWhileLoop != null) ? pWhileLoop : (pWhileLoop = new WhileLoopElements());
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//DoWhileLoop returns actionLanguage::DoWhileLoop:
	//	"do" block=Block "while" "(" loopTest=Expression ");";
	public DoWhileLoopElements getDoWhileLoopAccess() {
		return (pDoWhileLoop != null) ? pDoWhileLoop : (pDoWhileLoop = new DoWhileLoopElements());
	}
	
	public ParserRule getDoWhileLoopRule() {
		return getDoWhileLoopAccess().getRule();
	}

	//IfStatement returns actionLanguage::IfStatement:
	//	"if" "(" ifCondition=Expression ")" ifBlock=Block ("elseif" "(" elseIfConditions+=Expression ")" elseIfBlocks+=Block)*
	//	("else" elseBlock=Block)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//ReturnStatement returns actionLanguage::ReturnStatement:
	//	{actionLanguage::ReturnStatement} "return" expression=ArithmeticExpression ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//ExpressionStartRule returns expressions::Expression:
	//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement;
	public ExpressionStartRuleElements getExpressionStartRuleAccess() {
		return (pExpressionStartRule != null) ? pExpressionStartRule : (pExpressionStartRule = new ExpressionStartRuleElements());
	}
	
	public ParserRule getExpressionStartRuleRule() {
		return getExpressionStartRuleAccess().getRule();
	}

	//Assignment returns actionLanguage::Assignment:
	//	lhs_attributeExpression=AttributeLeafExpression (assignOperator=AssignOperator rhs_assignExpression=Expression |
	//	incrementDecrementOperator=IncrementDecrementOperator) ";";
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//ForLoopCountingExpression returns actionLanguage::Assignment:
	//	lhs_attributeExpression=AttributeLeafExpression (incrementDecrementOperator=IncrementDecrementOperator |
	//	assignOperator=AssignOperator rhs_assignExpression=Expression);
	public ForLoopCountingExpressionElements getForLoopCountingExpressionAccess() {
		return (pForLoopCountingExpression != null) ? pForLoopCountingExpression : (pForLoopCountingExpression = new ForLoopCountingExpressionElements());
	}
	
	public ParserRule getForLoopCountingExpressionRule() {
		return getForLoopCountingExpressionAccess().getRule();
	}

	//Expression returns expressions::Expression:
	//	ArithmeticExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//ArithmeticExpression returns expressions::Expression:
	//	ComparisonExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=ArithmeticOperator
	//	rightExpression=ComparisonExpression)*;
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return (pArithmeticExpression != null) ? pArithmeticExpression : (pArithmeticExpression = new ArithmeticExpressionElements());
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}

	//ComparisonExpression returns expressions::Expression:
	//	LogicalExpression (({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingOperator)
	//	rightExpression=LogicalExpression)*;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//LogicalExpression returns expressions::Expression:
	//	(UnaryExpression | AttributeExpression) (({commonExpressions::LogicalExpression.leftExpression=current}
	//	operator=LogicOperator) rightExpression=(UnaryExpression | AttributeExpression))*;
	public LogicalExpressionElements getLogicalExpressionAccess() {
		return (pLogicalExpression != null) ? pLogicalExpression : (pLogicalExpression = new LogicalExpressionElements());
	}
	
	public ParserRule getLogicalExpressionRule() {
		return getLogicalExpressionAccess().getRule();
	}

	//UnaryExpression returns expressions::Expression:
	//	{commonExpressions::UnaryExpression} operator=UnaryOperator enclosedExpression=AttributeExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//AttributeExpression returns expressions::Expression:
	//	OperationCall | {actionLanguage::AttributeExpression} attribute=[core::Attribute] ("[" indices+=Expression "]")*;
	public AttributeExpressionElements getAttributeExpressionAccess() {
		return (pAttributeExpression != null) ? pAttributeExpression : (pAttributeExpression = new AttributeExpressionElements());
	}
	
	public ParserRule getAttributeExpressionRule() {
		return getAttributeExpressionAccess().getRule();
	}

	//AttributeLeafExpression returns actionLanguage::AttributeExpression:
	//	{actionLanguage::AttributeExpression} attribute=[core::Attribute] ("[" indices+=Expression "]")*;
	public AttributeLeafExpressionElements getAttributeLeafExpressionAccess() {
		return (pAttributeLeafExpression != null) ? pAttributeLeafExpression : (pAttributeLeafExpression = new AttributeLeafExpressionElements());
	}
	
	public ParserRule getAttributeLeafExpressionRule() {
		return getAttributeLeafExpressionAccess().getRule();
	}

	//OperationCall returns expressions::Expression:
	//	LiteralExpression | {actionLanguage::OperationCall} (operation=[core::Operation] "("
	//	parameterBinding+=ParamaterBinding? ("," parameterBinding+=ParamaterBinding)* ")");
	public OperationCallElements getOperationCallAccess() {
		return (pOperationCall != null) ? pOperationCall : (pOperationCall = new OperationCallElements());
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}

	//ParamaterBinding returns core::ParameterBinding:
	//	{core::ParameterBinding} parameter=[core::Parameter] ":=" value=Expression;
	public ParamaterBindingElements getParamaterBindingAccess() {
		return (pParamaterBinding != null) ? pParamaterBinding : (pParamaterBinding = new ParamaterBindingElements());
	}
	
	public ParserRule getParamaterBindingRule() {
		return getParamaterBindingAccess().getRule();
	}

	//LiteralExpression returns expressions::Expression:
	//	"(" Expression ")" | {commonExpressions::LiteralExpression} value=IdentifierOrValue;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return (pLiteralExpression != null) ? pLiteralExpression : (pLiteralExpression = new LiteralExpressionElements());
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//IdentifierOrValue returns ecore::EString:
	//	NUMBER | BOOLEAN | INT;
	public IdentifierOrValueElements getIdentifierOrValueAccess() {
		return (pIdentifierOrValue != null) ? pIdentifierOrValue : (pIdentifierOrValue = new IdentifierOrValueElements());
	}
	
	public ParserRule getIdentifierOrValueRule() {
		return getIdentifierOrValueAccess().getRule();
	}

	//enum AssignOperator returns actionLanguage::AssignOperator:
	//	ASSIGN=":=" | PLUS_EQUAL="+=" | EQUAL_PLUS="=+" | MINUS_EQUAL="-=" | EQUAL_MINUS="=-";
	public AssignOperatorElements getAssignOperatorAccess() {
		return (unknownRuleAssignOperator != null) ? unknownRuleAssignOperator : (unknownRuleAssignOperator = new AssignOperatorElements());
	}
	
	public EnumRule getAssignOperatorRule() {
		return getAssignOperatorAccess().getRule();
	}

	//enum IncrementDecrementOperator returns actionLanguage::IncrementDecrementOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public IncrementDecrementOperatorElements getIncrementDecrementOperatorAccess() {
		return (unknownRuleIncrementDecrementOperator != null) ? unknownRuleIncrementDecrementOperator : (unknownRuleIncrementDecrementOperator = new IncrementDecrementOperatorElements());
	}
	
	public EnumRule getIncrementDecrementOperatorRule() {
		return getIncrementDecrementOperatorAccess().getRule();
	}

	//enum LogicOperator returns commonExpressions::LogicOperator:
	//	AND="&" | OR="|" | XOR="xor" | IMPLY="=>" | EQUIVALENT="<=>";
	public LogicOperatorElements getLogicOperatorAccess() {
		return (unknownRuleLogicOperator != null) ? unknownRuleLogicOperator : (unknownRuleLogicOperator = new LogicOperatorElements());
	}
	
	public EnumRule getLogicOperatorRule() {
		return getLogicOperatorAccess().getRule();
	}

	//enum ArithmeticOperator returns commonExpressions::ArithmeticOperator:
	//	PLUS="+" | MINUS="-" | TIMES="*" | DIVIDE="/" | MODULO="%";
	public ArithmeticOperatorElements getArithmeticOperatorAccess() {
		return (unknownRuleArithmeticOperator != null) ? unknownRuleArithmeticOperator : (unknownRuleArithmeticOperator = new ArithmeticOperatorElements());
	}
	
	public EnumRule getArithmeticOperatorRule() {
		return getArithmeticOperatorAccess().getRule();
	}

	//enum ComparingOperator returns commonExpressions::ComparingOperator:
	//	LESS="<" | LESS_OR_EQUAL="<=" | EQUAL="==" | GREATER_OR_EQUAL=">=" | GREATER=">" | UNEQUAL="<>";
	public ComparingOperatorElements getComparingOperatorAccess() {
		return (unknownRuleComparingOperator != null) ? unknownRuleComparingOperator : (unknownRuleComparingOperator = new ComparingOperatorElements());
	}
	
	public EnumRule getComparingOperatorRule() {
		return getComparingOperatorAccess().getRule();
	}

	//enum UnaryOperator returns commonExpressions::UnaryOperator:
	//	NOT="not" | MINUS="-" | PLUS="+";
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return (unknownRuleUnaryOperator != null) ? unknownRuleUnaryOperator : (unknownRuleUnaryOperator = new UnaryOperatorElements());
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}

	//terminal NUMBER returns ecore::EBigDecimal:
	//	INT "." INT;
	public TerminalRule getNUMBERRule() {
		return (tNUMBER != null) ? tNUMBER : (tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER"));
	} 

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
