[module state('http://www.fujaba.de/muml/realtimestatechart/0.4.0')/]

[import de::uni_paderborn::fujaba::modelica::m2t::rtsc::actionlanguage::expression]
[import de::uni_paderborn::fujaba::modelica::m2t::rtsc::util::pkg]

[import de::uni_paderborn::fujaba::modelica::m2t::rtsc::state::queries]
[import de::uni_paderborn::fujaba::modelica::m2t::rtsc::util::query::naming]
[import de::uni_paderborn::fujaba::modelica::m2t::rtsc::util::query::rtsc]

[**
 * Create declarations for the states
 * @param vertexSet set of vertices/states
*/]
[template public createStateDeclarations(rtsc : RealtimeStatechart)]
	// step declarations
[for (state : State | rtsc.states->sortedBy(name))]
[createStateDeclaration(state)/]
[/for]
	// end step declarations
[/template]

[**
 * Create flat state declaration
 * @param state the state which is declared
*/]
[template public createStateDeclaration(state : State) ? (state.embeddedRegions->isEmpty())]
	RealTimeCoordinationLibrary.Step [state.name/](
		nIn=[state.getnInValue()/],
		[if state.initial and not state.parentStatechart.embedded]
		initialStep=true,
		[/if]
		[if state.invariants->notEmpty()]
		use_activePort=true,
		[/if]
		nOut=[state.outgoingTransitions->size()/])
		[state.createStateDeclAnnotation()/];
[createStateExitMarker(state)/]
[createStateInvariantDeclarations(state)/]
[/template]

[**
 * Create parallel state declaration
 * @param state the state which is declared (which contains regions)
*/]
[template public createStateDeclaration(state : State) ? (state.embeddedRegions->notEmpty())]
	[state.getComplexStateModelName()/].[state.getComplexStateModelName()/] [state.name/](
		nIn=[state.getnInValue()/],
		[comment for now hardcode use_outPort=false /]
		use_outPort=false,
		nSuspend=[state.outgoingTransitions->size()/][if state.initial and not state.parentStatechart.embedded],
		initialStep=true
		[/if])
		[state.createStateDeclAnnotation()/];
	[createStateExitMarker(state)/]
[/template]

[**
 * Create delegation state which is needed for entry points.
 * @param rtsc the region statechart
*/]
[template public createDelegationStateDeclaration(rtsc : RealtimeStatechart) ? (
	rtsc.isEnterable()
)
{
	nOut : Integer = rtsc.getEntryPoints()->size() + if rtsc.getRelevantEntryPointTransitions()->collect(target)->includes(rtsc.getInitialState()) then 0 else 1 endif;
}]
	RealTimeCoordinationLibrary.Step [rtsc.getEntryPointDelegationStateName()/](
		nIn=1,
		nOut=[nOut/]);
[/template]

[**
 * Create state exit marker declaration.
 * @param state the state
*/]
[template private createStateExitMarker(state : State) ? (
	not state.exitEvent.oclIsUndefined() and state.exitEvent.clockResets->notEmpty()
)]
Modelica.Blocks.Logical.Not [state.getExitMarkerName()/];
[/template] 

[**
 * Create the invariant declarations for this state.
 * @param state the state
*/]
[template private createStateInvariantDeclarations(state : State) ? (state.invariants->notEmpty())]
[for (clockConstraint : ClockConstraint | state.invariants)]
[createStateInvariantDeclaration(state, clockConstraint)/]
[/for]
[/template]

[**
 * Create a state invariant declaration.
 * @param state the state
 * @param clockConstraint the clock constraint
*/]
[template private createStateInvariantDeclaration(state : State, clockConstraint : ClockConstraint)]
	[clockConstraint.getInvariantModelName()/] [state.getInvariantName(clockConstraint)/](bound=[clockConstraint.bound.value/]);
[/template]

[**
 * Generates a state model for a complex state
 * @param state the complex state
 * @param parentPackage the name of the parent package
*/]
[template public generateComplexState(state : State, parentPackage : String)]
[createPackage(state.getComplexStateModelName(), parentPackage)/]
[file (state.getPath(parentPackage), false, 'UTF-8')]
[within(state.getComplexStateModelName(), parentPackage)/]
model [state.getComplexStateModelName() /] extends Modelica_StateGraph2.PartialParallel(nEntry=[state.embeddedRegions->size() /]);
	// no annotations will be generated for complex states
[createRegionDeclarations(state) /]
[createEntryPointInputDeclarations(state->asSet())/]
	equation
		// connect to the initial states of the region statecharts
	[for (region : Region | state.embeddedRegions->sortedBy(priority))]
		connect(entry['[' + (state.embeddedRegions->size() - region.priority + 1) + ']' /],
				[region.getRegionRealtimeStatechartName() /].inPort['[1]' /]);
	[/for]
		// end connect to the initial states of the region statecharts
		// connect entry point ports with the corresponding entry point ports of the regions
	[for (entryPoint : EntryPoint | state.getEntryPoints())]
		[for (region : Region | state.embeddedRegions->sortedBy(priority))]
		connect([entryPoint.name/],
				[region.getRegionRealtimeStatechartName()/].[entryPoint.name/]);
		[/for]
	[/for]
		// end connect entry point ports with the corresponding entry point ports of the regions
end [state.getComplexStateModelName() /];
[/file]
[/template]

[**
 * Create region declarations
 * @param state the complex state
*/]
[template public createRegionDeclarations(state : State)]
	// region declarations
[for (region : Region | state.embeddedRegions)]
	[comment for now hardcode use_outPort=false /]
	[region.embeddedStatechart.name.toUpperFirst() /].[region.embeddedStatechart.name.toUpperFirst() /] [region.getRegionRealtimeStatechartName() /](nIn=1, use_outPort=false);
[/for]
	// end region declarations
[/template]

[**
 * Create the corresponding input port declarations for entry points.
 * @param state the state
*/]
[template public createEntryPointInputDeclarations(stateSet : Set(State))]
	// entry point input declarations
[for (state : State | stateSet)]
[for (entryPoint : EntryPoint | state.getEntryPoints())]
	Modelica.Blocks.Interfaces.BooleanInput [entryPoint.name/];
[/for]
[/for]
	// end entry point input declarations
[/template]

[**
 * Connect initial step with entry (region statechart)
 * @param rtsc the region statechart
*/]
[template public connectInitialStep(rtsc : RealtimeStatechart) ? (
	not rtsc.isEnterable()
)
{
	initial : State = rtsc.getInitialState();
}]
	// connect initial step
	connect(entry['[1]'/], [initial.name/].inPort['[' + (initial.incomingTransitions->size() + 1) + ']' /]);
	// end connect initial step
[/template]

[**
 * Connect initial step with entry (region statechart)
 * @param rtsc the region statechart
*/]
[template public connectInitialStep(rtsc : RealtimeStatechart) ? (
	rtsc.isEnterable()
)
{
	delegationName : String = rtsc.getEntryPointDelegationStateName();
}]
	// connect initial step
	connect(entry['[1]'/], [delegationName/].inPort['[1]' /]);
	// end connect initial step
[/template]

[**
 * Connect state invariants.
 * @param rtsc the realtimestatechart
*/]
[template public createStateInvariants(stateSet : Set(State))]
	// connect state invariants
[for (state : State | stateSet->select(invariants->notEmpty()))]
[for (clockConstraint : ClockConstraint | state.invariants)]
	connect([state.name/].activePort,
		[state.getInvariantName(clockConstraint)/].conditionPort);
	connect([clockConstraint.clock.name/].y,
		[state.getInvariantName(clockConstraint)/].clockValue);
[/for]
[/for]
	// end connect state invariants
[/template]

[**
 * Generates entry actions for all states in the rtsc and
 * the states in the sub realtimestatecharts.
 * @param rtsc the (component) realtimestatechart
*/]
[template public generateEntryActions(rtsc : RealtimeStatechart) {
	stateSet : Set(State) = rtsc.allSubstatecharts()->prepend(rtsc)->collect(
		states->select(not entryEvent.oclIsUndefined() and not entryEvent.action.oclIsUndefined())
	)->asOrderedSet();
}]
	// state entry actions
[for (state : State | stateSet)]
	[let subrtsc : RealtimeStatechart = state.parentStatechart]
	[comment generate first expression for now /]
	when [state.getFullyQualifiedName() /].active then
		[generateExpression(state.entryEvent.action.expressions->at(1), false, subrtsc.getFullyQualifiedName() ) /]
	end when;
	[/let]
[/for]
	// end state entry actions
[/template]

[**
 * Generates exit actions for all states in the rtsc and
 * the states in the sub realtimestatecharts.rtscSet : OrderedSet(OrderedSet(RealtimeStatechart)) = rtsc.allSubstatechartsPostOrder()->append(OrderedSet{rtsc});
 * @param rtsc the (component) realtimestatechart
*/]
[template public generateExitActions(rtsc : RealtimeStatechart) {
	rtscSet : OrderedSet(OrderedSet(RealtimeStatechart)) = rtsc.allSubstatechartsPostOrder()->append(OrderedSet{rtsc});
}]
	// state exit actions
[for (level : OrderedSet(RealtimeStatechart) | rtscSet)]
[for (r : RealtimeStatechart | level)]
[for (state : State | r.states->select(not exitEvent.oclIsUndefined() and not exitEvent.action.oclIsUndefined()))]
	[comment use ExitMarker.y here/]
	when not [state.getFullyQualifiedName() /].active and pre([state.getFullyQualifiedName() /].active) then
		[generateExpression(state.exitEvent.action.expressions->at(1), false, r.getFullyQualifiedName() ) /]
	end when;
[/for] 
[/for]
[/for]
	// end state exit actions
[/template]

[**
 * Creates variable declarations for do events.
 * @param rtsc the (root) rtsc
*/]
[template public createDoEventVariableDeclarations(rtsc : RealtimeStatechart) {
	rtscSet : OrderedSet(RealtimeStatechart) = rtsc.allSubstatecharts()->append(rtsc);
}]
	// variable declarations for do events
[for (doEvent : DoEvent | rtscSet->collect(states)->select(not doEvent.oclIsUndefined())->collect(doEvent))]
	Real [doEvent.getVariableName(rtsc)/](start=[0/]);
[/for]
	// end variable declarations for do events
[/template]

[**
 * Generates do event actions.
 * @param rtsc the rtsc
*/]
[template public generateDoEventActions(rtsc : RealtimeStatechart) {
	rtscSet : OrderedSet(RealtimeStatechart) = rtsc.allSubstatecharts()->append(rtsc);
}]
	// do event actions
[for (state : State | rtscSet->collect(states)->select(not doEvent.oclIsUndefined()))]
	[let doEvent : DoEvent = state.doEvent]
	when [state.getFullyQualifiedName()/].active then
		[doEvent.getVariableName(rtsc)/] := time;
	end when;
	if [state.getFullyQualifiedName()/].active and [doEvent.getVariableName(rtsc)/] <= time and time <= [doEvent.getVariableName(rtsc)/] + [doEvent.period.value/] then
		[generateExpression(doEvent.action.expressions->at(1), false, state.parentStatechart.getFullyQualifiedName())/]
		[doEvent.getVariableName(rtsc)/] := [doEvent.getVariableName(rtsc)/] + [doEvent.period.value/];
	end if;
	[/let]
[/for]
	// end do event actions
[/template]