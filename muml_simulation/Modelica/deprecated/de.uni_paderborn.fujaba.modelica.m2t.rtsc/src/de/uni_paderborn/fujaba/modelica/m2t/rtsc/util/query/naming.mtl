[module naming('http://www.fujaba.de/muml/behavior/0.4.0',
				'http://www.storydriven.org/core/0.3.1',
				'http://www.fujaba.de/muml/actionlanguage/0.4.0',
				'http://www.fujaba.de/muml/msgtype/0.4.0',
				'http://www.fujaba.de/muml/types/0.4.0',
				'http://www.fujaba.de/muml/component/0.4.0',
				'http://www.fujaba.de/muml/instance/0.4.0',
				'http://www.fujaba.de/muml/modelica/adapter/transform/0.4.0',
				'http://www.fujaba.de/muml/realtimestatechart/0.4.0')/]

[import de::uni_paderborn::fujaba::modelica::m2t::rtsc::util::query::rtsc]

[**
 * Returns the relatively qualified name of the statechart rtsc. The
 * name is relative to the passed ref statechart. If rtsc = ref then
 * the empty string is returned
 * @param rtsc the realtimestatechart
 * @param ref the reference statechart (in case of null the fully qualified name is returned)
*/]
[query public getRelativelyQualifiedName(rtsc : RealtimeStatechart, ref : RealtimeStatechart) : String =
	if rtsc.embedded and rtsc <> ref then
		let name : String = rtsc.parentRegion.parentState.parentStatechart.getRelativelyQualifiedName(ref)
		in 
		if name <> '' then
			name + '.'
		else
			''
		endif + rtsc.parentRegion.parentState.name + '.' + rtsc.parentRegion.getRegionRealtimeStatechartName()
	else
		''
	endif
/]

[**
 * Returns the fully qualified name of the statechart rtsc. If the statechart
 * rtsc is not embedded the empty string is returned.
 * @param rtsc the realtimestatechart
*/]
[query public getFullyQualifiedName(rtsc : RealtimeStatechart) : String =
	rtsc.getRelativelyQualifiedName(null)
/]

[**
 * Returns the name for a region's statechart
 * @param region the region
*/]
[query public getRegionRealtimeStatechartName(region : Region) : String =
	'region_' + region.priority + '_' + region.embeddedStatechart.name
/]

[**
 * Calculates and returns the transition's name.
 * @param transition the transition
*/]
[query public getName(transition : Transition) : String =
	'transition_' + 
	if transition.source.oclIsKindOf(EntryPoint) then
		transition.statechart.getEntryPointDelegationStateName() + '_'
	else
		transition.source.name + '_'
	endif
	+
	if transition.target.oclIsKindOf(EntryPoint) then
		transition.target.oclAsType(EntryPoint).state.name
	else
		transition.target.name
	endif
/]

[**
 * Returns the fully qualified transition name. If the transition belongs
 * to the root statechart the plain transition name is returned.
 * @param transition the transition
*/]
[query public getFullyQualifiedName(transition : Transition) : String =
	if transition.statechart.embedded then
		transition.statechart.getFullyQualifiedName() + '.' + transition.getName()
	else
		transition.getName()
	endif
/]

[**
 * Returns the fully qualified state name. If the state's statechart
 * is not embedded the plain state name is returned.
 * @param state the state
*/]
[query public getFullyQualifiedName(state : realtimestatechart::State) : String =
	if state.parentStatechart.embedded then
		state.parentStatechart.getFullyQualifiedName() + '.' + state.name
	else
		state.name
	endif
/]

[**
 * Returns the name of the state's exit marker.
 * @param state the state
*/]
[query public getExitMarkerName(state : realtimestatechart::State) : String =
	state.name + 'ExitMarker'
/]

[**
 * Returns the fully qualified name of the state's exit marker. If
 * the state's statechart is not embedded the plain state's exit marker
 * name is returned.
 * @param state the sate
*/]
[query public getFullyQualifiedExitMarkerName(state : realtimestatechart::State) : String =
	if state.parentStatechart.embedded then
		state.parentStatechart.getFullyQualifiedName() + '.' + state.getExitMarkerName()
	else
		state.getExitMarkerName()
	endif
/]

[**
 * Returns the name of a entry point's delegation
 * state.
*/]
[query public getEntryPointDelegationStateName(rtsc : RealtimeStatechart) : String =
	getUniqueNameRec('DelegationState', 'suf', rtsc.states->collect(name)->asSet())
/]

[**
 * Returns an unique name (unique with respect to the names specified by
 * the names set).
 * @param name the desired name
 * @param suffix the suffix which is concated to name if name is not unique
 * @param names set of already used names
*/]
[query public getUniqueNameRec(name : String, suffix : String, names : Set(String)) : String =
	if names->includes(name) then
		getUniqueNameRec(name + suffix, suffix, names)
	else
		name
	endif
 /]

[**
 * Get the name of a trigger message event's mailbox
 * @param ev the AsynchronousMessageEvent
*/]
[query public getMailboxName(messageType : MessageType) : String =
	'mailbox_' + messageType.getName()
/]

[**
 * Returns the messageType's name (whitespaces are replaced with underscores).
*/]
[query public getName(messageType : MessageType) : String =
	messageType.name.replace(' ', '_')
/]

[**
 * Get the name of a trigger message event's parameter variable.
 * @param param the parameter
 * @param messageType the message type which belongs to the trigger message event
*/]
[query public getTriggerMessageEventParameterVariableName(param : Parameter, messageType : MessageType) : String =
	messageType.getMailboxName() + '_' + param.name
/]