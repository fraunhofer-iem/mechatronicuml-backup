[comment encoding = UTF-8 /]
[module generate_Utilities('http://www.fujaba.de/muml/model/instance/0.2.2',
						   'http://www.fujaba.de/muml/model/realtimestatechart/0.2.3',
						   'http://www.fujaba.de/muml/model/core/0.2.4',
						   'http://www.storydriven.org/core/0.2.0', 
						   'http://www.storydriven.org/core/expressions/0.2.0',
						   'http://www.eclipse.org/emf/2002/Ecore',
						   'http://www.fujaba.de/muml/model/component/0.2.3',
						   'http://www.fujaba.de/muml/model/msgiface/0.2.2')/]
[import de::uni_paderborn::fujaba::muml::model::gen::modelica::files::transform_Variable/]
[import de::uni_paderborn::fujaba::muml::model::gen::modelica::common::queries /]


[**
 * 
 * @param traceabilityContext 
 */]
[template public generate_Utilities(traceabilityContext : OclAny)]
[generate_PortInterfaces()/]
[generate_Transitions()/]
[generate_PartialParallel()/]
[generate_PartialParallelBase()/]
[generate_Semaphore()/]
[/template]

[**
 * 
 * @param traceabilityContext 
 */]
[template private generate_PortInterfaces(traceabilityContext : OclAny)]
package PortInterfaces
  connector port
       Boolean fire;
       replaceable MessageInterfaces.Messages.Message  message;
  end port;

  connector input_port
       extends port;
       output Boolean hasMessage;
       input Boolean active;
  end input_port;

  connector output_port
       extends port;
       input Boolean hasMessage;
       output Boolean active;
  end output_port;
end PortInterfaces;
[/template]

[**
 * 
 * @param traceabilityContext 
 */]
[template private generate_PartialParallel(traceabilityContext : OclAny)]
partial model PartialParallel
  "Partial compont to construct a parallel submodel via inheritance"
  extends PartialParallelBase(
    use_inPort=true,
    use_outPort=true,
    use_suspend=true);

  Modelica_StateGraph2.Internal.Interfaces.Step_in inPort['['/]nIn[']'/] if use_inPort 
    "If enabled, port for one or more input transitions"annotation (Placement(iconTransformation(extent={{-40,191},
            {40,209}})));
  Modelica_StateGraph2.Internal.Interfaces.Step_out outPort['['/]nOut[']'/] if use_outPort 
    "If enabled, port for one or more output transitions"   annotation (Placement(iconTransformation(extent={{-39,
            -214},{41,-200}})));
  Modelica_StateGraph2.Internal.Interfaces.Composite_resume resume['['/]nResume[']'/] if 
    use_suspend "If enabled, port for zero, one or more resume transitions"                                                       annotation (Placement(iconTransformation(
        extent={{-208,-160},{-193,-80}})));
  Modelica_StateGraph2.Internal.Interfaces.Composite_suspend suspend['['/]nSuspend[']'/] if 
       use_suspend "If enabled, port for zero, one or more suspend transitions"
                                                                                                        annotation (Placement(iconTransformation(
        extent={{-216,160},{-200,80}})));

  Modelica.Blocks.Interfaces.BooleanOutput activePort = active if use_activePort 
    "= true if Parallel component is active, otherwise it is not active"
    annotation (Placement(iconTransformation(extent={{200,-11},{220,9}})));

protected 
  Modelica_StateGraph2.Internal.Interfaces.EntryPort entry['['/]nEntry[']'/] 
    "Entry port for one or more branches (Step or Parallel components must be connected to this port)"
    annotation (Placement(transformation(extent={{-60,95},{60,105}})));
  Modelica_StateGraph2.Internal.Interfaces.ExitPort exit['['/]nExit[']'/] if use_outPort 
    "If enabled, synchronization port for one or more branches (Step or Parallel components must be connected to this port)"
    annotation (Placement(transformation(extent={{-60,-110},{60,-100}})));
equation 
  // Handle conditional connectors
  connect(inPort,  local_inPort);
  connect(outPort, local_outPort);
  connect(suspend, local_suspend);
  connect(resume,  local_resume);
  connect(entry, local_entry);
  if use_outPort then
     connect(exit, local_exit);
  end if;
  annotation (defaultComponentName="step1",Diagram(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}},
        grid={1,1}), graphics),
                      Icon(coordinateSystem(
        preserveAspectRatio=false,
        extent={{-200,-200},{200,200}},
        grid={2,2}), graphics={
        Rectangle(
          extent={{-200,200},{200,-200}},
          lineColor={95,95,95},
          fillColor=DynamicSelect({255,255,255}, if active > 0.5 then {0,255,0}
               else {255,255,255}),
          fillPattern=FillPattern.Solid,
          radius=40,
          lineThickness=0.5),
        Text(
          extent={{54,231},{400,210}},
          lineColor={0,0,255},
          fillPattern=FillPattern.Solid,
          textString="%name"),
        Text(
          visible=use_suspend,
          extent={{-36,11},{122,-3}},
          lineColor={0,0,0},
          fillPattern=FillPattern.Solid,
          textString="suspend",
          origin={-179,160},
          rotation=270),
        Text(
          visible=use_suspend,
          extent={{-110,9},{42,-5}},
          lineColor={0,0,0},
          fillPattern=FillPattern.Solid,
          origin={-173,-154},
          rotation=270,
          textString="resume"),
        Ellipse(
          visible=initialStep,
          extent={{-224,248},{-208,232}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid),
        Polygon(
          visible=initialStep,
          points={{-170,200},{-172,224},{-186,216},{-170,200}},
          lineColor={0,0,0},
          smooth=Smooth.None,
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid),
        Line(
          visible=initialStep,
          points={{-216,240},{-186,232},{-170,200}},
          color={0,0,0},
          smooth=Smooth.Bezier)}),
    Documentation(info="<html>
<p>
This is a variant of the
<a href=\"modelica://Modelica_StateGraph2.Parallel\">Parallel</a>
component. The essential difference is that this
is a \"partial\" model. It is therefore not allowed to drag it. The only purpose of this
model is to inherit from it in order to construct a new model that is a special
Parallel component.
</p>

<p>
The Figure below shows a component (&quot;s2&quot;) built from a PartialParallel component. As the diagram and the icon layer of the PartialParallel component does not need to be the same size, the user can benefit from collecting large subsystems in smaller closed Parallel components to improve overview and modularization of the full system.
</p>

<blockquote>
<img src=\"../Images/StateGraph/Elements/PartialParallel.png\">
</blockquote>


</html>"));
end PartialParallel;

	
[/template]

[**
 * 
 * @param traceabilityContext 
 */]
[template private generate_PartialParallelBase(traceabilityContext : OclAny)]
	partial block PartialParallelBase 
  "Base class of a parallel component (including a composite step as special case)"

  parameter Integer nIn(min=0)=0 "Number of input connections"    annotation(Dialog(connectorSizing=true), HideResult=true);
  parameter Integer nOut(min=0)=0 "Number of output connections"   annotation(Dialog(connectorSizing=true), HideResult=true);
  parameter Integer nSuspend(min=0)=0 "Number of suspend ports"
                                                              annotation(Dialog(connectorSizing=true), HideResult=true);
  parameter Integer nResume(min=0)=0 "Number of resume ports"annotation(Dialog(connectorSizing=true), HideResult=true);
  parameter Integer nEntry(min=0)=0 "Number of entry branches"
      annotation(Dialog(connectorSizing=true), HideResult=true);
  parameter Integer nExit(min=0)=0 "Number of exit branches"
      annotation(Dialog(connectorSizing=true), HideResult=true);

  parameter Boolean initialStep=false 
    "=true, if initial step (start state machine at entry ports of Parallel)"
        annotation (Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  parameter Boolean use_inPort = true "=true, if inPort enabled"
        annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Boolean use_outPort = false "=true, if outPort enabled"
        annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Boolean use_suspend = false 
    "=true, if suspend and resume ports enabled"
        annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Boolean use_activePort = false "=true, if activePort enabled"
        annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Integer nd = 1;
  output Boolean active(final start=initialStep, fixed=true) 
    "= true if composite/parallel step is active, otherwise it is not active";
protected 
  parameter Integer nExit2 = if use_outPort then nExit else 0;
  parameter Integer nMinBranches = min(nEntry, nExit);
  Modelica_StateGraph2.Internal.Interfaces.Node node 
    "Node of Parallel component to handle rootIDs from inPort to outPort transitions";

  Boolean newActive(start=initialStep, fixed=true) 
    "Value of active in the next iteration";
  Boolean finished(start=not initialStep, fixed=true);

  Boolean inport_fire(start=false, fixed=true) "One of the inports fires";
  Boolean outport_fire "One of the outports fires";
  Boolean suspend_fire(start=false, fixed=true) 
    "One of the suspend ports fires";
  Boolean resume_fire "One of the resume ports fires";
  Boolean entry_fire(start=false, fixed=true) "One of the entry ports fires";
  Boolean startTransition(start=true, fixed=true) 
    "Initialize entry port for autonomous step";
  Boolean checkOneDelayedTransitionPerLoopIn;
  Integer firstActive(start=0, fixed=true) 
    "= 1, if step becomes the first time active, for future activations, its value is 2. Is used to correctly initialize if nIn=0 and nResume>0";
  Integer entryIndices['['/]nEntry[']'/] "exit['['/]i[']'/] belongs to entry['['/]rootIndices['['/]i[']'/][']'/]" annotation(Evaluate=true);
  Boolean entry_restart['['/]nEntry[']'/] 
    "elements corresponding to the entry array deciding whether or not they should be restarted upon resume when finished (information is collected from ";

  // Local connectors of conditional connectors
  Modelica_StateGraph2.Internal.Interfaces.Step_in local_inPort['['/]nIn[']'/];
  Modelica_StateGraph2.Internal.Interfaces.Step_out local_outPort['['/]nOut[']'/];
  Modelica_StateGraph2.Internal.Interfaces.Composite_suspend local_suspend['['/]nSuspend[']'/];
  Modelica_StateGraph2.Internal.Interfaces.Composite_resume local_resume['['/]nResume[']'/];
  Modelica_StateGraph2.Internal.Interfaces.EntryPort local_entry['['/]nEntry[']'/];
  Modelica_StateGraph2.Internal.Interfaces.ExitPort local_exit['['/]nExit2[']'/];

   Boolean oldActive(start=initialStep, fixed=true) 
    "Value of active when CompositeStep was aborted";
equation 
  if use_outPort then
     assert(nEntry >= nExit,
            "The number of entry branches is not greater or equal to the number of exit branches of a parallel step.");
     assert(nExit > 0, "Since outPort is enabled, there must be at least one connection to the exit port");
  end if;

  assert(nIn==0 and nResume==0 and initialStep or nIn > 0 or nResume > 0,
        "Parallel has neither an inPort, a resume port nor is set to be an initial step.\n" +
        "One of these must be true in order to initialize correctly");

  when {outport_fire, pre(entry_fire)} then
     finished = outport_fire;
  end when;

  when node.suspend then
    oldActive = active;
  end when;

  // Set active state
   if initialStep then
     startTransition = pre(startTransition) and not pre(inport_fire);
     inport_fire     = pre(startTransition) or Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                                                        local_inPort.fire);
  else
     startTransition = false;
     inport_fire     = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                                local_inPort.fire) or (pre(newActive) and pre(node.resume));
  end if;

  outport_fire = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_outPort.fire);
  suspend_fire = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_inPort.node.suspend) or 
                Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_resume.node.suspend) or 
                 Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_suspend.fire);

  resume_fire  = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_inPort.node.resume) or 
                 Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_resume.node.resume) or 
                 Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_resume.fire);

  entry_fire   = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_entry.fire);
  active       = pre(newActive);
  newActive    = if Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                             local_inPort.node.resume) then oldActive else inport_fire or Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                                                                              local_resume.fire) or active and not outport_fire and not suspend_fire;

  for i in 1:nMinBranches loop
    entry_restart['['/]entryIndices['['/]i[']'/][']'/] = true;
  end for;
  for i in nMinBranches+1:nEntry loop
    entry_restart['['/]entryIndices['['/]i[']'/][']'/] = if nExit == 0 then true else false;
  end for;

  // Propagate flags between the connectors
// if initialStep or nIn  == 0 and nResume > 0 then
   if initialStep or nResume > 0 then
     //firstActive = if active and pre(firstActive) <= 1 then pre(firstActive) + 1 else
        firstActive = if (active and not suspend_fire) and pre(firstActive) <= 1 then pre(firstActive) + 1 else 
                   if resume_fire and finished then 0 else pre(firstActive);
     if firstActive == 1 then
//      local_entry.fire = fill(true, nEntry);
        local_entry.fire = entry_restart;
     else
       local_entry.fire = fill(inport_fire,  nEntry);
     end if;
  else
     firstActive = 0;
     local_entry.fire = fill(inport_fire, nEntry);
  end if;
  local_exit.fire  = fill(outport_fire, nExit2);

  for i in 1:nOut loop
     local_outPort['['/]i[']'/].available = if i == 1 then 
                                    active and 
                                    Modelica_StateGraph2.Blocks.BooleanFunctions.allTrue(
                                                             local_exit.available) else 
                                    local_outPort['['/]i-1[']'/].available and not local_outPort['['/]i-1[']'/].fire;
  end for;

  for i in 1:nSuspend loop
     local_suspend['['/]i[']'/].available = if i == 1 then active and not pre(suspend_fire) else 
                                     local_suspend['['/]i-1[']'/].available and not 
                                     local_suspend['['/]i-1[']'/].fire;
  end for;

  // Check unary connections
  local_inPort.checkUnaryConnection = fill(true, nIn);
  local_resume.checkUnaryConnection = fill(true, nResume);

  // Check Modelica_StateGraph2 structure
  Connections.uniqueRoot(local_entry.node, "
The StateGraph has a wrong connection structure. Reasons:
(1) The StateGraph is initialized at two different locations (initial steps or entry ports).
(2) A transition is made wrongly out of a Parallel component.
(3) A transition is made between two branches of a Parallel component.
All these cases are not allowed.
");

   entryIndices = Connections.uniqueRootIndices(local_entry.node, local_exit.node, "
 The connection structure in a Parallel component is not correct:
 There must be exactly one unique path from every exit port to every entry port.
 This is not the case here.
 ");

  for i in 1:nEntry loop
     local_entry['['/]i[']'/].node.suspend = active and suspend_fire or not active and pre(active);
//   local_entry['['/]i[']'/].node.suspend = suspend_fire;
//     local_entry['['/]i[']'/].node.resume  = resume_fire and not entry_fire;
     local_entry['['/]i[']'/].node.resume  = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                         local_resume.node.resume) or 
                 Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(
                                          local_resume.fire); // and not entry_fire;
//   local_entry['['/]i[']'/].node.resume  = resume_fire;
  end for;

  if initialStep then
    Connections.uniqueRoot(node, "uniqueRoot Error in Parallel");
    node.resume = false;
    node.suspend = false;
  else
     // In order that check works (nIn=0), provide the missing equations
     if nIn==0 and nResume==0 then
        node.resume  = false;
        node.suspend = false;
     end if;
  end if;

  for i in 1:nIn loop
     Connections.branch(local_inPort['['/]i[']'/].node, node);
     local_inPort['['/]i[']'/].node = node;
  end for;

  for i in 1:nResume loop
     Connections.branch(local_resume['['/]i[']'/].node, node);
     local_resume['['/]i[']'/].node = node;
  end for;

  for i in 1:nOut loop
     Connections.branch(node, local_outPort['['/]i[']'/].node);
     local_outPort['['/]i[']'/].node = node;
  end for;

  for i in 1:nSuspend loop
     Connections.branch(node, local_suspend['['/]i[']'/].node);
     local_suspend['['/]i[']'/].node = node;
  end for;

  // Check loops of Modelica_StateGraph2
  if initialStep then
    checkOneDelayedTransitionPerLoopIn =
      Modelica_StateGraph2.Internal.Utilities.initializeLoopCheck();
  else
    checkOneDelayedTransitionPerLoopIn =
      Modelica_StateGraph2.Internal.Utilities.propagateLoopCheck(local_inPort.checkOneDelayedTransitionPerLoop)
       and Modelica_StateGraph2.Internal.Utilities.propagateLoopCheck(
      local_resume.checkOneDelayedTransitionPerLoop);
  end if;

  local_suspend.checkOneDelayedTransitionPerLoop = fill(checkOneDelayedTransitionPerLoopIn, nSuspend);

  if nOut == 0 or nEntry == 0 then
     // no outPort connector or no branches
     local_entry.checkOneDelayedTransitionPerLoop   = fill(checkOneDelayedTransitionPerLoopIn, nEntry);
     local_outPort.checkOneDelayedTransitionPerLoop = fill(true, nOut);
  else
//   local_entry['['/]1[']'/].checkOneDelayedTransitionPerLoop = checkOneDelayedTransitionPerLoopIn;
     local_entry['['/]entryIndices['['/]1[']'/][']'/].checkOneDelayedTransitionPerLoop = checkOneDelayedTransitionPerLoopIn;

     // During initialization it is checked whether entry and exit port connections
     // are fine. The for-statements are made in such a form, that no translation
     // error occurs, if this case is present. Instead, during initialization
     // a meaningful error message is printed
     for i in 2:nMinBranches loop
        local_entry['['/]entryIndices['['/]i[']'/][']'/].checkOneDelayedTransitionPerLoop = local_exit['['/]i-1[']'/].checkOneDelayedTransitionPerLoop;
//      local_entry['['/]i[']'/].checkOneDelayedTransitionPerLoop = local_exit['['/]i-1[']'/].checkOneDelayedTransitionPerLoop;
     end for;
     for i in nMinBranches+1:nEntry loop
//      local_entry['['/]i[']'/].checkOneDelayedTransitionPerLoop = true;
        local_entry['['/]entryIndices['['/]i[']'/][']'/].checkOneDelayedTransitionPerLoop = true;
     end for;
     local_outPort.checkOneDelayedTransitionPerLoop =
          fill(local_exit['['/]nMinBranches[']'/].checkOneDelayedTransitionPerLoop, nOut);
  end if;

  annotation (Diagram(coordinateSystem(
        preserveAspectRatio=false,
        extent={{-100,-100},{100,100}},
        initialScale=0.1,
        grid={2,2}),     graphics), Icon(coordinateSystem(
        preserveAspectRatio=false,
        extent={{-100,-100},{100,100}},
        initialScale=0.1,
        grid={2,2},
        preserveAspectRatio=false,
        extent={{-100,-100},{100,100}}), graphics),
    Documentation(info="<html>
<p>
Parallel splitting of execution path including special cases so that step is:
autonomous, composed, parallel unsynchronized, parallel with synchronized outputs.
</p>
</html>"));
end PartialParallelBase;
	
[/template]

[**
 * 
 * @param traceabilityContext 
 */]
[template private generate_Transitions(traceabilityContext : OclAny)]
model SyncTransition_receive 
  "Synchronize two Transition between steps"
  parameter Boolean use_conditionPort = false 
    "= true, if conditionPort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
 parameter Integer SyncOut(min=0)=0 annotation(Dialog(__Dymola_connectorSizing=true), HideResult=true);
  input Boolean condition = true 
    "Fire condition (time varying Boolean expression)"
    annotation(Dialog(enable=not use_conditionPort));

  parameter Boolean use_firePort = false "= true, if firePort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  parameter Boolean delayedTransition = false 
    "= true, if transition fires after waitTime"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  parameter Boolean loopCheck = true 
    "= true, if one delayed transition per loop required"
    annotation(Evaluate=true, HideResult=true, Dialog(tab="Advanced"), choices(__Dymola_checkBox=true));
  parameter Modelica.SIunits.Time waitTime = 0 
    "Wait time before transition fires (> 0 required)"
    annotation(Dialog(enable=delayedTransition));
  Modelica_StateGraph2.Internal.Interfaces.Transition_in inPort 
    "Input port of transition (exactly one connection to this port is required)"
    annotation (Placement(transformation(extent={{23,87},{57,121}}),
        iconTransformation(extent={{23,87},{57,121}})));

  Modelica_StateGraph2.Internal.Interfaces.Transition_out outPort 
    "Output port of transition (exactly one connection from this port is required)"
    annotation (Placement(transformation(extent={{-25,-150},{25,-100}})));

  Modelica.Blocks.Interfaces.BooleanInput conditionPort if use_conditionPort 
    "Fire condition as Boolean input."
    annotation (
      Placement(transformation(extent={{-150,-25},{-100,25}})));

  Modelica.Blocks.Interfaces.BooleanOutput firePort = fire if use_firePort 
    "= true, if transition fires"
    annotation (Placement(transformation(extent={{90,-15},{120,15}})));

 Boolean pre_fire;
  output Boolean fire "= true, if transition fires";
  output Boolean enableFire "= true, if firing condition is true";

protected 
    constant Modelica.SIunits.Time minimumWaitTime = 100*Modelica.Constants.eps;
  Modelica.SIunits.Time t_start 
    "Time instant at which the transition would fire, if waitTime would be zero";
  Modelica.Blocks.Interfaces.BooleanInput localCondition;
public 
  replaceable SyncChannels.receiver['['/]SyncOut[']'/]                        receiver
    annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
  replaceable output SyncChannels.rec r;
  //replaceable Utilities.SyncChannels.rec r_temp['['/]SyncOut[']'/];
  //Boolean index_fire_ready_s['['/]SyncOut[']'/];
  Integer index_SyncOut;
initial equation 
  pre(enableFire) = false;
  pre(t_start) = 0;
  pre(pre_fire) = false;

equation 
  // Handle conditional conditionPort
  connect(conditionPort, localCondition);
  if not use_conditionPort then
     localCondition = condition;
  end if;

  // Determine firing condition
  enableFire = localCondition and inPort.available;
 // Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive enableFire " + String(enableFire));

  if delayedTransition then
     when enableFire then
        t_start = time;
     end when;
     pre_fire = enableFire and time >= t_start + waitTime;
     outPort.checkOneDelayedTransitionPerLoop = true;
  else
     t_start = 0;
     pre_fire = enableFire;
     if loopCheck then
        outPort.checkOneDelayedTransitionPerLoop = inPort.checkOneDelayedTransitionPerLoop;
     else
        outPort.checkOneDelayedTransitionPerLoop = true;
     end if;
  end if;
  for i in 1:SyncOut loop
    receiver['['/]i[']'/].fire_ready_r = pre_fire and not pre(fire);
    //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive receiver['['/]"+String(i)+"[']'/].fire_ready_r " + String(receiver['['/]i[']'/].fire_ready_r));

  end for;

  index_SyncOut = Modelica_StateGraph2.Blocks.BooleanFunctions.firstTrueIndex(receiver.fire_ready_s);
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive index_SyncOut " + String(index_SyncOut));

  if index_SyncOut > 0 then
     r = receiver['['/]index_SyncOut[']'/].r;
  else
    r = pre(r);
  end if;
  fire = pre_fire and Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(receiver.fire_ready_s);
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive fire " + String(fire));

  inPort.fire  = fire;
  outPort.fire = fire;
  // Handling of node
  Connections.branch(inPort.node, outPort.node);
  outPort.node = inPort.node;

  annotation (defaultComponentName="SyncT1",
    Icon(
      coordinateSystem(extent={{-100,-100},{100,100}},initialScale=0.04,   preserveAspectRatio=true,
        grid={1,1}), graphics={
        Line(
          visible=not delayedTransition,
          points={{0,-2},{0,-102}},
          color={0,0,0}),
        Text(
          extent={{-150,-15},{150,15}},
          textString="%name",
          lineColor={0,0,255},
          origin={160,75},
          rotation=0),
        Rectangle(
          extent={{-100,-15},{100,15}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid,
          radius=10),
        Line(points={{40,91},{40,13}},   color={0,0,0}),
        Text(
          visible=not use_conditionPort,
          extent={{-300,-15},{300,15}},
          lineColor=DynamicSelect({128,128,128}, if condition > 0.5 then {0,255,
              0} else {128,128,128}),
          textString="%condition",
          origin={-155,-3},
          rotation=90),
        Text(
          visible=not loopCheck,
          extent={{10,-60},{400,-80}},
          lineColor={255,0,0},
          fillColor={170,255,213},
          fillPattern=FillPattern.Solid,
          textString="no check"),
        Line(
          visible=not loopCheck,
          points={{-50,-15},{-50,-100}},
          color={255,0,0},
          smooth=Smooth.None),
        Line(
          visible=not loopCheck,
          points={{50,-15},{50,-100}},
          color={255,0,0},
          smooth=Smooth.None)}),
      Documentation(info="<html>
                            <p>
                            <img src=\"../Images/StateGraph/Elements/SimpleStateGraph.png\" align=\"right\">
                            To define a possible change of states, a Transition is connected to the output of the preceding Step and to the input of the succeeding Step, see figure to the right, where Transition t1 defines the transition from Step s1 to Step s2. Note: A Transition has exactly one preceding and one succeeding Step. A Transition is said to be enabled if the preceding step is active. An enabled transition is said to be fireable when the Boolean condition defined in the parameter menu of the transition is evaluated to <b>true</b>. This condition is also called <u>Transition condition</u> and is displayed in the icon of the Transition (e.g., &quot;time &gt; 1&quot; is the condition of Transition t1). When parameter <u>use_conditionPort</u> is set, the Transition condition is alternatively defined by a Boolean signal that is connected to the enabled <u>conditionPort</u>.
                            </p>
                            
                            <p>
                            A fireable transition will fire immediately. In the figure to the right, t1 fires when s1 is active and time is greater than one, i.e., s1 becomes inactive and s2 becomes active.
                            The firing of a transition can optionally also be delayed for a certain period of time defined by parameter &quot;waitTime&quot;. See, e.g., t2 in the figure to right, that is delayed for one second before it may fire, given that the condition remains true and the preceding Step remains active during the entire delay time.
                            </p>
                            
                            <p>
                            In the following table different configurations of a Transition are shown:
                            </p>
                            
                            <blockquote>
                            <table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" width=\"600\">
                            <tr><th>Parameter setting</th>
                                <th>Icon</th>
                                <th>Description</th></tr>
                            
                            <tr><td>Default transition</td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-default.png\"></td>
                                <td>The transition fires when the preceding step is active
                                    and the expression &quot;condition&quot; in the parameter menu is <b>true</b>.</td>
                                </tr>
                            
                            <tr><td>use_conditionPort = <b>true</b></td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-use_conditionPort.png\"></td>
                                <td>The transition fires when the preceding step is active
                                    and connector &quot;conditionPort&quot; is <b>true</b>.</td>
                                </tr>
                            
                            <tr><td>delayedTransition = <b>true</b></td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-delayedTransition.png\"></td>
                                <td>The transition fires after the delay time &quot;waitTime&quot; (here: 1.23 s),
                                    if the preceding step was active, and &quot;condition = <b>true</b>&quot;
                                    during the entire delay time.</td>
                                </tr>
                            
                            <tr><td>use_firePort = <b>true</b></td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-use_firePort.png\"></td>
                                <td>Connector &quot;firePort&quot; is <b>true</b> when the transition fires.
                                    Actions may be triggered, e.g., by connecting block
                                    <a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean.MultiSwitch\">MultiSwitch</a>
                                    to the firePort.</td>
                                </tr>
                            
                            <tr><td>loopCheck = <b>false</b><br>
                                    (in &quot;Advanced&quot; tab)</td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-noLoopCheck.png\"></td>
                                <td>It is <u>not</u> checked whether the loop in which this Transition
                                    is used, has at least one delayed transition.
                                    Use this option only, if you are completley sure that
                                    infinite event looping is not possible in this loop.
                                    Consider to use
                                    <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                                    instead!</td>
                                </tr>
                            
                            </table>
                            </blockquote>
                            
                            <p>
                            <img src=\"../Images/StateGraph/Elements/SimpleInfiniteLoop.png\" align=\"right\">
                            At an event instant, an iteration occurs, due to the Modelica semantics (= whenever a new event occurs, the model is re-evaluated). This means that Transitions keep firing along a connected graph, as long as the firing conditions are true. In principal, it is therefore possible that infinite event looping occurs.
                            A simple example of this kind is shown in the figure to the right. Here, all Transition conditions are true and therefore all Transitions would fire forever at the initial time. This is, however, no valid StateGraph2 model and will result in a translation error, since it is required that a StateGraph2 model has at least one delayed Transition per loop.
                            This means that one of T1, T2, or T3, must have parameter delayedTransition=<b>true</b>. Since event iteration stops at a delayed Transition, infinite event looping cannot occur. This also means that at one time instant every Transition can fire at most once and therefore the number of model evaluations at an event instant is bounded by the number of Transition components.
                            </p>
                            
                            <p>
                            If you have to artifically introduce a delay time in order to fulfill the requirement above, it is recommended to use the special
                            <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                            that is designed for this case.
                            </p>
                            
                            <p>
                            Note, it is still possible that infinite event looping occurs due to <u>model errors</u> in other parts of the model. For example, if a user introduces an equation of the form &quot;J = <b>pre</b>(J) + 1&quot; outside of a when-clause, event iteration does not stop.
                            </p>
                            
                            <p>
                            There are rare situations, where infinite event looping cannot occur even if there is no delayed transition in a loop. When you do not want to introduce an artifical time delay in a loop in this case, you can switch off the loop check by setting parameter &quot;loopCheck = <b>false</b>&quot; in the &quot;Advanced&quot; tab of the parameter menu of one Transition in this loop.
                            </p>
                            
                            </html>"),
    Diagram(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}},
        grid={1,1}), graphics));
end SyncTransition_receive;

model SyncTransition_send "Synchronize two Transition between steps"
  parameter Boolean use_conditionPort = false 
    "= true, if conditionPort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  input Boolean condition = true 
    "Fire condition (time varying Boolean expression)"
    annotation(Dialog(enable=not use_conditionPort));

  parameter Integer SyncIn(min=0)=0 annotation(Dialog(__Dymola_connectorSizing=true), HideResult=true);

  parameter Boolean use_firePort = false "= true, if firePort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Boolean delayedTransition = false 
    "= true, if transition fires after waitTime"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Boolean loopCheck = true 
    "= true, if one delayed transition per loop required"
    annotation(Evaluate=true, HideResult=true, Dialog(tab="Advanced"), choices(__Dymola_checkBox=true));
  parameter Modelica.SIunits.Time waitTime = 0 
    "Wait time before transition fires (> 0 required)"
    annotation(Dialog(enable=delayedTransition));
  Modelica_StateGraph2.Internal.Interfaces.Transition_in inPort 
    "Input port of transition (exactly one connection to this port is required)"
    annotation (Placement(transformation(extent={{-66,85},{-32,119}})));

  Modelica_StateGraph2.Internal.Interfaces.Transition_out outPort 
    "Output port of transition (exactly one connection from this port is required)"
    annotation (Placement(transformation(extent={{-25,-150},{25,-100}})));

  Modelica.Blocks.Interfaces.BooleanInput conditionPort if use_conditionPort 
    "Fire condition as Boolean input."
    annotation (
      Placement(transformation(extent={{-150,-25},{-100,25}})));

  Modelica.Blocks.Interfaces.BooleanOutput firePort = fire if use_firePort 
    "= true, if transition fires"
    annotation (Placement(transformation(extent={{90,-15},{120,15}})));

  output Boolean fire "= true, if transition fires";
  Boolean pre_fire "= true, if transition could fire";
  output Boolean enableFire "= true, if firing condition is true";

protected 
    constant Modelica.SIunits.Time minimumWaitTime = 100*Modelica.Constants.eps;
  Modelica.SIunits.Time t_start 
    "Time instant at which the transition would fire, if waitTime would be zero";
  Modelica.Blocks.Interfaces.BooleanInput localCondition;
public 
  replaceable SyncChannels.sender['['/]SyncIn[']'/]            sender
    annotation (Placement(transformation(extent={{80,80},{100,100}})));
  replaceable output SyncChannels.rec r;
initial equation 
  pre(enableFire) = false;
  pre(t_start) = 0;
  pre(pre_fire) = false;
equation 
  // Handle conditional conditionPort
  connect(conditionPort, localCondition);
  if not use_conditionPort then
     localCondition = condition;
  end if;

  // Determine firing condition
   enableFire = localCondition and inPort.available;
    //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send enableFire " + String(enableFire));

   if delayedTransition then
     when enableFire then
        t_start = time;
     end when;
     pre_fire = enableFire and time >= t_start + waitTime;
     outPort.checkOneDelayedTransitionPerLoop = true;
  else
     t_start = 0;
     pre_fire = enableFire;
     if loopCheck then
        outPort.checkOneDelayedTransitionPerLoop = inPort.checkOneDelayedTransitionPerLoop;
     else
        outPort.checkOneDelayedTransitionPerLoop = true;
     end if;
   end if;
   //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send pre_fire " + String(pre_fire));
   for i in 1:SyncIn loop
     sender['['/]i[']'/].fire_ready_s =  if i == 1 then pre_fire and sender['['/]i[']'/].fire_ready_r
                               else not sender['['/]i-1[']'/].fire_ready_s and 
                                    sender['['/]i[']'/].fire_ready_r and 
                                    pre_fire;
    // Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send sender['['/]"+String(i)+"[']'/].fire_ready_s " + String(sender['['/]i[']'/].fire_ready_s));
   end for;

   for i in 1:SyncIn loop
     sender['['/]i[']'/].r = r;
   end for;
   fire =  pre_fire and Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(sender.fire_ready_s);
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send fire " + String(fire));
  inPort.fire  = fire;
  outPort.fire = fire;
  // Handling of node
  Connections.branch(inPort.node, outPort.node);
  outPort.node = inPort.node;

  annotation (defaultComponentName="SyncT1",
    Icon(
      coordinateSystem(extent={{-100,-100},{100,100}},initialScale=0.04,   preserveAspectRatio=true,
        grid={1,1}), graphics={
        Line(
          visible=not delayedTransition,
          points={{0,-2},{0,-102}},
          color={0,0,0}),
        Text(
          extent={{-150,-15},{150,15}},
          textString="%name",
          lineColor={0,0,255},
          origin={160,75},
          rotation=0),
        Rectangle(
          extent={{-100,-15},{100,15}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid,
          radius=10),
        Line(points={{-50,90},{-50,12}}, color={0,0,0}),
        Text(
          visible=not use_conditionPort,
          extent={{-300,-15},{300,15}},
          lineColor=DynamicSelect({128,128,128}, if condition > 0.5 then {0,255,
              0} else {128,128,128}),
          textString="%condition",
          origin={-155,-3},
          rotation=90),
        Text(
          visible=not loopCheck,
          extent={{10,-60},{400,-80}},
          lineColor={255,0,0},
          fillColor={170,255,213},
          fillPattern=FillPattern.Solid,
          textString="no check"),
        Line(
          visible=not loopCheck,
          points={{-50,-15},{-50,-100}},
          color={255,0,0},
          smooth=Smooth.None),
        Line(
          visible=not loopCheck,
          points={{50,-15},{50,-100}},
          color={255,0,0},
          smooth=Smooth.None)}),
      Documentation(info="<html>
                            <p>
                            <img src=\"../Images/StateGraph/Elements/SimpleStateGraph.png\" align=\"right\">
                            To define a possible change of states, a Transition is connected to the output of the preceding Step and to the input of the succeeding Step, see figure to the right, where Transition t1 defines the transition from Step s1 to Step s2. Note: A Transition has exactly one preceding and one succeeding Step. A Transition is said to be enabled if the preceding step is active. An enabled transition is said to be fireable when the Boolean condition defined in the parameter menu of the transition is evaluated to <b>true</b>. This condition is also called <u>Transition condition</u> and is displayed in the icon of the Transition (e.g., &quot;time &gt; 1&quot; is the condition of Transition t1). When parameter <u>use_conditionPort</u> is set, the Transition condition is alternatively defined by a Boolean signal that is connected to the enabled <u>conditionPort</u>.
                            </p>
                            
                            <p>
                            A fireable transition will fire immediately. In the figure to the right, t1 fires when s1 is active and time is greater than one, i.e., s1 becomes inactive and s2 becomes active.
                            The firing of a transition can optionally also be delayed for a certain period of time defined by parameter &quot;waitTime&quot;. See, e.g., t2 in the figure to right, that is delayed for one second before it may fire, given that the condition remains true and the preceding Step remains active during the entire delay time.
                            </p>
                            
                            <p>
                            In the following table different configurations of a Transition are shown:
                            </p>
                            
                            <blockquote>
                            <table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" width=\"600\">
                            <tr><th>Parameter setting</th>
                                <th>Icon</th>
                                <th>Description</th></tr>
                            
                            <tr><td>Default transition</td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-default.png\"></td>
                                <td>The transition fires when the preceding step is active
                                    and the expression &quot;condition&quot; in the parameter menu is <b>true</b>.</td>
                                </tr>
                            
                            <tr><td>use_conditionPort = <b>true</b></td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-use_conditionPort.png\"></td>
                                <td>The transition fires when the preceding step is active
                                    and connector &quot;conditionPort&quot; is <b>true</b>.</td>
                                </tr>
                            
                            <tr><td>delayedTransition = <b>true</b></td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-delayedTransition.png\"></td>
                                <td>The transition fires after the delay time &quot;waitTime&quot; (here: 1.23 s),
                                    if the preceding step was active, and &quot;condition = <b>true</b>&quot;
                                    during the entire delay time.</td>
                                </tr>
                            
                            <tr><td>use_firePort = <b>true</b></td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-use_firePort.png\"></td>
                                <td>Connector &quot;firePort&quot; is <b>true</b> when the transition fires.
                                    Actions may be triggered, e.g., by connecting block
                                    <a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean.MultiSwitch\">MultiSwitch</a>
                                    to the firePort.</td>
                                </tr>
                            
                            <tr><td>loopCheck = <b>false</b><br>
                                    (in &quot;Advanced&quot; tab)</td>
                                <td><img src=\"../Images/StateGraph/Elements/Transition-noLoopCheck.png\"></td>
                                <td>It is <u>not</u> checked whether the loop in which this Transition
                                    is used, has at least one delayed transition.
                                    Use this option only, if you are completley sure that
                                    infinite event looping is not possible in this loop.
                                    Consider to use
                                    <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                                    instead!</td>
                                </tr>
                            
                            </table>
                            </blockquote>
                            
                            <p>
                            <img src=\"../Images/StateGraph/Elements/SimpleInfiniteLoop.png\" align=\"right\">
                            At an event instant, an iteration occurs, due to the Modelica semantics (= whenever a new event occurs, the model is re-evaluated). This means that Transitions keep firing along a connected graph, as long as the firing conditions are true. In principal, it is therefore possible that infinite event looping occurs.
                            A simple example of this kind is shown in the figure to the right. Here, all Transition conditions are true and therefore all Transitions would fire forever at the initial time. This is, however, no valid StateGraph2 model and will result in a translation error, since it is required that a StateGraph2 model has at least one delayed Transition per loop.
                            This means that one of T1, T2, or T3, must have parameter delayedTransition=<b>true</b>. Since event iteration stops at a delayed Transition, infinite event looping cannot occur. This also means that at one time instant every Transition can fire at most once and therefore the number of model evaluations at an event instant is bounded by the number of Transition components.
                            </p>
                            
                            <p>
                            If you have to artifically introduce a delay time in order to fulfill the requirement above, it is recommended to use the special
                            <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                            that is designed for this case.
                            </p>
                            
                            <p>
                            Note, it is still possible that infinite event looping occurs due to <u>model errors</u> in other parts of the model. For example, if a user introduces an equation of the form &quot;J = <b>pre</b>(J) + 1&quot; outside of a when-clause, event iteration does not stop.
                            </p>
                            
                            <p>
                            There are rare situations, where infinite event looping cannot occur even if there is no delayed transition in a loop. When you do not want to introduce an artifical time delay in a loop in this case, you can switch off the loop check by setting parameter &quot;loopCheck = <b>false</b>&quot; in the &quot;Advanced&quot; tab of the parameter menu of one Transition in this loop.
                            </p>
                            
                            </html>"),
    Diagram(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}},
        grid={1,1}), graphics));
end SyncTransition_send;

model Transition_message 
  "Transition between steps (optionally with delayed transition and/or condition input port)"
  parameter Boolean use_conditionPort = false 
    "= true, if conditionPort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

 /* parameter Boolean use_messages_outport = false 
              "= true, if conditionPort enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
          
            parameter Boolean use_messages_inport = false 
              "= true, if conditionPort enabled"
              annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
              */
  input Boolean condition = true 
    "Fire condition (time varying Boolean expression)"
    annotation(Dialog(enable=not use_conditionPort));

  parameter Boolean delayedTransition = false 
    "= true, if transition fires after waitTime"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Modelica.SIunits.Time waitTime = 0 
    "Wait time before transition fires (> 0 required)"
    annotation(Dialog(enable=delayedTransition));

  parameter Boolean use_firePort = false "= true, if firePort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  parameter Boolean loopCheck = true 
    "= true, if one delayed transition per loop required"
    annotation(Evaluate=true, HideResult=true, Dialog(tab="Advanced"), choices(__Dymola_checkBox=true));

  Modelica_StateGraph2.Internal.Interfaces.Transition_in inPort 
    "Input port of transition (exactly one connection to this port is required)"
    annotation (Placement(transformation(extent={{-17,83},{17,117}})));

  Modelica_StateGraph2.Internal.Interfaces.Transition_out outPort 
    "Output port of transition (exactly one connection from this port is required)"
    annotation (Placement(transformation(extent={{-25,-150},{25,-100}})));

  Modelica.Blocks.Interfaces.BooleanInput conditionPort if use_conditionPort 
    "Fire condition as Boolean input."
    annotation (
      Placement(transformation(extent={{-150,-25},{-100,25}})));

  Modelica.Blocks.Interfaces.BooleanOutput firePort = fire if use_firePort 
    "= true, if transition fires"
    annotation (Placement(transformation(extent={{90,-15},{120,15}})));

  replaceable [messageportInterfacesLocation()/]output_port message_output_port
    annotation (Placement(transformation(extent={{-120,70},{-100,90}})));
  Boolean pre_fire;
  output Boolean fire "= true, if transition fires";
  output Boolean enableFire "= true, if firing condition is true";
  replaceable output MessageInterfaces.Messages.Message message;
protected 
  constant Modelica.SIunits.Time minimumWaitTime = 100*Modelica.Constants.eps;
  Modelica.SIunits.Time t_start 
    "Time instant at which the transition would fire, if waitTime would be zero";
  Modelica.Blocks.Interfaces.BooleanInput localCondition;
initial equation 
  pre(enableFire) = false;
  pre(t_start) = 0;
  pre(pre_fire) = false;
equation 
  //messageC =  messageC_transition_in_output.messageC;
  // Handle conditional conditionPort
  connect(conditionPort, localCondition);
  if not use_conditionPort then
     localCondition = condition;
  end if;

  // Determine firing condition
  enableFire = localCondition and inPort.available;

  if delayedTransition then
     when enableFire then
        t_start = time;
     end when;
     pre_fire = enableFire and time >= t_start + waitTime;
     outPort.checkOneDelayedTransitionPerLoop = true;
  else
     t_start = 0;
     pre_fire = enableFire;
     if loopCheck then
        outPort.checkOneDelayedTransitionPerLoop = inPort.checkOneDelayedTransitionPerLoop;
     else
        outPort.checkOneDelayedTransitionPerLoop = true;
     end if;
  end if;

  message_output_port.active = pre_fire and message_output_port.hasMessage and not fire;

  //Modelica.Utilities.Streams.print(String(time) + " Transition_message pre_fire " + String(pre_fire));
  fire = pre_fire and pre(message_output_port.fire);
  if fire then
    message =  message_output_port.message;
  else
    message =  pre(message);
  end if;
  //Modelica.Utilities.Streams.print(String(time) + " Transition_message fire " + String(fire));
  inPort.fire  = fire;
  outPort.fire = fire;

  // Handling of node
  Connections.branch(inPort.node, outPort.node);
  outPort.node = inPort.node;

  // Asserts
  assert(not delayedTransition or 
         delayedTransition and waitTime > minimumWaitTime,
        "Either set delayTransition = false, or set waitTime (= " + String(waitTime) + ") > " + String(minimumWaitTime));
  annotation (defaultComponentName="T1",
    Icon(
      coordinateSystem(extent={{-100,-100},{100,100}},initialScale=0.04,   preserveAspectRatio=true,
        grid={1,1}), graphics={
        Text(
          visible=delayedTransition,
          extent={{-200,10},{200,-10}},
          lineColor={255,0,0},
          textString="%waitTime",
          origin={210,-70},
          rotation=0),
        Line(
          visible=delayedTransition,
          points={{0,-12.5},{0,-30}},
          color={255,0,0}),
        Line(
          visible=delayedTransition,
          points={{0,-86},{0,-100}},
          color={255,0,0}),
        Line(
          visible=delayedTransition,
          points={{0,-47},{0,-63}},
          color={255,0,0}),
        Line(
          visible=not delayedTransition,
          points={{0,0},{0,-100}},
          color={0,0,0}),
        Text(
          extent={{-150,-15},{150,15}},
          textString="%name",
          lineColor={0,0,255},
          origin={160,75},
          rotation=0),
        Rectangle(
          extent={{-100,-15},{100,15}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid,
          radius=10),
        Line(points={{0,90},{0,12}}, color={0,0,0}),
        Text(
          visible=not use_conditionPort,
          extent={{-300,-15},{300,15}},
          lineColor=DynamicSelect({128,128,128}, if condition > 0.5 then {0,255,
              0} else {128,128,128}),
          textString="%condition",
          origin={-155,-3},
          rotation=90),
        Text(
          visible=not loopCheck,
          extent={{10,-60},{400,-80}},
          lineColor={255,0,0},
          fillColor={170,255,213},
          fillPattern=FillPattern.Solid,
          textString="no check"),
        Line(
          visible=not loopCheck,
          points={{0,-15},{0,-100}},
          color={255,0,0},
          smooth=Smooth.None)}),
      Documentation(info="<html>
          <p>
          <img src=\"../Images/StateGraph/Elements/SimpleStateGraph.png\" align=\"right\">
          To define a possible change of states, a Transition is connected to the output of the preceding Step and to the input of the succeeding Step, see figure to the right, where Transition t1 defines the transition from Step s1 to Step s2. Note: A Transition has exactly one preceding and one succeeding Step. A Transition is said to be enabled if the preceding step is active. An enabled transition is said to be fireable when the Boolean condition defined in the parameter menu of the transition is evaluated to <b>true</b>. This condition is also called <u>Transition condition</u> and is displayed in the icon of the Transition (e.g., &quot;time &gt; 1&quot; is the condition of Transition t1). When parameter <u>use_conditionPort</u> is set, the Transition condition is alternatively defined by a Boolean signal that is connected to the enabled <u>conditionPort</u>.
          </p>
          
          <p>
          A fireable transition will fire immediately. In the figure to the right, t1 fires when s1 is active and time is greater than one, i.e., s1 becomes inactive and s2 becomes active.
          The firing of a transition can optionally also be delayed for a certain period of time defined by parameter &quot;waitTime&quot;. See, e.g., t2 in the figure to right, that is delayed for one second before it may fire, given that the condition remains true and the preceding Step remains active during the entire delay time.
          </p>
          
          <p>
          In the following table different configurations of a Transition are shown:
          </p>
          
          <blockquote>
          <table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" width=\"600\">
          <tr><th>Parameter setting</th>
              <th>Icon</th>
              <th>Description</th></tr>
          
          <tr><td>Default transition</td>
              <td><img src=\"../Images/StateGraph/Elements/Transition-default.png\"></td>
              <td>The transition fires when the preceding step is active
                  and the expression &quot;condition&quot; in the parameter menu is <b>true</b>.</td>
              </tr>
          
          <tr><td>use_conditionPort = <b>true</b></td>
              <td><img src=\"../Images/StateGraph/Elements/Transition-use_conditionPort.png\"></td>
              <td>The transition fires when the preceding step is active
                  and connector &quot;conditionPort&quot; is <b>true</b>.</td>
              </tr>
          
          <tr><td>delayedTransition = <b>true</b></td>
              <td><img src=\"../Images/StateGraph/Elements/Transition-delayedTransition.png\"></td>
              <td>The transition fires after the delay time &quot;waitTime&quot; (here: 1.23 s),
                  if the preceding step was active, and &quot;condition = <b>true</b>&quot;
                  during the entire delay time.</td>
              </tr>
          
          <tr><td>use_firePort = <b>true</b></td>
              <td><img src=\"../Images/StateGraph/Elements/Transition-use_firePort.png\"></td>
              <td>Connector &quot;firePort&quot; is <b>true</b> when the transition fires.
                  Actions may be triggered, e.g., by connecting block
                  <a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean.MultiSwitch\">MultiSwitch</a>
                  to the firePort.</td>
              </tr>
          
          <tr><td>loopCheck = <b>false</b><br>
                  (in &quot;Advanced&quot; tab)</td>
              <td><img src=\"../Images/StateGraph/Elements/Transition-noLoopCheck.png\"></td>
              <td>It is <u>not</u> checked whether the loop in which this Transition
                  is used, has at least one delayed transition.
                  Use this option only, if you are completley sure that
                  infinite event looping is not possible in this loop.
                  Consider to use
                  <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                  instead!</td>
              </tr>
          
          </table>
          </blockquote>
          
          <p>
          <img src=\"../Images/StateGraph/Elements/SimpleInfiniteLoop.png\" align=\"right\">
          At an event instant, an iteration occurs, due to the Modelica semantics (= whenever a new event occurs, the model is re-evaluated). This means that Transitions keep firing along a connected graph, as long as the firing conditions are true. In principal, it is therefore possible that infinite event looping occurs.
          A simple example of this kind is shown in the figure to the right. Here, all Transition conditions are true and therefore all Transitions would fire forever at the initial time. This is, however, no valid StateGraph2 model and will result in a translation error, since it is required that a StateGraph2 model has at least one delayed Transition per loop.
          This means that one of T1, T2, or T3, must have parameter delayedTransition=<b>true</b>. Since event iteration stops at a delayed Transition, infinite event looping cannot occur. This also means that at one time instant every Transition can fire at most once and therefore the number of model evaluations at an event instant is bounded by the number of Transition components.
          </p>
          
          <p>
          If you have to artifically introduce a delay time in order to fulfill the requirement above, it is recommended to use the special
          <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
          that is designed for this case.
          </p>
          
          <p>
          Note, it is still possible that infinite event looping occurs due to <u>model errors</u> in other parts of the model. For example, if a user introduces an equation of the form &quot;J = <b>pre</b>(J) + 1&quot; outside of a when-clause, event iteration does not stop.
          </p>
          
          <p>
          There are rare situations, where infinite event looping cannot occur even if there is no delayed transition in a loop. When you do not want to introduce an artifical time delay in a loop in this case, you can switch off the loop check by setting parameter &quot;loopCheck = <b>false</b>&quot; in the &quot;Advanced&quot; tab of the parameter menu of one Transition in this loop.
          </p>
          
          </html>"),
    Diagram(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}},
        grid={1,1}), graphics));
end Transition_message;

model SyncTransition_receive_m 
  "Synchronize two Transition between steps"
  parameter Boolean use_conditionPort = false 
    "= true, if conditionPort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  input Boolean condition = true 
    "Fire condition (time varying Boolean expression)"
    annotation(Dialog(enable=not use_conditionPort));
 parameter Integer SyncOut(min=0)=0 annotation(Dialog(__Dymola_connectorSizing=true), HideResult=true);
  parameter Boolean use_firePort = false "= true, if firePort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  parameter Boolean delayedTransition = false 
    "= true, if transition fires after waitTime"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Modelica.SIunits.Time waitTime = 0 
    "Wait time before transition fires (> 0 required)"
    annotation(Dialog(enable=delayedTransition));
  parameter Boolean loopCheck = true 
    "= true, if one delayed transition per loop required"
    annotation(Evaluate=true, HideResult=true, Dialog(tab="Advanced"), choices(__Dymola_checkBox=true));

  Modelica_StateGraph2.Internal.Interfaces.Transition_in inPort 
    "Input port of transition (exactly one connection to this port is required)"
    annotation (Placement(transformation(extent={{23,87},{57,121}}),
        iconTransformation(extent={{23,87},{57,121}})));

  Modelica_StateGraph2.Internal.Interfaces.Transition_out outPort 
    "Output port of transition (exactly one connection from this port is required)"
    annotation (Placement(transformation(extent={{-25,-150},{25,-100}})));

  Modelica.Blocks.Interfaces.BooleanInput conditionPort if use_conditionPort 
    "Fire condition as Boolean input."
    annotation (
      Placement(transformation(extent={{-150,-25},{-100,25}})));

  Modelica.Blocks.Interfaces.BooleanOutput firePort = fire if use_firePort 
    "= true, if transition fires"
    annotation (Placement(transformation(extent={{90,-15},{120,15}})));
  Integer index_SyncOut;
  Boolean pre_fire;
  output Boolean fire "= true, if transition fires";
  output Boolean enableFire "= true, if firing condition is true";
  Boolean fire_s;
protected 
  constant Modelica.SIunits.Time minimumWaitTime = 100*Modelica.Constants.eps;
  Modelica.SIunits.Time t_start 
    "Time instant at which the transition would fire, if waitTime would be zero";
  Modelica.Blocks.Interfaces.BooleanInput localCondition;
public 
  replaceable Beispiel_DK_v3.Utilities.SyncChannels.receiver['['/]SyncOut[']'/] receiver
    annotation (Placement(transformation(extent={{-33,91},{-13,111}})));
  replaceable [messageportInterfacesLocation()/]output_port message_output_port
    annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
  replaceable output MessageInterfaces.Messages.Message message;
  replaceable output Utilities.SyncChannels.rec r;
initial equation 
  pre(enableFire) = false;
  pre(pre_fire) = false;
equation 
  // Handle conditional conditionPort
  connect(conditionPort, localCondition);
  if not use_conditionPort then
     localCondition = condition;
  end if;

  // Determine firing condition
  enableFire = localCondition and inPort.available;

if delayedTransition then
     when enableFire then
        t_start = time;
     end when;
     pre_fire = enableFire and time >= t_start + waitTime;
     outPort.checkOneDelayedTransitionPerLoop = true;
  else
     t_start = 0;
     pre_fire = enableFire;
     if loopCheck then
        outPort.checkOneDelayedTransitionPerLoop = inPort.checkOneDelayedTransitionPerLoop;
     else
        outPort.checkOneDelayedTransitionPerLoop = true;
     end if;
  end if;
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive_m pre_fire " + String(pre_fire));

  if index_SyncOut > 0 then
     r = receiver['['/]index_SyncOut[']'/].r;
  else
    r = pre(r);
  end if;

  message_output_port.active = pre_fire and Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(receiver.fire_ready_s) and not fire;

  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive_m message_output_port.active " + String(message_output_port.active));
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive_m message_output_port.fire " + String(message_output_port.fire));
   for i in 1:SyncOut loop
    receiver['['/]i[']'/].fire_ready_r =  pre_fire and not pre(fire) and (message_output_port.hasMessage);
    //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send receiver['['/]"+String(i)+"[']'/].fire_ready_r " + String(receiver['['/]i[']'/].fire_ready_r));
   end for;
     index_SyncOut = Modelica_StateGraph2.Blocks.BooleanFunctions.firstTrueIndex(receiver.fire_ready_s);
 // Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive_m index_SyncOut " + String(index_SyncOut));
  fire_s = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(receiver.fire_ready_s);
  fire = pre_fire and pre(fire_s) and pre(message_output_port.fire);
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_receive_m pre fire " + String(pre_fire));
  if fire then
    message =  message_output_port.message;
  else
    message =  pre(message);
  end if;

  inPort.fire  = fire;
  outPort.fire = fire;
  // Handling of node
  Connections.branch(inPort.node, outPort.node);
  outPort.node = inPort.node;

  annotation (defaultComponentName="SyncT1",
    Icon(
      coordinateSystem(extent={{-100,-100},{100,100}},initialScale=0.04,   preserveAspectRatio=true,
        grid={1,1}), graphics={
        Line(
          visible=not delayedTransition,
          points={{0,-2},{0,-102}},
          color={0,0,0}),
        Text(
          extent={{-150,-15},{150,15}},
          textString="%name",
          lineColor={0,0,255},
          origin={160,75},
          rotation=0),
        Rectangle(
          extent={{-100,-15},{100,15}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid,
          radius=10),
        Line(points={{40,91},{40,13}},   color={0,0,0}),
        Text(
          visible=not use_conditionPort,
          extent={{-300,-15},{300,15}},
          lineColor=DynamicSelect({128,128,128}, if condition > 0.5 then {0,255,
              0} else {128,128,128}),
          textString="%condition",
          origin={-155,-3},
          rotation=90),
        Text(
          visible=not loopCheck,
          extent={{10,-60},{400,-80}},
          lineColor={255,0,0},
          fillColor={170,255,213},
          fillPattern=FillPattern.Solid,
          textString="no check"),
        Line(
          visible=not loopCheck,
          points={{-50,-15},{-50,-100}},
          color={255,0,0},
          smooth=Smooth.None),
        Line(
          visible=not loopCheck,
          points={{50,-15},{50,-100}},
          color={255,0,0},
          smooth=Smooth.None)}),
      Documentation(info="<html>
                    <p>
                    <img src=\"../Images/StateGraph/Elements/SimpleStateGraph.png\" align=\"right\">
                    To define a possible change of states, a Transition is connected to the output of the preceding Step and to the input of the succeeding Step, see figure to the right, where Transition t1 defines the transition from Step s1 to Step s2. Note: A Transition has exactly one preceding and one succeeding Step. A Transition is said to be enabled if the preceding step is active. An enabled transition is said to be fireable when the Boolean condition defined in the parameter menu of the transition is evaluated to <b>true</b>. This condition is also called <u>Transition condition</u> and is displayed in the icon of the Transition (e.g., &quot;time &gt; 1&quot; is the condition of Transition t1). When parameter <u>use_conditionPort</u> is set, the Transition condition is alternatively defined by a Boolean signal that is connected to the enabled <u>conditionPort</u>.
                    </p>
                    
                    <p>
                    A fireable transition will fire immediately. In the figure to the right, t1 fires when s1 is active and time is greater than one, i.e., s1 becomes inactive and s2 becomes active.
                    The firing of a transition can optionally also be delayed for a certain period of time defined by parameter &quot;waitTime&quot;. See, e.g., t2 in the figure to right, that is delayed for one second before it may fire, given that the condition remains true and the preceding Step remains active during the entire delay time.
                    </p>
                    
                    <p>
                    In the following table different configurations of a Transition are shown:
                    </p>
                    
                    <blockquote>
                    <table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" width=\"600\">
                    <tr><th>Parameter setting</th>
                        <th>Icon</th>
                        <th>Description</th></tr>
                    
                    <tr><td>Default transition</td>
                        <td><img src=\"../Images/StateGraph/Elements/Transition-default.png\"></td>
                        <td>The transition fires when the preceding step is active
                            and the expression &quot;condition&quot; in the parameter menu is <b>true</b>.</td>
                        </tr>
                    
                    <tr><td>use_conditionPort = <b>true</b></td>
                        <td><img src=\"../Images/StateGraph/Elements/Transition-use_conditionPort.png\"></td>
                        <td>The transition fires when the preceding step is active
                            and connector &quot;conditionPort&quot; is <b>true</b>.</td>
                        </tr>
                    
                    <tr><td>delayedTransition = <b>true</b></td>
                        <td><img src=\"../Images/StateGraph/Elements/Transition-delayedTransition.png\"></td>
                        <td>The transition fires after the delay time &quot;waitTime&quot; (here: 1.23 s),
                            if the preceding step was active, and &quot;condition = <b>true</b>&quot;
                            during the entire delay time.</td>
                        </tr>
                    
                    <tr><td>use_firePort = <b>true</b></td>
                        <td><img src=\"../Images/StateGraph/Elements/Transition-use_firePort.png\"></td>
                        <td>Connector &quot;firePort&quot; is <b>true</b> when the transition fires.
                            Actions may be triggered, e.g., by connecting block
                            <a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean.MultiSwitch\">MultiSwitch</a>
                            to the firePort.</td>
                        </tr>
                    
                    <tr><td>loopCheck = <b>false</b><br>
                            (in &quot;Advanced&quot; tab)</td>
                        <td><img src=\"../Images/StateGraph/Elements/Transition-noLoopCheck.png\"></td>
                        <td>It is <u>not</u> checked whether the loop in which this Transition
                            is used, has at least one delayed transition.
                            Use this option only, if you are completley sure that
                            infinite event looping is not possible in this loop.
                            Consider to use
                            <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                            instead!</td>
                        </tr>
                    
                    </table>
                    </blockquote>
                    
                    <p>
                    <img src=\"../Images/StateGraph/Elements/SimpleInfiniteLoop.png\" align=\"right\">
                    At an event instant, an iteration occurs, due to the Modelica semantics (= whenever a new event occurs, the model is re-evaluated). This means that Transitions keep firing along a connected graph, as long as the firing conditions are true. In principal, it is therefore possible that infinite event looping occurs.
                    A simple example of this kind is shown in the figure to the right. Here, all Transition conditions are true and therefore all Transitions would fire forever at the initial time. This is, however, no valid StateGraph2 model and will result in a translation error, since it is required that a StateGraph2 model has at least one delayed Transition per loop.
                    This means that one of T1, T2, or T3, must have parameter delayedTransition=<b>true</b>. Since event iteration stops at a delayed Transition, infinite event looping cannot occur. This also means that at one time instant every Transition can fire at most once and therefore the number of model evaluations at an event instant is bounded by the number of Transition components.
                    </p>
                    
                    <p>
                    If you have to artifically introduce a delay time in order to fulfill the requirement above, it is recommended to use the special
                    <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                    that is designed for this case.
                    </p>
                    
                    <p>
                    Note, it is still possible that infinite event looping occurs due to <u>model errors</u> in other parts of the model. For example, if a user introduces an equation of the form &quot;J = <b>pre</b>(J) + 1&quot; outside of a when-clause, event iteration does not stop.
                    </p>
                    
                    <p>
                    There are rare situations, where infinite event looping cannot occur even if there is no delayed transition in a loop. When you do not want to introduce an artifical time delay in a loop in this case, you can switch off the loop check by setting parameter &quot;loopCheck = <b>false</b>&quot; in the &quot;Advanced&quot; tab of the parameter menu of one Transition in this loop.
                    </p>
                    
                    </html>"),
    Diagram(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}},
        grid={1,1}), graphics));
end SyncTransition_receive_m;

model SyncTransition_send_m 
  "Synchronize two Transition between steps"
  parameter Boolean use_conditionPort = false 
    "= true, if conditionPort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));

  input Boolean condition = true 
    "Fire condition (time varying Boolean expression)"
    annotation(Dialog(enable=not use_conditionPort));

  parameter Integer SyncIn(min=0)=0 annotation(Dialog(__Dymola_connectorSizing=true), HideResult=true);

  parameter Boolean use_firePort = false "= true, if firePort enabled"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Boolean delayedTransition = false 
    "= true, if transition fires after waitTime"
    annotation(Evaluate=true, HideResult=true, choices(__Dymola_checkBox=true));
  parameter Boolean loopCheck = true 
    "= true, if one delayed transition per loop required"
    annotation(Evaluate=true, HideResult=true, Dialog(tab="Advanced"), choices(__Dymola_checkBox=true));
  parameter Modelica.SIunits.Time waitTime = 0 
    "Wait time before transition fires (> 0 required)"
    annotation(Dialog(enable=delayedTransition));
  Modelica_StateGraph2.Internal.Interfaces.Transition_in inPort 
    "Input port of transition (exactly one connection to this port is required)"
    annotation (Placement(transformation(extent={{-66,85},{-32,119}})));

  Modelica_StateGraph2.Internal.Interfaces.Transition_out outPort 
    "Output port of transition (exactly one connection from this port is required)"
    annotation (Placement(transformation(extent={{-25,-150},{25,-100}})));

  Modelica.Blocks.Interfaces.BooleanInput conditionPort if use_conditionPort 
    "Fire condition as Boolean input."
    annotation (
      Placement(transformation(extent={{-150,-25},{-100,25}})));

  Modelica.Blocks.Interfaces.BooleanOutput firePort = fire if use_firePort 
    "= true, if transition fires"
    annotation (Placement(transformation(extent={{90,-15},{120,15}})));

  output Boolean fire "= true, if transition fires";
  Boolean pre_fire "= true, if transition could fire";
  output Boolean enableFire "= true, if firing condition is true";
  replaceable output MessageInterfaces.Messages.Message message;
protected 
    constant Modelica.SIunits.Time minimumWaitTime = 100*Modelica.Constants.eps;
  Modelica.SIunits.Time t_start 
    "Time instant at which the transition would fire, if waitTime would be zero";
  Modelica.Blocks.Interfaces.BooleanInput localCondition;
public 
  replaceable SyncChannels.sender['['/]SyncIn[']'/]            sender
    annotation (Placement(transformation(extent={{80,80},{100,100}})));
  replaceable output SyncChannels.rec r;
  replaceable [messageportInterfacesLocation()/]output_port message_output_port
    annotation (Placement(transformation(extent={{80,-72},{100,-52}})));
initial equation 
  pre(enableFire) = false;
  pre(t_start) = 0;
  pre(pre_fire) = false;
equation 
  // Handle conditional conditionPort
  connect(conditionPort, localCondition);
  if not use_conditionPort then
     localCondition = condition;
  end if;

  // Determine firing condition
   enableFire = localCondition and inPort.available;
    //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send_m enableFire " + String(enableFire));

   if delayedTransition then
     when enableFire then
        t_start = time;
     end when;
     pre_fire = enableFire and time >= t_start + waitTime;
     outPort.checkOneDelayedTransitionPerLoop = true;
  else
     t_start = 0;
     pre_fire = enableFire;
     if loopCheck then
        outPort.checkOneDelayedTransitionPerLoop = inPort.checkOneDelayedTransitionPerLoop;
     else
        outPort.checkOneDelayedTransitionPerLoop = true;
     end if;
   end if;
   for i in 1:SyncIn loop
     sender['['/]i[']'/].fire_ready_s =  if i == 1 then pre_fire and sender['['/]i[']'/].fire_ready_r and pre(message_output_port.fire)
                               else not sender['['/]i-1[']'/].fire_ready_s and 
                                    sender['['/]i[']'/].fire_ready_r and 
                                    pre_fire and message_output_port.fire;
    // Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send_m sender['['/]"+String(i)+"[']'/].fire_ready_s " + String(sender['['/]i[']'/].fire_ready_s));
   end for;

   for i in 1:SyncIn loop
     sender['['/]i[']'/].r = r;
   end for;
  message_output_port.active = if pre_fire and (message_output_port.hasMessage) and Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(sender.fire_ready_r) then true else false;
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send_m message_output_port.active " + String(message_output_port.active) +"hasMessage = " + String(message_output_port.hasMessage));
   fire =  pre_fire and Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(sender.fire_ready_s) and pre(message_output_port.fire);
   //Modelica.Utilities.Streams.print(String(time) + " SyncTransition_send_m fire " + String(fire));
if fire then
    message =  message_output_port.message;
  else
    message =  pre(message);
end if;
  //Modelica.Utilities.Streams.print(String(time) + " SyncTransition send message.t = " + String(message.t));

  inPort.fire  = fire;
  outPort.fire = fire;
  // Handling of node
  Connections.branch(inPort.node, outPort.node);
  outPort.node = inPort.node;

  annotation (defaultComponentName="SyncT1",
    Icon(
      coordinateSystem(extent={{-100,-100},{100,100}},initialScale=0.04,   preserveAspectRatio=true,
        grid={1,1}), graphics={
        Line(
          visible=not delayedTransition,
          points={{0,-2},{0,-102}},
          color={0,0,0}),
        Text(
          extent={{-150,-15},{150,15}},
          textString="%name",
          lineColor={0,0,255},
          origin={160,75},
          rotation=0),
        Rectangle(
          extent={{-100,-15},{100,15}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid,
          radius=10),
        Line(points={{-50,90},{-50,12}}, color={0,0,0}),
        Text(
          visible=not use_conditionPort,
          extent={{-300,-15},{300,15}},
          lineColor=DynamicSelect({128,128,128}, if condition > 0.5 then {0,255,
              0} else {128,128,128}),
          textString="%condition",
          origin={-155,-3},
          rotation=90),
        Text(
          visible=not loopCheck,
          extent={{10,-60},{400,-80}},
          lineColor={255,0,0},
          fillColor={170,255,213},
          fillPattern=FillPattern.Solid,
          textString="no check"),
        Line(
          visible=not loopCheck,
          points={{-50,-15},{-50,-100}},
          color={255,0,0},
          smooth=Smooth.None),
        Line(
          visible=not loopCheck,
          points={{50,-15},{50,-100}},
          color={255,0,0},
          smooth=Smooth.None)}),
      Documentation(info="<html>
                                      <p>
                                      <img src=\"../Images/StateGraph/Elements/SimpleStateGraph.png\" align=\"right\">
                                      To define a possible change of states, a Transition is connected to the output of the preceding Step and to the input of the succeeding Step, see figure to the right, where Transition t1 defines the transition from Step s1 to Step s2. Note: A Transition has exactly one preceding and one succeeding Step. A Transition is said to be enabled if the preceding step is active. An enabled transition is said to be fireable when the Boolean condition defined in the parameter menu of the transition is evaluated to <b>true</b>. This condition is also called <u>Transition condition</u> and is displayed in the icon of the Transition (e.g., &quot;time &gt; 1&quot; is the condition of Transition t1). When parameter <u>use_conditionPort</u> is set, the Transition condition is alternatively defined by a Boolean signal that is connected to the enabled <u>conditionPort</u>.
                                      </p>
                                      
                                      <p>
                                      A fireable transition will fire immediately. In the figure to the right, t1 fires when s1 is active and time is greater than one, i.e., s1 becomes inactive and s2 becomes active.
                                      The firing of a transition can optionally also be delayed for a certain period of time defined by parameter &quot;waitTime&quot;. See, e.g., t2 in the figure to right, that is delayed for one second before it may fire, given that the condition remains true and the preceding Step remains active during the entire delay time.
                                      </p>
                                      
                                      <p>
                                      In the following table different configurations of a Transition are shown:
                                      </p>
                                      
                                      <blockquote>
                                      <table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" width=\"600\">
                                      <tr><th>Parameter setting</th>
                                          <th>Icon</th>
                                          <th>Description</th></tr>
                                      
                                      <tr><td>Default transition</td>
                                          <td><img src=\"../Images/StateGraph/Elements/Transition-default.png\"></td>
                                          <td>The transition fires when the preceding step is active
                                              and the expression &quot;condition&quot; in the parameter menu is <b>true</b>.</td>
                                          </tr>
                                      
                                      <tr><td>use_conditionPort = <b>true</b></td>
                                          <td><img src=\"../Images/StateGraph/Elements/Transition-use_conditionPort.png\"></td>
                                          <td>The transition fires when the preceding step is active
                                              and connector &quot;conditionPort&quot; is <b>true</b>.</td>
                                          </tr>
                                      
                                      <tr><td>delayedTransition = <b>true</b></td>
                                          <td><img src=\"../Images/StateGraph/Elements/Transition-delayedTransition.png\"></td>
                                          <td>The transition fires after the delay time &quot;waitTime&quot; (here: 1.23 s),
                                              if the preceding step was active, and &quot;condition = <b>true</b>&quot;
                                              during the entire delay time.</td>
                                          </tr>
                                      
                                      <tr><td>use_firePort = <b>true</b></td>
                                          <td><img src=\"../Images/StateGraph/Elements/Transition-use_firePort.png\"></td>
                                          <td>Connector &quot;firePort&quot; is <b>true</b> when the transition fires.
                                              Actions may be triggered, e.g., by connecting block
                                              <a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean.MultiSwitch\">MultiSwitch</a>
                                              to the firePort.</td>
                                          </tr>
                                      
                                      <tr><td>loopCheck = <b>false</b><br>
                                              (in &quot;Advanced&quot; tab)</td>
                                          <td><img src=\"../Images/StateGraph/Elements/Transition-noLoopCheck.png\"></td>
                                          <td>It is <u>not</u> checked whether the loop in which this Transition
                                              is used, has at least one delayed transition.
                                              Use this option only, if you are completley sure that
                                              infinite event looping is not possible in this loop.
                                              Consider to use
                                              <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                                              instead!</td>
                                          </tr>
                                      
                                      </table>
                                      </blockquote>
                                      
                                      <p>
                                      <img src=\"../Images/StateGraph/Elements/SimpleInfiniteLoop.png\" align=\"right\">
                                      At an event instant, an iteration occurs, due to the Modelica semantics (= whenever a new event occurs, the model is re-evaluated). This means that Transitions keep firing along a connected graph, as long as the firing conditions are true. In principal, it is therefore possible that infinite event looping occurs.
                                      A simple example of this kind is shown in the figure to the right. Here, all Transition conditions are true and therefore all Transitions would fire forever at the initial time. This is, however, no valid StateGraph2 model and will result in a translation error, since it is required that a StateGraph2 model has at least one delayed Transition per loop.
                                      This means that one of T1, T2, or T3, must have parameter delayedTransition=<b>true</b>. Since event iteration stops at a delayed Transition, infinite event looping cannot occur. This also means that at one time instant every Transition can fire at most once and therefore the number of model evaluations at an event instant is bounded by the number of Transition components.
                                      </p>
                                      
                                      <p>
                                      If you have to artifically introduce a delay time in order to fulfill the requirement above, it is recommended to use the special
                                      <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
                                      that is designed for this case.
                                      </p>
                                      
                                      <p>
                                      Note, it is still possible that infinite event looping occurs due to <u>model errors</u> in other parts of the model. For example, if a user introduces an equation of the form &quot;J = <b>pre</b>(J) + 1&quot; outside of a when-clause, event iteration does not stop.
                                      </p>
                                      
                                      <p>
                                      There are rare situations, where infinite event looping cannot occur even if there is no delayed transition in a loop. When you do not want to introduce an artifical time delay in a loop in this case, you can switch off the loop check by setting parameter &quot;loopCheck = <b>false</b>&quot; in the &quot;Advanced&quot; tab of the parameter menu of one Transition in this loop.
                                      </p>
                                      
                                      </html>"),
    Diagram(coordinateSystem(
        preserveAspectRatio=true,
        extent={{-100,-100},{100,100}},
        grid={1,1}), graphics));
end SyncTransition_send_m;


package SyncChannels
    connector sender
      output Boolean fire_ready_s;
      input Boolean fire_ready_r;
      replaceable output rec r;
    end sender;

    connector receiver
      input Boolean fire_ready_s;
      output Boolean fire_ready_r;
      replaceable input rec r;
    end receiver;

    record rec
    end rec;
end SyncChannels;

[/template]

[**
 * 
 * @param traceabilityContext 
 */]
[template private generate_Functions(traceabilityContext : OclAny)]
function beforeIndexTrue 
  "Returns true, if a boolean element of the input with the index is true, else false"
   input Boolean b['['/]:[']'/];
   input Integer index;
   output Boolean t;
algorithm 
   t := false;
   for i in 1:size(b,1) loop
      if b['['/]i[']'/] and index == i then
         t := true;
         return;
      elseif b['['/]i[']'/] and index > i then
          return;
      end if;
   end for;
end beforeIndexTrue;
	
[/template]

[**
 * 
 * @param aRealtimeStatechart 
 */]
[template public generate_SyncChannels(aRealtimeStatechart : RealtimeStatechart)]
  package SyncChannels  
    [for (sync : SynchronizationChannel | getSyncChannels_h(aRealtimeStatechart->asSet()))]
  record [sync.name.toUpperFirst()/]
    extends Utilities.SyncChannels.rec;
  		[for (p : Parameter | sync.parameters)]
    [p.init_Parameter('')/]			
  		[/for]
  end [sync.name.toUpperFirst()/];
  
  connector [sync.name.toUpperFirst()/]_receiver = Utilities.SyncChannels.receiver (redeclare [sync.name.toUpperFirst()/] r);
  connector [sync.name.toUpperFirst()/]_sender = Utilities.SyncChannels.sender (redeclare [sync.name.toUpperFirst()/] r);
  	[/for]
  end SyncChannels;
[/template]

[**
 * 
 * @param aRealtimeStatechart 
 */]
[template public generate_ExtendedTransitions(aRealtimeStatechart : RealtimeStatechart)]
[if (aRealtimeStatechart.transitions->collect(t : Transition | getSyncChannel(t))->excluding(null).parameters->notEmpty() or aRealtimeStatechart.transitions->collect(getTriggerMessageType())->excluding(null).parameters->notEmpty())]
package ExtendedTransitions_[aRealtimeStatechart.name.toUpperFirst()/]	
	[for (t : Transition | aRealtimeStatechart.transitions->select(hasTriggerMessageEvent() and hasSyncChannel()))]
		//transition with trigger message and sync	
		[if (getSyncChannel(t).parameters->notEmpty() or t.getTriggerMessageType().parameters->notEmpty())]
model SyncTransition_[getSyncChannel(t).name.toUpperFirst()/]_[if (t.synchronization.kind = SynchronizationKind::SEND)]send[else]receive[/if]_[t.getTriggerMessageType().messageInterface.name.toUpperFirst()/]_[t.getTriggerMessageType().name.toUpperFirst()/]_message = Utilities.SyncTransition_[if (t.synchronization.kind = SynchronizationKind::SEND)]send[else]receive[/if]_m(
  [if(getSyncChannel(t).parameters->notEmpty())]redeclare Component_Utilities.SyncChannels.[getSyncChannel(t).name.toUpperFirst()/]_[if (t.synchronization.kind = SynchronizationKind::SEND)]sender[else]receiver[/if] [if (t.synchronization.kind = SynchronizationKind::SEND)]sender[else]receiver[/if],[/if] 
  [if(t.getTriggerMessageType().parameters->notEmpty())]redeclare Components.Ports.Message_[t.getTriggerMessageType().messageInterface.name.toUpperFirst()/]_[t.getTriggerMessageType().name.toUpperFirst()/]_output_port message_output_port, [/if]
  [if(t.getTriggerMessageType().parameters->notEmpty())]redeclare MessageInterfaces.Messages.Message_[t.getTriggerMessageType().messageInterface.name.toUpperFirst()/]_[t.getTriggerMessageType().name.toUpperFirst()/] message,[/if] 
  [if(getSyncChannel(t).parameters->notEmpty())]redeclare Component_Utilities.SyncChannels.[getSyncChannel(t).name.toUpperFirst()/] r[/if])
  annotation (Diagram(graphics));				
		[/if]
	[/for]
	
	[for (t : Transition | aRealtimeStatechart.transitions->select(hasTriggerMessageEvent() and not hasSyncChannel()))]
		//transition with trigger message
		[if (t.getTriggerMessageType().parameters->notEmpty())]
  model Transition_[t.getTriggerMessageType().messageInterface.name.toUpperFirst()/]_[t.getTriggerMessageType().name.toUpperFirst()/]_message = Utilities.Transition_message(
  redeclare Components.Ports.[getPortName(t.getTriggerMessageType(), t, 'output', false)/] message_output_port, 
  redeclare MessageInterfaces.Messages.[getMessageName(t.getTriggerMessageType(), t, false)/] message) 
  annotation (Diagram(graphics));		
		[/if]
	[/for]
	
	[for (t : Transition | aRealtimeStatechart.transitions)]
		// - [t.target.name/] [t.statechart.name/]
	[/for]
	
	[for (t : Transition | aRealtimeStatechart.transitions->select(t : Transition | t.getTriggerMessageEvent().oclIsUndefined() and hasSyncChannel(t)))]
		// - [t.target.name/]
		[if (getSyncChannel(t).parameters->notEmpty())]
model SyncTransition_[getSyncChannel(t).name.toUpperFirst()/]_[if (t.synchronization.kind = SynchronizationKind::SEND)]send[else]receive[/if] = Utilities.SyncTransition_[if (t.synchronization.kind = SynchronizationKind::SEND)]send[else]receive[/if](
  redeclare Component_Utilities.SyncChannels.[getSyncChannel(t).name.toUpperFirst()/]_[if (t.synchronization.kind = SynchronizationKind::SEND)]sender[else]receiver[/if] [if (t.synchronization.kind = SynchronizationKind::SEND)]sender[else]receiver[/if],
  redeclare Component_Utilities.SyncChannels.[getSyncChannel(t).name.toUpperFirst()/] r)
  annotation (Diagram(graphics));
  		[/if]
	[/for]	
	
	
end ExtendedTransitions_[aRealtimeStatechart.name.toUpperFirst()/];
[/if]
[/template]


[**
 * 
 * @param traceabilityContext 
 */]
[template public generate_Semaphore(traceabilityContext : OclAny)]
package Semaphores
  model Sem "model of an IPC semaphore"
    parameter Integer num = 1;
    parameter Integer n = 2 "number of connections to the semaphore";
    parameter Integer initValue = 0 "initial value for the semaphore";
    Integer value(start = initValue) "current semaphore value";
    SemPort port['['/]n[']'/] "connection ports";
    Integer releasesSem "last port that releases the semaphore";
    Integer getsSem "last port that gets the semaphore";
  protected 
    Integer p['['/]n[']'/];
    Integer v['['/]n[']'/];
    Boolean okp['['/]n[']'/];
    Boolean okv['['/]n[']'/];
    Integer waiting['['/]n[']'/] 
      "processes waiting on the semaphore for a number of resources";
    Integer waitorder['['/]n[']'/] "order for the processes waiting";
    Integer waitpos( start = 1);
    Integer j;
  equation 
    p = port.p;
    v = port.v;
    okp = port.okp;
    okv = port.okv;
  algorithm 
    for i in 1:n loop
      // ***** SIGNAL (V)
      when pre(v['['/]i[']'/]) > 0 then
       // Modelica.Utilities.Streams.print("V "+String(pre(v['['/]i[']'/]))+" on "+String(num));
        releasesSem := i;
        value := value + pre(v['['/]i[']'/]);
        // find first process waiting in the queue
        j := 1;
        while j < waitpos loop
          if (waiting['['/]waitorder['['/]j[']'/][']'/] <= value) and (waiting['['/]waitorder['['/]j[']'/][']'/] > 0) then
            value := value - waiting['['/]waitorder['['/]j[']'/][']'/];
            waiting['['/]waitorder['['/]j[']'/][']'/] := 0;
            okp['['/]waitorder['['/]j[']'/][']'/] := true;
            getsSem := waitorder['['/]j[']'/];
            for k in j:waitpos-1 loop
              if k < n then
                waitorder['['/]k[']'/] := waitorder['['/]k+1[']'/];
              else
                waitorder['['/]k[']'/] := 0;
              end if;
            end for;
            waitpos := waitpos -1;
            j := waitpos;
          else
            getsSem := 0;
            okp['['/]waitorder['['/]j[']'/][']'/] := false;
            j := j +1;
          end if;
        end while;
        okv['['/]i[']'/] := true;
        //Modelica.Utilities.Streams.print("End V");
      end when;
      // ***** WAIT (P)
      when p['['/]i[']'/]  > 0 then
       //Modelica.Utilities.Streams.print("P "+String(p['['/]i[']'/])+" on "+String(num)+" value = "+String(value));
       if value == 0 then
          waiting['['/]i[']'/] := p['['/]i[']'/];
          waitorder['['/]waitpos[']'/] := i;
          waitpos := waitpos +1;
          okp['['/]i[']'/] := false;
       else
          getsSem := i;
          //Modelica.Utilities.Streams.print(String(value));
          value := value - p['['/]i[']'/];
          //Modelica.Utilities.Streams.print(String(value));
          waiting['['/]i[']'/] := 0;
          okp['['/]i[']'/] := true;
       end if;
       //Modelica.Utilities.Streams.print("End P");
      end when;

      // ***** restore OK signal
      when {p['['/]i[']'/] == 0 and (pre(p['['/]i[']'/]) > 0) and value == pre(value), v['['/]i[']'/] == 0 and (pre(v['['/]i[']'/]) > 0) and value == pre(value)} then
        okp['['/]i[']'/] := false;
        okv['['/]i[']'/] := false;
      end when;
    end for;
  end Sem;

  connector SemPort
    Integer p;
    Integer v;
    Boolean okp( start = false);
    Boolean okv( start = false);
  end SemPort;

  annotation ();
end Semaphores;
	
[/template]

