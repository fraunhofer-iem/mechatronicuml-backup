[module port('http://www.fujaba.de/muml/instance/0.4.0',
			 'http://www.fujaba.de/muml/msgtype/0.4.0',
			 'http://www.fujaba.de/muml/component/0.4.0')/]

[import de::uni_paderborn::fujaba::muml::model::gen::modelica::rtsc::async::helper::port]
[import de::uni_paderborn::fujaba::muml::model::gen::modelica::rtsc::hybrid::hybrid]
[import de::uni_paderborn::fujaba::muml::model::gen::modelica::rtsc::hybrid::queries]

[import de::uni_paderborn::fujaba::muml::model::gen::modelica::instance::component::naming]
[import de::uni_paderborn::fujaba::muml::model::gen::modelica::instance::component::port_queries]

[**
 * Generate the ports for an atomic component.
 * @param portInstanceSet the set of port instances of the atomic component
*/]
[template public generatePorts(portInstanceSet : Set(PortInstance))]
	// port declarations
[for (port : PortInstance | portInstanceSet->select(not oclIsKindOf(DiscreteMultiPortInstance)))]
	[createPortDeclaration(port)/]
[/for]
	// end port declarations
[/template]


[template private createPortDeclaration(portInstance : PortInstance)]
	ERROR unexpected port instance [portInstance/]
[/template]

[**
 * Creates a declaration for a discrete input port
 * @param portInstance the discrete input port instance
*/]
[template private createPortDeclaration(portInstance : DiscreteSinglePortInstance) ? (
	portInstance.portType.oclAsType(DiscretePort).isDiscreteInPort
)]
[createInputPortDeclaration(portInstance)/]
[/template]

[**
 * Creates a declaration for a discrete output port
 * @param portInstance the discrete output port instance
*/]
[template private createPortDeclaration(portInstance : DiscreteSinglePortInstance) ? (
	portInstance.portType.oclAsType(DiscretePort).isDiscreteOutPort
)]
[createOutputPortDeclaration(portInstance)/]
[/template]

[**
 * Creates a declaration for a discrete inout port
 * @param portInstance the discrete inout port instance
*/]
[template private createPortDeclaration(portInstance : DiscreteSinglePortInstance) ? (
	portInstance.portType.oclAsType(DiscretePort).isDiscreteInOutPort
)]
[createInputPortDeclaration(portInstance)/]
[createOutputPortDeclaration(portInstance)/]
[/template]

[**
 * Creates declaration for a discrete input or inout port
 * @param portInstance the discrete input or inout port instance
*/]
[template private createInputPortDeclaration(portInstance : DiscreteSinglePortInstance)]
[for (messageType : MessageType | portInstance.portType.oclAsType(DiscretePort).receiverMessageTypes)]
[createInputDelegationPortDecl(messageType, portInstance.getInputPortName(messageType))/];
[/for]
[/template]

[**
 * Creates a declaration for a discrete output or inout port
 * @param portInstance the discrete output or inout port instance
*/]
[template private createOutputPortDeclaration(portInstance : DiscreteSinglePortInstance)]
[for (messageType : MessageType | portInstance.portType.oclAsType(DiscretePort).senderMessageTypes)]
[createOutputDelegationPortDecl(messageType, portInstance.getOutputPortName(messageType))/];
[/for]
[/template]

[**
 * Creates a declaration for a hybrid input or output port.
 * @param portInstance the hybrid input or output port instance
*/]
[template private createPortDeclaration(portInstance : HybridPortInstance)]
[createHybridPortConnector(portInstance)/]
[/template]

[**
 * Creates a declaration for a continuous input or output port.
 * @param portInstance the continuous input or output port instance
*/]
[template private createPortDeclaration(portInstance : ContinuousPortInstance)]
[portInstance.getModelicaConnectorType()/] [portInstance.getPortName()/];
[/template]

[**
 * Connect the atomic component instance ports with their corresponding rtsc ports
 * @param portInstanceSet the set of port instances
*/]
[template public connectPorts(portInstanceSet : Set(PortInstance)) {
	discretePortInstanceSet : Set(DiscretePortInstance) = portInstanceSet->select(oclIsKindOf(DiscretePortInstance))
		->collect(oclAsType(DiscretePortInstance))->asSet();
	hybridPortInstanceSet : Set(HybridPortInstance) = portInstanceSet->select(portType.oclIsKindOf(HybridPort))
		->collect(oclAsType(HybridPortInstance))->asSet();
	continuousPortInstanceSet : Set(ContinuousPortInstance) = portInstanceSet->select(portType.oclIsKindOf(ContinuousPort))
		->collect(oclAsType(ContinuousPortInstance))->asSet();
}]
[connectDiscretePorts(discretePortInstanceSet)/]
[connectHybridPorts(hybridPortInstanceSet)/]
[/template]

[**
 * Connect the atomic component instance discrete ports with their corresponding rtsc ports
 * @param discretePortInstanceSet the set of discrete port instances
*/]
[template private connectDiscretePorts(discretePortInstanceSet : Set(DiscretePortInstance))]
	// connect discrete component ports with the corresponding rtsc ports 
[for (discretePortInstance : DiscretePortInstance | discretePortInstanceSet->select(not oclIsKindOf(DiscreteMultiPortInstance)))]
[for (messageType : MessageType | discretePortInstance.receiverMessageTypes)]
	connect([discretePortInstance.getRTSCInputPortName(messageType)/],
		[discretePortInstance.getInputPortName(messageType)/]);
[/for]
[for (messageType : MessageType | discretePortInstance.senderMessageTypes)]
	connect([discretePortInstance.getRTSCOutputPortName(messageType)/],
		[discretePortInstance.getOutputPortName(messageType)/]);
[/for]
[/for]
	// connect discrete component ports with the corresponding rtsc ports
[/template]

[**
 * Connect the atomic component instance hybrid ports with their corresponding rtsc
 * connector.
 * @param hybridPortInstanceSet the set of hybrid port instances
*/]
[template private connectHybridPorts(hybridPortInstanceSet : Set(HybridPortInstance))]
	// connect hybrid component ports with the corresponding rtsc ports
[for (hybridPortInstance : HybridPortInstance | hybridPortInstanceSet)]
	connect([hybridPortInstance.getPortName()/],
		[hybridPortInstance.getBehaviorVariableName()/].[hybridPortInstance.getPortName()/]);
[/for]
	// end connect hybrid component ports with the corresponding rtsc ports
[/template]