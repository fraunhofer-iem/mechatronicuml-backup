[module queries('http://www.fujaba.de/muml/realtimestatechart/0.4.0',
			  'http://www.storydriven.org/core/0.3.1')/]

[import de::uni_paderborn::fujaba::muml::model::gen::modelica::rtsc::util::query::annotation]
[import de::uni_paderborn::fujaba::muml::model::gen::modelica::rtsc::util::query::rtsc]
[import de::uni_paderborn::fujaba::muml::model::gen::modelica::rtsc::util::query::naming]

[**
 * Creates an annotation for a state declaration
 * @TODO implement me (currently it returns a hardcoded string)
 * @param state the state (currently unused) 'annotation (Placement(transformation(extent={{-80,62},{-72,70}})))'
*/]
[query public createStateDeclAnnotation(element : ExtendableElement) : String =
	element.createNodeDeclAnnotation()
/]

[**
 * Returns the name of a complex state
 * @param state the complex state
*/]
[query public getComplexStateModelName(state : State) : String =
	'Complex_' + state.parentStatechart.name + '_' + state.name
/]

[**
 * Returns the path of the complex state's model file.
 * @param state the complex state
 * @param parentPackage the name of the parent package
*/]
[query public getPath(state : State, parentPackage : String) : String =
	let modelName : String = state.getComplexStateModelName()
	in
	parentPackage.replaceAll('\\.', '/') + '/' + modelName + '/' + modelName + '.mo'
/]

[**
 * Returns the initial state of the realtimestatechart
 * @param rtsc the realtimestatechart
*/]
[query public getInitialState(rtsc : RealtimeStatechart) : State =
	rtsc.states->select(s : State | s.initial)->at(1)
/]

[**
 * Returns the name of the invariant.
 * @param state the state to which the invariant (clock constraint) belongs to
 * @param clockConstraint the clock constraint
*/]
[query public getInvariantName(state : State, clockConstraint : ClockConstraint) : String =
	-- according to the techreport there is at most one invariant for a clock
	state.name + 'Invariant' + clockConstraint.clock.name
/]

[**
 * Returns the name of the corresponding modelica element for the
 * passed clock constraint/invariant.
 * @param clockConstraint the clock constraint
*/]
[query public getInvariantModelName(clockConstraint : ClockConstraint) : String =
	if clockConstraint.operator = ComparingOperator::LESS_OR_EQUAL then
		'RealTimeCoordinationLibrary.TimeElements.TimeInvariant.TimeInvariantLessOrEqual'
	else if clockConstraint.operator = ComparingOperator::LESS then
		'RealTimeCoordinationLibrary.TimeElements.TimeInvariant.TimeInvariantLess'
	else
		'ERROR: unexpected invariant operator'
	endif
	endif
/]

[**
 * Returns the nIn value for the passed state.
 * @param state the state
*/]
[query public getnInValue(state : State) : Integer =
	if state.initial and state.parentStatechart.embedded then
		if state.incomingTransitions->select(source.oclIsKindOf(EntryPoint))->notEmpty() then
			-- 0 because the delegation state already points to this state (because an entry point points to this state)
			0
		else
			-- 1 because we have to connect the parallel or delegation state with this state
			1
		endif
	else
		0
	endif + state.incomingTransitions->size() + state.getEntryPoints()->collect(incomingTransitions->size())->sum()
/]

[**
 * Returns the name for a do event's variable.
 * @param state the state which contains the do event
 * @param rtscSet ordered set of rtscs
*/]
[query private getUniqueDoEventVariableName(state : State, rtscSet : OrderedSet(RealtimeStatechart)) : String =
	let idx : Integer = rtscSet->indexOf(state.parentStatechart)
	in
	let predecessors : OrderedSet(RealtimeStatechart)
	=
	if idx = 1 then
		OrderedSet{}
	else
		rtscSet->subOrderedSet(1, idx - 1)
	endif
	in
	let names : Set(String) =
	predecessors->collect(states)->collect(s : State |
		getUniqueDoEventVariableName(s, predecessors)
	)->asSet()
	in
	getUniqueNameRec('doEvent_' + state.getFullyQualifiedName().replaceAll('\\.', '_'), '_doEvent', names)
/]

[**
 * Returns the name unique name for a do event's variable.
 * @param doEvent the do event
 * @param rtsc the (root) rtsc
*/]
[query public getVariableName(doEvent : DoEvent, rtsc : RealtimeStatechart) : String =
	let rtscSet : OrderedSet(RealtimeStatechart)
	=
	rtsc.allSubstatecharts()->including(rtsc)->sortedBy(getFullyQualifiedName())
	in
	let names : Set(String)
	=
	rtscSet->collect(allAvailableVariables)->collect(
		name
	)->union(
		rtscSet->collect(allAvailableOperations)->collect(name)
	)->asSet()
	in
	getUniqueNameRec(getUniqueDoEventVariableName(doEvent.eContainer().oclAsType(State), rtscSet), '_doEvent', names)
/]