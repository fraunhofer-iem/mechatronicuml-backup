import transforms.naming;
import transforms.util;

modeltype RTSC uses muml::realtimestatechart("http://www.fujaba.de/muml/0.4.0");
modeltype COMP uses muml::component("http://www.fujaba.de/muml/0.4.0");
modeltype PROT uses muml::protocol("http://www.fujaba.de/muml/0.4.0");
modeltype MSGTYPE uses muml::msgtype("http://www.fujaba.de/muml/0.4.0");
modeltype BEHAVIOR uses muml::behavior("http://www.fujaba.de/muml/0.4.0");
modeltype TYPES uses muml::types("http://www.fujaba.de/muml/0.4.0");
modeltype COREEXP uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype CORE uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype ACTION uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.4.0');
modeltype ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype TRANSFORM uses transform('http://www.fujaba.de/modelica/m2t/transform/0.4.0');

library SelectorExpression
	extends Util; // extends is only used due to a qvto bug, which is fixed in luna
	
property FIRST : String = "first";
property LAST : String = "last";
property SELF : String = "self";
property INT : String = "INT";


helper normalizeDiscreteInteractionEndpointReferences(root : RealtimeStatechart, sub : RealtimeStatechart, lastIdx : Integer) : RealtimeStatechart {
	sub.getDiscreteInteractionEndpointReferences()->forEach(ep) {
		normalize(ep, root, sub, lastIdx);
	};
	root.map fixupPortOrRoleDataTypes();
	return sub;
}

mapping RealtimeStatechart::fixupPortOrRoleDataTypes() {
	self.embeddedStatecharts()->collect(variables)->map fixupPortOrRoleDataType()
}

mapping inout Variable::fixupPortOrRoleDataType()
	when { self.dataType.oclIsKindOf(Port) or self.dataType.oclIsKindOf(Role) }
{
	// simply convert it to an integer
	// (that is how selector expressions are transformed)
	self.dataType := self.getDataType(INT);
}

helper normalize(inout ep : DiscreteInteractionEndpointReference, root : RealtimeStatechart, sub : RealtimeStatechart, lastIdx : Integer) {
	var feature : EStructuralFeature := ep.eContainingFeature();
	assert fatal (not feature.many) with log("unsupported expression");
	var container : EObject := ep.eContainer();
	var typedNamedElementExpression : TypedNamedElementExpression := ep.typedNamedElementExpression;
	var positionSelector : PositionSelector := ep.position;
	if (typedNamedElementExpression.oclIsUndefined()) then {
		typedNamedElementExpression := new TypedNamedElementExpression(ep.position.map getVariable(root, sub, lastIdx));
		// self.position should not be undefined in this case
		positionSelector := ep.position.successor;
	} endif;
	container.eSet(feature, buildNavigationExpression(typedNamedElementExpression, positionSelector));
	return;
}

helper buildNavigationExpression(typedNamedElementExpression : TypedNamedElementExpression, positionSelector : PositionSelector) : Expression {
	var cur : PositionSelector := positionSelector;
	var expr : Expression := typedNamedElementExpression;
	while (not cur.oclIsUndefined()) {
		expr := new ArithmeticExpression(expr, new LiteralExpression('1'),
			if cur.kind = PositionSelectorKind::NEXT then ArithmeticOperator::PLUS else ArithmeticOperator::MINUS endif);
		cur := cur.successor;
	};
	return expr;
}

mapping PositionSelector::getVariable(root : RealtimeStatechart, sub : RealtimeStatechart, lastIdx : Integer) : Variable
	disjuncts PositionSelector::getFirstVariable, PositionSelector::getLastVariable, PositionSelector::getSelfVariable;
	
mapping PositionSelector::getFirstVariable(root : RealtimeStatechart, sub : RealtimeStatechart, lastIdx : Integer) : Variable
	when {self.kind = PositionSelectorKind::FIRST}
{
	init {
		result := map createSelectorConstant(root, FIRST, 1);
	}
}

mapping PositionSelector::getLastVariable(root : RealtimeStatechart, sub : RealtimeStatechart, lastIdx : Integer) : Variable
	when {self.kind = PositionSelectorKind::LAST}	
{
	init {
		result := map createSelectorConstant(root, LAST, lastIdx);
	}
}

mapping PositionSelector::getSelfVariable(root : RealtimeStatechart, sub : RealtimeStatechart, lastIdx : Integer) : Variable
	when {self.kind = PositionSelectorKind::SELF}
{
	init {
		result := map createSelectorConstant(sub, SELF, sub.parentRegion.priority);
	}
}

mapping createSelectorConstant(rtsc : RealtimeStatechart, name : String, idx : Integer) : Variable {
	//var variable : Variable := createVariable(rtsc, name, rtsc.getDataType(INT));
	//variable.initializeExpression := new LiteralExpression(idx.toString());
	//return variable;
	init {
		result := createVariable(rtsc, name, rtsc.getDataType(INT));
	}
	constant := true;
	initializeExpression := new LiteralExpression(idx.toString());
}

query RealtimeStatechart::getDiscreteInteractionEndpointReferences() : Set(DiscreteInteractionEndpointReference) {
	return self.allEntryEventExpressions()->union(self.allExitEventExpressions())
		->union(self.allActionExpressions())->union(self.allSynchronizationExpressions())
		->getDiscreteInteractionEndpointReferences();
}

query RealtimeStatechart::allEntryEventExpressions() : Set(Expression) {
	return self.embeddedStatecharts()->collect(states)->select(
		not entryEvent.oclIsUndefined() and not entryEvent.action.oclIsUndefined()
	)->collect(entryEvent.action.expressions)->asSet()
}

query RealtimeStatechart::allExitEventExpressions() : Set(Expression) {
	return self.embeddedStatecharts()->collect(states)->select(
		not exitEvent.oclIsUndefined() and not exitEvent.action.oclIsUndefined()
	)->collect(exitEvent.action.expressions)->asSet();
}

query RealtimeStatechart::allActionExpressions() : Set(Expression) {
	return self.embeddedStatecharts()->collect(transitions)->select(
		not action.oclIsUndefined()
	)->collect(action.expressions)->asSet();
}

query RealtimeStatechart::allSynchronizationExpressions() : Set(Expression) {
	return self.embeddedStatecharts()->collect(transitions)->select(
		not synchronization.oclIsUndefined() and not synchronization.selectorExpression.oclIsUndefined()
	)->collect(synchronization.selectorExpression)->asSet()
}

query Set(Expression)::getDiscreteInteractionEndpointReferences() : Set(DiscreteInteractionEndpointReference) {
	return self->closure(e : Expression |
		if e.oclIsKindOf(DiscreteInteractionEndpointReference) then
			e->asSet()
		else
			e.eContents()->select(oclIsKindOf(Expression))
		endif		
	)->select(oclIsKindOf(DiscreteInteractionEndpointReference))->collect(oclAsType(DiscreteInteractionEndpointReference))->asSet()
}