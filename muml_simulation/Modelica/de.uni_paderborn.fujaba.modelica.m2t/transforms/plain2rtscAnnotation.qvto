import transforms.naming;

modeltype GRAPHVIZ uses input("http://www.fujaba.de/graphviz/input/0.1.0");
modeltype PLAIN uses output("http://www.fujaba.de/graphviz/output/0.1.0");
modeltype RTSC uses muml::realtimestatechart("http://www.fujaba.de/muml/0.4.0");
modeltype CORE uses core("http://www.storydriven.org/core/0.3.1");
modeltype ECORE uses ecore("http://www.eclipse.org/emf/2002/Ecore");

transformation plain2rtscAnnotation(inout rtscModel : RTSC, in graphvizModel : GRAPHVIZ, in plainModel : PLAIN)
	access Naming;

property WIDTH : Real = 0;
property HEIGHT : Real = 0;

property INCH_MM : Real = 25.4;

property ANNOTATION_SOURCE : String = "MODELICA_CODEGEN";

property RTSC_SCALE : String = "scale";
property RTSC_WIDTH : String = "width";
property RTSC_HEIGHT : String = "height";

property NODE_X_LEFT : String = "xleft";
property NODE_Y_LEFT : String = "yleft";
property NODE_X_RIGHT : String = "xright";
property NODE_Y_RIGHT = "yright";

property TRANSITION_POLY_SOURCE : String = "source_points";
property TRANSITION_POLY_TARGET : String = "target_points";

property POLY_MESSAGE_DELEGATION : String = "message_delegation_points";
property POLY_MAILBOX_DELEGATION : String = "mailbox_delegation_points";

property ROOT_RTSC : RealtimeStatechart = null;
	

main() {
    log("transformation " + this.toString() + " started");
   // log(rtscModel.objects()[RealtimeStatechart]->any(true).resolve()->size().toString());
 //   rtscModel.objects()[RealtimeStatechart]->map createContainer();
 	assert fatal (plainModel.objects()[PLAIN::Graph]->size() = 1) with log("ERR");
 	plainModel.objects()[PLAIN::Graph]->any(true).layout();
 	plainModel.objects()[PLAIN::Node]->forEach(pNode) {
 		pNode.layout();
 	};
 	log("edges: " + plainModel.objects()[PLAIN::Edge]->size().toString());
 	plainModel.objects()[PLAIN::Edge]->forEach(pEdge) {
 		pEdge.layout();
 	};
    log("transformation " + this.toString() + " finished");
}

helper PLAIN::Graph::layout() {
	graphvizModel.objects()[Graph]->select(parentGraph.oclIsUndefined())->any(true).invresolveone(RealtimeStatechart).annotate(self);
}

helper RealtimeStatechart::annotate(pGraph : PLAIN::Graph) {
	this.ROOT_RTSC := self;
	log("rtsc annotate: " + self.name);
	var ann : EAnnotation := self.map getOrCreateAnnotation(ANNOTATION_SOURCE);
	this.WIDTH := pGraph.width;
	this.HEIGHT := pGraph.height;
	ann.map addDetail(RTSC_SCALE, inchToMM(pGraph.scale));
	ann.map addDetail(RTSC_WIDTH, inchToMM(xTrans(pGraph.width)));
	ann.map addDetail(RTSC_HEIGHT, inchToMM(yTrans(pGraph.height)));
}

helper PLAIN::Node::layout() {
	var gNode : Node := self.getGNode();
	assert fatal (gNode != null) with log("no graphviz node found for node " + self.name);
	assert fatal (gNode.invresolve()->size() = 1) with log("ERRX");
	var res : OclAny := gNode.invresolveone();
	assert fatal (res != null) with log("no match in rtsc model for graphviz node " + gNode.name);
	res.map annotate(self);
	//return null;
}

helper PLAIN::Edge::layout() {
	var gSource : Node := self.source.getGNode();
	var gTarget : Node := self.target.getGNode();
	assert fatal (gSource != null) with log("source graphviz node not found");
	assert fatal (gTarget != null) with log("target graphviz node not found");
	var gSourceInv : OclAny := gSource.invresolveone();
	var gTargetInv : OclAny := gTarget.invresolveone();
	var gEdge : Edge := getGEdge(gSource, gTarget);
	assert fatal (gEdge != null) with log("graphviz edge not found: " + gSourceInv.toString() + " -> " + gTargetInv.toString());
	if (gSourceInv.oclIsKindOf(State) or gTargetInv.oclIsKindOf(State)) then {
		log("OK XXX" + gSourceInv.toString() + " # " + gTargetInv.toString());
		var gEdgeInv : Transition := gEdge.invresolveone(Transition);
		var ann : EAnnotation := gEdgeInv.annotate(self, getTransitionAnnotationKind(gSourceInv, gTargetInv));
		if (gTargetInv.oclIsKindOf(Transition)) then {
			ann.addNodeDetails(self.target);
		} endif;
		assert fatal (gEdgeInv != null) with log("no rtsc transition for graphviz edge")
	} else {
		if (gSourceInv.oclIsKindOf(AsynchronousMessageEvent) and gTargetInv.oclIsKindOf(AsynchronousMessageEvent)) then {
			gSourceInv.oclAsType(AsynchronousMessageEvent).annotate(self);
		} endif;
	} endif;
	//return graphvizModel.objects()[Edge]->select()
}

helper getGEdge(gSource : Node, gTarget : Node) : Edge {
	log("get edge for: " + gSource.name + " -> " + gTarget.name);
	var edges : Set(Edge) := graphvizModel.objects()[Edge]->select(source = gSource and target = gTarget);
	assert fatal (edges->size() = 1) with log("unexpected edges size");
	return edges->any(true);
}

query getTransitionAnnotationKind(source : OclAny, target : OclAny) : String {
	return if (source.oclIsKindOf(State)) then
		TRANSITION_POLY_SOURCE
	else
		 TRANSITION_POLY_TARGET
	endif;
}

helper Transition::annotate(pEdge : PLAIN::Edge, kind : String) : EAnnotation {
	var ann : EAnnotation := self.map getOrCreateAnnotation(ANNOTATION_SOURCE);
	ann.addTransitionDetails(pEdge, kind);
	return ann;
}

helper AsynchronousMessageEvent::annotate(pEdge : PLAIN::Edge) {
	var ann : EAnnotation := this.ROOT_RTSC.map getOrCreateAnnotation(ANNOTATION_SOURCE);
	if (self.kind = EventKind::RAISE) then {
		ann.addTransitionDetails(pEdge, self.getMessageName() + '_' + POLY_MESSAGE_DELEGATION);
	} else {
		ann.addTransitionDetails(pEdge, self.getMailboxName() + '_' + POLY_MAILBOX_DELEGATION);
	} endif;
}

helper EAnnotation::addTransitionDetails(pEdge : PLAIN::Edge, kind : String) {
	var points : String := '';
	pEdge.splinePoints->forEach(p) {
		points := points + ', ' + '{' + inchToMM(xTrans(p.x)) + ',' + inchToMM(yTrans(p.y)) + '}';
	};
	self.map addDetail(kind, points.substring(2, points.length()));
}

// this mapping is also called for a transition but ignored
mapping inout OclAny::annotate(pNode : PLAIN::Node)
	disjuncts State::annotate, AsynchronousMessageEvent::annotate;
	
mapping inout State::annotate(pNode : PLAIN::Node) {
	var ann : EAnnotation := self.map getOrCreateAnnotation(ANNOTATION_SOURCE);
	ann.addNodeDetails(pNode);
}

mapping inout AsynchronousMessageEvent::annotate(pNode : PLAIN::Node) {
	log("annontate async");
	var ann : EAnnotation := this.ROOT_RTSC.map getOrCreateAnnotation(ANNOTATION_SOURCE);
	ann.addNodeDetails(pNode, pNode.name + '_');
}

query PLAIN::Node::getGNode() : Node {
	return graphvizModel.objects()[Node]->select(name = self.name.replaceAll('"', ''))->any(true);
}

mapping inout ExtendableElement::getOrCreateAnnotation(src : String) : EAnnotation {
	init {
		result := self.annotation->select(source = src)->any(true);
	}
	if (not self.annotation->includes(result)) then {
		self.annotation := self.annotation->union(Set{result});
	} endif;
	result.source := src;
}

helper EAnnotation::addNodeDetails(pNode : PLAIN::Node) {
	self.addNodeDetails(pNode, '');
}

helper EAnnotation::addNodeDetails(pNode : PLAIN::Node, prefix : String) {
	self.map addDetail(prefix + NODE_X_LEFT, inchToMM(xTrans(pNode.position.x - pNode.width * 0.5)));
	self.map addDetail(prefix + NODE_X_RIGHT, inchToMM(xTrans(pNode.position.x + pNode.width * 0.5)));
	self.map addDetail(prefix + NODE_Y_LEFT, inchToMM(yTrans(pNode.position.y - pNode.height * 0.5)));
	self.map addDetail(prefix + NODE_Y_RIGHT, inchToMM(yTrans(pNode.position.y + pNode.height * 0.5)));
}

mapping inout EAnnotation::addDetail(key : String, val : String) {
	self.details += new EStringToStringMapEntry(key, val);
}

constructor EStringToStringMapEntry::EStringToStringMapEntry(key : String, val : String) {
	result.key := key;
	result.value := val;
}

query xTrans(val : Real) : Real {
	return val - (this.WIDTH * 0.5);
}

query yTrans(val : Real) : Real {
	return val - (this.HEIGHT * 0.5);
}

query inchToMM(inch : Real) : String {
	return _inchToMM(inch).toString();
}

query _inchToMM(inch : Real) : Real {
	return inch * INCH_MM;
}
