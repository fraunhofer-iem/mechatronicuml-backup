import MUML2MUML;

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype RTSCPackage uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype TypesPackage uses muml::types("http://www.fujaba.de/muml/0.4.0");
modeltype ValuetypePackage uses muml::valuetype("http://www.fujaba.de/muml/0.4.0");
modeltype MessageTypePackage uses muml::msgtype("http://www.fujaba.de/muml/0.4.0");
modeltype BehaviorPackage uses muml::behavior("http://www.fujaba.de/muml/0.4.0");
modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.4.0");
modeltype PatternPackage uses pattern('http://www.fujaba.de/muml/pattern/0.3.18');

transformation TransformPatternToProtocol(inout input : ModelInstancePackage);

main()
{ 
// get the input parameters. There is exactly one root and exactly one coordination pattern
	
	var thePattern : CoordinationPattern := input.rootObjects()[CoordinationPattern]->any(true);
	var theRootNode : RootNode := thePattern.eContainer().eContainer().oclAsType(RootNode);
	//var patternCategory : ModelElementCategory  :=theRootNode.categories-> select(c : ModelElementCategory | c.key = 'pattern.category') -> any(true);
	//var thePattern := patternCategory.modelElements->any(true).oclAsType(CoordinationPattern);
	var bindings : Set(ParameterBinding) := input.rootObjects()[ParameterBinding];
	createProtocol(thePattern, theRootNode, bindings);

	
}

 // this helper method will be put into an extra transformation later --> Transformation steps
helper bindParameters(protocol : CoordinationProtocol, bindings : Set(ParameterBinding))
{
	
}
helper createProtocol(pattern : CoordinationPattern, root : RootNode, bindings : Set(ParameterBinding))
{
	var newProtocol : CoordinationProtocol := new CoordinationProtocol(pattern);
	var connector : RoleConnector  := new RoleConnector(pattern.roleConnector.comment);
	newProtocol.roleConnector := connector;
	pattern.roles->forEach(role)
	{
		var newRole := new Role(role,newProtocol);		
		role.receiverMessageBuffer->forEach(buffer)
		{
			newRole.receiverMessageBuffer += new MessageBuffer(buffer,newRole);
		};
		newProtocol.roles+= newRole;
		connector.connectorEndpoints+= newRole;
		if(role.behavior != null)
		{
			var roleBehavior : Behavior := role.behavior.map Behavior2Behavior();
			newRole.behavior := roleBehavior.oclAsType(RealtimeStatechart);
			var rtscCategory := getRTSCCategory(root);
			rtscCategory.modelElements+=roleBehavior.oclAsType(RealtimeStatechart);
		}
	};
	
	bindParameters(newProtocol, bindings);
	var protocolCategory : ModelElementCategory := getProtocolCategory(root);
	protocolCategory.modelElements +=newProtocol;
}
constructor ConnectorQualityOfServiceAssumptions::ConnectorQualityOfServiceAssumptions(patternqosa : ConnectorQualityOfServiceAssumptions)
{
	messageLossPossible := patternqosa.messageLossPossible;
	comment := patternqosa.comment;
	minMessageDelay	:= new TimeValue(patternqosa.minMessageDelay);
	maxMessageDelay := new TimeValue(patternqosa.maxMessageDelay);
}

constructor TimeValue::TimeValue(valueToCopy : TimeValue)
{
	value := null;
	unit := valueToCopy.unit;
}
constructor RoleConnector::RoleConnector(_comment : String) {
	comment:=_comment;	
}
query getProtocolCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.protocol.category') -> any(true);
}

constructor muml::constraint::VerificationConstraintRepository::VerificationConstraintRepository(rep : muml::constraint::VerificationConstraintRepository)
{
	
}
constructor CoordinationProtocol::CoordinationProtocol(pattern : CoordinationPattern) {	
	name:=pattern.name;	
	comment := pattern.comment;
	
}
constructor MessageBuffer::MessageBuffer(buffer : MessageBuffer, sourceRole : Role)
{
	name := buffer.name;
	bufferSize := new NaturalNumber(buffer.bufferSize);
	comment := buffer.comment;
	buffer.messageType->forEach(type)
	{
		messageType+= type;
	};
	bufferOverflowAvoidanceStrategy := buffer.bufferOverflowAvoidanceStrategy;
	discreteInteractionEndpoint := sourceRole;	
}
constructor Role::Role(roleToCopy : Role, protocol : CoordinationProtocol)
{
	// behavior is missing --> maybe we can use the existing transformation for copying the role to port properties
	//roleconnector is read only
	name :=  roleToCopy.name;
	// no new objects, since it is a reference to a given message type!
	senderMessageTypes := roleToCopy.senderMessageTypes; 
	receiverMessageTypes := roleToCopy.receiverMessageTypes;
	comment := roleToCopy.comment;
	// role 
	//coordinationProtocol := protocol;
	
	cardinality := new Cardinality(roleToCopy.cardinality);
	
}
constructor Cardinality::Cardinality(c :Cardinality)
{
	lowerBound := new NaturalNumber(c.lowerBound);
	upperBound := new NaturalNumber(c.upperBound);
}

constructor NaturalNumber::NaturalNumber(nn : NaturalNumber)
{
	value := nn.value;
	infinity := nn.infinity;	
}

-- return the RTSC category of the root node
query getRTSCCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.realtimestatechart.category') -> any(true);
}

mapping muml::realtimestatechart::RealtimeStatechart :: RealtimeStatechart2RealtimeStatechart() : muml::realtimestatechart::RealtimeStatechart{
    	_name := self._name;
    	_comment := self._comment;
    	_annotation := self._annotation.map EAnnotation2EAnnotation();
    	_extension := self._extension.map Extension2Extension();
    	//_behavioralElement := self._behavioralElement.map BehavioralElement2BehavioralElement();
    	_operations := self._operations.map Operation2Operation();
    	_variables := self._variables.map Variable2Variable();
    	_parentRegion := self._parentRegion.map Region2Region();
    	_transitions := self._transitions.map Transition2Transition();
    	_states := self._states.map State2State();
    	_clocks := self._clocks.map Clock2Clock();
   		 }


