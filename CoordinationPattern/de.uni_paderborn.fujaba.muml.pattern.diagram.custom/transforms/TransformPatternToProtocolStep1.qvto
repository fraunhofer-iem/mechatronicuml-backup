import MUML2MUML;
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype RTSCPackage uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype TypesPackage uses muml::types("http://www.fujaba.de/muml/0.4.0");
modeltype ValuetypePackage uses muml::valuetype("http://www.fujaba.de/muml/0.4.0");
modeltype MessageTypePackage uses muml::msgtype("http://www.fujaba.de/muml/0.4.0");
modeltype BehaviorPackage uses muml::behavior("http://www.fujaba.de/muml/0.4.0");
modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.4.0");
modeltype PatternPackage uses muml::pattern('http://www.fujaba.de/muml/0.4.0');
modeltype ActionLanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';

transformation TransformPatternToProtocolStep1(inout input : ModelInstancePackage);

main()
{ 
// get the input parameters. There is exactly one root and exactly one coordination pattern
	
	// test case: get Pattern P10
	//var theRootNode : RootNode := input.rootObjects()[RootNode] -> any(true);		
	//var thePattern : CoordinationPattern := getPatternCategory(theRootNode).modelElements->select(p | p.oclAsType(CoordinationPattern).name.equalsIgnoreCase("P10"))->any(true).oclAsType(CoordinationPattern);
	//bindings :=thePattern.legalConfigurations->any(true).parameterBindings;
	
	var thePattern : CoordinationPattern := input.rootObjects()[CoordinationPattern] -> any(true);
	
	var theRootNode : RootNode := thePattern.eContainer().eContainer().oclAsType(RootNode);
	
    bindings := input.rootObjects()[ParameterBinding];
	createProtocol(thePattern, theRootNode);
//	input.objects()[ParameterExpression];
	//theRootNode.oclAsType(EObject)->asSet()->closure(e:EObject|e.eContents()->collect(oclAsType(EObject)))[ParameterExpression];
}


helper createProtocol(pattern : CoordinationPattern, root : RootNode)
{
	var newProtocol : CoordinationProtocol := new CoordinationProtocol(pattern);
	var statechartCategory : ModelElementCategory := getRealtimeStatechartCategory(root);
	newProtocol.roleConnector := pattern.roleConnector.map RoleConnector2RoleConnector();
	pattern.roles->forEach(role)
	{
		var newRole := new Role(role,newProtocol);		
		role.receiverMessageBuffer->forEach(buffer)
		{
			newRole.receiverMessageBuffer += new MessageBuffer(buffer,newRole);			
		};
		newRole.behavior := role.behavior.oclAsType(RealtimeStatechart).map RealtimeStatechart2RealtimeStatechart();
		//set behavorial element?? --> should be already considered when setting behavior of the role!
		statechartCategory.modelElements += newRole.behavior.oclAsType(RealtimeStatechart);
		newProtocol.roles+= newRole;
		newProtocol.roleConnector.connectorEndpoints+=newRole;
	};
		
	var protocolCategory : ModelElementCategory := getProtocolCategory(root);
	protocolCategory.modelElements +=newProtocol;
}


mapping CoordinationProtocol :: coordinationPattern2CoordinationProtocol(): CoordinationPattern
{
	_name := self._name;
    _comment := self._comment;
    _annotation := self._annotation.map EAnnotation2EAnnotation();
    _extension := self._extension.map Extension2Extension();
    _verificationConstraintRepositories := self._verificationConstraintRepositories.map VerificationConstraintRepository2VerificationConstraintRepository();
    _roles := self._roles.map Role2Role();
    _roleConnector := self._roleConnector.map RoleConnector2RoleConnector();
}


query getRealtimeStatechartCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.realtimestatechart.category') -> any(true);
}
query getProtocolCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.protocol.category') -> any(true);
}
query getPatternCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.pattern.category') -> any(true);
}
helper copyMessageBuffer(protocol : CoordinationProtocol, pattern : CoordinationPattern)
{
	protocol.verificationConstraintRepositories
}

constructor muml::constraint::VerificationConstraintRepository::VerificationConstraintRepository(rep : muml::constraint::VerificationConstraintRepository)
{
	
}
constructor CoordinationProtocol::CoordinationProtocol(pattern : CoordinationPattern) {	
	name:=pattern.name;	
	comment := pattern.comment;
	
}
constructor MessageBuffer::MessageBuffer(buffer : MessageBuffer, sourceRole : Role)
{
	name := buffer.name;
	bufferSize := new NaturalNumber(buffer.bufferSize);
	comment := buffer.comment;
	buffer.messageType->forEach(type)
	{
		messageType+= type;
	};
	bufferOverflowAvoidanceStrategy := buffer.bufferOverflowAvoidanceStrategy;
	discreteInteractionEndpoint := sourceRole;
	
}
constructor Role::Role(roleToCopy : Role, protocol : CoordinationProtocol)
{
	// behavior is missing --> maybe we can use the existing transformation for copying the role to port properties
	//roleconnector is read only
	name :=  roleToCopy.name;
	// no new objects, since it is a reference to a given message type!
	senderMessageTypes := roleToCopy.senderMessageTypes; 
	receiverMessageTypes := roleToCopy.receiverMessageTypes;
	comment := roleToCopy.comment;
	// role 
	coordinationProtocol := protocol;
	
	cardinality := new Cardinality(roleToCopy.cardinality);
	
}
constructor Cardinality::Cardinality(c :Cardinality)
{
	lowerBound := new NaturalNumber(c.lowerBound);
	upperBound := new NaturalNumber(c.upperBound);
}

constructor NaturalNumber::NaturalNumber(nn : NaturalNumber)
{
	value := nn.value;
	infinity := nn.infinity;	
}


mapping muml::realtimestatechart::RealtimeStatechart :: RealtimeStatechart2RealtimeStatechart() : muml::realtimestatechart::RealtimeStatechart{
    	_name := self._name;
    	_comment := self._comment;
    	_annotation := self._annotation.map EAnnotation2EAnnotation();
    	_extension := self._extension.map Extension2Extension();
    //	_behavioralElement := self._behavioralElement.map BehavioralElement2BehavioralElement();
    	_operations := self._operations.map Operation2Operation();
    	_variables := self._variables.map Variable2Variable();
    	_parentRegion := self._parentRegion.map Region2Region();
    	_transitions := self._transitions.map Transition2Transition();
    	_states := self._states.map State2State();
    	_clocks := self._clocks.map Clock2Clock();
   		 }
mapping core::expressions::Expression :: Expression2Expression() : core::expressions::Expression disjuncts core::expressions::common::LiteralExpression::LiteralExpression2LiteralExpression, actionlanguage::TypedNamedElementExpression::TypedNamedElementExpression2TypedNamedElementExpression, actionlanguage::LocalVariableDeclarationStatement::LocalVariableDeclarationStatement2LocalVariableDeclarationStatement, actionlanguage::IfStatement::IfStatement2IfStatement, actionlanguage::ReturnStatement::ReturnStatement2ReturnStatement, actionlanguage::Assignment::Assignment2Assignment, core::expressions::TextualExpression::TextualExpression2TextualExpression, actionlanguage::NondeterministicChoiceExpression::NondeterministicChoiceExpression2NondeterministicChoiceExpression, actionlanguage::PositionSelector::PositionSelector2PositionSelector, actionlanguage::ArrayInitializeExpression::ArrayInitializeExpression2ArrayInitializeExpression, actionlanguage::DiscreteInteractionEndpointReference::DiscreteInteractionEndpointReference2DiscreteInteractionEndpointReference, actionlanguage::TriggerMessageExpression::TriggerMessageExpression2TriggerMessageExpression, actionlanguage::Block::Block2Block, core::expressions::common::BinaryExpression::BinaryExpression2BinaryExpression, core::expressions::common::UnaryExpression::UnaryExpression2UnaryExpression, actionlanguage::OperationCall::OperationCall2OperationCall, actionLanguage::ParameterExpression :: ParameterExpression2Expression;
      	


mapping actionLanguage::ParameterExpression :: ParameterExpression2Expression() : core::expressions::Expression {		
	init {
		var myExp : core::expressions::Expression =  getBoundExpressionToGivenParameter(self.parameter);
		result := myExp.map Expression2Expression();
		}	
	
	}
	
	query getBoundExpressionToGivenParameter(in parameter : Parameter) : core::expressions::Expression {	
	if (bindings->one(p : ParameterBinding | p.parameter=parameter))
	{
		return bindings->any(p : ParameterBinding | p.parameter=parameter).value;
	};
	return null;
}		
   		 

mapping muml::protocol::RoleConnector :: RoleConnector2RoleConnector() : muml::protocol::RoleConnector{
    	_comment := self._comment;
    	_annotation := self._annotation.map EAnnotation2EAnnotation();
    	_extension := self._extension.map Extension2Extension();
    	//_connectorEndpoints := self._connectorEndpoints.map ConnectorEndpoint2ConnectorEndpoint();
    	//_coordinationProtocol := self._coordinationProtocol.map AbstractCoordinationSpecification2AbstractCoordinationSpecification();
    	_connectorQualityOfServiceAssumptions := self._connectorQualityOfServiceAssumptions.map ConnectorQualityOfServiceAssumptions2ConnectorQualityOfServiceAssumptions();
   		 }


