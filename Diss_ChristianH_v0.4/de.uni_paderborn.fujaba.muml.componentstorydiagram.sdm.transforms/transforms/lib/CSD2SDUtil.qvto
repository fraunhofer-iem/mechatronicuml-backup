import queries;

library CSD2SDUtil;

modeltype sdPatterns uses storydiagrams::patterns('http://www.storydriven.org/storydiagrams/0.2.1');

modeltype componentInstanceConfiguration uses 'http://www.fujaba.de/muml/instance/0.4.0';

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';

modeltype reconfiguration uses 'http://www.fujaba.de/muml/reconfiguration/0.3.18';

modeltype csp uses 'http://www.fujaba.de/muml/componentstorypattern/0.4.0';

modeltype componentModel uses muml::component('http://www.fujaba.de/muml/0.4.0');

modeltype core uses 'http://www.storydriven.org/core/0.3.1';

modeltype sd_expressions uses core::expressions ('http://www.storydriven.org/core/0.3.1');


mapping componentstorypattern::ComponentStoryPattern :: createInitialCIC() : ObjectVariable{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := 'rootCIC';
	classifier:=ComponentInstanceConfiguration.oclAsType(EClass);
}

mapping componentstorypattern::ComponentVariable:: createEmbeddedCIC() : ObjectVariable{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := 'embeddedCIC';
	classifier:=ComponentInstanceConfiguration.oclAsType(EClass);
}

mapping componentstorypattern::ComponentStoryPatternVariable ::createComponentInstance() : ObjectVariable disjuncts componentstorypattern::ComponentVariable :: createStructuredComponentInstance,
 componentstorypattern::ComponentVariable :: createAtomicComponentInstance,
  componentstorypattern::PartVariable ::createStructuredComponentInstance,
   componentstorypattern::PartVariable ::createAtomicComponentInstance;


mapping componentstorypattern::ComponentVariable :: createStructuredComponentInstance() : ObjectVariable
 when{self.type.eClass() = ReconfigurableStructuredComponent or self.type.eClass() = StaticStructuredComponent}{
 	annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name;
	classifier := StructuredComponentInstance.oclAsType(EClass);
	bindingState := self._bindingState;
    bindingSemantics := self._bindingSemantics;
    bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::ComponentVariable :: createAtomicComponentInstance() : ObjectVariable 
when {self.type.eClass() = AtomicComponent or self.type.eClass() = ReconfigurableAtomicComponent}{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name;
	classifier := AtomicComponentInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
    _bindingSemantics := self._bindingSemantics;
    _bindingOperator := self._bindingOperator;
}

//mapping componentstorypattern::PartVariable ::createComponentInstance() : ObjectVariable disjuncts componentstorypattern::PartVariable ::createStructuredComponentInstance, componentstorypattern::PartVariable ::createAtomicComponentInstance;

mapping componentstorypattern::PartVariable ::createStructuredComponentInstance() : ObjectVariable
when {self.type.componentType.eClass() = StaticStructuredComponent or self.type.componentType.eClass() = ReconfigurableStructuredComponent}{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name;
	classifier := StructuredComponentInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
    _bindingSemantics := self._bindingSemantics;
    _bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PartVariable ::createAtomicComponentInstance() : ObjectVariable 
when {self.type.componentType.eClass() = StaticAtomicComponent or self.type.componentType.eClass() = ReconfigurableAtomicComponent}{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);	
	name := self.name;
	classifier := AtomicComponentInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
    _bindingSemantics := self._bindingSemantics;
    _bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PortVariable :: createPortInstance() : ObjectVariable disjuncts componentstorypattern::PortVariable :: createDiscreteSinglePortInstance,
 componentstorypattern::PortVariable :: createDiscreteMultiPortInstance,
  componentstorypattern::PortVariable :: createContinousPortInstance,
   componentstorypattern::PortVariable :: createHybridPortInstance;

mapping componentstorypattern::PortVariable :: createDiscreteSinglePortInstance() : ObjectVariable
 when{self.type.eClass() = DiscretePort and self.type.oclAsType(DiscretePort).cardinality.upperBound.value = 1}{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name;
	classifier := DiscreteSinglePortInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
    _bindingSemantics := self._bindingSemantics;
    _bindingOperator := self._bindingOperator;
}

//TODO check if we need new references compared to single here
mapping componentstorypattern::PortVariable :: createDiscreteMultiPortInstance() : ObjectVariable
 when{self.type.eClass() = DiscretePort and self.type.oclAsType(DiscretePort).cardinality.upperBound.value > 1}{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name;
	classifier := DiscreteMultiPortInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
    _bindingSemantics := self._bindingSemantics;
    _bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PortVariable :: createContinousPortInstance() : ObjectVariable
 when{self.type.eClass() = ContinuousPort}{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name;
	classifier := ContinuousPortInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
    _bindingSemantics := self._bindingSemantics;
    _bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PortVariable :: createHybridPortInstance() : ObjectVariable
 when{self.type.eClass() = HybridPort}{
	name := self.name;
	classifier := HybridPortInstance.oclAsType(EClass);
   	_bindingState := self._bindingState;
   	_bindingSemantics := self._bindingSemantics;
   	_bindingOperator := self._bindingOperator;
   	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
    	
}


mapping Port :: createPortType(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name;
	classifier := self.eClass();
	constraint := createNameConstraint(self.name);
}


mapping Port :: createPortPart(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	name := self.name.concat('Part');
	classifier := PortPart.oclAsType(EClass);
}


-- we need the parameter to create every "component type variable" anew for each story pattern
mapping muml::component::Component ::createComponentType(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	name := self.name;
	classifier := self.eClass();
	constraint := createNameConstraint(self.name);
}


mapping componentstorypattern::PartVariable :: createComponentPart() : ObjectVariable{
	name := self.type.name;
	classifier := self.type.eClass();
	constraint := createNameConstraint(self.type.name);
}


mapping ConnectorVariable :: createConnectorInstance() : ObjectVariable disjuncts AssemblyVariable::createAssemblyConnectorInstance, DelegationVariable::createDelegationConnectorInstance;

mapping AssemblyVariable :: createAssemblyConnectorInstance() : ObjectVariable {
	classifier := AssemblyConnectorInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
   	_bindingSemantics := self._bindingSemantics;
   	_bindingOperator := self._bindingOperator;
   	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
	
}

mapping DelegationVariable :: createDelegationConnectorInstance() : ObjectVariable{
	classifier := DelegationConnectorInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
   	_bindingSemantics := self._bindingSemantics;
   	_bindingOperator := self._bindingOperator;
   	_annotation := self._annotation.deepclone().oclAsType(EAnnotation);
    _extension := self._extension.deepclone().oclAsType(Extension);
}

mapping PortConnector :: createConnectorType(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable disjuncts AssemblyConnector::createAssemblyConnectorType, DelegationConnector::createDelegationConnectorType;

mapping AssemblyConnector :: createAssemblyConnectorType(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	classifier := self.eClass();
	//TODO no such thing like a name constraint here?
}

mapping DelegationConnector :: createDelegationConnectorType(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	classifier := self.eClass();
}

mapping createLinkVaribale(sourceVariable : ObjectVariable, targetVariable : ObjectVariable, targetEndReference : EReference) : LinkVariable{
//	_name := self._name;
//    _bindingSemantics := self._bindingSemantics;
//    _bindingOperator := self._bindingOperator;
//    _annotation := self._annotation.map EAnnotation2EAnnotation();
//    _extension := self._extension.map Extension2Extension();
    _source := sourceVariable;
//    _secondLinkConstraint := self._secondLinkConstraint.map LinkConstraint2LinkConstraint();
//    _firstLinkConstraint := self._firstLinkConstraint.map LinkConstraint2LinkConstraint();
//    _pattern := self._pattern.map StoryPattern2StoryPattern();
    _target := targetVariable;
    
    _targetEnd := targetEndReference;
//    _qualifierExpression := self._qualifierExpression.map Expression2Expression();
}

query createNameConstraint(name : String) : Constraint{
	return object Constraint{
		constraintExpression := object TextualExpression{
			language := 'OCL';
			expressionText := "name = \'".concat(name).concat("\'");
			languageVersion := '1.0';
		}
	}
}


