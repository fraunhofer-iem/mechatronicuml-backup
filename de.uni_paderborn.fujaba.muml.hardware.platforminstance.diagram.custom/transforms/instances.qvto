transformation PlatformInstanceTransformation(inout hwplatformInstanceConfig:PlatformInstancePackage, in platform:PlatformPackage);


modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype HardwarePackage uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype ResourcePackage uses hardware::hwresource('http://www.fujaba.de/muml/hardware/1.0/');
modeltype ResourceInstancePackage uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformPackage uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformInstancePackage uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.0/');
modeltype HWValueTypePackage uses hardware::hwvaluetype('http://www.fujaba.de/muml/hardware/1.0/');




//This transformation creates an initial HWPlatformInstance.
//Therefore all embedded HWPlatforms, ResourceInstances and CommunicationResources 
//are created according to their cardinality of the HWPlatform type.

main() {
	log("QVT-O Script \"PlatformInstanceTransformation.qvto\" started.");
		hwplatformInstanceConfig.rootObjects()[HWPlatformInstanceConfiguration]->forEach(pi){
		pi.hwplatformInstances+=platform.rootObjects()[HWPlatform]->map createHWPlatformInstance(".0",null);
		//pi.hwplatformType->map createHWPlatformInstance(".0",null);
	};
}

// This is an intermediate property used to map the connectedMedia of the HWPortInstances (used as DelegationPorts) in the HWPlatform-Model
//to connectedMedia of this HWPlatformInstance 
//From a HWPortInstance (used as a Delegation) point of view this is the grandparent
// The value holds the parent of this HWPlatformInstance. 
intermediate property HWPlatformInstance::parentOfPlatformInstance : HWPlatformInstance;

//create a HWPlatformInstance derived from a HWPlatform
//the number is used to distinguish between multiple instances of the same HWPlatform
mapping HWPlatform::createHWPlatformInstance(number:String,parent:HWPlatformInstance):HWPlatformInstance{
	result.name:=self.name+number.toString();
	result.hwplatformType:=self;
	result.parentOfPlatformInstance:=parent;
	
	log("Start to create the HWPlatformInstance for:" +result.eClass().name +", Name:" +result.name);
	
	result.embeddedHPIC:=new HWPlatformInstanceConfiguration();
	//create the embedded CommunicationMedia	
	result.embeddedHPIC.networkingHardwareInstances+=self.networkingHardwareParts->map createNetworkingResourceInstance(number)->asOrderedSet();
		
	//create the delegation ports
	
	result.delegationPorts:=self.delegationPorts->map createDelegationHWPortInstance(number);
	
	//create the embedded ResourceInstances
	var instances:Set(ResourceInstance);
	self.embeddedPlatformParts[ResourcePart]->forEach(rip){
		instances+=rip.ResourcePart2ResourceInstance(number,result)->asOrderedSet();
	};
	result.embeddedHPIC.resources:=instances;
	
	
	//the delegation and delegation Ports are created by the mapping createPort(), to ease resolving
	//so each port with a delegation creats its delegation and corresponding DelegationPort
	
	//initialize the embedded HWPlatforms
	var platforminstances:Set(HWPlatformInstance);
	self.embeddedPlatformParts[HWPlatformPart]->forEach(hwp){
		platforminstances+=hwp.HWPlatformPart2HWPlatformInstance(number,result);
	};
	result.embeddedHPIC.hwplatformInstances:=platforminstances;
}


//create the embedded ResourceInstances derived by the ResourceInstancePart
// each ResourceInstance gets a number
//the number is used to distinguish between multiple instances of the same ResourceInstance
// the argument parent is used to resolve the correct CommunicationMedia of the HWPortInstances
query ResourcePart::ResourcePart2ResourceInstance(number:String,parent:HWPlatformInstance):Set(ResourceInstance){
	var instances:Set(ResourceInstance);
	var lowerBound: Integer;
	lowerBound:=InitValue(self);
	while(lowerBound>0){
			instances+=self->map createResourceInstance(self.name,number+"."+lowerBound.toString(),parent)->asOrderedSet();
			lowerBound:=lowerBound-1;
			};
	return instances;
}



//create the embedded HWPlatformInstances derived by the HWPlatformPart
// each HWPlatformInstance gets a number
//the number is used to distinguish between multiple instances of the same HWPlatformIstance
query HWPlatformPart::HWPlatformPart2HWPlatformInstance(number:String,parent:HWPlatformInstance):Set(HWPlatformInstance){
	var instances:Set(HWPlatformInstance);
	var lowerBound: Integer;
	lowerBound:=InitValue(self);
	while(lowerBound>0){
			log("create embedded HWPlatformInstance for:"+self.eClass().name +", Name:" +self.name+", Parent is"+self.parentHWPlatform.name);
			instances+=self.hwplatformType->map createHWPlatformInstance(number+"."+lowerBound.toString(),parent);
			lowerBound:=lowerBound-1;
			};
	return instances;
}


mapping  ResourcePart::createResourceInstance(partName:String,number:String,parent:HWPlatformInstance):ResourceInstance
 disjuncts ResourcePart::createStructuredResourceInstance, ResourcePart::createActuatorInstance, ResourcePart::createSensorInstance
	{}


//create a StructuredResourceInstances
// the argument parent is used to resolve the correct CommunicationMedia of the HWPortInstances
mapping ResourcePart::createStructuredResourceInstance(partName:String,number:String,parent:HWPlatformInstance):StructuredResourceInstance when {self.resourceType.oclIsKindOf(StructuredResourceInstance)}{
	result.name:=partName+number;
	result.resourceType:=self.resourceType.resourceType;
	result.hwports+=self.hwPortParts->createPortInstances(number,parent);
	result.embeddedAtomicResourceInstances:=self.resourceType.oclAsType(StructuredResourceInstance).embeddedAtomicResourceInstances.deepclone().oclAsType(AtomicResourceInstance);
	
}


mapping ResourcePart::createActuatorInstance(partName:String,number:String,parent:HWPlatformInstance):ActuatorInstance when {self.resourceType.oclIsKindOf(ActuatorInstance)}{
	result.name:=partName+number;
	result.resourceType:=self.resourceType.resourceType;
 	result.hwports+=self.hwPortParts->createPortInstances(number,parent);
	
}

mapping ResourcePart::createSensorInstance(partName:String,number:String,parent:HWPlatformInstance):SensorInstance when {self.resourceType.oclIsKindOf(SensorInstance)}{
	result.name:=partName+number;
	result.resourceType:=self.resourceType.resourceType;
 	result.hwports+=self.hwPortParts->createPortInstances(number,parent);
	
}



helper Set(HWPortPart)::createPortInstances(number:String,parent:HWPlatformInstance):Set(HWPortInstance){
	var portInstances:Set(HWPortInstance);
	var lowerBound: Integer;
	self->forEach(portPart){
		if(portPart.cardinality.lowerBound.toInteger()< self.connectors->size()) then{
					lowerBound:=self.connectors->size();	
		}
		endif;
		while(lowerBound>0){
				portInstances+=self.map createPortInstance(number, parent);
				lowerBound:=lowerBound-1;
				};
		};
	return portInstances;
}

//create a HWPortInstance and resovle the correct connectedCommunicationMedia with the help of the argument parent
mapping HWPortPart::createPortInstance(number:String,parent:HWPlatformInstance):HWPortInstance{
init{
	switch{ 	
			case (self.portKind = hardware::hwresource::HWPortKind::BUS){
			result.connectorInstances:=self.connectors.resolve(BusConnectorInstance)->selectOne(c|c.connectorEndpointInstances->size()=1);
					}
			case (self.portKind = hardware::hwresource::HWPortKind::LINK){
			result.connectorInstances:=self.connectors.resolve(LinkInstance)->selectOne(c|c.connectorEndpointInstances->size()=1);
					}
					
			else{//sollte nich aufgerufen werden
				//result:=new BusPortInstance();
				}
			};	
	}
//	result.name:=self.name+number;
	type:= self;
	name:=self.communicationResource.name;
	comment:=self.comment;
	connectorInstances:=self.connectors.late resolve(muml::connector::ConnectorInstance);
//	result.hwportType:=self.hwportType;
//	result.queuingTime:=self.queuingTime.deepclone().oclAsType(TimeInterval);
//	result.payloadDataSize:=self.payloadDataSize.deepclone().oclAsType(DataSize);
/*
	if(self.isDelegationPort) then{
	//resolve the corresponding delegation 
		result.delegation:=parent.delegations->any(hwPortInstance->size()<=1);
		//resolve the connectedMedia of the grandparent only for Busses
		if(parent.parentOfPlatformInstance<>null) then{
				result.connectedMedia:=self.connectedMedia.resolve(Bus)->asOrderedSet()->intersection(parent.parentOfPlatformInstance.communicationResources[Bus]);
		}endif;
	} else{
		result.delegation:=self.delegation.createDelegation(number,parent);
	}endif;
	*/
}

/*
//create a delegation an the correspond Delegation Port
helper Delegation::createDelegation(number:String, inout parent:HWPlatformInstance):Set(Delegation){
	var delegations:Set(Delegation);
	delegations:=parent.delegations+=self->map createDelegation(number);
//	parent.delegationPorts+=self.hwPortInstance->select(port|port.isDelegationPort=true)->map createPort(number,parent);
	return delegations;
}

*/


//creates a CommunicationMedia
mapping NetworkingHardwarePart::createNetworkingResourceInstance(number:String):NetworkingHardwareInstance
disjuncts BusConnector::createBusConnectorInstance,BusPart::createBusInstance, BridgePart::createBridgeInstance, LinkPart::createLinkInstance, Delegation::createDelegationInstance{}
//	result.comment:=self.comment+number;
	//result.bandwidth:=self.bandwidth.deepclone().oclAsType(DataRate);
	//result.protocol:=self.protocol;
	//result.isSerial:=self.isSerial;
	//result.dataFrameSize:=self.dataFrameSize.deepclone().oclAsType(DataSize);



mapping BusConnector::createBusConnectorInstance(number:String):BusConnectorInstance{
  	type:=self;
	comment:=self.comment+number;
	connectorEndpointInstances:=self.connectorEndpoints.oclAsType(NetworkingHardwarePart)->asSet()->map createNetworkingResourceInstance(number).oclAsType(muml::connector::ConnectorEndpointInstance);
	}
	
mapping BridgePart::createBridgeInstance(number:String):BridgeInstance{
	type:=self;
	comment:=self.comment+number;	 
	connectorInstances:=self.connectors.late resolve(muml::connector::ConnectorInstance);
	}
	
mapping LinkPart::createLinkInstance(number:String):LinkInstance{
	type:=self;
	result.comment:=self.comment+number;	
	communicationMediaPart:=self; 
	connectorEndpointInstances:=self.late resolve(muml::connector::ConnectorEndpointInstance);
	}
	
mapping BusPart::createBusInstance(number:String):BusInstance{
	type:=self;
	result.comment:=self.comment+number;
	communicationMediaPart	:=self; 	
	//connectorInstances:=self.connectors.late resolve(muml::connector::ConnectorInstance);	 
	}	
	
mapping Delegation::createDelegationInstance(number:String):DelegationInstance{
	type:=self;
	result.comment:=self.comment+number;
	connectorEndpointInstances:=self.connectorEndpoints.late resolve(muml::connector::ConnectorEndpointInstance);
	}	

mapping DelegationHWPort::createDelegationHWPortInstance(number:String):DelegationHWPortInstance{
	type:=self;
	name:=self.name+number;
	connectorInstances:=self.connectors.late resolve(DelegationInstance);
}

// Convenience query to cast a natural number to an integer, using -1 as value for infinity.
query NaturalNumber::toInteger() : Integer {
	if (self.infinity) then {
		return -1;
	} endif;
	return self.value;
}

//just for test purpose
configuration property initVector : Dict(String,Integer);
			
		
	
query InitValue(part:PlatformPart) : Integer {
if(initVector->hasKey(part.name)) then{
	return initVector->get(part.name);
	}
else{
	return part.cardinality.lowerBound.toInteger();
}endif;
}
 