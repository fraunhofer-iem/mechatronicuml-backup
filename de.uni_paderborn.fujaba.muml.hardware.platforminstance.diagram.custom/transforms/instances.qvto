transformation PlatformInstanceTransformation(inout hwplatformInstanceConfig:PlatformInstancePackage, in platform:PlatformPackage);


modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype HardwarePackage uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformPackage uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformInstancePackage uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.0/');
modeltype HWValueTypePackage uses hardware::hwvaluetype('http://www.fujaba.de/muml/hardware/1.0/');

/* 


//This transformation creates an initial HWPlatformInstance.
//Therefore all embedded HWPlatforms, ResourceInstances and CommunicationResources 
//are created according to their cardinality of the HWPlatform type.

main() {
	log("QVT-O Script \"PlatformInstanceTransformation.qvto\" started.");
		hwplatformInstanceConfig.rootObjects()[HWPlatformInstanceConfiguration]->forEach(pi){
		pi.hwplatformInstances+=platform.rootObjects()[HWPlatform]->map createHWPlatformInstance(".0",null);
		//pi.hwplatformType->map createHWPlatformInstance(".0",null);
	};
}

// This is an intermediate property used to map the connectedMedia of the HWPortInstances (used as DelegationPorts) in the HWPlatform-Model
//to connectedMedia of this HWPlatformInstance 
//From a HWPortInstance (used as a Delegation) point of view this is the grandparent
// The value holds the parent of this HWPlatformInstance. 
intermediate property HWPlatformInstance::parentOfPlatformInstance : HWPlatformInstance;

//create a HWPlatformInstance derived from a HWPlatform
//the number is used to distinguish between multiple instances of the same HWPlatform
mapping HWPlatform::createHWPlatformInstance(number:String,parent:HWPlatformInstance):HWPlatformInstance{
	result.name:=self.name+number.toString();
	result.hwplatformType:=self;
	result.parentOfPlatformInstance:=parent;
	
	log("Start to create the HWPlatformInstance for:" +result.eClass().name +", Name:" +result.name);
	
	//create the embedded CommunicationMedia	
	result.communicationResources+=self.embeddedCommunicationResources[CommunicationMedia]->map createMedia(number)->asOrderedSet();
		
	//create the embedded Bridges
	result.communicationResources+=self.embeddedCommunicationResources[Bridge]->map createBridge(number)->asOrderedSet();
	
	
	
	//create the embedded ResourceInstances
	var instances:Set(ResourceInstance);
	self.embeddedPlatformParts[ResourceInstancePart]->forEach(rip){
		instances+=rip.ResourceInstancePart2ResourceInstance(number,result)->asOrderedSet();
	};
	result.resourceInstances:=instances;
	
	
	//the delegation and delegation Ports are created by the mapping createPort(), to ease resolving
	//so each port with a delegation creats its delegation and corresponding DelegationPort
	
	//initialize the embedded HWPlatforms
	var platforminstances:Set(HWPlatformInstance);
	self.embeddedPlatformParts[HWPlatformPart]->forEach(hwp){
		platforminstances+=hwp.HWPlatformPart2HWPlatformInstance(number,result);
	};
	result.hwplatformInstances:=platforminstances;
}


//create the embedded ResourceInstances derived by the ResourceInstancePart
// each ResourceInstance gets a number
//the number is used to distinguish between multiple instances of the same ResourceInstance
// the argument parent is used to resolve the correct CommunicationMedia of the HWPortInstances
query ResourceInstancePart::ResourceInstancePart2ResourceInstance(number:String,parent:HWPlatformInstance):Set(ResourceInstance){
	var instances:Set(ResourceInstance);
	var lowerBound: Integer;
	lowerBound:=InitValue(self);
	while(lowerBound>0){
			instances+=self.resourceInstanceType->map createStructuredResourceInstance(self.name,number+"."+lowerBound.toString(),parent)->asOrderedSet();
			lowerBound:=lowerBound-1;
			};
	return instances;
}



//create the embedded HWPlatformInstances derived by the HWPlatformPart
// each HWPlatformInstance gets a number
//the number is used to distinguish between multiple instances of the same HWPlatformIstance
query HWPlatformPart::HWPlatformPart2HWPlatformInstance(number:String,parent:HWPlatformInstance):Set(HWPlatformInstance){
	var instances:Set(HWPlatformInstance);
	var lowerBound: Integer;
	lowerBound:=InitValue(self);
	while(lowerBound>0){
			log("create embedded HWPlatformInstance for:"+self.eClass().name +", Name:" +self.name+", Parent is"+self.parentHWPlatform.name);
			instances+=self.hwplatformType->map createHWPlatformInstance(number+"."+lowerBound.toString(),parent);
			lowerBound:=lowerBound-1;
			};
	return instances;
}


//create a StructuredResourceInstances
// the argument parent is used to resolve the correct CommunicationMedia of the HWPortInstances
mapping ResourceInstance::createStructuredResourceInstance(partName:String,number:String,parent:HWPlatformInstance):ResourceInstance{
init{
	switch{ 	
			case (self.oclIsTypeOf(StructuredResourceInstance)){
			result:=new StructuredResourceInstance();
			result.oclAsType(StructuredResourceInstance).embeddedAtomicResourceInstances:=self.oclAsType(StructuredResourceInstance).embeddedAtomicResourceInstances.deepclone().oclAsType(AtomicResourceInstance);
					}
			case (self.oclIsTypeOf(SensorInstance)){
			result:=new SensorInstance();
					}
			case (self.oclIsTypeOf(ActuatorInstance)){
			result:=new ActuatorInstance();
					}
			else{//sollte nich aufgerufen werden
				result:=new StructuredResourceInstance();
				}
		};	
}
	result.name:=partName+number;
	result.resourceType:=self.resourceType;
	result.hwportInstances+=self.hwportInstances->map createPort(number,parent);
	
}

//create a HWPortInstance and resovle the correct connectedCommunicationMedia with the help of the argument parent
mapping HWPortInstance::createPort(number:String,parent:HWPlatformInstance):HWPortInstance{
init{
	switch{ 	
			case (self.oclIsTypeOf(BusPortInstance)){
			result:=new BusPortInstance();
			result.connectedMedia:=self.connectedMedia.resolve(Bus)->asOrderedSet()->intersection(parent.communicationResources[Bus]);
					}
			case (self.oclIsTypeOf(LinkPortInstance)){
			result:=new LinkPortInstance();
			result.connectedMedia:=self.connectedMedia.resolve(Link)->asOrderedSet()->intersection(parent.communicationResources[Link]);
						
					}
					
			else{//sollte nich aufgerufen werden
				result:=new BusPortInstance();
				}
			};	
	}
	result.name:=self.name+number;
	result.hwportType:=self.hwportType;
	result.queuingTime:=self.queuingTime.deepclone().oclAsType(TimeInterval);
	result.payloadDataSize:=self.payloadDataSize.deepclone().oclAsType(DataSize);

	if(self.isDelegationPort) then{
	//resolve the corresponding delegation 
		result.delegation:=parent.delegations->any(hwPortInstance->size()<=1);
		//resolve the connectedMedia of the grandparent only for Busses
		if(parent.parentOfPlatformInstance<>null) then{
				result.connectedMedia:=self.connectedMedia.resolve(Bus)->asOrderedSet()->intersection(parent.parentOfPlatformInstance.communicationResources[Bus]);
		}endif;
	} else{
		result.delegation:=self.delegation.createDelegation(number,parent);
	}endif;
	
}

//create a delegation an the correspond Delegation Port
helper Delegation::createDelegation(number:String, inout parent:HWPlatformInstance):Set(Delegation){
	var delegations:Set(Delegation);
	delegations:=parent.delegations+=self->map createDelegation(number);
//	parent.delegationPorts+=self.hwPortInstance->select(port|port.isDelegationPort=true)->map createPort(number,parent);
	return delegations;
}



//creates a CommunicationMedia
mapping CommunicationMedia::createMedia(number:String):CommunicationMedia{
init{
	switch{ 	
			case (self.oclIsTypeOf(Bus)){
			result:=new Bus();
					}
			case (self.oclIsTypeOf(Link)){
			result:=new Link();
					}
			else{//sollte nich aufgerufen werden
				result:=new Bus();
				}
			};
	}
	result.comment:=self.comment+number;
	result.bandwidth:=self.bandwidth.deepclone().oclAsType(DataRate);
	result.protocol:=self.protocol;
	result.isSerial:=self.isSerial;
	result.dataFrameSize:=self.dataFrameSize.deepclone().oclAsType(DataSize);
}


//creates a Bridges and resolves the correct CommuncationMedia
mapping Bridge::createBridge(number:String):Bridge{
	result.comment:=self.comment+number;
	result.delay:=self.delay.deepclone().oclAsType(TimeInterval);
	result.connectedCommunicationMedia:=self.connectedCommunicationMedia.resolve(CommunicationMedia);
}



//creates a Delegation
mapping Delegation::createDelegation(number:String):Delegation{
	result.comment:=self.comment+number;
}



// Convenience query to cast a natural number to an integer, using -1 as value for infinity.
query NaturalNumber::toInteger() : Integer {
	if (self.infinity) then {
		return -1;
	} endif;
	return self.value;
}

//just for test purpose
configuration property initVector : Dict(String,Integer);
			
		
	
query InitValue(part:PlatformPart) : Integer {
if(initVector->hasKey(part.name)) then{
	return initVector->get(part.name);
	}
else{
	return part.cardinality.lowerBound.toInteger();
}endif;
}
 */