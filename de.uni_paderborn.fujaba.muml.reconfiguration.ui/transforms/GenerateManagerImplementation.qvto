import transforms.lib.RTSCBaseLibrary;
import transforms.lib.ActionLanguageBaseLibrary;
import transforms.lib.TypeAndBehaviorLibrary;
import transforms.lib.MessageTypeLibrary;
import transforms.lib.ProjectSpecificConstants;

--core models
modeltype core uses core('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype expressions_common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype modelinst uses modelinstance("http://www.fujaba.de/modelinstance/0.3.15");

-- muml models 
modeltype behavior uses muml::behavior("http://www.fujaba.de/muml/0.2.2");
modeltype component uses muml::component("http://www.fujaba.de/muml/0.2.2");
modeltype connector uses muml::connector("http://www.fujaba.de/muml/0.2.2");
modeltype constraints uses muml::constraint("http://www.fujaba.de/muml/0.2.2");
modeltype deployment uses muml::deployment("http://www.fujaba.de/muml/0.2.2");
modeltype instance uses muml::instance("http://www.fujaba.de/muml/0.2.2");
modeltype msgi uses muml::msgtype("http://www.fujaba.de/muml/0.2.2");
modeltype protocol uses muml::protocol("http://www.fujaba.de/muml/0.2.2");
modeltype realtimestatechart uses muml::realtimestatechart('http://www.fujaba.de/muml/0.2.2');
modeltype types uses muml::types("http://www.fujaba.de/muml/0.2.2");
modeltype valuetype uses muml::valuetype("http://www.fujaba.de/muml/0.2.2");

modeltype actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.3.19');
modeltype reconf uses reconfiguration("http://www.fujaba.de/muml/reconfiguration/0.3.18");
modeltype reconf_expressions uses reconfiguration::expression("http://www.fujaba.de/muml/reconfiguration/0.3.18");
modeltype reconf_datatype uses reconfiguration::structdatatype("http://www.fujaba.de/muml/reconfiguration/0.3.18");

modeltype componentpattern uses componentstorydiagram::componentstorypattern("http://www.fujaba.de/muml/componentstorydiagram/0.3.1");
modeltype componentstory uses componentstorydiagram::controlflow("http://www.fujaba.de/muml/componentstorydiagram/0.3.1");

-- this transformation parses the reconfiguration specification of the manager of the
-- reconfigurable structured component contained in inputComponent and generates a behavior
-- specification in terms of real-time statecharts for it
transformation GenerateManagerImplementation(inout inputComponent : component, inout category : modelinst);

main() {

	var theComponent : ReconfigurableStructuredComponent := inputComponent.rootObjects()[ReconfigurableStructuredComponent] -> any(true);
	var rootNode : RootNode := category.rootObjects()[RootNode] -> any(true);
	
	createManagerImplementation(theComponent, rootNode);
	
}

-- creates and implementation for the manager
helper createManagerImplementation(inout theComponent : ReconfigurableStructuredComponent, inout rootNode : RootNode){
	
	-- create the statechart
	var rtsc : RealtimeStatechart := new RealtimeStatechart(theComponent.name + '_Manager_RTSC');
	rtsc.comment := 'Generated Real-Time Statechart -- DO NOT EDIT!';
	
	-- assign it to the manager
	theComponent.manager.behavior := rtsc;
	
	-- add statechart to category
	rootNode.getRTSCCategory().modelElements += rtsc;
	
	--generate static statechart frame (black parts in the generation template)
	generateStaticStatechartFrame(rootNode, theComponent.manager);
	
	--generate variable parts of the statechart (colored parts in the generation template)
	theComponent.manager.specificationEntries -> forEach(specEntry){ 
		specEntry.generateSpecificationEntry(rootNode);
	};
	
	return;
}

-- generates the static statechart frame (the 'black' parts in the manager generation template)
helper generateStaticStatechartFrame(inout rootNode : RootNode, inout manager : Manager){
	
	-- retrieve statechart
	var managerRTSC : RealtimeStatechart := manager.behavior.oclAsType(RealtimeStatechart);
	
	-- generate initial state
	var initialState : State := new State(genStateManager_Main);
	initialState.initial := true;
	managerRTSC.states += initialState;
	
	-- add variables
	managerRTSC.variables += new Variable(genVarManager_Reconfiguration, rootNode.getPrimitiveType(intType));
	
	-- add sync channels
	initialState.channels += new SynchronizationChannel(genSyncChanReply, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanParentReply, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanExecuted, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanExecuteReconf, null);
	
	-- generate embedded statecharts
	var parentSubRTSC : RealtimeStatechart := createEmbeddedRTSC(genEmbeddedRTSCManager_Parent, initialState, 2);
	generateStaticParentStatechartFrame(rootNode, parentSubRTSC);
	manager.ports -> any(name = 'parent').behavior := parentSubRTSC;
	
	var executorSubRTSC : RealtimeStatechart := createEmbeddedRTSC(genEmbeddedRTSCManager_Executor, initialState, 1);
	generateStaticExecutorStatechartFrame(rootNode, executorSubRTSC);
	manager.ports -> any(name = 'executor').behavior := executorSubRTSC;
	
	var internalRTSC : RealtimeStatechart := createEmbeddedRTSC(genEmbeddedRTSCManager_Internal, initialState, 3);
	generateStaticInternalBehaviorStatechartFrame(rootNode, internalRTSC);
	
	var embeddedCISubRTSC : RealtimeStatechart := createEmbeddedRTSC(genEmbeddedRTSCManager_EmbeddedCI, initialState, 4);
	generateStaticEmbeddedCIStatechartFrame(rootNode, embeddedCISubRTSC);
	manager.ports -> any(name = 'embeddedCI').roleAndAdaptationBehavior := embeddedCISubRTSC;
	manager.ports -> any(name = 'embeddedCI').behavior := embeddedCISubRTSC.getEmbeddedRTSCByName(genEmbeddedRTSCManager_EmbeddedCI_subrole);
	manager.ports -> any(name = 'embeddedCI').adaptationBehavior := embeddedCISubRTSC.getEmbeddedRTSCByName(genEmbeddedRTSCManager_EmbeddedCI_adapt);
	
	-- configure message types of ports
	var currentPort : DiscretePort = null;
	
	-- parent port
	currentPort := manager.ports -> any(name = 'parent');
	currentPort.receiverMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeSuccess);
	currentPort.receiverMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed);
	currentPort.receiverMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeOccupied);
	
	-- executor port
	currentPort := manager.ports -> any(name = 'executor');
	currentPort.receiverMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeSuccess);
	currentPort.receiverMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed);
	currentPort.senderMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeDeclineRequest);
	currentPort.senderMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeConfirmRequest);
	currentPort.senderMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeExecute);
	
	-- embeddedCI port
	currentPort := manager.ports -> any(name = 'embeddedCI');
	currentPort.senderMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeSuccess);
	currentPort.senderMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed);
	currentPort.senderMessageTypes += rootNode.getGeneratedReconfigurationMessageType(genMsgTypeOccupied);
	
	return;
}

-- generates the static statechart frame for the parent statechart (the 'black' parts in the manager generation template)
helper generateStaticParentStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable := new Variable(genVarManager_Parent_Request, rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	-- create states
	var initState : State := new State(genStateManager_Parent_Idle);
	initState.initial := true;
	initState.entryEvent := new EntryEvent(createSimpleAssignmentExpressioninBlock(requestVar, 'false'), null);
	rtsc.states += initState;
	
	var propState : State := new State(genStateManager_Parent_Propagated);
	propState.urgent := true;
	rtsc.states += propState;
	
	var awaitState : State := new State(genStateManager_Parent_AwaitReply);
	rtsc.states += awaitState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- Propagated -> Idle
	currentTrans := new Transition(propState, initState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Propagated -> AwaitReply
	currentTrans := new Transition(propState, awaitState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (success)
	currentTrans := new Transition(awaitState, initState, 3);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('true'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeSuccess), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (failed)
	currentTrans := new Transition(awaitState, initState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (occupied)
	currentTrans := new Transition(awaitState, initState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeOccupied), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	
	return;
}

-- generates the static statechart frame for the executor statechart (the 'black' parts in the manager generation template)
helper generateStaticExecutorStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable = new Variable(genVarManager_Executor_Reuqest, rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	-- create states
	var idleState : State := new State(genStateManager_Executor_Idle);
	idleState.initial := true;
	idleState.entryEvent := new EntryEvent(createSimpleAssignmentExpressioninBlock(requestVar, 'false'), null);
	rtsc.states += idleState;
	
	var requestState : State := new State(genStateManager_Executor_Request);
	rtsc.states += requestState;
	
	var executeState : State := new State(genStateManager_Executor_ExecuteReconf);
	rtsc.states += executeState;
	
	var waitState : State := new State(genStateManager_Executor_WaitForConfirm);
	rtsc.states += waitState;
	
	var finishedState : State := new State(genStateManager_Executor_Finished);
	finishedState.urgent := true;
	rtsc.states += finishedState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- Idle -> ExecuteReconf
	currentTrans := new Transition(idleState, executeState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuteReconf), SynchronizationKind::RECEIVE, 
			null);
	var msgType : MessageType := rootNode.getGeneratedReconfigurationMessageType(genMsgTypeExecute);
	var sendMsg : AsynchronousMessageEvent := new AsynchronousMessageEvent(msgType, EventKind::RAISE);
	sendMsg.message.parameterBinding += createSimpleSendVariableParameterBinding(msgType.getParameterByName(genParamExecute_Reconf), rtsc.getVariableByName(genVarManager_Reconfiguration));
	currentTrans.events += sendMsg;
	rtsc.transitions += currentTrans;
	
	-- ExecuteReconf -> Finished (success)
	currentTrans := new Transition(executeState, finishedState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::SEND, 
			new LiteralExpression('true'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeSuccess), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- ExecuteReconf -> Finished (failed)
	currentTrans := new Transition(executeState, finishedState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- Finished -> Idle (request + sucess)
	currentTrans := new Transition(finishedState, idleState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('true'));
	rtsc.transitions += currentTrans;
	
	-- Finished -> Idle (request + failed)
	currentTrans := new Transition(finishedState, idleState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	rtsc.transitions += currentTrans;
	
	-- Finished -> Idle (no request)
	currentTrans := new Transition(finishedState, idleState, 3);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Request -> ExecuteReconf
	currentTrans := new Transition(requestState, executeState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuteReconf), SynchronizationKind::RECEIVE, 
			null);
	msgType := rootNode.getGeneratedReconfigurationMessageType(genMsgTypeConfirmRequest);
	sendMsg := new AsynchronousMessageEvent(msgType, EventKind::RAISE);
	sendMsg.message.parameterBinding += createSimpleSendVariableParameterBinding(msgType.getParameterByName(genParamExecute_Reconf), rtsc.getVariableByName(genVarManager_Reconfiguration));
	currentTrans.events += sendMsg;
	rtsc.transitions += currentTrans;
	
		-- Request -> WaitForConfirm
	currentTrans := new Transition(requestState, waitState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeDeclineRequest), EventKind::RAISE);
	rtsc.transitions += currentTrans;
	
	-- WaitForConfirm -> Idle
	currentTrans := new Transition(waitState, idleState, 1);
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	return;
}

-- generates the static statechart frame for the internal behavior statechart (the 'black' parts in the manager generation template)
helper generateStaticInternalBehaviorStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable := new Variable(genVarManager_Internal_Request, rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	var resultVar : Variable := new Variable(genVarManager_Internal_Result, rootNode.getPrimitiveType(boolType));
	rtsc.variables += resultVar;
	
	-- create states
	var idleState : State := new State(genStateManager_Internal_Idle);
	idleState.initial := true;
	idleState.entryEvent := new EntryEvent(createSimpleAssignmentExpressioninBlock(requestVar, 'false'), null);
	rtsc.states += idleState;
	
	var planState : State := new State(genStateManager_Internal_Plan);
	planState.urgent := true;
	rtsc.states += planState;
	
	var executeState : State := new State(genStateManager_Internal_Execute);
	rtsc.states += executeState;
	
	var successState : State := new State(genStateManager_Internal_Success);
	successState.urgent := true;
	rtsc.states += successState;
	
	var failState : State := new State(genStateManager_Internal_Fail);
	successState.urgent := true;
	rtsc.states += failState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- Plan -> Execute
	currentTrans := new Transition(planState, executeState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(resultVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuteReconf), SynchronizationKind::SEND, 
			null);
	rtsc.transitions += currentTrans;
	
	-- Plan -> Fail
	currentTrans := new Transition(planState, executeState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(resultVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Execute -> Fail
	currentTrans := new Transition(executeState, failState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	rtsc.transitions += currentTrans;
	
	-- Execute -> Success
	currentTrans := new Transition(executeState, successState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::RECEIVE, 
			new LiteralExpression('true'));
	rtsc.transitions += currentTrans;
	
	-- Success -> Idle (request)
	currentTrans := new Transition(successState, idleState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('true'));
	rtsc.transitions += currentTrans;
	
	-- Success -> Idle (no request)
	currentTrans := new Transition(successState, idleState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Fail -> Idle (request)
	currentTrans := new Transition(failState, idleState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	rtsc.transitions += currentTrans;
	
	-- Fail -> Idle (no request)
	currentTrans := new Transition(failState, idleState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	return;
}

-- generates the static statechart frame for the embeddedCI statechart (the 'black' parts in the manager generation template)
helper generateStaticEmbeddedCIStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	--create initial state
	var mainState : State := new State(genStateManager_EmbeddedCI_Main);
	mainState.initial := true;
	rtsc.states += mainState;

	-- create embedded statecharts	
	var adaptationRTSC : RealtimeStatechart := createEmbeddedRTSC(genEmbeddedRTSCManager_EmbeddedCI_adapt, mainState, 2);
	generateStaticEmbeddedCIAdaptationStatechartFrame(rootNode, adaptationRTSC);
	
	var subroleRTSC : RealtimeStatechart := createEmbeddedRTSC(genEmbeddedRTSCManager_EmbeddedCI_subrole, mainState, 1);
	generateStaticEmbeddedCISubroleStatechartFrame(rootNode, subroleRTSC);
	
	return;
}

-- generates the static statechart frame for the adaptation substatechart of the embeddedCI statechart (the 'black' parts in the manager generation template)
helper generateStaticEmbeddedCIAdaptationStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create states
	var initState : State := new State(genStateManager_EmbeddedCI_Idle);
	initState.initial := true;
	rtsc.states += initState;
	
	return;
}

-- generates the static statechart frame for the subrole substatechart of the embeddedCI statechart (the 'black' parts in the manager generation template)
helper generateStaticEmbeddedCISubroleStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable := new Variable(genVarManager_EmbeddedCI_Request, rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	var propVar : Variable := new Variable(genVarManager_EmbeddedCI_Propagate, rootNode.getPrimitiveType(boolType));
	rtsc.variables += propVar;
	
	-- create clocks
	var reqClock : Clock := new Clock(genClockManager_embeddedCI_cReq);
	rtsc.clocks += reqClock;
	
	-- create states
	var idleState : State := new State(genStateManager_EmbeddedCI_Idle);
	idleState.initial := true;
	var theBlock : Block := new Block();
	theBlock.expressions += createSimpleAssignmentExpression(requestVar, 'false');
	theBlock.expressions += createSimpleAssignmentExpression(propVar, 'false');
	idleState.entryEvent := new EntryEvent(theBlock, null);
	rtsc.states += idleState;
	
	var deliverState : State := new State(genStateManager_EmbeddedCI_Deliver);
	deliverState.urgent := true;
	rtsc.states += deliverState;
	
	var awaitState : State := new State(genStateManager_EmbeddedCI_AwaitReply);
	rtsc.states += awaitState;
	
	var awaitParentState : State := new State(genStateManager_EmbeddedCI_AwaitParent);
	rtsc.states += awaitParentState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- DeliverMsg -> Idle
	currentTrans := new Transition(deliverState, idleState, 3);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- DeliverMsg -> AwaitReply
	currentTrans := new Transition(deliverState, awaitState, 2);
	currentTrans.guard := new LogicalExpression(createSimpleCompareGuardExpression(requestVar, 'true'),
								LogicOperator::AND,
								createSimpleCompareGuardExpression(propVar, 'false'));
	rtsc.transitions += currentTrans;
	
	-- DeliverMsg -> AwaitParentReply
	currentTrans := new Transition(deliverState, awaitParentState, 1);
	currentTrans.guard := new LogicalExpression(createSimpleCompareGuardExpression(requestVar, 'true'),
								LogicOperator::AND,
								createSimpleCompareGuardExpression(propVar, 'true'));
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (success)
	currentTrans := new Transition(awaitState, idleState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('true'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeSuccess), EventKind::RAISE);
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (failed)
	currentTrans := new Transition(awaitState, idleState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed), EventKind::RAISE);
	rtsc.transitions += currentTrans;
	
	-- AwaitParentReply -> Idle (success)
	currentTrans := new Transition(awaitParentState, idleState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanParentReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('true'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeSuccess), EventKind::RAISE);
	rtsc.transitions += currentTrans;
	
	-- AwaitParentReply -> Idle (failed)
	currentTrans := new Transition(awaitParentState, idleState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanParentReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(rootNode.getGeneratedReconfigurationMessageType(genMsgTypeFailed), EventKind::RAISE);
	rtsc.transitions += currentTrans;
	
	return;
}

-- creates the variable parts resulting from a specification entry 
-- (colored parts in the generation template)
helper ManagerSpecificationEntry::generateSpecificationEntry(in rootNode : RootNode){
	
	
	
	return;	
}

-- creates the variable parts for a message that is received from a child and
-- propagated to the parent (either request or info) (blue and purple parts)
helper ManagerSpecificationEntry::generatePropagatedMessage(in rootNode : RootNode){
	
	return;
}

-- creates the variable parts for a message that is treated. This helper only
-- generates the brown and yellow parts for the internal behavior.
-- The remaining parts in the embeddedCI and executor RTSC are generated by helper queries
helper ManagerSpecificationEntry::generateTreatedMessage(in rootNode : RootNode){
	
}

-- creates the variable parts for message that is treated and received by a
-- child. This helper only generates the green and purple parts in the 
-- embeddedCI RTSC. 
helper ManagerSpecificationEntry::generateTreatedMessageByChild(in rootNode : RootNode){
	
}

-- creates the variable parts for message that is treated and received by the
-- executor. This helper only generates the green parts in the executor RTSC.
helper ManagerSpecificationEntry::generateTreatedMessageByParent(in rootNode : RootNode){
	
}