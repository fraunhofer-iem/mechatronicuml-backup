import transforms.lib.RTSCBaseLibrary;
import transforms.lib.ActionLanguageBaseLibrary;
import transforms.lib.TypeAndBehaviorLibrary;
import transforms.lib.MessageTypeLibrary;
import transforms.lib.ProjectSpecificConstants;

--core models
modeltype core uses core('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype expressions_common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype modelinst uses modelinstance("http://www.fujaba.de/modelinstance/0.3.15");

-- muml models 
modeltype behavior uses muml::behavior("http://www.fujaba.de/muml/0.2.2");
modeltype component uses muml::component("http://www.fujaba.de/muml/0.2.2");
modeltype connector uses muml::connector("http://www.fujaba.de/muml/0.2.2");
modeltype constraints uses muml::constraint("http://www.fujaba.de/muml/0.2.2");
modeltype deployment uses muml::deployment("http://www.fujaba.de/muml/0.2.2");
modeltype instance uses muml::instance("http://www.fujaba.de/muml/0.2.2");
modeltype msgi uses muml::msgtype("http://www.fujaba.de/muml/0.2.2");
modeltype protocol uses muml::protocol("http://www.fujaba.de/muml/0.2.2");
modeltype realtimestatechart uses muml::realtimestatechart('http://www.fujaba.de/muml/0.2.2');
modeltype types uses muml::types("http://www.fujaba.de/muml/0.2.2");
modeltype valuetype uses muml::valuetype("http://www.fujaba.de/muml/0.2.2");

modeltype actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.3.16');
modeltype reconf uses reconfiguration("http://www.fujaba.de/muml/reconfiguration/0.3.18");
modeltype reconf_expressions uses reconfiguration::expression("http://www.fujaba.de/muml/reconfiguration/0.3.18");
modeltype reconf_datatype uses reconfiguration::structdatatype("http://www.fujaba.de/muml/reconfiguration/0.3.18");

modeltype componentpattern uses componentstorydiagram::componentstorypattern("http://www.fujaba.de/muml/componentstorydiagram/0.3.1");
modeltype componentstory uses componentstorydiagram::controlflow("http://www.fujaba.de/muml/componentstorydiagram/0.3.1");

-- this transformation parses the reconfiguration specification of the manager of the
-- reconfigurable structured component contained in inputComponent and generates a behavior
-- specification in terms of real-time statecharts for it
transformation GenerateManagerImplementation(inout inputComponent : component, inout category : modelinst);

main() {

	var theComponent : ReconfigurableStructuredComponent := inputComponent.rootObjects()[ReconfigurableStructuredComponent] -> any(true);
	var rootNode : RootNode := category.rootObjects()[RootNode] -> any(true);
	
	createManagerImplementation(theComponent, rootNode);
	
}

-- creates and implementation for the manager
helper createManagerImplementation(inout theComponent : ReconfigurableStructuredComponent, inout rootNode : RootNode){
	
	-- create the statechart
	var rtsc : RealtimeStatechart := new RealtimeStatechart(theComponent.name + '_Manager_RTSC');
	rtsc.comment := 'Generated Real-Time Statechart -- DO NOT EDIT!';
	
	-- assign it to the manager
	theComponent.manager.behavior := rtsc;
	
	-- add statechart to category
	rootNode.getRTSCCategory().modelElements += rtsc;
	
	--generate static statechart frame
	generateStaticStatechartFrame(rootNode, rtsc);
	
	return;
}

-- generates the static statechart frame (the 'black' parts in the manager generation template)
helper generateStaticStatechartFrame(inout rootNode : RootNode, inout managerRTSC : RealtimeStatechart){
	
	-- generate initial state
	var initialState : State := new State('Manager_Main');
	initialState.initial := true;
	managerRTSC.states += initialState;
	
	-- add variables
	managerRTSC.variables += new Variable('reconfiguration', rootNode.getPrimitiveType(intType));
	
	-- add sync channels
	initialState.channels += new SynchronizationChannel(genSyncChanReply, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanParentReply, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanExecuted, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanExecuteReconf, null);
	
	-- generate embedded statecharts
	var parentSubRTSC : RealtimeStatechart := createEmbeddedRTSC('parent', initialState, 2);
	generateStaticParentStatechartFrame(rootNode, parentSubRTSC);
	
	var executorSubRTSC : RealtimeStatechart := createEmbeddedRTSC('executor', initialState, 1);
	generateStaticExecutorStatechartFrame(rootNode, executorSubRTSC);
	
	var internalRTSC : RealtimeStatechart := createEmbeddedRTSC('internal behavior', initialState, 3);
	generateStaticInternalBehaviorStatechartFrame(rootNode, internalRTSC);
	
	var embeddedCISubRTSC : RealtimeStatechart := createEmbeddedRTSC('embeddedCI', initialState, 4);
	generateStaticEmbeddedCIStatechartFrame(rootNode, embeddedCISubRTSC);
	
	return;
}

-- generates the static statechart frame for the parent statechart (the 'black' parts in the manager generation template)
helper generateStaticParentStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable := new Variable(genVarManager_Parent_Request, rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	-- create states
	var initState : State := new State(genStateManager_Parent_Idle);
	initState.initial := true;
	initState.entryEvent := new EntryEvent(createSimpleAssignmentExpressioninBlock(requestVar, 'false'), null);
	rtsc.states += initState;
	
	var propState : State := new State(genStateManager_Parent_Propagated);
	propState.urgent := true;
	rtsc.states += propState;
	
	var awaitState : State := new State(genStateManager_Parent_AwaitReply);
	rtsc.states += awaitState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- Propagated -> Idle
	currentTrans := new Transition(propState, initState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Propagated -> AwaitReply
	currentTrans := new Transition(propState, awaitState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (success)
	currentTrans := new Transition(awaitState, initState, 3);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('true'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeSuccess), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (failed)
	currentTrans := new Transition(awaitState, initState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeFailed), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (occupied)
	currentTrans := new Transition(awaitState, initState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeOccupied), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	
	return;
}

-- generates the static statechart frame for the executor statechart (the 'black' parts in the manager generation template)
helper generateStaticExecutorStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable = new Variable(genVarManager_Executor_Reuqest, rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	-- create states
	var idleState : State := new State(genStateManager_Executor_Idle);
	idleState.initial := true;
	idleState.entryEvent := new EntryEvent(createSimpleAssignmentExpressioninBlock(requestVar, 'false'), null);
	rtsc.states += idleState;
	
	var requestState : State := new State(genStateManager_Executor_Request);
	rtsc.states += requestState;
	
	var executeState : State := new State(genStateManager_Executor_ExecuteReconf);
	rtsc.states += executeState;
	
	var waitState : State := new State(genStateManager_Executor_WaitForConfirm);
	rtsc.states += waitState;
	
	var finishedState : State := new State(genStateManager_Executor_Finished);
	finishedState.urgent := true;
	rtsc.states += finishedState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- Idle -> ExecuteReconf
	currentTrans := new Transition(idleState, executeState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuteReconf), SynchronizationKind::RECEIVE, 
			null);
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeExecute), EventKind::RAISE);
	-- FIXME: add parameter binding
	rtsc.transitions += currentTrans;
	
	-- ExecuteReconf -> Finished (success)
	currentTrans := new Transition(executeState, finishedState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::SEND, 
			new LiteralExpression('true'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeSuccess), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- ExecuteReconf -> Finished (failed)
	currentTrans := new Transition(executeState, finishedState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeFailed), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- Finished -> Idle (request + sucess)
	currentTrans := new Transition(finishedState, idleState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('true'));
	rtsc.transitions += currentTrans;
	
	-- Finished -> Idle (request + failed)
	currentTrans := new Transition(finishedState, idleState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	rtsc.transitions += currentTrans;
	
	-- Finished -> Idle (no request)
	currentTrans := new Transition(finishedState, idleState, 3);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Request -> ExecuteReconf
	currentTrans := new Transition(requestState, executeState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuteReconf), SynchronizationKind::RECEIVE, 
			null);
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeConfirmRequest), EventKind::RAISE);
	-- FIXME: add parameter binding
	rtsc.transitions += currentTrans;
	
		-- Request -> WaitForConfirm
	currentTrans := new Transition(requestState, waitState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeDeclineRequest), EventKind::RAISE);
	rtsc.transitions += currentTrans;
	
	-- WaitForConfirm -> Idle
	currentTrans := new Transition(waitState, idleState, 1);
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeFailed), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	return;
}

-- generates the static statechart frame for the internal behavior statechart (the 'black' parts in the manager generation template)
helper generateStaticInternalBehaviorStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable := new Variable(genVarManager_Internal_Request, rootNode.getPrimitiveType(boolType));
	var resultVar : Variable := new Variable(genVarManager_Internal_Result, rootNode.getPrimitiveType(boolType));
	
	-- create states
	var idleState : State := new State(genStateManager_Internal_Idle);
	idleState.initial := true;
	idleState.entryEvent := new EntryEvent(createSimpleAssignmentExpressioninBlock(requestVar, 'false'), null);
	rtsc.states += idleState;
	
	var planState : State := new State(genStateManager_Internal_Plan);
	planState.urgent := true;
	rtsc.states += planState;
	
	var executeState : State := new State(genStateManager_Internal_Execute);
	rtsc.states += executeState;
	
	var successState : State := new State(genStateManager_Internal_Success);
	successState.urgent := true;
	rtsc.states += successState;
	
	var failState : State := new State(genStateManager_Internal_Fail);
	successState.urgent := true;
	rtsc.states += successState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- Plan -> Execute
	currentTrans := new Transition(planState, executeState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(resultVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuteReconf), SynchronizationKind::SEND, 
			null);
	rtsc.transitions += currentTrans;
	
	-- Plan -> Fail
	currentTrans := new Transition(planState, executeState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(resultVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Execute -> Fail
	currentTrans := new Transition(executeState, failState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::RECEIVE, 
			new LiteralExpression('false'));
	rtsc.transitions += currentTrans;
	
	-- Execute -> Success
	currentTrans := new Transition(executeState, successState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanExecuted), SynchronizationKind::RECEIVE, 
			new LiteralExpression('true'));
	rtsc.transitions += currentTrans;
	
	-- Success -> Idle (request)
	currentTrans := new Transition(successState, idleState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('true'));
	rtsc.transitions += currentTrans;
	
	-- Success -> Idle (no request)
	currentTrans := new Transition(successState, idleState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Fail -> Idle (request)
	currentTrans := new Transition(failState, idleState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	rtsc.transitions += currentTrans;
	
	-- Fail -> Idle (no request)
	currentTrans := new Transition(failState, idleState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	return;
}

-- generates the static statechart frame for the embeddedCI statechart (the 'black' parts in the manager generation template)
helper generateStaticEmbeddedCIStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	--create initial state
	var mainState : State := new State(genStateManager_EmbeddedCI_Main);
	mainState.initial := true;
	rtsc.states += mainState;

	-- create embedded statecharts	
	var adaptationRTSC : RealtimeStatechart := createEmbeddedRTSC('adaptation', mainState, 2);
	generateStaticEmbeddedCIAdaptationStatechartFrame(rootNode, adaptationRTSC);
	
	var subroleRTSC : RealtimeStatechart := createEmbeddedRTSC('subrole', mainState, 1);
	generateStaticEmbeddedCISubroleStatechartFrame(rootNode, subroleRTSC);
	
	return;
}

-- generates the static statechart frame for the adaptation substatechart of the embeddedCI statechart (the 'black' parts in the manager generation template)
helper generateStaticEmbeddedCIAdaptationStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create states
	var initState : State := new State(genStateManager_EmbeddedCI_Idle);
	initState.initial := true;
	rtsc.states += initState;
	
	return;
}

-- generates the static statechart frame for the subrole substatechart of the embeddedCI statechart (the 'black' parts in the manager generation template)
helper generateStaticEmbeddedCISubroleStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable := new Variable(genVarManager_embeddedCI_Request, rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	var propVar : Variable := new Variable(genVarManager_embeddedCI_Propagate, rootNode.getPrimitiveType(boolType));
	rtsc.variables += propVar;
	
	-- create clocks
	var reqClock : Clock := new Clock(genClockManager_embeddedCI_cReq);
	rtsc.clocks += reqClock;
	
	-- create states
	var idleState : State := new State(genStateManager_EmbeddedCI_Idle);
	idleState.initial := true;
	rtsc.states += idleState;
	
	var deliverState : State := new State(genStateManager_EmbeddedCI_Deliver);
	deliverState.urgent := true;
	rtsc.states += deliverState;
	
	var awaitState : State := new State(genStateManager_EmbeddedCI_AwaitReply);
	rtsc.states += awaitState;
	
	var awaitParentState : State := new State(genStateManager_EmbeddedCI_AwaitParent);
	rtsc.states += awaitParentState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- DeliverMsg -> AwaitReply
	currentTrans := new Transition(deliverState, awaitState, 2);
	-- FIXME: correct guard
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	rtsc.transitions += currentTrans;
	
	return;
}