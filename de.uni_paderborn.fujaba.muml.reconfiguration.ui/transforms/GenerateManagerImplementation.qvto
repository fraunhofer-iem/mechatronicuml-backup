import transforms.lib.RTSCBaseLibrary;
import transforms.lib.ActionLanguageBaseLibrary;
import transforms.lib.TypeAndBehaviorLibrary;
import transforms.lib.MessageTypeLibrary;
import transforms.lib.ProjectSpecificConstants;

--core models
modeltype core uses core('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype expressions_common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype modelinst uses modelinstance("http://www.fujaba.de/modelinstance/0.3.15");

-- muml models 
modeltype behavior uses muml::behavior("http://www.fujaba.de/muml/0.2.2");
modeltype component uses muml::component("http://www.fujaba.de/muml/0.2.2");
modeltype connector uses muml::connector("http://www.fujaba.de/muml/0.2.2");
modeltype constraints uses muml::constraint("http://www.fujaba.de/muml/0.2.2");
modeltype deployment uses muml::deployment("http://www.fujaba.de/muml/0.2.2");
modeltype instance uses muml::instance("http://www.fujaba.de/muml/0.2.2");
modeltype msgi uses muml::msgtype("http://www.fujaba.de/muml/0.2.2");
modeltype protocol uses muml::protocol("http://www.fujaba.de/muml/0.2.2");
modeltype realtimestatechart uses muml::realtimestatechart('http://www.fujaba.de/muml/0.2.2');
modeltype types uses muml::types("http://www.fujaba.de/muml/0.2.2");
modeltype valuetype uses muml::valuetype("http://www.fujaba.de/muml/0.2.2");

modeltype actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.3.16');
modeltype reconf uses reconfiguration("http://www.fujaba.de/muml/reconfiguration/0.3.18");
modeltype reconf_expressions uses reconfiguration::expression("http://www.fujaba.de/muml/reconfiguration/0.3.18");
modeltype reconf_datatype uses reconfiguration::structdatatype("http://www.fujaba.de/muml/reconfiguration/0.3.18");

modeltype componentpattern uses componentstorydiagram::componentstorypattern("http://www.fujaba.de/muml/componentstorydiagram/0.3.1");
modeltype componentstory uses componentstorydiagram::controlflow("http://www.fujaba.de/muml/componentstorydiagram/0.3.1");

-- this transformation parses the reconfiguration specification of the manager of the
-- reconfigurable structured component contained in inputComponent and generates a behavior
-- specification in terms of real-time statecharts for it
transformation GenerateManagerImplementation(inout inputComponent : component, inout category : modelinst);

main() {

	var theComponent : ReconfigurableStructuredComponent := inputComponent.rootObjects()[ReconfigurableStructuredComponent] -> any(true);
	var rootNode : RootNode := category.rootObjects()[RootNode] -> any(true);
	
	createManagerImplementation(theComponent, rootNode);
	
}

-- creates and implementation for the manager
helper createManagerImplementation(inout theComponent : ReconfigurableStructuredComponent, inout rootNode : RootNode){
	
	-- create the statechart
	var rtsc : RealtimeStatechart := new RealtimeStatechart(theComponent.name + '_Manager_RTSC');
	rtsc.comment := 'Generated Real-Time Statechart -- DO NOT EDIT!';
	
	-- assign it to the manager
	theComponent.manager.behavior := rtsc;
	
	-- add statechart to category
	rootNode.getRTSCCategory().modelElements += rtsc;
	
	--generate static statechart frame
	generateStaticStatechartFrame(rootNode, rtsc);
	
	return;
}

-- generates the static statechart frame (the 'black' parts in the manager generation template)
helper generateStaticStatechartFrame(inout rootNode : RootNode, inout managerRTSC : RealtimeStatechart){
	
	-- generate initial state
	var initialState : State := new State('Manager_Main');
	initialState.initial := true;
	managerRTSC.states += initialState;
	
	-- add variables
	managerRTSC.variables += new Variable('reconfiguration', rootNode.getPrimitiveType(intType));
	
	-- add sync channels
	initialState.channels += new SynchronizationChannel(genSyncChanReply, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanParentReply, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanExecuted, rootNode.getPrimitiveType(boolType));
	initialState.channels += new SynchronizationChannel(genSyncChanExecuteReconf, null);
	
	-- generate embedded statecharts
	var parentSubRTSC : RealtimeStatechart := createEmbeddedRTSC('parent', initialState, 2);
	generateStaticParentStatechartFrame(rootNode, parentSubRTSC);
	
	var executorSubRTSC : RealtimeStatechart := createEmbeddedRTSC('executor', initialState, 1);
	generateStaticExecutorStatechartFrame(rootNode, executorSubRTSC);
	
	var internalRTSC : RealtimeStatechart := createEmbeddedRTSC('internal behavior', initialState, 3);
	generateStaticInternalBehaviorStatechartFrame(rootNode, internalRTSC);
	
	var embeddedCISubRTSC : RealtimeStatechart := createEmbeddedRTSC('embeddedCI', initialState, 4);
	generateStaticEmbeddedCIStatechartFrame(rootNode, embeddedCISubRTSC);
	
	return;
}

-- generates the static statechart frame for the parent statechart (the 'black' parts in the manager generation template)
helper generateStaticParentStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	-- create variables
	var requestVar : Variable := new Variable('request', rootNode.getPrimitiveType(boolType));
	rtsc.variables += requestVar;
	
	-- create states
	var initState : State := new State('Idle');
	initState.initial := true;
	initState.entryEvent := new EntryEvent(createSimpleAssignmentExpressioninBlock(requestVar, 'false'), null);
	rtsc.states += initState;
	
	var propState : State := new State('Propagated');
	propState.urgent := true;
	rtsc.states += propState;
	
	var awaitState : State := new State('AwaitReply');
	rtsc.states += awaitState;
	
	-- create transitions
	var currentTrans : Transition = null;
	
	-- Propagated -> Idle
	currentTrans := new Transition(propState, initState, 1);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'false');
	rtsc.transitions += currentTrans;
	
	-- Propagated -> AwaitReply
	currentTrans := new Transition(propState, awaitState, 2);
	currentTrans.guard := createSimpleCompareGuardExpression(requestVar, 'true');
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (success)
	currentTrans := new Transition(awaitState, initState, 3);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('true'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeSuccess), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (failed)
	currentTrans := new Transition(awaitState, initState, 2);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeFailed), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	-- AwaitReply -> Idle (occupied)
	currentTrans := new Transition(awaitState, initState, 1);
	currentTrans.synchronization := new Synchronization(getSynchronizationChannel(rtsc, genSyncChanReply), SynchronizationKind::SEND, 
			new LiteralExpression('false'));
	currentTrans.events += new AsynchronousMessageEvent(getGeneratedReconfigurationMessageType(rootNode, genMsgTypeOccupied), EventKind::TRIGGER);
	rtsc.transitions += currentTrans;
	
	
	return;
}

-- generates the static statechart frame for the executor statechart (the 'black' parts in the manager generation template)
helper generateStaticExecutorStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	
	return;
}

-- generates the static statechart frame for the internal behavior statechart (the 'black' parts in the manager generation template)
helper generateStaticInternalBehaviorStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	
	return;
}

-- generates the static statechart frame for the embeddedCI statechart (the 'black' parts in the manager generation template)
helper generateStaticEmbeddedCIStatechartFrame(inout rootNode : RootNode, inout rtsc : RealtimeStatechart){
	
	
	return;
}

