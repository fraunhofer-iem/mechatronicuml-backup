/*
 * generated by Xtext
 */
package org.muml.psm.allocation.ilp.lpsolve.xtext.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class LPSolveGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class IntegerLinearProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.IntegerLinearProgram");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cObjectiveFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cObjectiveFunctionObjectiveFunctionExpressionParserRuleCall_0_0 = (RuleCall)cObjectiveFunctionAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsConstraintExpressionParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		private final Assignment cVariablesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariablesVariableParserRuleCall_2_0 = (RuleCall)cVariablesAssignment_2.eContents().get(0);
		
		////import "platform:/resource/org.muml.core/model/core.ecore#//expressions" as expressions
		//IntegerLinearProgram ilp::IntegerLinearProgram:
		//	objectiveFunction=ObjectiveFunctionExpression
		//	constraints+=ConstraintExpression*
		//	variables+=Variable*
		@Override public ParserRule getRule() { return rule; }

		//objectiveFunction=ObjectiveFunctionExpression constraints+=ConstraintExpression* variables+=Variable*
		public Group getGroup() { return cGroup; }

		//objectiveFunction=ObjectiveFunctionExpression
		public Assignment getObjectiveFunctionAssignment_0() { return cObjectiveFunctionAssignment_0; }

		//ObjectiveFunctionExpression
		public RuleCall getObjectiveFunctionObjectiveFunctionExpressionParserRuleCall_0_0() { return cObjectiveFunctionObjectiveFunctionExpressionParserRuleCall_0_0; }

		//constraints+=ConstraintExpression*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }

		//ConstraintExpression
		public RuleCall getConstraintsConstraintExpressionParserRuleCall_1_0() { return cConstraintsConstraintExpressionParserRuleCall_1_0; }

		//variables+=Variable*
		public Assignment getVariablesAssignment_2() { return cVariablesAssignment_2; }

		//Variable
		public RuleCall getVariablesVariableParserRuleCall_2_0() { return cVariablesVariableParserRuleCall_2_0; }
	}

	public class ObjectiveFunctionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.ObjectiveFunctionExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cMinKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cMaxKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cGoalAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cGoalObjectiveGoalEnumRuleCall_1_0_0 = (RuleCall)cGoalAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cObjectiveFunctionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cObjectiveFunctionLinearExpressionParserRuleCall_1_2_0 = (RuleCall)cObjectiveFunctionAssignment_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//ObjectiveFunctionExpression ilp::ObjectiveFunctionExpression:
		//	('min' | 'max') ':' ';' | goal=ObjectiveGoal ':' objectiveFunction=LinearExpression ';'
		@Override public ParserRule getRule() { return rule; }

		//('min' | 'max') ':' ';' | goal=ObjectiveGoal ':' objectiveFunction=LinearExpression ';'
		public Alternatives getAlternatives() { return cAlternatives; }

		//('min' | 'max') ':' ';'
		public Group getGroup_0() { return cGroup_0; }

		//('min' | 'max')
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//'min'
		public Keyword getMinKeyword_0_0_0() { return cMinKeyword_0_0_0; }

		//'max'
		public Keyword getMaxKeyword_0_0_1() { return cMaxKeyword_0_0_1; }

		//':'
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//';'
		public Keyword getSemicolonKeyword_0_2() { return cSemicolonKeyword_0_2; }

		//goal=ObjectiveGoal ':' objectiveFunction=LinearExpression ';'
		public Group getGroup_1() { return cGroup_1; }

		//goal=ObjectiveGoal
		public Assignment getGoalAssignment_1_0() { return cGoalAssignment_1_0; }

		//ObjectiveGoal
		public RuleCall getGoalObjectiveGoalEnumRuleCall_1_0_0() { return cGoalObjectiveGoalEnumRuleCall_1_0_0; }

		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//objectiveFunction=LinearExpression
		public Assignment getObjectiveFunctionAssignment_1_2() { return cObjectiveFunctionAssignment_1_2; }

		//LinearExpression
		public RuleCall getObjectiveFunctionLinearExpressionParserRuleCall_1_2_0() { return cObjectiveFunctionLinearExpressionParserRuleCall_1_2_0; }

		//';'
		public Keyword getSemicolonKeyword_1_3() { return cSemicolonKeyword_1_3; }
	}

	public class ConstraintExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.ConstraintExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cCommentVariableIDParserRuleCall_0_0_0 = (RuleCall)cCommentAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cLeftExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftExpressionSimpleLinearExpressionParserRuleCall_1_0 = (RuleCall)cLeftExpressionAssignment_1.eContents().get(0);
		private final Assignment cOperatorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperatorRelationalOperatorEnumRuleCall_2_0 = (RuleCall)cOperatorAssignment_2.eContents().get(0);
		private final Assignment cRightExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightExpressionSimpleLinearExpressionParserRuleCall_3_0 = (RuleCall)cRightExpressionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConstraintExpression ilp::ConstraintExpression:
		//	(comment=VariableID ':')? leftExpression=SimpleLinearExpression operator=RelationalOperator
		//	rightExpression=SimpleLinearExpression ';'
		@Override public ParserRule getRule() { return rule; }

		//(comment=VariableID ':')? leftExpression=SimpleLinearExpression operator=RelationalOperator
		//rightExpression=SimpleLinearExpression ';'
		public Group getGroup() { return cGroup; }

		//(comment=VariableID ':')?
		public Group getGroup_0() { return cGroup_0; }

		//comment=VariableID
		public Assignment getCommentAssignment_0_0() { return cCommentAssignment_0_0; }

		//VariableID
		public RuleCall getCommentVariableIDParserRuleCall_0_0_0() { return cCommentVariableIDParserRuleCall_0_0_0; }

		//':'
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//leftExpression=SimpleLinearExpression
		public Assignment getLeftExpressionAssignment_1() { return cLeftExpressionAssignment_1; }

		//SimpleLinearExpression
		public RuleCall getLeftExpressionSimpleLinearExpressionParserRuleCall_1_0() { return cLeftExpressionSimpleLinearExpressionParserRuleCall_1_0; }

		//operator=RelationalOperator
		public Assignment getOperatorAssignment_2() { return cOperatorAssignment_2; }

		//RelationalOperator
		public RuleCall getOperatorRelationalOperatorEnumRuleCall_2_0() { return cOperatorRelationalOperatorEnumRuleCall_2_0; }

		//rightExpression=SimpleLinearExpression
		public Assignment getRightExpressionAssignment_3() { return cRightExpressionAssignment_3; }

		//SimpleLinearExpression
		public RuleCall getRightExpressionSimpleLinearExpressionParserRuleCall_3_0() { return cRightExpressionSimpleLinearExpressionParserRuleCall_3_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDataTypeILPDataTypeEnumRuleCall_0_0 = (RuleCall)cDataTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameVariableIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Variable ilp::Variable:
		//	dataType=ILPDataType name=VariableID ';'
		@Override public ParserRule getRule() { return rule; }

		//dataType=ILPDataType name=VariableID ';'
		public Group getGroup() { return cGroup; }

		//dataType=ILPDataType
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//ILPDataType
		public RuleCall getDataTypeILPDataTypeEnumRuleCall_0_0() { return cDataTypeILPDataTypeEnumRuleCall_0_0; }

		//name=VariableID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//VariableID
		public RuleCall getNameVariableIDParserRuleCall_1_0() { return cNameVariableIDParserRuleCall_1_0; }

		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class VariableIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.VariableID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_1_0 = (RuleCall)cAlternatives_1_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_1_0 = (RuleCall)cGroup_1_1_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1_1_1 = (RuleCall)cGroup_1_1_1.eContents().get(1);
		
		//VariableID:
		//	ID ('.' (ID | INT ID?))*;
		@Override public ParserRule getRule() { return rule; }

		//ID ('.' (ID | INT ID?))*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//('.' (ID | INT ID?))*
		public Group getGroup_1() { return cGroup_1; }

		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//(ID | INT ID?)
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1_0() { return cIDTerminalRuleCall_1_1_0; }

		//INT ID?
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1_0() { return cINTTerminalRuleCall_1_1_1_0; }

		//ID?
		public RuleCall getIDTerminalRuleCall_1_1_1_1() { return cIDTerminalRuleCall_1_1_1_1; }
	}

	public class LinearExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.LinearExpression");
		private final RuleCall cSimpleLinearExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LinearExpression ilp::Expression:
		//	SimpleLinearExpression
		@Override public ParserRule getRule() { return rule; }

		//// if you need a more sophisticated expression grammar override this rule
		//SimpleLinearExpression
		public RuleCall getSimpleLinearExpressionParserRuleCall() { return cSimpleLinearExpressionParserRuleCall; }
	}

	public class SimpleLinearExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.SimpleLinearExpression");
		private final RuleCall cAdditionExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SimpleLinearExpression ilp::Expression:
		//	AdditionExpression
		@Override public ParserRule getRule() { return rule; }

		//AdditionExpression
		public RuleCall getAdditionExpressionParserRuleCall() { return cAdditionExpressionParserRuleCall; }
	}

	public class AdditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.AdditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditionOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionLinearExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//AdditionExpression ilp::Expression:
		//	MultiplicationExpression ({ilp::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//	rightExpression=LinearExpression)?
		@Override public ParserRule getRule() { return rule; }

		//MultiplicationExpression ({ilp::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=LinearExpression)?
		public Group getGroup() { return cGroup; }

		//MultiplicationExpression
		public RuleCall getMultiplicationExpressionParserRuleCall_0() { return cMultiplicationExpressionParserRuleCall_0; }

		//({ilp::ArithmeticExpression.leftExpression=current} operator=AdditionOperator rightExpression=LinearExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{ilp::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=AdditionOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditionOperator
		public RuleCall getOperatorAdditionOperatorEnumRuleCall_1_1_0() { return cOperatorAdditionOperatorEnumRuleCall_1_1_0; }

		//rightExpression=LinearExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//LinearExpression
		public RuleCall getRightExpressionLinearExpressionParserRuleCall_1_2_0() { return cRightExpressionLinearExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.MultiplicationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOperandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicationOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionOperandParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//// XXX: here we also allow non-linear expressions, but we do not care,
		//// because this grammar is just for internal use (test fixture specification)
		//MultiplicationExpression ilp::Expression:
		//	Operand ({ilp::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator rightExpression=Operand)?
		@Override public ParserRule getRule() { return rule; }

		//Operand ({ilp::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator rightExpression=Operand)?
		public Group getGroup() { return cGroup; }

		//Operand
		public RuleCall getOperandParserRuleCall_0() { return cOperandParserRuleCall_0; }

		//({ilp::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator rightExpression=Operand)?
		public Group getGroup_1() { return cGroup_1; }

		//{ilp::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=MultiplicationOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//MultiplicationOperator
		public RuleCall getOperatorMultiplicationOperatorEnumRuleCall_1_1_0() { return cOperatorMultiplicationOperatorEnumRuleCall_1_1_0; }

		//rightExpression=Operand
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//Operand
		public RuleCall getRightExpressionOperandParserRuleCall_1_2_0() { return cRightExpressionOperandParserRuleCall_1_2_0; }
	}

	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Operand ilp::Expression:
		//	NumberLiteralExpression | VariableExpression
		@Override public ParserRule getRule() { return rule; }

		//NumberLiteralExpression | VariableExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteralExpression
		public RuleCall getNumberLiteralExpressionParserRuleCall_0() { return cNumberLiteralExpressionParserRuleCall_0; }

		//VariableExpression
		public RuleCall getVariableExpressionParserRuleCall_1() { return cVariableExpressionParserRuleCall_1; }
	}

	public class NumberLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.NumberLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNumberParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumberLiteralExpression ilp::LiteralExpression:
		//	value=Number
		@Override public ParserRule getRule() { return rule; }

		//value=Number
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Number
		public RuleCall getValueNumberParserRuleCall_0() { return cValueNumberParserRuleCall_0; }
	}

	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.Number");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cDecimalParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//Number:
		//	'-'? (Decimal | INT);
		@Override public ParserRule getRule() { return rule; }

		//'-'? (Decimal | INT)
		public Group getGroup() { return cGroup; }

		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//(Decimal | INT)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//Decimal
		public RuleCall getDecimalParserRuleCall_1_0() { return cDecimalParserRuleCall_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}

	public class DecimalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.Decimal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Decimal:
		//	INT '.' INT;
		@Override public ParserRule getRule() { return rule; }

		//INT '.' INT
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}

	public class VariableExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.VariableExpression");
		private final Assignment cVariableAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cVariableVariableCrossReference_0 = (CrossReference)cVariableAssignment.eContents().get(0);
		private final RuleCall cVariableVariableVariableIDParserRuleCall_0_1 = (RuleCall)cVariableVariableCrossReference_0.eContents().get(1);
		
		//VariableExpression ilp::VariableExpression:
		//	variable=[ilp::Variable|VariableID]
		@Override public ParserRule getRule() { return rule; }

		//variable=[ilp::Variable|VariableID]
		public Assignment getVariableAssignment() { return cVariableAssignment; }

		//[ilp::Variable|VariableID]
		public CrossReference getVariableVariableCrossReference_0() { return cVariableVariableCrossReference_0; }

		//VariableID
		public RuleCall getVariableVariableVariableIDParserRuleCall_0_1() { return cVariableVariableVariableIDParserRuleCall_0_1; }
	}
	
	
	public class ObjectiveGoalElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.ObjectiveGoal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINMinKeyword_0_0 = (Keyword)cMINEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMAXEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMAXMaxKeyword_1_0 = (Keyword)cMAXEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ObjectiveGoal returns ilp::ObjectiveGoal:
		//	MIN='min' | MAX='max';
		public EnumRule getRule() { return rule; }

		//MIN='min' | MAX='max'
		public Alternatives getAlternatives() { return cAlternatives; }

		//MIN='min'
		public EnumLiteralDeclaration getMINEnumLiteralDeclaration_0() { return cMINEnumLiteralDeclaration_0; }

		//'min'
		public Keyword getMINMinKeyword_0_0() { return cMINMinKeyword_0_0; }

		//MAX='max'
		public EnumLiteralDeclaration getMAXEnumLiteralDeclaration_1() { return cMAXEnumLiteralDeclaration_1; }

		//'max'
		public Keyword getMAXMaxKeyword_1_0() { return cMAXMaxKeyword_1_0; }
	}

	public class RelationalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.RelationalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLESS_THAN_OR_EQUAL_TOEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLESS_THAN_OR_EQUAL_TOLessThanSignEqualsSignKeyword_0_0 = (Keyword)cLESS_THAN_OR_EQUAL_TOEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_THAN_OR_EQUAL_TOEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATER_THAN_OR_EQUAL_TOGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cGREATER_THAN_OR_EQUAL_TOEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUAL_TOEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUAL_TOEqualsSignKeyword_2_0 = (Keyword)cEQUAL_TOEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum RelationalOperator returns ilp::Operator:
		//	LESS_THAN_OR_EQUAL_TO='<=' | GREATER_THAN_OR_EQUAL_TO='>=' | EQUAL_TO='=';
		public EnumRule getRule() { return rule; }

		//LESS_THAN_OR_EQUAL_TO='<=' | GREATER_THAN_OR_EQUAL_TO='>=' | EQUAL_TO='='
		public Alternatives getAlternatives() { return cAlternatives; }

		//LESS_THAN_OR_EQUAL_TO='<='
		public EnumLiteralDeclaration getLESS_THAN_OR_EQUAL_TOEnumLiteralDeclaration_0() { return cLESS_THAN_OR_EQUAL_TOEnumLiteralDeclaration_0; }

		//'<='
		public Keyword getLESS_THAN_OR_EQUAL_TOLessThanSignEqualsSignKeyword_0_0() { return cLESS_THAN_OR_EQUAL_TOLessThanSignEqualsSignKeyword_0_0; }

		//GREATER_THAN_OR_EQUAL_TO='>='
		public EnumLiteralDeclaration getGREATER_THAN_OR_EQUAL_TOEnumLiteralDeclaration_1() { return cGREATER_THAN_OR_EQUAL_TOEnumLiteralDeclaration_1; }

		//'>='
		public Keyword getGREATER_THAN_OR_EQUAL_TOGreaterThanSignEqualsSignKeyword_1_0() { return cGREATER_THAN_OR_EQUAL_TOGreaterThanSignEqualsSignKeyword_1_0; }

		//EQUAL_TO='='
		public EnumLiteralDeclaration getEQUAL_TOEnumLiteralDeclaration_2() { return cEQUAL_TOEnumLiteralDeclaration_2; }

		//'='
		public Keyword getEQUAL_TOEqualsSignKeyword_2_0() { return cEQUAL_TOEqualsSignKeyword_2_0; }
	}

	public class ILPDataTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.ILPDataType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBINARYEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBINARYBinKeyword_0_0 = (Keyword)cBINARYEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cINTEGEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cINTEGERIntKeyword_1_0 = (Keyword)cINTEGEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cREALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cREALRealKeyword_2_0 = (Keyword)cREALEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ILPDataType returns ilp::ILPDataType:
		//	BINARY='bin' | INTEGER='int' | REAL='real';
		public EnumRule getRule() { return rule; }

		//BINARY='bin' | INTEGER='int' | REAL='real'
		public Alternatives getAlternatives() { return cAlternatives; }

		//BINARY='bin'
		public EnumLiteralDeclaration getBINARYEnumLiteralDeclaration_0() { return cBINARYEnumLiteralDeclaration_0; }

		//'bin'
		public Keyword getBINARYBinKeyword_0_0() { return cBINARYBinKeyword_0_0; }

		//INTEGER='int'
		public EnumLiteralDeclaration getINTEGEREnumLiteralDeclaration_1() { return cINTEGEREnumLiteralDeclaration_1; }

		//'int'
		public Keyword getINTEGERIntKeyword_1_0() { return cINTEGERIntKeyword_1_0; }

		//REAL='real'
		public EnumLiteralDeclaration getREALEnumLiteralDeclaration_2() { return cREALEnumLiteralDeclaration_2; }

		//'real'
		public Keyword getREALRealKeyword_2_0() { return cREALRealKeyword_2_0; }
	}

	public class AdditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.AdditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditionOperator returns ilp::Operator:
		//	PLUS='+' | MINUS='-';
		public EnumRule getRule() { return rule; }

		//PLUS='+' | MINUS='-'
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS='+'
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//'+'
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS='-'
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//'-'
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class MultiplicationOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve.MultiplicationOperator");
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cTIMESAsteriskKeyword_0 = (Keyword)cTIMESEnumLiteralDeclaration.eContents().get(0);
		
		//enum MultiplicationOperator returns ilp::Operator:
		//	TIMES='*';
		public EnumRule getRule() { return rule; }

		//TIMES='*'
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration() { return cTIMESEnumLiteralDeclaration; }

		//'*'
		public Keyword getTIMESAsteriskKeyword_0() { return cTIMESAsteriskKeyword_0; }
	}
	
	private final IntegerLinearProgramElements pIntegerLinearProgram;
	private final ObjectiveFunctionExpressionElements pObjectiveFunctionExpression;
	private final ObjectiveGoalElements eObjectiveGoal;
	private final ConstraintExpressionElements pConstraintExpression;
	private final RelationalOperatorElements eRelationalOperator;
	private final VariableElements pVariable;
	private final VariableIDElements pVariableID;
	private final ILPDataTypeElements eILPDataType;
	private final LinearExpressionElements pLinearExpression;
	private final SimpleLinearExpressionElements pSimpleLinearExpression;
	private final AdditionOperatorElements eAdditionOperator;
	private final AdditionExpressionElements pAdditionExpression;
	private final MultiplicationExpressionElements pMultiplicationExpression;
	private final MultiplicationOperatorElements eMultiplicationOperator;
	private final OperandElements pOperand;
	private final NumberLiteralExpressionElements pNumberLiteralExpression;
	private final NumberElements pNumber;
	private final DecimalElements pDecimal;
	private final VariableExpressionElements pVariableExpression;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LPSolveGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pIntegerLinearProgram = new IntegerLinearProgramElements();
		this.pObjectiveFunctionExpression = new ObjectiveFunctionExpressionElements();
		this.eObjectiveGoal = new ObjectiveGoalElements();
		this.pConstraintExpression = new ConstraintExpressionElements();
		this.eRelationalOperator = new RelationalOperatorElements();
		this.pVariable = new VariableElements();
		this.pVariableID = new VariableIDElements();
		this.eILPDataType = new ILPDataTypeElements();
		this.pLinearExpression = new LinearExpressionElements();
		this.pSimpleLinearExpression = new SimpleLinearExpressionElements();
		this.eAdditionOperator = new AdditionOperatorElements();
		this.pAdditionExpression = new AdditionExpressionElements();
		this.pMultiplicationExpression = new MultiplicationExpressionElements();
		this.eMultiplicationOperator = new MultiplicationOperatorElements();
		this.pOperand = new OperandElements();
		this.pNumberLiteralExpression = new NumberLiteralExpressionElements();
		this.pNumber = new NumberElements();
		this.pDecimal = new DecimalElements();
		this.pVariableExpression = new VariableExpressionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////import "platform:/resource/org.muml.core/model/core.ecore#//expressions" as expressions
	//IntegerLinearProgram ilp::IntegerLinearProgram:
	//	objectiveFunction=ObjectiveFunctionExpression
	//	constraints+=ConstraintExpression*
	//	variables+=Variable*
	public IntegerLinearProgramElements getIntegerLinearProgramAccess() {
		return pIntegerLinearProgram;
	}
	
	public ParserRule getIntegerLinearProgramRule() {
		return getIntegerLinearProgramAccess().getRule();
	}

	//ObjectiveFunctionExpression ilp::ObjectiveFunctionExpression:
	//	('min' | 'max') ':' ';' | goal=ObjectiveGoal ':' objectiveFunction=LinearExpression ';'
	public ObjectiveFunctionExpressionElements getObjectiveFunctionExpressionAccess() {
		return pObjectiveFunctionExpression;
	}
	
	public ParserRule getObjectiveFunctionExpressionRule() {
		return getObjectiveFunctionExpressionAccess().getRule();
	}

	//enum ObjectiveGoal returns ilp::ObjectiveGoal:
	//	MIN='min' | MAX='max';
	public ObjectiveGoalElements getObjectiveGoalAccess() {
		return eObjectiveGoal;
	}
	
	public EnumRule getObjectiveGoalRule() {
		return getObjectiveGoalAccess().getRule();
	}

	//ConstraintExpression ilp::ConstraintExpression:
	//	(comment=VariableID ':')? leftExpression=SimpleLinearExpression operator=RelationalOperator
	//	rightExpression=SimpleLinearExpression ';'
	public ConstraintExpressionElements getConstraintExpressionAccess() {
		return pConstraintExpression;
	}
	
	public ParserRule getConstraintExpressionRule() {
		return getConstraintExpressionAccess().getRule();
	}

	//enum RelationalOperator returns ilp::Operator:
	//	LESS_THAN_OR_EQUAL_TO='<=' | GREATER_THAN_OR_EQUAL_TO='>=' | EQUAL_TO='=';
	public RelationalOperatorElements getRelationalOperatorAccess() {
		return eRelationalOperator;
	}
	
	public EnumRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}

	//Variable ilp::Variable:
	//	dataType=ILPDataType name=VariableID ';'
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//VariableID:
	//	ID ('.' (ID | INT ID?))*;
	public VariableIDElements getVariableIDAccess() {
		return pVariableID;
	}
	
	public ParserRule getVariableIDRule() {
		return getVariableIDAccess().getRule();
	}

	//enum ILPDataType returns ilp::ILPDataType:
	//	BINARY='bin' | INTEGER='int' | REAL='real';
	public ILPDataTypeElements getILPDataTypeAccess() {
		return eILPDataType;
	}
	
	public EnumRule getILPDataTypeRule() {
		return getILPDataTypeAccess().getRule();
	}

	//LinearExpression ilp::Expression:
	//	SimpleLinearExpression
	public LinearExpressionElements getLinearExpressionAccess() {
		return pLinearExpression;
	}
	
	public ParserRule getLinearExpressionRule() {
		return getLinearExpressionAccess().getRule();
	}

	//SimpleLinearExpression ilp::Expression:
	//	AdditionExpression
	public SimpleLinearExpressionElements getSimpleLinearExpressionAccess() {
		return pSimpleLinearExpression;
	}
	
	public ParserRule getSimpleLinearExpressionRule() {
		return getSimpleLinearExpressionAccess().getRule();
	}

	//enum AdditionOperator returns ilp::Operator:
	//	PLUS='+' | MINUS='-';
	public AdditionOperatorElements getAdditionOperatorAccess() {
		return eAdditionOperator;
	}
	
	public EnumRule getAdditionOperatorRule() {
		return getAdditionOperatorAccess().getRule();
	}

	//AdditionExpression ilp::Expression:
	//	MultiplicationExpression ({ilp::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
	//	rightExpression=LinearExpression)?
	public AdditionExpressionElements getAdditionExpressionAccess() {
		return pAdditionExpression;
	}
	
	public ParserRule getAdditionExpressionRule() {
		return getAdditionExpressionAccess().getRule();
	}

	//// XXX: here we also allow non-linear expressions, but we do not care,
	//// because this grammar is just for internal use (test fixture specification)
	//MultiplicationExpression ilp::Expression:
	//	Operand ({ilp::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator rightExpression=Operand)?
	public MultiplicationExpressionElements getMultiplicationExpressionAccess() {
		return pMultiplicationExpression;
	}
	
	public ParserRule getMultiplicationExpressionRule() {
		return getMultiplicationExpressionAccess().getRule();
	}

	//enum MultiplicationOperator returns ilp::Operator:
	//	TIMES='*';
	public MultiplicationOperatorElements getMultiplicationOperatorAccess() {
		return eMultiplicationOperator;
	}
	
	public EnumRule getMultiplicationOperatorRule() {
		return getMultiplicationOperatorAccess().getRule();
	}

	//Operand ilp::Expression:
	//	NumberLiteralExpression | VariableExpression
	public OperandElements getOperandAccess() {
		return pOperand;
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}

	//NumberLiteralExpression ilp::LiteralExpression:
	//	value=Number
	public NumberLiteralExpressionElements getNumberLiteralExpressionAccess() {
		return pNumberLiteralExpression;
	}
	
	public ParserRule getNumberLiteralExpressionRule() {
		return getNumberLiteralExpressionAccess().getRule();
	}

	//Number:
	//	'-'? (Decimal | INT);
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	//Decimal:
	//	INT '.' INT;
	public DecimalElements getDecimalAccess() {
		return pDecimal;
	}
	
	public ParserRule getDecimalRule() {
		return getDecimalAccess().getRule();
	}

	//VariableExpression ilp::VariableExpression:
	//	variable=[ilp::Variable|VariableID]
	public VariableExpressionElements getVariableExpressionAccess() {
		return pVariableExpression;
	}
	
	public ParserRule getVariableExpressionRule() {
		return getVariableExpressionAccess().getRule();
	}

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
