/*
* generated by Xtext
*/
package org.muml.psm.allocation.ilp.lpsolve.xtext.services;

import java.util.List;

import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

import com.google.inject.Inject;
import com.google.inject.Singleton;

@Singleton
public class LPSolveGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class IntegerLinearProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerLinearProgram");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cObjectiveFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cObjectiveFunctionObjectiveFunctionExpressionParserRuleCall_0_0 = (RuleCall)cObjectiveFunctionAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsConstraintExpressionParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		private final Assignment cVariablesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariablesVariableParserRuleCall_2_0 = (RuleCall)cVariablesAssignment_2.eContents().get(0);
		
		////import "platform:/resource/org.muml.core/model/core.ecore#//expressions/common" as common
		//IntegerLinearProgram returns ilp::IntegerLinearProgram:
		//	objectiveFunction=ObjectiveFunctionExpression constraints+=ConstraintExpression* variables+=Variable*;
		public ParserRule getRule() { return rule; }

		//objectiveFunction=ObjectiveFunctionExpression constraints+=ConstraintExpression* variables+=Variable*
		public Group getGroup() { return cGroup; }

		//objectiveFunction=ObjectiveFunctionExpression
		public Assignment getObjectiveFunctionAssignment_0() { return cObjectiveFunctionAssignment_0; }

		//ObjectiveFunctionExpression
		public RuleCall getObjectiveFunctionObjectiveFunctionExpressionParserRuleCall_0_0() { return cObjectiveFunctionObjectiveFunctionExpressionParserRuleCall_0_0; }

		//constraints+=ConstraintExpression*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }

		//ConstraintExpression
		public RuleCall getConstraintsConstraintExpressionParserRuleCall_1_0() { return cConstraintsConstraintExpressionParserRuleCall_1_0; }

		//variables+=Variable*
		public Assignment getVariablesAssignment_2() { return cVariablesAssignment_2; }

		//Variable
		public RuleCall getVariablesVariableParserRuleCall_2_0() { return cVariablesVariableParserRuleCall_2_0; }
	}

	public class ObjectiveFunctionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ObjectiveFunctionExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cMinKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cMaxKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cGoalAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cGoalObjectiveGoalEnumRuleCall_1_0_0 = (RuleCall)cGoalAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cObjectiveFunctionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cObjectiveFunctionLinearExpressionParserRuleCall_1_2_0 = (RuleCall)cObjectiveFunctionAssignment_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//ObjectiveFunctionExpression returns ilp::ObjectiveFunctionExpression:
		//	("min" | "max") ":" ";" // support lpsolve's (strange) specification of a non-existent objective function
		//	// (in this case _no_ ObjectiveFunctionExpression object should be created)
		//	| goal=ObjectiveGoal ":" objectiveFunction=LinearExpression ";";
		public ParserRule getRule() { return rule; }

		//("min" | "max") ":" ";" // support lpsolve's (strange) specification of a non-existent objective function
		//// (in this case _no_ ObjectiveFunctionExpression object should be created)
		//| goal=ObjectiveGoal ":" objectiveFunction=LinearExpression ";"
		public Alternatives getAlternatives() { return cAlternatives; }

		//("min" | "max") ":" ";"
		public Group getGroup_0() { return cGroup_0; }

		//"min" | "max"
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"min"
		public Keyword getMinKeyword_0_0_0() { return cMinKeyword_0_0_0; }

		//"max"
		public Keyword getMaxKeyword_0_0_1() { return cMaxKeyword_0_0_1; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//";"
		public Keyword getSemicolonKeyword_0_2() { return cSemicolonKeyword_0_2; }

		//goal=ObjectiveGoal ":" objectiveFunction=LinearExpression ";"
		public Group getGroup_1() { return cGroup_1; }

		//goal=ObjectiveGoal
		public Assignment getGoalAssignment_1_0() { return cGoalAssignment_1_0; }

		//ObjectiveGoal
		public RuleCall getGoalObjectiveGoalEnumRuleCall_1_0_0() { return cGoalObjectiveGoalEnumRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//objectiveFunction=LinearExpression
		public Assignment getObjectiveFunctionAssignment_1_2() { return cObjectiveFunctionAssignment_1_2; }

		//LinearExpression
		public RuleCall getObjectiveFunctionLinearExpressionParserRuleCall_1_2_0() { return cObjectiveFunctionLinearExpressionParserRuleCall_1_2_0; }

		//";"
		public Keyword getSemicolonKeyword_1_3() { return cSemicolonKeyword_1_3; }
	}

	public class ConstraintExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstraintExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cCommentVariableIDParserRuleCall_0_0_0 = (RuleCall)cCommentAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cLeftExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftExpressionSimpleLinearExpressionParserRuleCall_1_0 = (RuleCall)cLeftExpressionAssignment_1.eContents().get(0);
		private final Assignment cOperatorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperatorComparingOperatorEnumRuleCall_2_0 = (RuleCall)cOperatorAssignment_2.eContents().get(0);
		private final Assignment cRightExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightExpressionSimpleLinearExpressionParserRuleCall_3_0 = (RuleCall)cRightExpressionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConstraintExpression returns ilp::ConstraintExpression:
		//	(comment=VariableID ":")? // the comment represents an optional name of a restriction
		//	leftExpression=SimpleLinearExpression operator=ComparingOperator rightExpression=SimpleLinearExpression ";";
		public ParserRule getRule() { return rule; }

		//(comment=VariableID ":")? // the comment represents an optional name of a restriction
		//leftExpression=SimpleLinearExpression operator=ComparingOperator rightExpression=SimpleLinearExpression ";"
		public Group getGroup() { return cGroup; }

		//(comment=VariableID ":")?
		public Group getGroup_0() { return cGroup_0; }

		//comment=VariableID
		public Assignment getCommentAssignment_0_0() { return cCommentAssignment_0_0; }

		//VariableID
		public RuleCall getCommentVariableIDParserRuleCall_0_0_0() { return cCommentVariableIDParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//leftExpression=SimpleLinearExpression
		public Assignment getLeftExpressionAssignment_1() { return cLeftExpressionAssignment_1; }

		//SimpleLinearExpression
		public RuleCall getLeftExpressionSimpleLinearExpressionParserRuleCall_1_0() { return cLeftExpressionSimpleLinearExpressionParserRuleCall_1_0; }

		//operator=ComparingOperator
		public Assignment getOperatorAssignment_2() { return cOperatorAssignment_2; }

		//ComparingOperator
		public RuleCall getOperatorComparingOperatorEnumRuleCall_2_0() { return cOperatorComparingOperatorEnumRuleCall_2_0; }

		//rightExpression=SimpleLinearExpression
		public Assignment getRightExpressionAssignment_3() { return cRightExpressionAssignment_3; }

		//SimpleLinearExpression
		public RuleCall getRightExpressionSimpleLinearExpressionParserRuleCall_3_0() { return cRightExpressionSimpleLinearExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDataTypeILPDataTypeEnumRuleCall_0_0 = (RuleCall)cDataTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameVariableIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Variable returns ilp::Variable:
		//	dataType=ILPDataType name=VariableID ";";
		public ParserRule getRule() { return rule; }

		//dataType=ILPDataType name=VariableID ";"
		public Group getGroup() { return cGroup; }

		//dataType=ILPDataType
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//ILPDataType
		public RuleCall getDataTypeILPDataTypeEnumRuleCall_0_0() { return cDataTypeILPDataTypeEnumRuleCall_0_0; }

		//name=VariableID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//VariableID
		public RuleCall getNameVariableIDParserRuleCall_1_0() { return cNameVariableIDParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class VariableIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_1_0 = (RuleCall)cAlternatives_1_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_1_0 = (RuleCall)cGroup_1_1_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1_1_1 = (RuleCall)cGroup_1_1_1.eContents().get(1);
		
		//VariableID returns ecore::EString:
		//	ID ("." (ID | INT ID?))*;
		public ParserRule getRule() { return rule; }

		//ID ("." (ID | INT ID?))*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." (ID | INT ID?))*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID | INT ID?
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1_0() { return cIDTerminalRuleCall_1_1_0; }

		//INT ID?
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1_0() { return cINTTerminalRuleCall_1_1_1_0; }

		//ID?
		public RuleCall getIDTerminalRuleCall_1_1_1_1() { return cIDTerminalRuleCall_1_1_1_1; }
	}

	public class LinearExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LinearExpression");
		private final RuleCall cSimpleLinearExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LinearExpression returns expressions::Expression: // if you need a more sophisticated expression grammar override this rule
		//	SimpleLinearExpression;
		public ParserRule getRule() { return rule; }

		//// if you need a more sophisticated expression grammar override this rule
		//SimpleLinearExpression
		public RuleCall getSimpleLinearExpressionParserRuleCall() { return cSimpleLinearExpressionParserRuleCall; }
	}

	public class SimpleLinearExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleLinearExpression");
		private final RuleCall cAdditionExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SimpleLinearExpression returns expressions::Expression:
		//	AdditionExpression;
		public ParserRule getRule() { return rule; }

		//AdditionExpression
		public RuleCall getAdditionExpressionParserRuleCall() { return cAdditionExpressionParserRuleCall; }
	}

	public class AdditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditionOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionLinearExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//AdditionExpression returns expressions::Expression:
		//	MultiplicationExpression ({common::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//	rightExpression=LinearExpression)?;
		public ParserRule getRule() { return rule; }

		//MultiplicationExpression ({common::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=LinearExpression)?
		public Group getGroup() { return cGroup; }

		//MultiplicationExpression
		public RuleCall getMultiplicationExpressionParserRuleCall_0() { return cMultiplicationExpressionParserRuleCall_0; }

		//({common::ArithmeticExpression.leftExpression=current} operator=AdditionOperator rightExpression=LinearExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{common::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=AdditionOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditionOperator
		public RuleCall getOperatorAdditionOperatorEnumRuleCall_1_1_0() { return cOperatorAdditionOperatorEnumRuleCall_1_1_0; }

		//rightExpression=LinearExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//LinearExpression
		public RuleCall getRightExpressionLinearExpressionParserRuleCall_1_2_0() { return cRightExpressionLinearExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOperandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicationOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionOperandParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//// XXX: here we also allow non-linear expressions, but we do not care,
		//// because this grammar is just for internal use (test fixture specification)
		//MultiplicationExpression returns expressions::Expression:
		//	Operand ({common::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//	rightExpression=Operand)?;
		public ParserRule getRule() { return rule; }

		//Operand ({common::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator rightExpression=Operand)?
		public Group getGroup() { return cGroup; }

		//Operand
		public RuleCall getOperandParserRuleCall_0() { return cOperandParserRuleCall_0; }

		//({common::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator rightExpression=Operand)?
		public Group getGroup_1() { return cGroup_1; }

		//{common::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=MultiplicationOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//MultiplicationOperator
		public RuleCall getOperatorMultiplicationOperatorEnumRuleCall_1_1_0() { return cOperatorMultiplicationOperatorEnumRuleCall_1_1_0; }

		//rightExpression=Operand
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//Operand
		public RuleCall getRightExpressionOperandParserRuleCall_1_2_0() { return cRightExpressionOperandParserRuleCall_1_2_0; }
	}

	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Operand returns expressions::Expression:
		//	NumberLiteralExpression | VariableExpression;
		public ParserRule getRule() { return rule; }

		//NumberLiteralExpression | VariableExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteralExpression
		public RuleCall getNumberLiteralExpressionParserRuleCall_0() { return cNumberLiteralExpressionParserRuleCall_0; }

		//VariableExpression
		public RuleCall getVariableExpressionParserRuleCall_1() { return cVariableExpressionParserRuleCall_1; }
	}

	public class NumberLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNumberParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumberLiteralExpression returns common::LiteralExpression:
		//	value=Number;
		public ParserRule getRule() { return rule; }

		//value=Number
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Number
		public RuleCall getValueNumberParserRuleCall_0() { return cValueNumberParserRuleCall_0; }
	}

	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Number");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cDecimalParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//Number returns ecore::EString:
		//	"-"? (Decimal | INT);
		public ParserRule getRule() { return rule; }

		//"-"? (Decimal | INT)
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//Decimal | INT
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//Decimal
		public RuleCall getDecimalParserRuleCall_1_0() { return cDecimalParserRuleCall_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}

	public class DecimalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Decimal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Decimal returns ecore::EString:
		//	INT "." INT;
		public ParserRule getRule() { return rule; }

		//INT "." INT
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}

	public class VariableExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableExpression");
		private final Assignment cVariableAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cVariableVariableCrossReference_0 = (CrossReference)cVariableAssignment.eContents().get(0);
		private final RuleCall cVariableVariableVariableIDParserRuleCall_0_1 = (RuleCall)cVariableVariableCrossReference_0.eContents().get(1);
		
		//VariableExpression returns ilp::VariableExpression:
		//	variable=[ilp::Variable|VariableID];
		public ParserRule getRule() { return rule; }

		//variable=[ilp::Variable|VariableID]
		public Assignment getVariableAssignment() { return cVariableAssignment; }

		//[ilp::Variable|VariableID]
		public CrossReference getVariableVariableCrossReference_0() { return cVariableVariableCrossReference_0; }

		//VariableID
		public RuleCall getVariableVariableVariableIDParserRuleCall_0_1() { return cVariableVariableVariableIDParserRuleCall_0_1; }
	}
	
	
	public class ObjectiveGoalElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ObjectiveGoal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINMinKeyword_0_0 = (Keyword)cMINEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMAXEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMAXMaxKeyword_1_0 = (Keyword)cMAXEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ObjectiveGoal returns ilp::ObjectiveGoal:
		//	MIN="min" | MAX="max";
		public EnumRule getRule() { return rule; }

		//MIN="min" | MAX="max"
		public Alternatives getAlternatives() { return cAlternatives; }

		//MIN="min"
		public EnumLiteralDeclaration getMINEnumLiteralDeclaration_0() { return cMINEnumLiteralDeclaration_0; }

		//"min"
		public Keyword getMINMinKeyword_0_0() { return cMINMinKeyword_0_0; }

		//MAX="max"
		public EnumLiteralDeclaration getMAXEnumLiteralDeclaration_1() { return cMAXEnumLiteralDeclaration_1; }

		//"max"
		public Keyword getMAXMaxKeyword_1_0() { return cMAXMaxKeyword_1_0; }
	}

	public class ComparingOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATERGreaterThanSignKeyword_1_0 = (Keyword)cGREATEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESSLessThanSignKeyword_3_0 = (Keyword)cLESSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum ComparingOperator returns common::ComparingOperator:
		//	EQUAL="=" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQUAL="<=";
		public EnumRule getRule() { return rule; }

		//EQUAL="=" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQUAL="<="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL="="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }

		//"="
		public Keyword getEQUALEqualsSignKeyword_0_0() { return cEQUALEqualsSignKeyword_0_0; }

		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_1() { return cGREATEREnumLiteralDeclaration_1; }

		//">"
		public Keyword getGREATERGreaterThanSignKeyword_1_0() { return cGREATERGreaterThanSignKeyword_1_0; }

		//GREATER_OR_EQUAL=">="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_2() { return cGREATER_OR_EQUALEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0; }

		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_3() { return cLESSEnumLiteralDeclaration_3; }

		//"<"
		public Keyword getLESSLessThanSignKeyword_3_0() { return cLESSLessThanSignKeyword_3_0; }

		//LESS_OR_EQUAL="<="
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_4() { return cLESS_OR_EQUALEnumLiteralDeclaration_4; }

		//"<="
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0; }
	}

	public class ILPDataTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ILPDataType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBINARYEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBINARYBinKeyword_0_0 = (Keyword)cBINARYEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cINTEGEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cINTEGERIntKeyword_1_0 = (Keyword)cINTEGEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cREALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cREALRealKeyword_2_0 = (Keyword)cREALEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ILPDataType returns ilp::ILPDataType:
		//	BINARY="bin" | INTEGER="int" | REAL="real";
		public EnumRule getRule() { return rule; }

		//BINARY="bin" | INTEGER="int" | REAL="real"
		public Alternatives getAlternatives() { return cAlternatives; }

		//BINARY="bin"
		public EnumLiteralDeclaration getBINARYEnumLiteralDeclaration_0() { return cBINARYEnumLiteralDeclaration_0; }

		//"bin"
		public Keyword getBINARYBinKeyword_0_0() { return cBINARYBinKeyword_0_0; }

		//INTEGER="int"
		public EnumLiteralDeclaration getINTEGEREnumLiteralDeclaration_1() { return cINTEGEREnumLiteralDeclaration_1; }

		//"int"
		public Keyword getINTEGERIntKeyword_1_0() { return cINTEGERIntKeyword_1_0; }

		//REAL="real"
		public EnumLiteralDeclaration getREALEnumLiteralDeclaration_2() { return cREALEnumLiteralDeclaration_2; }

		//"real"
		public Keyword getREALRealKeyword_2_0() { return cREALRealKeyword_2_0; }
	}

	public class AdditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditionOperator returns common::ArithmeticOperator:
		//	PLUS="+" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class MultiplicationOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationOperator");
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cTIMESAsteriskKeyword_0 = (Keyword)cTIMESEnumLiteralDeclaration.eContents().get(0);
		
		//enum MultiplicationOperator returns common::ArithmeticOperator:
		//	TIMES="*";
		public EnumRule getRule() { return rule; }

		//TIMES="*"
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration() { return cTIMESEnumLiteralDeclaration; }

		//"*"
		public Keyword getTIMESAsteriskKeyword_0() { return cTIMESAsteriskKeyword_0; }
	}
	
	private IntegerLinearProgramElements pIntegerLinearProgram;
	private ObjectiveFunctionExpressionElements pObjectiveFunctionExpression;
	private ObjectiveGoalElements unknownRuleObjectiveGoal;
	private ConstraintExpressionElements pConstraintExpression;
	private ComparingOperatorElements unknownRuleComparingOperator;
	private VariableElements pVariable;
	private VariableIDElements pVariableID;
	private ILPDataTypeElements unknownRuleILPDataType;
	private LinearExpressionElements pLinearExpression;
	private SimpleLinearExpressionElements pSimpleLinearExpression;
	private AdditionOperatorElements unknownRuleAdditionOperator;
	private AdditionExpressionElements pAdditionExpression;
	private MultiplicationExpressionElements pMultiplicationExpression;
	private MultiplicationOperatorElements unknownRuleMultiplicationOperator;
	private OperandElements pOperand;
	private NumberLiteralExpressionElements pNumberLiteralExpression;
	private NumberElements pNumber;
	private DecimalElements pDecimal;
	private VariableExpressionElements pVariableExpression;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public LPSolveGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.muml.psm.allocation.ilp.lpsolve.xtext.LPSolve".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////import "platform:/resource/org.muml.core/model/core.ecore#//expressions/common" as common
	//IntegerLinearProgram returns ilp::IntegerLinearProgram:
	//	objectiveFunction=ObjectiveFunctionExpression constraints+=ConstraintExpression* variables+=Variable*;
	public IntegerLinearProgramElements getIntegerLinearProgramAccess() {
		return (pIntegerLinearProgram != null) ? pIntegerLinearProgram : (pIntegerLinearProgram = new IntegerLinearProgramElements());
	}
	
	public ParserRule getIntegerLinearProgramRule() {
		return getIntegerLinearProgramAccess().getRule();
	}

	//ObjectiveFunctionExpression returns ilp::ObjectiveFunctionExpression:
	//	("min" | "max") ":" ";" // support lpsolve's (strange) specification of a non-existent objective function
	//	// (in this case _no_ ObjectiveFunctionExpression object should be created)
	//	| goal=ObjectiveGoal ":" objectiveFunction=LinearExpression ";";
	public ObjectiveFunctionExpressionElements getObjectiveFunctionExpressionAccess() {
		return (pObjectiveFunctionExpression != null) ? pObjectiveFunctionExpression : (pObjectiveFunctionExpression = new ObjectiveFunctionExpressionElements());
	}
	
	public ParserRule getObjectiveFunctionExpressionRule() {
		return getObjectiveFunctionExpressionAccess().getRule();
	}

	//enum ObjectiveGoal returns ilp::ObjectiveGoal:
	//	MIN="min" | MAX="max";
	public ObjectiveGoalElements getObjectiveGoalAccess() {
		return (unknownRuleObjectiveGoal != null) ? unknownRuleObjectiveGoal : (unknownRuleObjectiveGoal = new ObjectiveGoalElements());
	}
	
	public EnumRule getObjectiveGoalRule() {
		return getObjectiveGoalAccess().getRule();
	}

	//ConstraintExpression returns ilp::ConstraintExpression:
	//	(comment=VariableID ":")? // the comment represents an optional name of a restriction
	//	leftExpression=SimpleLinearExpression operator=ComparingOperator rightExpression=SimpleLinearExpression ";";
	public ConstraintExpressionElements getConstraintExpressionAccess() {
		return (pConstraintExpression != null) ? pConstraintExpression : (pConstraintExpression = new ConstraintExpressionElements());
	}
	
	public ParserRule getConstraintExpressionRule() {
		return getConstraintExpressionAccess().getRule();
	}

	//enum ComparingOperator returns common::ComparingOperator:
	//	EQUAL="=" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQUAL="<=";
	public ComparingOperatorElements getComparingOperatorAccess() {
		return (unknownRuleComparingOperator != null) ? unknownRuleComparingOperator : (unknownRuleComparingOperator = new ComparingOperatorElements());
	}
	
	public EnumRule getComparingOperatorRule() {
		return getComparingOperatorAccess().getRule();
	}

	//Variable returns ilp::Variable:
	//	dataType=ILPDataType name=VariableID ";";
	public VariableElements getVariableAccess() {
		return (pVariable != null) ? pVariable : (pVariable = new VariableElements());
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//VariableID returns ecore::EString:
	//	ID ("." (ID | INT ID?))*;
	public VariableIDElements getVariableIDAccess() {
		return (pVariableID != null) ? pVariableID : (pVariableID = new VariableIDElements());
	}
	
	public ParserRule getVariableIDRule() {
		return getVariableIDAccess().getRule();
	}

	//enum ILPDataType returns ilp::ILPDataType:
	//	BINARY="bin" | INTEGER="int" | REAL="real";
	public ILPDataTypeElements getILPDataTypeAccess() {
		return (unknownRuleILPDataType != null) ? unknownRuleILPDataType : (unknownRuleILPDataType = new ILPDataTypeElements());
	}
	
	public EnumRule getILPDataTypeRule() {
		return getILPDataTypeAccess().getRule();
	}

	//LinearExpression returns expressions::Expression: // if you need a more sophisticated expression grammar override this rule
	//	SimpleLinearExpression;
	public LinearExpressionElements getLinearExpressionAccess() {
		return (pLinearExpression != null) ? pLinearExpression : (pLinearExpression = new LinearExpressionElements());
	}
	
	public ParserRule getLinearExpressionRule() {
		return getLinearExpressionAccess().getRule();
	}

	//SimpleLinearExpression returns expressions::Expression:
	//	AdditionExpression;
	public SimpleLinearExpressionElements getSimpleLinearExpressionAccess() {
		return (pSimpleLinearExpression != null) ? pSimpleLinearExpression : (pSimpleLinearExpression = new SimpleLinearExpressionElements());
	}
	
	public ParserRule getSimpleLinearExpressionRule() {
		return getSimpleLinearExpressionAccess().getRule();
	}

	//enum AdditionOperator returns common::ArithmeticOperator:
	//	PLUS="+" | MINUS="-";
	public AdditionOperatorElements getAdditionOperatorAccess() {
		return (unknownRuleAdditionOperator != null) ? unknownRuleAdditionOperator : (unknownRuleAdditionOperator = new AdditionOperatorElements());
	}
	
	public EnumRule getAdditionOperatorRule() {
		return getAdditionOperatorAccess().getRule();
	}

	//AdditionExpression returns expressions::Expression:
	//	MultiplicationExpression ({common::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
	//	rightExpression=LinearExpression)?;
	public AdditionExpressionElements getAdditionExpressionAccess() {
		return (pAdditionExpression != null) ? pAdditionExpression : (pAdditionExpression = new AdditionExpressionElements());
	}
	
	public ParserRule getAdditionExpressionRule() {
		return getAdditionExpressionAccess().getRule();
	}

	//// XXX: here we also allow non-linear expressions, but we do not care,
	//// because this grammar is just for internal use (test fixture specification)
	//MultiplicationExpression returns expressions::Expression:
	//	Operand ({common::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
	//	rightExpression=Operand)?;
	public MultiplicationExpressionElements getMultiplicationExpressionAccess() {
		return (pMultiplicationExpression != null) ? pMultiplicationExpression : (pMultiplicationExpression = new MultiplicationExpressionElements());
	}
	
	public ParserRule getMultiplicationExpressionRule() {
		return getMultiplicationExpressionAccess().getRule();
	}

	//enum MultiplicationOperator returns common::ArithmeticOperator:
	//	TIMES="*";
	public MultiplicationOperatorElements getMultiplicationOperatorAccess() {
		return (unknownRuleMultiplicationOperator != null) ? unknownRuleMultiplicationOperator : (unknownRuleMultiplicationOperator = new MultiplicationOperatorElements());
	}
	
	public EnumRule getMultiplicationOperatorRule() {
		return getMultiplicationOperatorAccess().getRule();
	}

	//Operand returns expressions::Expression:
	//	NumberLiteralExpression | VariableExpression;
	public OperandElements getOperandAccess() {
		return (pOperand != null) ? pOperand : (pOperand = new OperandElements());
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}

	//NumberLiteralExpression returns common::LiteralExpression:
	//	value=Number;
	public NumberLiteralExpressionElements getNumberLiteralExpressionAccess() {
		return (pNumberLiteralExpression != null) ? pNumberLiteralExpression : (pNumberLiteralExpression = new NumberLiteralExpressionElements());
	}
	
	public ParserRule getNumberLiteralExpressionRule() {
		return getNumberLiteralExpressionAccess().getRule();
	}

	//Number returns ecore::EString:
	//	"-"? (Decimal | INT);
	public NumberElements getNumberAccess() {
		return (pNumber != null) ? pNumber : (pNumber = new NumberElements());
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	//Decimal returns ecore::EString:
	//	INT "." INT;
	public DecimalElements getDecimalAccess() {
		return (pDecimal != null) ? pDecimal : (pDecimal = new DecimalElements());
	}
	
	public ParserRule getDecimalRule() {
		return getDecimalAccess().getRule();
	}

	//VariableExpression returns ilp::VariableExpression:
	//	variable=[ilp::Variable|VariableID];
	public VariableExpressionElements getVariableExpressionAccess() {
		return (pVariableExpression != null) ? pVariableExpression : (pVariableExpression = new VariableExpressionElements());
	}
	
	public ParserRule getVariableExpressionRule() {
		return getVariableExpressionAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
