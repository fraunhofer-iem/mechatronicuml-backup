// automatically generated by Xtext
grammar org.muml.pim.actionlanguage.xtext.ActionLanguage with org.eclipse.xtext.common.Terminals 

import "platform:/resource/org.muml.pim.actionlanguage/model/actionlanguage.ecore" as actionlanguage

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

import "platform:/resource/org.muml.core/model/core.ecore" as modeling

import "platform:/resource/org.muml.pim/model/pim.ecore#//realtimestatechart" as rtsc

import "platform:/resource/org.muml.pim/model/pim.ecore#//behavior" as behavior

import "platform:/resource/org.muml.pim/model/pim.ecore#//types" as types

import "platform:/resource/org.muml.pim/model/pim.ecore#//msgtype" as msgtype

import "platform:/resource/org.muml.pim/model/pim.ecore#//valuetype" as valuetype

import "platform:/resource/org.muml.core/model/core.ecore#//expressions" as expressions

import "platform:/resource/org.muml.core/model/core.ecore#//expressions/common" as commonExpressions

Entry returns expressions::Expression:
	Block | Expression | ArrayInitializeExpression
;

Block returns actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	{actionlanguage::Block}
	'{'
		(expressions+=ExpressionStartRule*)
	'}'
;

// TODO: clarify if it makes sense to allow arbitrary expressions for
// the initializeExpression and countingExpression
ForLoop returns actionlanguage::ForLoop:
	'for' '(' initializeExpression=Assignment  loopTest=Expression';'  countingExpression=ForLoopCountingExpression ')' 
		block=Block
;

ForLoopCountingExpression returns actionlanguage::Assignment:
	lhs_typedNamedElementExpression=TypedNamedElementExpression
	(
		incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		| (assignOperator=AssignOperator rhs_assignExpression=Expression)
	)
;

WhileLoop returns actionlanguage::WhileLoop:
	'while' '('  loopTest=Expression ')' 
		block=Block
;

DoWhileLoop returns actionlanguage::DoWhileLoop:
	'do'  
		block=Block
	'while' '('  loopTest=Expression ');'
;

IfStatement returns actionlanguage::IfStatement:
	'if' '(' ifCondition=Expression ')'
		ifBlock=Block
	(elseIfStatements+=ElseIfStatement)*
	('else' elseBlock=Block)?
;
ElseIfStatement returns actionlanguage::ElseIfStatement:
	'elseif' '(' elseIfCondition=Expression ')'
		elseIfBlock=Block
;

ReturnStatement returns actionlanguage::ReturnStatement:
	{actionlanguage::ReturnStatement}
	'return' expression=Expression ';'
;

OperationCallStatement returns actionlanguage::OperationCall:
	OperationCall ';'
;
	
ExpressionStartRule returns expressions::Expression:
	Assignment |  ForLoop | 
	WhileLoop | DoWhileLoop | 
	IfStatement | ReturnStatement | LocalVariableOrConstantDeclarationStatement |
	OperationCallStatement
;

enum UnaryPostIncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
	INCREMENT='++' | DECREMENT='--'
;

// Assignment
	
Assignment returns actionlanguage::Assignment:
	lhs_typedNamedElementExpression=TypedNamedElementExpression
	(
		(		
			assignOperator=AssignOperator rhs_assignExpression=InitializeExpression	
		) |
		(
			incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		)
		
	)';'
;

enum IncrementDecrementOperatorExpression returns actionlanguage::IncrementDecrementOperator:
	INCREMENT='++' | DECREMENT='--'
;

enum AssignOperator returns actionlanguage::AssignOperator:
	ASSIGN=':=' | PLUS_EQUAL='+='| MINUS_EQUAL='-='
;

// end of assignment

// initialize expression

InitializeExpression returns expressions::Expression:
	ArrayInitializeExpression | NondeterministicChoiceExpression | Expression
;

// end of initialize expression

// array initialization

ArrayInitializeExpression returns actionlanguage::ArrayInitializeExpression:
	'[' expressions+=InitializeExpression
		(',' expressions+=InitializeExpression)*
	']'
;

// end of array initialization

// local variable declaration

LocalVariableOrConstantDeclarationStatement returns actionlanguage::LocalVariableDeclarationStatement:
	variable=(LocalVariableDeclaration | LocalConstantDeclaration)
;

LocalVariableDeclaration returns behavior::Variable:
	dataType=[types::DataType|DATATYPE] name=ID (':=' initializeExpression=InitializeExpression)? ';'
;

LocalConstantDeclaration returns behavior::Variable:
	constant?='const' dataType=[types::DataType|DATATYPE] name=ID ':=' initializeExpression=InitializeExpression ';'
;

// end of local variable declaration

// nondeterministic choice expression

NondeterministicChoiceExpression returns actionlanguage::NondeterministicChoiceExpression:
	dataType=[types::PrimitiveDataType] range=Range
;

Range returns valuetype::Range:
	'<' lowerBound=LONG ',' upperBound=LONG '>'
;

LONG returns ecore::ELong:
	INT
;

// end of nondeterministic choice expression

Expression returns expressions::Expression:
	LogicalExpression
;

// LogicalExpression

LogicalExpression returns expressions::Expression:
	LogicalOrExpression
;

LogicalOrExpression returns expressions::Expression:
	LogicalAndExpression
	(
		{commonExpressions::LogicalExpression.leftExpression=current}
		operator=LogicalOrOperator
		rightExpression=LogicalAndExpression
	)*
;

enum LogicalOrOperator returns commonExpressions::LogicOperator:
	OR='||'
;

LogicalAndExpression returns expressions::Expression:
	ComparisonExpression
	(
		{commonExpressions::LogicalExpression.leftExpression=current}
		operator=LogicalAndOperator
		rightExpression=ComparisonExpression
	)*
;

enum LogicalAndOperator returns commonExpressions::LogicOperator:
	AND='&&'
;

// end of LogicalExpression

// ComparisonExpression

ComparisonExpression returns expressions::Expression:
	ComparisonHigherOpExpression
	(	
		{commonExpressions::ComparisonExpression.leftExpression=current}
		operator=ComparingEQNEQOperator
		rightExpression=ComparisonHigherOpExpression
	)?
;

ComparisonHigherOpExpression returns expressions::Expression:
	ArithmeticExpression
	(	{commonExpressions::ComparisonExpression.leftExpression=current}
		operator=ComparingRelOperator
		rightExpression=ArithmeticExpression
	)?
;

enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
	EQUAL='==' | UNEQUAL='<>' 
;

enum ComparingRelOperator returns commonExpressions::ComparingOperator:
	LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>'
;  

// end of ComparisonExpression

// ArithmeticExpression	
	
ArithmeticExpression returns expressions::Expression:
	AdditionExpression
;

AdditionExpression returns expressions::Expression:
	MultiplicationExpression
	(
		{commonExpressions::ArithmeticExpression.leftExpression=current}
		operator=AdditionOperator rightExpression=MultiplicationExpression
	)*
;

enum AdditionOperator returns commonExpressions::ArithmeticOperator:
	PLUS='+' | MINUS='-'
;

MultiplicationExpression returns expressions::Expression:
	UnaryPreExpression | TypeCastExpression
	(	{commonExpressions::ArithmeticExpression.leftExpression=current}
		operator=MultiplicationOperator rightExpression=(UnaryPreExpression | TypeCastExpression)
	)*
;

enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
	TIMES='*' | DIVIDE='/' | MODULO='%'
;

// end of ArithmeticExpression

// UnaryPreExpression

UnaryPreExpression returns expressions::Expression:
	{commonExpressions::UnaryExpression}
	operator=UnaryPreOperator enclosedExpression=TypeCastExpression
;

enum UnaryPreOperator returns commonExpressions::UnaryOperator:
	NOT='not' | MINUS='-' 
;

// end of UnaryPreExpression

TypeCastExpression returns expressions::Expression:
	Operand | (
		{actionlanguage::TypeCastExpression}
		'(' dataType=[types::DataType|DATATYPE] ')' enclosedExpression=Operand
	)
;

// Operand

Operand returns expressions::Expression:
	'(' Expression ')' | LiteralExpression | ExtendedTypedNamedElementExpression | TimeValueExpression
	| OperationCall | TriggerMessageExpression | NoAttributeSelectorExpression
;

// end of Operand

LiteralExpression returns commonExpressions::LiteralExpression:
	{commonExpressions::LiteralExpression} value=Literal
;

Literal returns ecore::EString:
	NUMBER | BOOLEAN | INT | 'null'
;

TimeValueExpression returns actionlanguage::TimeValueExpression:
	timeValue=[valuetype::TimeValue|MINORMAXKEYWORD]
;

terminal MINORMAXKEYWORD:
	'maxMsgDelay'
;

ExtendedTypedNamedElementExpression returns expressions::Expression:
	TypedNamedElementExpression
	(
		(
			{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression = current}
			'->' position=PositionSelectorExpression			
		) |
		(
			// unary post increment/decrement			
			{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
			incrementDecrementOperator=IncrementDecrementOperatorExpression
		)
	)?
;

TypedNamedElementExpression returns actionlanguage::TypedNamedElementExpression:
	typedNamedElement=[behavior::TypedNamedElement](elementAccessors+= (ArrayIndexExpression | AttributeAccessorExpression))* 
;

ArrayIndexExpression returns actionlanguage::ArrayIndexExpression:
	'['index=ArithmeticExpression']'
;

AttributeAccessorExpression returns actionlanguage::AttributeAccessorExpression:
	'.'attribute=[types::Attribute]
;

NoAttributeSelectorExpression returns actionlanguage::DiscreteInteractionEndpointReference:
	position=PositionSelectorExpression
;

PositionSelectorExpression returns actionlanguage::PositionSelector:
	kind=PositionSelectorKind ('->' successor=PositionSelectorExpression)?
;

enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
	SELF='self' | FIRST='first' | LAST='last' | PREV='prev' | NEXT='next'
;

OperationCall returns actionlanguage::OperationCall:
	operation=[behavior::Operation] '('
		(parameterBinding+=ParamaterBinding (',' parameterBinding+=ParamaterBinding)* )?
	')'
;

ParamaterBinding returns behavior::ParameterBinding:
	{behavior::ParameterBinding}parameter=[behavior::Parameter] ':=' value=Expression
;	

// TriggerMessageExpression

TriggerMessageExpression returns actionlanguage::TriggerMessageExpression:
	messageType=[msgtype::MessageType] '->' parameter=[behavior::Parameter]
;

// end of TriggerMessageExpression

terminal NUMBER returns ecore::EBigDecimal:
	INT'.' INT
;

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

terminal ID:
	'^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;

DATATYPE returns ecore::EString:
	ID ('['INT']')*
;