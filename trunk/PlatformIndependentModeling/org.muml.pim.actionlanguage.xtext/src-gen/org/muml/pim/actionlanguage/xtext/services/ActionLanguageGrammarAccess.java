/*
 * generated by Xtext
 */
package org.muml.pim.actionlanguage.xtext.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ActionLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class EntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.Entry");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cArrayInitializeExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Entry expressions::Expression:
		//	Block | Expression | ArrayInitializeExpression
		@Override public ParserRule getRule() { return rule; }

		//Block | Expression | ArrayInitializeExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//Block
		public RuleCall getBlockParserRuleCall_0() { return cBlockParserRuleCall_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//ArrayInitializeExpression
		public RuleCall getArrayInitializeExpressionParserRuleCall_2() { return cArrayInitializeExpressionParserRuleCall_2; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionsExpressionStartRuleParserRuleCall_2_0 = (RuleCall)cExpressionsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
		//	{actionlanguage::Block}
		//	'{'
		//	expressions+=ExpressionStartRule* '}'
		@Override public ParserRule getRule() { return rule; }

		//{actionlanguage::Block} '{' expressions+=ExpressionStartRule* '}'
		public Group getGroup() { return cGroup; }

		//{actionlanguage::Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//expressions+=ExpressionStartRule*
		public Assignment getExpressionsAssignment_2() { return cExpressionsAssignment_2; }

		//ExpressionStartRule
		public RuleCall getExpressionsExpressionStartRuleParserRuleCall_2_0() { return cExpressionsExpressionStartRuleParserRuleCall_2_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitializeExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitializeExpressionAssignmentParserRuleCall_2_0 = (RuleCall)cInitializeExpressionAssignment_2.eContents().get(0);
		private final Assignment cLoopTestAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopTestExpressionParserRuleCall_3_0 = (RuleCall)cLoopTestAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCountingExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0 = (RuleCall)cCountingExpressionAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBlockAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBlockBlockParserRuleCall_7_0 = (RuleCall)cBlockAssignment_7.eContents().get(0);
		
		//// TODO: clarify if it makes sense to allow arbitrary expressions for
		//// the initializeExpression and countingExpression
		//ForLoop actionlanguage::ForLoop:
		//	'for' '(' initializeExpression=Assignment loopTest=Expression ';' countingExpression=ForLoopCountingExpression ')'
		//	block=Block
		@Override public ParserRule getRule() { return rule; }

		//'for' '(' initializeExpression=Assignment loopTest=Expression ';' countingExpression=ForLoopCountingExpression ')'
		//block=Block
		public Group getGroup() { return cGroup; }

		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//initializeExpression=Assignment
		public Assignment getInitializeExpressionAssignment_2() { return cInitializeExpressionAssignment_2; }

		//Assignment
		public RuleCall getInitializeExpressionAssignmentParserRuleCall_2_0() { return cInitializeExpressionAssignmentParserRuleCall_2_0; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_3() { return cLoopTestAssignment_3; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_3_0() { return cLoopTestExpressionParserRuleCall_3_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }

		//countingExpression=ForLoopCountingExpression
		public Assignment getCountingExpressionAssignment_5() { return cCountingExpressionAssignment_5; }

		//ForLoopCountingExpression
		public RuleCall getCountingExpressionForLoopCountingExpressionParserRuleCall_5_0() { return cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0; }

		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//block=Block
		public Assignment getBlockAssignment_7() { return cBlockAssignment_7; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_7_0() { return cBlockBlockParserRuleCall_7_0; }
	}

	public class ForLoopCountingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ForLoopCountingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_typedNamedElementExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0 = (RuleCall)cLhs_typedNamedElementExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIncrementDecrementOperatorAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cAssignOperatorAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0 = (RuleCall)cAssignOperatorAssignment_1_1_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_1_1.eContents().get(0);
		
		//ForLoopCountingExpression actionlanguage::Assignment:
		//	lhs_typedNamedElementExpression=TypedNamedElementExpression
		//	(incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		//	| assignOperator=AssignOperator rhs_assignExpression=Expression)
		@Override public ParserRule getRule() { return rule; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		//(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//rhs_assignExpression=Expression)
		public Group getGroup() { return cGroup; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		public Assignment getLhs_typedNamedElementExpressionAssignment_0() { return cLhs_typedNamedElementExpressionAssignment_0; }

		//TypedNamedElementExpression
		public RuleCall getLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0() { return cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0; }

		//(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//rhs_assignExpression=Expression)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_0() { return cIncrementDecrementOperatorAssignment_1_0; }

		//UnaryPostIncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0() { return cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_1_0() { return cAssignOperatorAssignment_1_1_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0; }

		//rhs_assignExpression=Expression
		public Assignment getRhs_assignExpressionAssignment_1_1_1() { return cRhs_assignExpressionAssignment_1_1_1; }

		//Expression
		public RuleCall getRhs_assignExpressionExpressionParserRuleCall_1_1_1_0() { return cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLoopTestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLoopTestExpressionParserRuleCall_2_0 = (RuleCall)cLoopTestAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		//WhileLoop actionlanguage::WhileLoop:
		//	'while' '(' loopTest=Expression ')'
		//	block=Block
		@Override public ParserRule getRule() { return rule; }

		//'while' '(' loopTest=Expression ')' block=Block
		public Group getGroup() { return cGroup; }

		//'while'
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_2() { return cLoopTestAssignment_2; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_2_0() { return cLoopTestExpressionParserRuleCall_2_0; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//block=Block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}

	public class DoWhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.DoWhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLoopTestAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopTestExpressionParserRuleCall_4_0 = (RuleCall)cLoopTestAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//DoWhileLoop actionlanguage::DoWhileLoop:
		//	'do'
		//	block=Block
		//	'while' '(' loopTest=Expression ');'
		@Override public ParserRule getRule() { return rule; }

		//'do' block=Block 'while' '(' loopTest=Expression ');'
		public Group getGroup() { return cGroup; }

		//'do'
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//block=Block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }

		//'while'
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//'('
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_4() { return cLoopTestAssignment_4; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_4_0() { return cLoopTestExpressionParserRuleCall_4_0; }

		//');'
		public Keyword getRightParenthesisSemicolonKeyword_5() { return cRightParenthesisSemicolonKeyword_5; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIfConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfConditionExpressionParserRuleCall_2_0 = (RuleCall)cIfConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockBlockParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final Assignment cElseIfStatementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseIfStatementsElseIfStatementParserRuleCall_5_0 = (RuleCall)cElseIfStatementsAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cElseKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cElseBlockAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cElseBlockBlockParserRuleCall_6_1_0 = (RuleCall)cElseBlockAssignment_6_1.eContents().get(0);
		
		//IfStatement actionlanguage::IfStatement:
		//	'if' '(' ifCondition=Expression ')'
		//	ifBlock=Block
		//	elseIfStatements+=ElseIfStatement* ('else' elseBlock=Block)?
		@Override public ParserRule getRule() { return rule; }

		//'if' '(' ifCondition=Expression ')' ifBlock=Block elseIfStatements+=ElseIfStatement* ('else' elseBlock=Block)?
		public Group getGroup() { return cGroup; }

		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//ifCondition=Expression
		public Assignment getIfConditionAssignment_2() { return cIfConditionAssignment_2; }

		//Expression
		public RuleCall getIfConditionExpressionParserRuleCall_2_0() { return cIfConditionExpressionParserRuleCall_2_0; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//ifBlock=Block
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }

		//Block
		public RuleCall getIfBlockBlockParserRuleCall_4_0() { return cIfBlockBlockParserRuleCall_4_0; }

		//elseIfStatements+=ElseIfStatement*
		public Assignment getElseIfStatementsAssignment_5() { return cElseIfStatementsAssignment_5; }

		//ElseIfStatement
		public RuleCall getElseIfStatementsElseIfStatementParserRuleCall_5_0() { return cElseIfStatementsElseIfStatementParserRuleCall_5_0; }

		//('else' elseBlock=Block)?
		public Group getGroup_6() { return cGroup_6; }

		//'else'
		public Keyword getElseKeyword_6_0() { return cElseKeyword_6_0; }

		//elseBlock=Block
		public Assignment getElseBlockAssignment_6_1() { return cElseBlockAssignment_6_1; }

		//Block
		public RuleCall getElseBlockBlockParserRuleCall_6_1_0() { return cElseBlockBlockParserRuleCall_6_1_0; }
	}

	public class ElseIfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ElseIfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElseifKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElseIfConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElseIfConditionExpressionParserRuleCall_2_0 = (RuleCall)cElseIfConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cElseIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElseIfBlockBlockParserRuleCall_4_0 = (RuleCall)cElseIfBlockAssignment_4.eContents().get(0);
		
		//ElseIfStatement actionlanguage::ElseIfStatement:
		//	'elseif' '(' elseIfCondition=Expression ')'
		//	elseIfBlock=Block
		@Override public ParserRule getRule() { return rule; }

		//'elseif' '(' elseIfCondition=Expression ')' elseIfBlock=Block
		public Group getGroup() { return cGroup; }

		//'elseif'
		public Keyword getElseifKeyword_0() { return cElseifKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//elseIfCondition=Expression
		public Assignment getElseIfConditionAssignment_2() { return cElseIfConditionAssignment_2; }

		//Expression
		public RuleCall getElseIfConditionExpressionParserRuleCall_2_0() { return cElseIfConditionExpressionParserRuleCall_2_0; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//elseIfBlock=Block
		public Assignment getElseIfBlockAssignment_4() { return cElseIfBlockAssignment_4; }

		//Block
		public RuleCall getElseIfBlockBlockParserRuleCall_4_0() { return cElseIfBlockBlockParserRuleCall_4_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReturnStatement actionlanguage::ReturnStatement:
		//	{actionlanguage::ReturnStatement}
		//	'return' expression=Expression ';'
		@Override public ParserRule getRule() { return rule; }

		//{actionlanguage::ReturnStatement} 'return' expression=Expression ';'
		public Group getGroup() { return cGroup; }

		//{actionlanguage::ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//'return'
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class OperationCallStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.OperationCallStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOperationCallParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//OperationCallStatement actionlanguage::OperationCall:
		//	OperationCall ';'
		@Override public ParserRule getRule() { return rule; }

		//OperationCall ';'
		public Group getGroup() { return cGroup; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_0() { return cOperationCallParserRuleCall_0; }

		//';'
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class ExpressionStartRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ExpressionStartRule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDoWhileLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIfStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cReturnStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLocalVariableOrConstantDeclarationStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cOperationCallStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//ExpressionStartRule expressions::Expression:
		//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement |
		//	LocalVariableOrConstantDeclarationStatement | OperationCallStatement
		@Override public ParserRule getRule() { return rule; }

		//Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement |
		//LocalVariableOrConstantDeclarationStatement | OperationCallStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_0() { return cAssignmentParserRuleCall_0; }

		//ForLoop
		public RuleCall getForLoopParserRuleCall_1() { return cForLoopParserRuleCall_1; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_2() { return cWhileLoopParserRuleCall_2; }

		//DoWhileLoop
		public RuleCall getDoWhileLoopParserRuleCall_3() { return cDoWhileLoopParserRuleCall_3; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_4() { return cIfStatementParserRuleCall_4; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_5() { return cReturnStatementParserRuleCall_5; }

		//LocalVariableOrConstantDeclarationStatement
		public RuleCall getLocalVariableOrConstantDeclarationStatementParserRuleCall_6() { return cLocalVariableOrConstantDeclarationStatementParserRuleCall_6; }

		//OperationCallStatement
		public RuleCall getOperationCallStatementParserRuleCall_7() { return cOperationCallStatementParserRuleCall_7; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_typedNamedElementExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0 = (RuleCall)cLhs_typedNamedElementExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cAssignOperatorAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0 = (RuleCall)cAssignOperatorAssignment_1_0_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_0_1.eContents().get(0);
		private final Assignment cIncrementDecrementOperatorAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Assignment
		//Assignment actionlanguage::Assignment:
		//	lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
		//	rhs_assignExpression=InitializeExpression
		//	| incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ';'
		@Override public ParserRule getRule() { return rule; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
		//rhs_assignExpression=InitializeExpression | incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ';'
		public Group getGroup() { return cGroup; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		public Assignment getLhs_typedNamedElementExpressionAssignment_0() { return cLhs_typedNamedElementExpressionAssignment_0; }

		//TypedNamedElementExpression
		public RuleCall getLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0() { return cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0; }

		//(assignOperator=AssignOperator rhs_assignExpression=InitializeExpression |
		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//assignOperator=AssignOperator rhs_assignExpression=InitializeExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_0_0() { return cAssignOperatorAssignment_1_0_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0; }

		//rhs_assignExpression=InitializeExpression
		public Assignment getRhs_assignExpressionAssignment_1_0_1() { return cRhs_assignExpressionAssignment_1_0_1; }

		//InitializeExpression
		public RuleCall getRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0() { return cRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_1() { return cIncrementDecrementOperatorAssignment_1_1; }

		//UnaryPostIncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0() { return cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0; }

		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class InitializeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.InitializeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrayInitializeExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNondeterministicChoiceExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// end of assignment
		//// initialize expression
		//InitializeExpression expressions::Expression:
		//	ArrayInitializeExpression | NondeterministicChoiceExpression | Expression
		@Override public ParserRule getRule() { return rule; }

		//ArrayInitializeExpression | NondeterministicChoiceExpression | Expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrayInitializeExpression
		public RuleCall getArrayInitializeExpressionParserRuleCall_0() { return cArrayInitializeExpressionParserRuleCall_0; }

		//NondeterministicChoiceExpression
		public RuleCall getNondeterministicChoiceExpressionParserRuleCall_1() { return cNondeterministicChoiceExpressionParserRuleCall_1; }

		//Expression
		public RuleCall getExpressionParserRuleCall_2() { return cExpressionParserRuleCall_2; }
	}

	public class ArrayInitializeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ArrayInitializeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsInitializeExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsInitializeExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// end of initialize expression
		//// array initialization
		//ArrayInitializeExpression actionlanguage::ArrayInitializeExpression:
		//	'[' expressions+=InitializeExpression (',' expressions+=InitializeExpression)*
		//	']'
		@Override public ParserRule getRule() { return rule; }

		//'[' expressions+=InitializeExpression (',' expressions+=InitializeExpression)* ']'
		public Group getGroup() { return cGroup; }

		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//expressions+=InitializeExpression
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }

		//InitializeExpression
		public RuleCall getExpressionsInitializeExpressionParserRuleCall_1_0() { return cExpressionsInitializeExpressionParserRuleCall_1_0; }

		//(',' expressions+=InitializeExpression)*
		public Group getGroup_2() { return cGroup_2; }

		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//expressions+=InitializeExpression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }

		//InitializeExpression
		public RuleCall getExpressionsInitializeExpressionParserRuleCall_2_1_0() { return cExpressionsInitializeExpressionParserRuleCall_2_1_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class LocalVariableOrConstantDeclarationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LocalVariableOrConstantDeclarationStatement");
		private final Assignment cVariableAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cVariableAlternatives_0 = (Alternatives)cVariableAssignment.eContents().get(0);
		private final RuleCall cVariableLocalVariableDeclarationParserRuleCall_0_0 = (RuleCall)cVariableAlternatives_0.eContents().get(0);
		private final RuleCall cVariableLocalConstantDeclarationParserRuleCall_0_1 = (RuleCall)cVariableAlternatives_0.eContents().get(1);
		
		//// end of array initialization
		//// local variable declaration
		//LocalVariableOrConstantDeclarationStatement actionlanguage::LocalVariableDeclarationStatement:
		//	variable=(LocalVariableDeclaration | LocalConstantDeclaration)
		@Override public ParserRule getRule() { return rule; }

		//variable=(LocalVariableDeclaration | LocalConstantDeclaration)
		public Assignment getVariableAssignment() { return cVariableAssignment; }

		//(LocalVariableDeclaration | LocalConstantDeclaration)
		public Alternatives getVariableAlternatives_0() { return cVariableAlternatives_0; }

		//LocalVariableDeclaration
		public RuleCall getVariableLocalVariableDeclarationParserRuleCall_0_0() { return cVariableLocalVariableDeclarationParserRuleCall_0_0; }

		//LocalConstantDeclaration
		public RuleCall getVariableLocalConstantDeclarationParserRuleCall_0_1() { return cVariableLocalConstantDeclarationParserRuleCall_0_1; }
	}

	public class LocalVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LocalVariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDataTypeDataTypeCrossReference_0_0 = (CrossReference)cDataTypeAssignment_0.eContents().get(0);
		private final RuleCall cDataTypeDataTypeDATATYPEParserRuleCall_0_0_1 = (RuleCall)cDataTypeDataTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInitializeExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitializeExpressionInitializeExpressionParserRuleCall_2_1_0 = (RuleCall)cInitializeExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//LocalVariableDeclaration behavior::Variable:
		//	dataType=[types::DataType|DATATYPE] name=ID (':=' initializeExpression=InitializeExpression)? ';'
		@Override public ParserRule getRule() { return rule; }

		//dataType=[types::DataType|DATATYPE] name=ID (':=' initializeExpression=InitializeExpression)? ';'
		public Group getGroup() { return cGroup; }

		//dataType=[types::DataType|DATATYPE]
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//[types::DataType|DATATYPE]
		public CrossReference getDataTypeDataTypeCrossReference_0_0() { return cDataTypeDataTypeCrossReference_0_0; }

		//DATATYPE
		public RuleCall getDataTypeDataTypeDATATYPEParserRuleCall_0_0_1() { return cDataTypeDataTypeDATATYPEParserRuleCall_0_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//(':=' initializeExpression=InitializeExpression)?
		public Group getGroup_2() { return cGroup_2; }

		//':='
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//initializeExpression=InitializeExpression
		public Assignment getInitializeExpressionAssignment_2_1() { return cInitializeExpressionAssignment_2_1; }

		//InitializeExpression
		public RuleCall getInitializeExpressionInitializeExpressionParserRuleCall_2_1_0() { return cInitializeExpressionInitializeExpressionParserRuleCall_2_1_0; }

		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class LocalConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LocalConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cConstantConstKeyword_0_0 = (Keyword)cConstantAssignment_0.eContents().get(0);
		private final Assignment cDataTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDataTypeDataTypeCrossReference_1_0 = (CrossReference)cDataTypeAssignment_1.eContents().get(0);
		private final RuleCall cDataTypeDataTypeDATATYPEParserRuleCall_1_0_1 = (RuleCall)cDataTypeDataTypeCrossReference_1_0.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInitializeExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInitializeExpressionInitializeExpressionParserRuleCall_4_0 = (RuleCall)cInitializeExpressionAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LocalConstantDeclaration behavior::Variable:
		//	constant?='const' dataType=[types::DataType|DATATYPE] name=ID ':=' initializeExpression=InitializeExpression ';'
		@Override public ParserRule getRule() { return rule; }

		//constant?='const' dataType=[types::DataType|DATATYPE] name=ID ':=' initializeExpression=InitializeExpression ';'
		public Group getGroup() { return cGroup; }

		//constant?='const'
		public Assignment getConstantAssignment_0() { return cConstantAssignment_0; }

		//'const'
		public Keyword getConstantConstKeyword_0_0() { return cConstantConstKeyword_0_0; }

		//dataType=[types::DataType|DATATYPE]
		public Assignment getDataTypeAssignment_1() { return cDataTypeAssignment_1; }

		//[types::DataType|DATATYPE]
		public CrossReference getDataTypeDataTypeCrossReference_1_0() { return cDataTypeDataTypeCrossReference_1_0; }

		//DATATYPE
		public RuleCall getDataTypeDataTypeDATATYPEParserRuleCall_1_0_1() { return cDataTypeDataTypeDATATYPEParserRuleCall_1_0_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//':='
		public Keyword getColonEqualsSignKeyword_3() { return cColonEqualsSignKeyword_3; }

		//initializeExpression=InitializeExpression
		public Assignment getInitializeExpressionAssignment_4() { return cInitializeExpressionAssignment_4; }

		//InitializeExpression
		public RuleCall getInitializeExpressionInitializeExpressionParserRuleCall_4_0() { return cInitializeExpressionInitializeExpressionParserRuleCall_4_0; }

		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class NondeterministicChoiceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.NondeterministicChoiceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDataTypePrimitiveDataTypeCrossReference_0_0 = (CrossReference)cDataTypeAssignment_0.eContents().get(0);
		private final RuleCall cDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cDataTypePrimitiveDataTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cRangeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRangeRangeParserRuleCall_1_0 = (RuleCall)cRangeAssignment_1.eContents().get(0);
		
		//// end of local variable declaration
		//// nondeterministic choice expression
		//NondeterministicChoiceExpression actionlanguage::NondeterministicChoiceExpression:
		//	dataType=[types::PrimitiveDataType] range=Range
		@Override public ParserRule getRule() { return rule; }

		//dataType=[types::PrimitiveDataType] range=Range
		public Group getGroup() { return cGroup; }

		//dataType=[types::PrimitiveDataType]
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//[types::PrimitiveDataType]
		public CrossReference getDataTypePrimitiveDataTypeCrossReference_0_0() { return cDataTypePrimitiveDataTypeCrossReference_0_0; }

		//ID
		public RuleCall getDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1() { return cDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1; }

		//range=Range
		public Assignment getRangeAssignment_1() { return cRangeAssignment_1; }

		//Range
		public RuleCall getRangeRangeParserRuleCall_1_0() { return cRangeRangeParserRuleCall_1_0; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundLONGParserRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundLONGParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Range valuetype::Range:
		//	'<' lowerBound=LONG ',' upperBound=LONG '>'
		@Override public ParserRule getRule() { return rule; }

		//'<' lowerBound=LONG ',' upperBound=LONG '>'
		public Group getGroup() { return cGroup; }

		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//lowerBound=LONG
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }

		//LONG
		public RuleCall getLowerBoundLONGParserRuleCall_1_0() { return cLowerBoundLONGParserRuleCall_1_0; }

		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//upperBound=LONG
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }

		//LONG
		public RuleCall getUpperBoundLONGParserRuleCall_3_0() { return cUpperBoundLONGParserRuleCall_3_0; }

		//'>'
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class LONGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LONG");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LONG ecore::ELong:
		//	INT
		@Override public ParserRule getRule() { return rule; }

		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.Expression");
		private final RuleCall cLogicalExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of nondeterministic choice expression
		//Expression expressions::Expression:
		//	LogicalExpression
		@Override public ParserRule getRule() { return rule; }

		//LogicalExpression
		public RuleCall getLogicalExpressionParserRuleCall() { return cLogicalExpressionParserRuleCall; }
	}

	public class LogicalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LogicalExpression");
		private final RuleCall cLogicalOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// LogicalExpression
		//LogicalExpression expressions::Expression:
		//	LogicalOrExpression
		@Override public ParserRule getRule() { return rule; }

		//LogicalOrExpression
		public RuleCall getLogicalOrExpressionParserRuleCall() { return cLogicalOrExpressionParserRuleCall; }
	}

	public class LogicalOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LogicalOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOrOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalOrExpression expressions::Expression:
		//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//	rightExpression=LogicalAndExpression)*
		@Override public ParserRule getRule() { return rule; }

		//LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup() { return cGroup; }

		//LogicalAndExpression
		public RuleCall getLogicalAndExpressionParserRuleCall_0() { return cLogicalAndExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalOrOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOrOperator
		public RuleCall getOperatorLogicalOrOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalOrOperatorEnumRuleCall_1_1_0; }

		//rightExpression=LogicalAndExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//LogicalAndExpression
		public RuleCall getRightExpressionLogicalAndExpressionParserRuleCall_1_2_0() { return cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0; }
	}

	public class LogicalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LogicalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalAndOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalAndExpression expressions::Expression:
		//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//	rightExpression=ComparisonExpression)*
		@Override public ParserRule getRule() { return rule; }

		//ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalAndOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalAndOperator
		public RuleCall getOperatorLogicalAndOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalAndOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightExpressionComparisonExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonHigherOpExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//// end of LogicalExpression
		//// ComparisonExpression
		//ComparisonExpression expressions::Expression:
		//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//	operator=ComparingEQNEQOperator
		//	rightExpression=ComparisonHigherOpExpression)?
		@Override public ParserRule getRule() { return rule; }

		//ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup() { return cGroup; }

		//ComparisonHigherOpExpression
		public RuleCall getComparisonHigherOpExpressionParserRuleCall_0() { return cComparisonHigherOpExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingEQNEQOperator
		//rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingEQNEQOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingEQNEQOperator
		public RuleCall getOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0() { return cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonHigherOpExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonHigherOpExpression
		public RuleCall getRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonHigherOpExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ComparisonHigherOpExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArithmeticExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingRelOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionArithmeticExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//ComparisonHigherOpExpression expressions::Expression:
		//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//	rightExpression=ArithmeticExpression)?
		@Override public ParserRule getRule() { return rule; }

		//ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup() { return cGroup; }

		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall_0() { return cArithmeticExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingRelOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingRelOperator
		public RuleCall getOperatorComparingRelOperatorEnumRuleCall_1_1_0() { return cOperatorComparingRelOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ArithmeticExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ArithmeticExpression
		public RuleCall getRightExpressionArithmeticExpressionParserRuleCall_1_2_0() { return cRightExpressionArithmeticExpressionParserRuleCall_1_2_0; }
	}

	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ArithmeticExpression");
		private final RuleCall cAdditionExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of ComparisonExpression
		//// ArithmeticExpression	
		//ArithmeticExpression expressions::Expression:
		//	AdditionExpression
		@Override public ParserRule getRule() { return rule; }

		//AdditionExpression
		public RuleCall getAdditionExpressionParserRuleCall() { return cAdditionExpressionParserRuleCall; }
	}

	public class AdditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.AdditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditionOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//AdditionExpression expressions::Expression:
		//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//	rightExpression=MultiplicationExpression)*
		@Override public ParserRule getRule() { return rule; }

		//MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicationExpression
		public RuleCall getMultiplicationExpressionParserRuleCall_0() { return cMultiplicationExpressionParserRuleCall_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=AdditionOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditionOperator
		public RuleCall getOperatorAdditionOperatorEnumRuleCall_1_1_0() { return cOperatorAdditionOperatorEnumRuleCall_1_1_0; }

		//rightExpression=MultiplicationExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//MultiplicationExpression
		public RuleCall getRightExpressionMultiplicationExpressionParserRuleCall_1_2_0() { return cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.MultiplicationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryPreExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cTypeCastExpressionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0 = (RuleCall)cOperatorAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final Alternatives cRightExpressionAlternatives_1_1_2_0 = (Alternatives)cRightExpressionAssignment_1_1_2.eContents().get(0);
		private final RuleCall cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(0);
		private final RuleCall cRightExpressionTypeCastExpressionParserRuleCall_1_1_2_0_1 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(1);
		
		//MultiplicationExpression expressions::Expression:
		//	UnaryPreExpression | TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | TypeCastExpression))*
		@Override public ParserRule getRule() { return rule; }

		//UnaryPreExpression | TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//operator=MultiplicationOperator rightExpression=(UnaryPreExpression | TypeCastExpression))*
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnaryPreExpression
		public RuleCall getUnaryPreExpressionParserRuleCall_0() { return cUnaryPreExpressionParserRuleCall_0; }

		//TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | TypeCastExpression))*
		public Group getGroup_1() { return cGroup_1; }

		//TypeCastExpression
		public RuleCall getTypeCastExpressionParserRuleCall_1_0() { return cTypeCastExpressionParserRuleCall_1_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | TypeCastExpression))*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_1_0() { return cArithmeticExpressionLeftExpressionAction_1_1_0; }

		//operator=MultiplicationOperator
		public Assignment getOperatorAssignment_1_1_1() { return cOperatorAssignment_1_1_1; }

		//MultiplicationOperator
		public RuleCall getOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0() { return cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0; }

		//rightExpression=(UnaryPreExpression | TypeCastExpression)
		public Assignment getRightExpressionAssignment_1_1_2() { return cRightExpressionAssignment_1_1_2; }

		//(UnaryPreExpression | TypeCastExpression)
		public Alternatives getRightExpressionAlternatives_1_1_2_0() { return cRightExpressionAlternatives_1_1_2_0; }

		//UnaryPreExpression
		public RuleCall getRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0() { return cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0; }

		//TypeCastExpression
		public RuleCall getRightExpressionTypeCastExpressionParserRuleCall_1_1_2_0_1() { return cRightExpressionTypeCastExpressionParserRuleCall_1_1_2_0_1; }
	}

	public class UnaryPreExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.UnaryPreExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnaryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorUnaryPreOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cEnclosedExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEnclosedExpressionTypeCastExpressionParserRuleCall_2_0 = (RuleCall)cEnclosedExpressionAssignment_2.eContents().get(0);
		
		//// end of ArithmeticExpression
		//// UnaryPreExpression
		//UnaryPreExpression expressions::Expression:
		//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=TypeCastExpression
		@Override public ParserRule getRule() { return rule; }

		//{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=TypeCastExpression
		public Group getGroup() { return cGroup; }

		//{commonExpressions::UnaryExpression}
		public Action getUnaryExpressionAction_0() { return cUnaryExpressionAction_0; }

		//operator=UnaryPreOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//UnaryPreOperator
		public RuleCall getOperatorUnaryPreOperatorEnumRuleCall_1_0() { return cOperatorUnaryPreOperatorEnumRuleCall_1_0; }

		//enclosedExpression=TypeCastExpression
		public Assignment getEnclosedExpressionAssignment_2() { return cEnclosedExpressionAssignment_2; }

		//TypeCastExpression
		public RuleCall getEnclosedExpressionTypeCastExpressionParserRuleCall_2_0() { return cEnclosedExpressionTypeCastExpressionParserRuleCall_2_0; }
	}

	public class TypeCastExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.TypeCastExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOperandParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cTypeCastExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cDataTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cDataTypeDataTypeCrossReference_1_2_0 = (CrossReference)cDataTypeAssignment_1_2.eContents().get(0);
		private final RuleCall cDataTypeDataTypeDATATYPEParserRuleCall_1_2_0_1 = (RuleCall)cDataTypeDataTypeCrossReference_1_2_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cEnclosedExpressionAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cEnclosedExpressionOperandParserRuleCall_1_4_0 = (RuleCall)cEnclosedExpressionAssignment_1_4.eContents().get(0);
		
		//// end of UnaryPreExpression
		//TypeCastExpression expressions::Expression:
		//	Operand | {actionlanguage::TypeCastExpression}
		//	'(' dataType=[types::DataType|DATATYPE] ')' enclosedExpression=Operand
		@Override public ParserRule getRule() { return rule; }

		//Operand | {actionlanguage::TypeCastExpression} '(' dataType=[types::DataType|DATATYPE] ')' enclosedExpression=Operand
		public Alternatives getAlternatives() { return cAlternatives; }

		//Operand
		public RuleCall getOperandParserRuleCall_0() { return cOperandParserRuleCall_0; }

		//{actionlanguage::TypeCastExpression} '(' dataType=[types::DataType|DATATYPE] ')' enclosedExpression=Operand
		public Group getGroup_1() { return cGroup_1; }

		//{actionlanguage::TypeCastExpression}
		public Action getTypeCastExpressionAction_1_0() { return cTypeCastExpressionAction_1_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//dataType=[types::DataType|DATATYPE]
		public Assignment getDataTypeAssignment_1_2() { return cDataTypeAssignment_1_2; }

		//[types::DataType|DATATYPE]
		public CrossReference getDataTypeDataTypeCrossReference_1_2_0() { return cDataTypeDataTypeCrossReference_1_2_0; }

		//DATATYPE
		public RuleCall getDataTypeDataTypeDATATYPEParserRuleCall_1_2_0_1() { return cDataTypeDataTypeDATATYPEParserRuleCall_1_2_0_1; }

		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//enclosedExpression=Operand
		public Assignment getEnclosedExpressionAssignment_1_4() { return cEnclosedExpressionAssignment_1_4; }

		//Operand
		public RuleCall getEnclosedExpressionOperandParserRuleCall_1_4_0() { return cEnclosedExpressionOperandParserRuleCall_1_4_0; }
	}

	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendedTypedNamedElementExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTimeValueExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cOperationCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTriggerMessageExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNoAttributeSelectorExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//// Operand
		//Operand expressions::Expression:
		//	'(' Expression ')' | LiteralExpression | ExtendedTypedNamedElementExpression | TimeValueExpression
		//	| OperationCall | TriggerMessageExpression | NoAttributeSelectorExpression
		@Override public ParserRule getRule() { return rule; }

		//'(' Expression ')' | LiteralExpression | ExtendedTypedNamedElementExpression | TimeValueExpression | OperationCall |
		//TriggerMessageExpression | NoAttributeSelectorExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_1() { return cLiteralExpressionParserRuleCall_1; }

		//ExtendedTypedNamedElementExpression
		public RuleCall getExtendedTypedNamedElementExpressionParserRuleCall_2() { return cExtendedTypedNamedElementExpressionParserRuleCall_2; }

		//TimeValueExpression
		public RuleCall getTimeValueExpressionParserRuleCall_3() { return cTimeValueExpressionParserRuleCall_3; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_4() { return cOperationCallParserRuleCall_4; }

		//TriggerMessageExpression
		public RuleCall getTriggerMessageExpressionParserRuleCall_5() { return cTriggerMessageExpressionParserRuleCall_5; }

		//NoAttributeSelectorExpression
		public RuleCall getNoAttributeSelectorExpressionParserRuleCall_6() { return cNoAttributeSelectorExpressionParserRuleCall_6; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//// end of Operand
		//LiteralExpression commonExpressions::LiteralExpression:
		//	{commonExpressions::LiteralExpression} value=Literal
		@Override public ParserRule getRule() { return rule; }

		//{commonExpressions::LiteralExpression} value=Literal
		public Group getGroup() { return cGroup; }

		//{commonExpressions::LiteralExpression}
		public Action getLiteralExpressionAction_0() { return cLiteralExpressionAction_0; }

		//value=Literal
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_0() { return cValueLiteralParserRuleCall_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNUMBERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBOOLEANTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Keyword cNullKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Literal:
		//	NUMBER | BOOLEAN | INT | 'null';
		@Override public ParserRule getRule() { return rule; }

		//NUMBER | BOOLEAN | INT | 'null'
		public Alternatives getAlternatives() { return cAlternatives; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_0() { return cNUMBERTerminalRuleCall_0; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_1() { return cBOOLEANTerminalRuleCall_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }

		//'null'
		public Keyword getNullKeyword_3() { return cNullKeyword_3; }
	}

	public class TimeValueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.TimeValueExpression");
		private final Assignment cTimeValueAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cTimeValueTimeValueCrossReference_0 = (CrossReference)cTimeValueAssignment.eContents().get(0);
		private final RuleCall cTimeValueTimeValueMINORMAXKEYWORDTerminalRuleCall_0_1 = (RuleCall)cTimeValueTimeValueCrossReference_0.eContents().get(1);
		
		//TimeValueExpression actionlanguage::TimeValueExpression:
		//	timeValue=[valuetype::TimeValue|MINORMAXKEYWORD]
		@Override public ParserRule getRule() { return rule; }

		//timeValue=[valuetype::TimeValue|MINORMAXKEYWORD]
		public Assignment getTimeValueAssignment() { return cTimeValueAssignment; }

		//[valuetype::TimeValue|MINORMAXKEYWORD]
		public CrossReference getTimeValueTimeValueCrossReference_0() { return cTimeValueTimeValueCrossReference_0; }

		//MINORMAXKEYWORD
		public RuleCall getTimeValueTimeValueMINORMAXKEYWORDTerminalRuleCall_0_1() { return cTimeValueTimeValueMINORMAXKEYWORDTerminalRuleCall_0_1; }
	}

	public class ExtendedTypedNamedElementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ExtendedTypedNamedElementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTypedNamedElementExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cPositionAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cPositionPositionSelectorExpressionParserRuleCall_1_0_2_0 = (RuleCall)cPositionAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cAssignmentLhs_typedNamedElementExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cIncrementDecrementOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_1_1.eContents().get(0);
		
		//ExtendedTypedNamedElementExpression expressions::Expression:
		//	TypedNamedElementExpression
		//	({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
		//	'->' position=PositionSelectorExpression
		//	| {actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//	incrementDecrementOperator=IncrementDecrementOperatorExpression)?
		@Override public ParserRule getRule() { return rule; }

		//TypedNamedElementExpression ({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
		//'->' position=PositionSelectorExpression | {actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression)?
		public Group getGroup() { return cGroup; }

		//TypedNamedElementExpression
		public RuleCall getTypedNamedElementExpressionParserRuleCall_0() { return cTypedNamedElementExpressionParserRuleCall_0; }

		//({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} '->'
		//position=PositionSelectorExpression | {actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} '->'
		//position=PositionSelectorExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
		public Action getDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0() { return cDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0; }

		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0_1() { return cHyphenMinusGreaterThanSignKeyword_1_0_1; }

		//position=PositionSelectorExpression
		public Assignment getPositionAssignment_1_0_2() { return cPositionAssignment_1_0_2; }

		//PositionSelectorExpression
		public RuleCall getPositionPositionSelectorExpressionParserRuleCall_1_0_2_0() { return cPositionPositionSelectorExpressionParserRuleCall_1_0_2_0; }

		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		public Action getAssignmentLhs_typedNamedElementExpressionAction_1_1_0() { return cAssignmentLhs_typedNamedElementExpressionAction_1_1_0; }

		//incrementDecrementOperator=IncrementDecrementOperatorExpression
		public Assignment getIncrementDecrementOperatorAssignment_1_1_1() { return cIncrementDecrementOperatorAssignment_1_1_1; }

		//IncrementDecrementOperatorExpression
		public RuleCall getIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0() { return cIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0; }
	}

	public class TypedNamedElementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.TypedNamedElementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypedNamedElementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypedNamedElementTypedNamedElementCrossReference_0_0 = (CrossReference)cTypedNamedElementAssignment_0.eContents().get(0);
		private final RuleCall cTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1 = (RuleCall)cTypedNamedElementTypedNamedElementCrossReference_0_0.eContents().get(1);
		private final Assignment cElementAccessorsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cElementAccessorsAlternatives_1_0 = (Alternatives)cElementAccessorsAssignment_1.eContents().get(0);
		private final RuleCall cElementAccessorsArrayIndexExpressionParserRuleCall_1_0_0 = (RuleCall)cElementAccessorsAlternatives_1_0.eContents().get(0);
		private final RuleCall cElementAccessorsAttributeAccessorExpressionParserRuleCall_1_0_1 = (RuleCall)cElementAccessorsAlternatives_1_0.eContents().get(1);
		
		//TypedNamedElementExpression actionlanguage::TypedNamedElementExpression:
		//	typedNamedElement=[behavior::TypedNamedElement] elementAccessors+=(ArrayIndexExpression |
		//	AttributeAccessorExpression)*
		@Override public ParserRule getRule() { return rule; }

		//typedNamedElement=[behavior::TypedNamedElement] elementAccessors+=(ArrayIndexExpression | AttributeAccessorExpression)*
		public Group getGroup() { return cGroup; }

		//typedNamedElement=[behavior::TypedNamedElement]
		public Assignment getTypedNamedElementAssignment_0() { return cTypedNamedElementAssignment_0; }

		//[behavior::TypedNamedElement]
		public CrossReference getTypedNamedElementTypedNamedElementCrossReference_0_0() { return cTypedNamedElementTypedNamedElementCrossReference_0_0; }

		//ID
		public RuleCall getTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1() { return cTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1; }

		//elementAccessors+=(ArrayIndexExpression | AttributeAccessorExpression)*
		public Assignment getElementAccessorsAssignment_1() { return cElementAccessorsAssignment_1; }

		//(ArrayIndexExpression | AttributeAccessorExpression)
		public Alternatives getElementAccessorsAlternatives_1_0() { return cElementAccessorsAlternatives_1_0; }

		//ArrayIndexExpression
		public RuleCall getElementAccessorsArrayIndexExpressionParserRuleCall_1_0_0() { return cElementAccessorsArrayIndexExpressionParserRuleCall_1_0_0; }

		//AttributeAccessorExpression
		public RuleCall getElementAccessorsAttributeAccessorExpressionParserRuleCall_1_0_1() { return cElementAccessorsAttributeAccessorExpressionParserRuleCall_1_0_1; }
	}

	public class ArrayIndexExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ArrayIndexExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexArithmeticExpressionParserRuleCall_1_0 = (RuleCall)cIndexAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ArrayIndexExpression actionlanguage::ArrayIndexExpression:
		//	'[' index=ArithmeticExpression ']'
		@Override public ParserRule getRule() { return rule; }

		//'[' index=ArithmeticExpression ']'
		public Group getGroup() { return cGroup; }

		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//index=ArithmeticExpression
		public Assignment getIndexAssignment_1() { return cIndexAssignment_1; }

		//ArithmeticExpression
		public RuleCall getIndexArithmeticExpressionParserRuleCall_1_0() { return cIndexArithmeticExpressionParserRuleCall_1_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class AttributeAccessorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.AttributeAccessorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAttributeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cAttributeAttributeCrossReference_1_0 = (CrossReference)cAttributeAssignment_1.eContents().get(0);
		private final RuleCall cAttributeAttributeIDTerminalRuleCall_1_0_1 = (RuleCall)cAttributeAttributeCrossReference_1_0.eContents().get(1);
		
		//AttributeAccessorExpression actionlanguage::AttributeAccessorExpression:
		//	'.' attribute=[types::Attribute]
		@Override public ParserRule getRule() { return rule; }

		//'.' attribute=[types::Attribute]
		public Group getGroup() { return cGroup; }

		//'.'
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//attribute=[types::Attribute]
		public Assignment getAttributeAssignment_1() { return cAttributeAssignment_1; }

		//[types::Attribute]
		public CrossReference getAttributeAttributeCrossReference_1_0() { return cAttributeAttributeCrossReference_1_0; }

		//ID
		public RuleCall getAttributeAttributeIDTerminalRuleCall_1_0_1() { return cAttributeAttributeIDTerminalRuleCall_1_0_1; }
	}

	public class NoAttributeSelectorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.NoAttributeSelectorExpression");
		private final Assignment cPositionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPositionPositionSelectorExpressionParserRuleCall_0 = (RuleCall)cPositionAssignment.eContents().get(0);
		
		//NoAttributeSelectorExpression actionlanguage::DiscreteInteractionEndpointReference:
		//	position=PositionSelectorExpression
		@Override public ParserRule getRule() { return rule; }

		//position=PositionSelectorExpression
		public Assignment getPositionAssignment() { return cPositionAssignment; }

		//PositionSelectorExpression
		public RuleCall getPositionPositionSelectorExpressionParserRuleCall_0() { return cPositionPositionSelectorExpressionParserRuleCall_0; }
	}

	public class PositionSelectorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.PositionSelectorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKindPositionSelectorKindEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSuccessorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSuccessorPositionSelectorExpressionParserRuleCall_1_1_0 = (RuleCall)cSuccessorAssignment_1_1.eContents().get(0);
		
		//PositionSelectorExpression actionlanguage::PositionSelector:
		//	kind=PositionSelectorKind ('->' successor=PositionSelectorExpression)?
		@Override public ParserRule getRule() { return rule; }

		//kind=PositionSelectorKind ('->' successor=PositionSelectorExpression)?
		public Group getGroup() { return cGroup; }

		//kind=PositionSelectorKind
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }

		//PositionSelectorKind
		public RuleCall getKindPositionSelectorKindEnumRuleCall_0_0() { return cKindPositionSelectorKindEnumRuleCall_0_0; }

		//('->' successor=PositionSelectorExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0() { return cHyphenMinusGreaterThanSignKeyword_1_0; }

		//successor=PositionSelectorExpression
		public Assignment getSuccessorAssignment_1_1() { return cSuccessorAssignment_1_1; }

		//PositionSelectorExpression
		public RuleCall getSuccessorPositionSelectorExpressionParserRuleCall_1_1_0() { return cSuccessorPositionSelectorExpressionParserRuleCall_1_1_0; }
	}

	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.OperationCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cOperationOperationCrossReference_0_0 = (CrossReference)cOperationAssignment_0.eContents().get(0);
		private final RuleCall cOperationOperationIDTerminalRuleCall_0_0_1 = (RuleCall)cOperationOperationCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterBindingAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_0_0 = (RuleCall)cParameterBindingAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterBindingAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_1_1_0 = (RuleCall)cParameterBindingAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//OperationCall actionlanguage::OperationCall:
		//	operation=[behavior::Operation] '(' (parameterBinding+=ParamaterBinding (',' parameterBinding+=ParamaterBinding)*)?
		//	')'
		@Override public ParserRule getRule() { return rule; }

		//operation=[behavior::Operation] '(' (parameterBinding+=ParamaterBinding (',' parameterBinding+=ParamaterBinding)*)? ')'
		public Group getGroup() { return cGroup; }

		//operation=[behavior::Operation]
		public Assignment getOperationAssignment_0() { return cOperationAssignment_0; }

		//[behavior::Operation]
		public CrossReference getOperationOperationCrossReference_0_0() { return cOperationOperationCrossReference_0_0; }

		//ID
		public RuleCall getOperationOperationIDTerminalRuleCall_0_0_1() { return cOperationOperationIDTerminalRuleCall_0_0_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameterBinding+=ParamaterBinding (',' parameterBinding+=ParamaterBinding)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_0() { return cParameterBindingAssignment_2_0; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_0_0() { return cParameterBindingParamaterBindingParserRuleCall_2_0_0; }

		//(',' parameterBinding+=ParamaterBinding)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_1_1() { return cParameterBindingAssignment_2_1_1; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_1_1_0() { return cParameterBindingParamaterBindingParserRuleCall_2_1_1_0; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ParamaterBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ParamaterBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterBindingAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cParameterParameterCrossReference_1_0 = (CrossReference)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_1_0_1 = (RuleCall)cParameterParameterCrossReference_1_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ParamaterBinding behavior::ParameterBinding:
		//	{behavior::ParameterBinding} parameter=[behavior::Parameter] ':=' value=Expression
		@Override public ParserRule getRule() { return rule; }

		//{behavior::ParameterBinding} parameter=[behavior::Parameter] ':=' value=Expression
		public Group getGroup() { return cGroup; }

		//{behavior::ParameterBinding}
		public Action getParameterBindingAction_0() { return cParameterBindingAction_0; }

		//parameter=[behavior::Parameter]
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }

		//[behavior::Parameter]
		public CrossReference getParameterParameterCrossReference_1_0() { return cParameterParameterCrossReference_1_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_1_0_1() { return cParameterParameterIDTerminalRuleCall_1_0_1; }

		//':='
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class TriggerMessageExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.TriggerMessageExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMessageTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cMessageTypeMessageTypeCrossReference_0_0 = (CrossReference)cMessageTypeAssignment_0.eContents().get(0);
		private final RuleCall cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cMessageTypeMessageTypeCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParameterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cParameterParameterCrossReference_2_0 = (CrossReference)cParameterAssignment_2.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_2_0_1 = (RuleCall)cParameterParameterCrossReference_2_0.eContents().get(1);
		
		//// TriggerMessageExpression
		//TriggerMessageExpression actionlanguage::TriggerMessageExpression:
		//	messageType=[msgtype::MessageType] '->' parameter=[behavior::Parameter]
		@Override public ParserRule getRule() { return rule; }

		//messageType=[msgtype::MessageType] '->' parameter=[behavior::Parameter]
		public Group getGroup() { return cGroup; }

		//messageType=[msgtype::MessageType]
		public Assignment getMessageTypeAssignment_0() { return cMessageTypeAssignment_0; }

		//[msgtype::MessageType]
		public CrossReference getMessageTypeMessageTypeCrossReference_0_0() { return cMessageTypeMessageTypeCrossReference_0_0; }

		//ID
		public RuleCall getMessageTypeMessageTypeIDTerminalRuleCall_0_0_1() { return cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1; }

		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }

		//parameter=[behavior::Parameter]
		public Assignment getParameterAssignment_2() { return cParameterAssignment_2; }

		//[behavior::Parameter]
		public CrossReference getParameterParameterCrossReference_2_0() { return cParameterParameterCrossReference_2_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_2_0_1() { return cParameterParameterIDTerminalRuleCall_2_0_1; }
	}

	public class DATATYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.DATATYPE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//DATATYPE:
		//	ID ('[' INT ']')*;
		@Override public ParserRule getRule() { return rule; }

		//ID ('[' INT ']')*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//('[' INT ']')*
		public Group getGroup_1() { return cGroup_1; }

		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }

		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	
	
	public class UnaryPostIncrementDecrementOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.UnaryPostIncrementDecrementOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryPostIncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
		//	INCREMENT='++' | DECREMENT='--';
		public EnumRule getRule() { return rule; }

		//INCREMENT='++' | DECREMENT='--'
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT='++'
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//'++'
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT='--'
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//'--'
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class IncrementDecrementOperatorExpressionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.IncrementDecrementOperatorExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum IncrementDecrementOperatorExpression returns actionlanguage::IncrementDecrementOperator:
		//	INCREMENT='++' | DECREMENT='--';
		public EnumRule getRule() { return rule; }

		//INCREMENT='++' | DECREMENT='--'
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT='++'
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//'++'
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT='--'
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//'--'
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class AssignOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.AssignOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cASSIGNEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cASSIGNColonEqualsSignKeyword_0_0 = (Keyword)cASSIGNEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUS_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUS_EQUALPlusSignEqualsSignKeyword_1_0 = (Keyword)cPLUS_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMINUS_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMINUS_EQUALHyphenMinusEqualsSignKeyword_2_0 = (Keyword)cMINUS_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum AssignOperator returns actionlanguage::AssignOperator:
		//	ASSIGN=':=' | PLUS_EQUAL='+=' | MINUS_EQUAL='-=';
		public EnumRule getRule() { return rule; }

		//ASSIGN=':=' | PLUS_EQUAL='+=' | MINUS_EQUAL='-='
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASSIGN=':='
		public EnumLiteralDeclaration getASSIGNEnumLiteralDeclaration_0() { return cASSIGNEnumLiteralDeclaration_0; }

		//':='
		public Keyword getASSIGNColonEqualsSignKeyword_0_0() { return cASSIGNColonEqualsSignKeyword_0_0; }

		//PLUS_EQUAL='+='
		public EnumLiteralDeclaration getPLUS_EQUALEnumLiteralDeclaration_1() { return cPLUS_EQUALEnumLiteralDeclaration_1; }

		//'+='
		public Keyword getPLUS_EQUALPlusSignEqualsSignKeyword_1_0() { return cPLUS_EQUALPlusSignEqualsSignKeyword_1_0; }

		//MINUS_EQUAL='-='
		public EnumLiteralDeclaration getMINUS_EQUALEnumLiteralDeclaration_2() { return cMINUS_EQUALEnumLiteralDeclaration_2; }

		//'-='
		public Keyword getMINUS_EQUALHyphenMinusEqualsSignKeyword_2_0() { return cMINUS_EQUALHyphenMinusEqualsSignKeyword_2_0; }
	}

	public class LogicalOrOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LogicalOrOperator");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORVerticalLineVerticalLineKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalOrOperator returns commonExpressions::LogicOperator:
		//	OR='||';
		public EnumRule getRule() { return rule; }

		//OR='||'
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }

		//'||'
		public Keyword getORVerticalLineVerticalLineKeyword_0() { return cORVerticalLineVerticalLineKeyword_0; }
	}

	public class LogicalAndOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.LogicalAndOperator");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDAmpersandAmpersandKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalAndOperator returns commonExpressions::LogicOperator:
		//	AND='&&';
		public EnumRule getRule() { return rule; }

		//AND='&&'
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }

		//'&&'
		public Keyword getANDAmpersandAmpersandKeyword_0() { return cANDAmpersandAmpersandKeyword_0; }
	}

	public class ComparingEQNEQOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ComparingEQNEQOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUNEQUALLessThanSignGreaterThanSignKeyword_1_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
		//	EQUAL='==' | UNEQUAL='<>';
		public EnumRule getRule() { return rule; }

		//EQUAL='==' | UNEQUAL='<>'
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL='=='
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }

		//'=='
		public Keyword getEQUALEqualsSignEqualsSignKeyword_0_0() { return cEQUALEqualsSignEqualsSignKeyword_0_0; }

		//UNEQUAL='<>'
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_1() { return cUNEQUALEnumLiteralDeclaration_1; }

		//'<>'
		public Keyword getUNEQUALLessThanSignGreaterThanSignKeyword_1_0() { return cUNEQUALLessThanSignGreaterThanSignKeyword_1_0; }
	}

	public class ComparingRelOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ComparingRelOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLESSLessThanSignKeyword_0_0 = (Keyword)cLESSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGREATERGreaterThanSignKeyword_3_0 = (Keyword)cGREATEREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
		//	LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>';
		public EnumRule getRule() { return rule; }

		//LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>'
		public Alternatives getAlternatives() { return cAlternatives; }

		//LESS='<'
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_0() { return cLESSEnumLiteralDeclaration_0; }

		//'<'
		public Keyword getLESSLessThanSignKeyword_0_0() { return cLESSLessThanSignKeyword_0_0; }

		//LESS_OR_EQUAL='<='
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_1() { return cLESS_OR_EQUALEnumLiteralDeclaration_1; }

		//'<='
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0; }

		//GREATER_OR_EQUAL='>='
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_2() { return cGREATER_OR_EQUALEnumLiteralDeclaration_2; }

		//'>='
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0; }

		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_3() { return cGREATEREnumLiteralDeclaration_3; }

		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_3_0() { return cGREATERGreaterThanSignKeyword_3_0; }
	}

	public class AdditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.AdditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
		//	PLUS='+' | MINUS='-';
		public EnumRule getRule() { return rule; }

		//PLUS='+' | MINUS='-'
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS='+'
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//'+'
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS='-'
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//'-'
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class MultiplicationOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.MultiplicationOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTIMESAsteriskKeyword_0_0 = (Keyword)cTIMESEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVIDESolidusKeyword_1_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODULOEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODULOPercentSignKeyword_2_0 = (Keyword)cMODULOEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
		//	TIMES='*' | DIVIDE='/' | MODULO='%';
		public EnumRule getRule() { return rule; }

		//TIMES='*' | DIVIDE='/' | MODULO='%'
		public Alternatives getAlternatives() { return cAlternatives; }

		//TIMES='*'
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration_0() { return cTIMESEnumLiteralDeclaration_0; }

		//'*'
		public Keyword getTIMESAsteriskKeyword_0_0() { return cTIMESAsteriskKeyword_0_0; }

		//DIVIDE='/'
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_1() { return cDIVIDEEnumLiteralDeclaration_1; }

		//'/'
		public Keyword getDIVIDESolidusKeyword_1_0() { return cDIVIDESolidusKeyword_1_0; }

		//MODULO='%'
		public EnumLiteralDeclaration getMODULOEnumLiteralDeclaration_2() { return cMODULOEnumLiteralDeclaration_2; }

		//'%'
		public Keyword getMODULOPercentSignKeyword_2_0() { return cMODULOPercentSignKeyword_2_0; }
	}

	public class UnaryPreOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.UnaryPreOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNOTNotKeyword_0_0 = (Keyword)cNOTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
		//	NOT='not' | MINUS='-';
		public EnumRule getRule() { return rule; }

		//NOT='not' | MINUS='-'
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT='not'
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_0() { return cNOTEnumLiteralDeclaration_0; }

		//'not'
		public Keyword getNOTNotKeyword_0_0() { return cNOTNotKeyword_0_0; }

		//MINUS='-'
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//'-'
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class PositionSelectorKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.PositionSelectorKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSELFEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSELFSelfKeyword_0_0 = (Keyword)cSELFEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFIRSTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFIRSTFirstKeyword_1_0 = (Keyword)cFIRSTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLASTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLASTLastKeyword_2_0 = (Keyword)cLASTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cPREVEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cPREVPrevKeyword_3_0 = (Keyword)cPREVEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cNEXTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cNEXTNextKeyword_4_0 = (Keyword)cNEXTEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
		//	SELF='self' | FIRST='first' | LAST='last' | PREV='prev' | NEXT='next';
		public EnumRule getRule() { return rule; }

		//SELF='self' | FIRST='first' | LAST='last' | PREV='prev' | NEXT='next'
		public Alternatives getAlternatives() { return cAlternatives; }

		//SELF='self'
		public EnumLiteralDeclaration getSELFEnumLiteralDeclaration_0() { return cSELFEnumLiteralDeclaration_0; }

		//'self'
		public Keyword getSELFSelfKeyword_0_0() { return cSELFSelfKeyword_0_0; }

		//FIRST='first'
		public EnumLiteralDeclaration getFIRSTEnumLiteralDeclaration_1() { return cFIRSTEnumLiteralDeclaration_1; }

		//'first'
		public Keyword getFIRSTFirstKeyword_1_0() { return cFIRSTFirstKeyword_1_0; }

		//LAST='last'
		public EnumLiteralDeclaration getLASTEnumLiteralDeclaration_2() { return cLASTEnumLiteralDeclaration_2; }

		//'last'
		public Keyword getLASTLastKeyword_2_0() { return cLASTLastKeyword_2_0; }

		//PREV='prev'
		public EnumLiteralDeclaration getPREVEnumLiteralDeclaration_3() { return cPREVEnumLiteralDeclaration_3; }

		//'prev'
		public Keyword getPREVPrevKeyword_3_0() { return cPREVPrevKeyword_3_0; }

		//NEXT='next'
		public EnumLiteralDeclaration getNEXTEnumLiteralDeclaration_4() { return cNEXTEnumLiteralDeclaration_4; }

		//'next'
		public Keyword getNEXTNextKeyword_4_0() { return cNEXTNextKeyword_4_0; }
	}
	
	private final EntryElements pEntry;
	private final BlockElements pBlock;
	private final ForLoopElements pForLoop;
	private final ForLoopCountingExpressionElements pForLoopCountingExpression;
	private final WhileLoopElements pWhileLoop;
	private final DoWhileLoopElements pDoWhileLoop;
	private final IfStatementElements pIfStatement;
	private final ElseIfStatementElements pElseIfStatement;
	private final ReturnStatementElements pReturnStatement;
	private final OperationCallStatementElements pOperationCallStatement;
	private final ExpressionStartRuleElements pExpressionStartRule;
	private final UnaryPostIncrementDecrementOperatorElements eUnaryPostIncrementDecrementOperator;
	private final AssignmentElements pAssignment;
	private final IncrementDecrementOperatorExpressionElements eIncrementDecrementOperatorExpression;
	private final AssignOperatorElements eAssignOperator;
	private final InitializeExpressionElements pInitializeExpression;
	private final ArrayInitializeExpressionElements pArrayInitializeExpression;
	private final LocalVariableOrConstantDeclarationStatementElements pLocalVariableOrConstantDeclarationStatement;
	private final LocalVariableDeclarationElements pLocalVariableDeclaration;
	private final LocalConstantDeclarationElements pLocalConstantDeclaration;
	private final NondeterministicChoiceExpressionElements pNondeterministicChoiceExpression;
	private final RangeElements pRange;
	private final LONGElements pLONG;
	private final ExpressionElements pExpression;
	private final LogicalExpressionElements pLogicalExpression;
	private final LogicalOrExpressionElements pLogicalOrExpression;
	private final LogicalOrOperatorElements eLogicalOrOperator;
	private final LogicalAndExpressionElements pLogicalAndExpression;
	private final LogicalAndOperatorElements eLogicalAndOperator;
	private final ComparisonExpressionElements pComparisonExpression;
	private final ComparisonHigherOpExpressionElements pComparisonHigherOpExpression;
	private final ComparingEQNEQOperatorElements eComparingEQNEQOperator;
	private final ComparingRelOperatorElements eComparingRelOperator;
	private final ArithmeticExpressionElements pArithmeticExpression;
	private final AdditionExpressionElements pAdditionExpression;
	private final AdditionOperatorElements eAdditionOperator;
	private final MultiplicationExpressionElements pMultiplicationExpression;
	private final MultiplicationOperatorElements eMultiplicationOperator;
	private final UnaryPreExpressionElements pUnaryPreExpression;
	private final UnaryPreOperatorElements eUnaryPreOperator;
	private final TypeCastExpressionElements pTypeCastExpression;
	private final OperandElements pOperand;
	private final LiteralExpressionElements pLiteralExpression;
	private final LiteralElements pLiteral;
	private final TimeValueExpressionElements pTimeValueExpression;
	private final TerminalRule tMINORMAXKEYWORD;
	private final ExtendedTypedNamedElementExpressionElements pExtendedTypedNamedElementExpression;
	private final TypedNamedElementExpressionElements pTypedNamedElementExpression;
	private final ArrayIndexExpressionElements pArrayIndexExpression;
	private final AttributeAccessorExpressionElements pAttributeAccessorExpression;
	private final NoAttributeSelectorExpressionElements pNoAttributeSelectorExpression;
	private final PositionSelectorExpressionElements pPositionSelectorExpression;
	private final PositionSelectorKindElements ePositionSelectorKind;
	private final OperationCallElements pOperationCall;
	private final ParamaterBindingElements pParamaterBinding;
	private final TriggerMessageExpressionElements pTriggerMessageExpression;
	private final TerminalRule tNUMBER;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tID;
	private final DATATYPEElements pDATATYPE;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public ActionLanguageGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pEntry = new EntryElements();
		this.pBlock = new BlockElements();
		this.pForLoop = new ForLoopElements();
		this.pForLoopCountingExpression = new ForLoopCountingExpressionElements();
		this.pWhileLoop = new WhileLoopElements();
		this.pDoWhileLoop = new DoWhileLoopElements();
		this.pIfStatement = new IfStatementElements();
		this.pElseIfStatement = new ElseIfStatementElements();
		this.pReturnStatement = new ReturnStatementElements();
		this.pOperationCallStatement = new OperationCallStatementElements();
		this.pExpressionStartRule = new ExpressionStartRuleElements();
		this.eUnaryPostIncrementDecrementOperator = new UnaryPostIncrementDecrementOperatorElements();
		this.pAssignment = new AssignmentElements();
		this.eIncrementDecrementOperatorExpression = new IncrementDecrementOperatorExpressionElements();
		this.eAssignOperator = new AssignOperatorElements();
		this.pInitializeExpression = new InitializeExpressionElements();
		this.pArrayInitializeExpression = new ArrayInitializeExpressionElements();
		this.pLocalVariableOrConstantDeclarationStatement = new LocalVariableOrConstantDeclarationStatementElements();
		this.pLocalVariableDeclaration = new LocalVariableDeclarationElements();
		this.pLocalConstantDeclaration = new LocalConstantDeclarationElements();
		this.pNondeterministicChoiceExpression = new NondeterministicChoiceExpressionElements();
		this.pRange = new RangeElements();
		this.pLONG = new LONGElements();
		this.pExpression = new ExpressionElements();
		this.pLogicalExpression = new LogicalExpressionElements();
		this.pLogicalOrExpression = new LogicalOrExpressionElements();
		this.eLogicalOrOperator = new LogicalOrOperatorElements();
		this.pLogicalAndExpression = new LogicalAndExpressionElements();
		this.eLogicalAndOperator = new LogicalAndOperatorElements();
		this.pComparisonExpression = new ComparisonExpressionElements();
		this.pComparisonHigherOpExpression = new ComparisonHigherOpExpressionElements();
		this.eComparingEQNEQOperator = new ComparingEQNEQOperatorElements();
		this.eComparingRelOperator = new ComparingRelOperatorElements();
		this.pArithmeticExpression = new ArithmeticExpressionElements();
		this.pAdditionExpression = new AdditionExpressionElements();
		this.eAdditionOperator = new AdditionOperatorElements();
		this.pMultiplicationExpression = new MultiplicationExpressionElements();
		this.eMultiplicationOperator = new MultiplicationOperatorElements();
		this.pUnaryPreExpression = new UnaryPreExpressionElements();
		this.eUnaryPreOperator = new UnaryPreOperatorElements();
		this.pTypeCastExpression = new TypeCastExpressionElements();
		this.pOperand = new OperandElements();
		this.pLiteralExpression = new LiteralExpressionElements();
		this.pLiteral = new LiteralElements();
		this.pTimeValueExpression = new TimeValueExpressionElements();
		this.tMINORMAXKEYWORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.MINORMAXKEYWORD");
		this.pExtendedTypedNamedElementExpression = new ExtendedTypedNamedElementExpressionElements();
		this.pTypedNamedElementExpression = new TypedNamedElementExpressionElements();
		this.pArrayIndexExpression = new ArrayIndexExpressionElements();
		this.pAttributeAccessorExpression = new AttributeAccessorExpressionElements();
		this.pNoAttributeSelectorExpression = new NoAttributeSelectorExpressionElements();
		this.pPositionSelectorExpression = new PositionSelectorExpressionElements();
		this.ePositionSelectorKind = new PositionSelectorKindElements();
		this.pOperationCall = new OperationCallElements();
		this.pParamaterBinding = new ParamaterBindingElements();
		this.pTriggerMessageExpression = new TriggerMessageExpressionElements();
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.NUMBER");
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.BOOLEAN");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.pim.actionlanguage.xtext.ActionLanguage.ID");
		this.pDATATYPE = new DATATYPEElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.muml.pim.actionlanguage.xtext.ActionLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Entry expressions::Expression:
	//	Block | Expression | ArrayInitializeExpression
	public EntryElements getEntryAccess() {
		return pEntry;
	}
	
	public ParserRule getEntryRule() {
		return getEntryAccess().getRule();
	}

	//Block actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	//	{actionlanguage::Block}
	//	'{'
	//	expressions+=ExpressionStartRule* '}'
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// TODO: clarify if it makes sense to allow arbitrary expressions for
	//// the initializeExpression and countingExpression
	//ForLoop actionlanguage::ForLoop:
	//	'for' '(' initializeExpression=Assignment loopTest=Expression ';' countingExpression=ForLoopCountingExpression ')'
	//	block=Block
	public ForLoopElements getForLoopAccess() {
		return pForLoop;
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}

	//ForLoopCountingExpression actionlanguage::Assignment:
	//	lhs_typedNamedElementExpression=TypedNamedElementExpression
	//	(incrementDecrementOperator=UnaryPostIncrementDecrementOperator
	//	| assignOperator=AssignOperator rhs_assignExpression=Expression)
	public ForLoopCountingExpressionElements getForLoopCountingExpressionAccess() {
		return pForLoopCountingExpression;
	}
	
	public ParserRule getForLoopCountingExpressionRule() {
		return getForLoopCountingExpressionAccess().getRule();
	}

	//WhileLoop actionlanguage::WhileLoop:
	//	'while' '(' loopTest=Expression ')'
	//	block=Block
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//DoWhileLoop actionlanguage::DoWhileLoop:
	//	'do'
	//	block=Block
	//	'while' '(' loopTest=Expression ');'
	public DoWhileLoopElements getDoWhileLoopAccess() {
		return pDoWhileLoop;
	}
	
	public ParserRule getDoWhileLoopRule() {
		return getDoWhileLoopAccess().getRule();
	}

	//IfStatement actionlanguage::IfStatement:
	//	'if' '(' ifCondition=Expression ')'
	//	ifBlock=Block
	//	elseIfStatements+=ElseIfStatement* ('else' elseBlock=Block)?
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//ElseIfStatement actionlanguage::ElseIfStatement:
	//	'elseif' '(' elseIfCondition=Expression ')'
	//	elseIfBlock=Block
	public ElseIfStatementElements getElseIfStatementAccess() {
		return pElseIfStatement;
	}
	
	public ParserRule getElseIfStatementRule() {
		return getElseIfStatementAccess().getRule();
	}

	//ReturnStatement actionlanguage::ReturnStatement:
	//	{actionlanguage::ReturnStatement}
	//	'return' expression=Expression ';'
	public ReturnStatementElements getReturnStatementAccess() {
		return pReturnStatement;
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//OperationCallStatement actionlanguage::OperationCall:
	//	OperationCall ';'
	public OperationCallStatementElements getOperationCallStatementAccess() {
		return pOperationCallStatement;
	}
	
	public ParserRule getOperationCallStatementRule() {
		return getOperationCallStatementAccess().getRule();
	}

	//ExpressionStartRule expressions::Expression:
	//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement |
	//	LocalVariableOrConstantDeclarationStatement | OperationCallStatement
	public ExpressionStartRuleElements getExpressionStartRuleAccess() {
		return pExpressionStartRule;
	}
	
	public ParserRule getExpressionStartRuleRule() {
		return getExpressionStartRuleAccess().getRule();
	}

	//enum UnaryPostIncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
	//	INCREMENT='++' | DECREMENT='--';
	public UnaryPostIncrementDecrementOperatorElements getUnaryPostIncrementDecrementOperatorAccess() {
		return eUnaryPostIncrementDecrementOperator;
	}
	
	public EnumRule getUnaryPostIncrementDecrementOperatorRule() {
		return getUnaryPostIncrementDecrementOperatorAccess().getRule();
	}

	//// Assignment
	//Assignment actionlanguage::Assignment:
	//	lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
	//	rhs_assignExpression=InitializeExpression
	//	| incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ';'
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//enum IncrementDecrementOperatorExpression returns actionlanguage::IncrementDecrementOperator:
	//	INCREMENT='++' | DECREMENT='--';
	public IncrementDecrementOperatorExpressionElements getIncrementDecrementOperatorExpressionAccess() {
		return eIncrementDecrementOperatorExpression;
	}
	
	public EnumRule getIncrementDecrementOperatorExpressionRule() {
		return getIncrementDecrementOperatorExpressionAccess().getRule();
	}

	//enum AssignOperator returns actionlanguage::AssignOperator:
	//	ASSIGN=':=' | PLUS_EQUAL='+=' | MINUS_EQUAL='-=';
	public AssignOperatorElements getAssignOperatorAccess() {
		return eAssignOperator;
	}
	
	public EnumRule getAssignOperatorRule() {
		return getAssignOperatorAccess().getRule();
	}

	//// end of assignment
	//// initialize expression
	//InitializeExpression expressions::Expression:
	//	ArrayInitializeExpression | NondeterministicChoiceExpression | Expression
	public InitializeExpressionElements getInitializeExpressionAccess() {
		return pInitializeExpression;
	}
	
	public ParserRule getInitializeExpressionRule() {
		return getInitializeExpressionAccess().getRule();
	}

	//// end of initialize expression
	//// array initialization
	//ArrayInitializeExpression actionlanguage::ArrayInitializeExpression:
	//	'[' expressions+=InitializeExpression (',' expressions+=InitializeExpression)*
	//	']'
	public ArrayInitializeExpressionElements getArrayInitializeExpressionAccess() {
		return pArrayInitializeExpression;
	}
	
	public ParserRule getArrayInitializeExpressionRule() {
		return getArrayInitializeExpressionAccess().getRule();
	}

	//// end of array initialization
	//// local variable declaration
	//LocalVariableOrConstantDeclarationStatement actionlanguage::LocalVariableDeclarationStatement:
	//	variable=(LocalVariableDeclaration | LocalConstantDeclaration)
	public LocalVariableOrConstantDeclarationStatementElements getLocalVariableOrConstantDeclarationStatementAccess() {
		return pLocalVariableOrConstantDeclarationStatement;
	}
	
	public ParserRule getLocalVariableOrConstantDeclarationStatementRule() {
		return getLocalVariableOrConstantDeclarationStatementAccess().getRule();
	}

	//LocalVariableDeclaration behavior::Variable:
	//	dataType=[types::DataType|DATATYPE] name=ID (':=' initializeExpression=InitializeExpression)? ';'
	public LocalVariableDeclarationElements getLocalVariableDeclarationAccess() {
		return pLocalVariableDeclaration;
	}
	
	public ParserRule getLocalVariableDeclarationRule() {
		return getLocalVariableDeclarationAccess().getRule();
	}

	//LocalConstantDeclaration behavior::Variable:
	//	constant?='const' dataType=[types::DataType|DATATYPE] name=ID ':=' initializeExpression=InitializeExpression ';'
	public LocalConstantDeclarationElements getLocalConstantDeclarationAccess() {
		return pLocalConstantDeclaration;
	}
	
	public ParserRule getLocalConstantDeclarationRule() {
		return getLocalConstantDeclarationAccess().getRule();
	}

	//// end of local variable declaration
	//// nondeterministic choice expression
	//NondeterministicChoiceExpression actionlanguage::NondeterministicChoiceExpression:
	//	dataType=[types::PrimitiveDataType] range=Range
	public NondeterministicChoiceExpressionElements getNondeterministicChoiceExpressionAccess() {
		return pNondeterministicChoiceExpression;
	}
	
	public ParserRule getNondeterministicChoiceExpressionRule() {
		return getNondeterministicChoiceExpressionAccess().getRule();
	}

	//Range valuetype::Range:
	//	'<' lowerBound=LONG ',' upperBound=LONG '>'
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//LONG ecore::ELong:
	//	INT
	public LONGElements getLONGAccess() {
		return pLONG;
	}
	
	public ParserRule getLONGRule() {
		return getLONGAccess().getRule();
	}

	//// end of nondeterministic choice expression
	//Expression expressions::Expression:
	//	LogicalExpression
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// LogicalExpression
	//LogicalExpression expressions::Expression:
	//	LogicalOrExpression
	public LogicalExpressionElements getLogicalExpressionAccess() {
		return pLogicalExpression;
	}
	
	public ParserRule getLogicalExpressionRule() {
		return getLogicalExpressionAccess().getRule();
	}

	//LogicalOrExpression expressions::Expression:
	//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
	//	rightExpression=LogicalAndExpression)*
	public LogicalOrExpressionElements getLogicalOrExpressionAccess() {
		return pLogicalOrExpression;
	}
	
	public ParserRule getLogicalOrExpressionRule() {
		return getLogicalOrExpressionAccess().getRule();
	}

	//enum LogicalOrOperator returns commonExpressions::LogicOperator:
	//	OR='||';
	public LogicalOrOperatorElements getLogicalOrOperatorAccess() {
		return eLogicalOrOperator;
	}
	
	public EnumRule getLogicalOrOperatorRule() {
		return getLogicalOrOperatorAccess().getRule();
	}

	//LogicalAndExpression expressions::Expression:
	//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
	//	rightExpression=ComparisonExpression)*
	public LogicalAndExpressionElements getLogicalAndExpressionAccess() {
		return pLogicalAndExpression;
	}
	
	public ParserRule getLogicalAndExpressionRule() {
		return getLogicalAndExpressionAccess().getRule();
	}

	//enum LogicalAndOperator returns commonExpressions::LogicOperator:
	//	AND='&&';
	public LogicalAndOperatorElements getLogicalAndOperatorAccess() {
		return eLogicalAndOperator;
	}
	
	public EnumRule getLogicalAndOperatorRule() {
		return getLogicalAndOperatorAccess().getRule();
	}

	//// end of LogicalExpression
	//// ComparisonExpression
	//ComparisonExpression expressions::Expression:
	//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
	//	operator=ComparingEQNEQOperator
	//	rightExpression=ComparisonHigherOpExpression)?
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return pComparisonExpression;
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//ComparisonHigherOpExpression expressions::Expression:
	//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
	//	rightExpression=ArithmeticExpression)?
	public ComparisonHigherOpExpressionElements getComparisonHigherOpExpressionAccess() {
		return pComparisonHigherOpExpression;
	}
	
	public ParserRule getComparisonHigherOpExpressionRule() {
		return getComparisonHigherOpExpressionAccess().getRule();
	}

	//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
	//	EQUAL='==' | UNEQUAL='<>';
	public ComparingEQNEQOperatorElements getComparingEQNEQOperatorAccess() {
		return eComparingEQNEQOperator;
	}
	
	public EnumRule getComparingEQNEQOperatorRule() {
		return getComparingEQNEQOperatorAccess().getRule();
	}

	//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
	//	LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>';
	public ComparingRelOperatorElements getComparingRelOperatorAccess() {
		return eComparingRelOperator;
	}
	
	public EnumRule getComparingRelOperatorRule() {
		return getComparingRelOperatorAccess().getRule();
	}

	//// end of ComparisonExpression
	//// ArithmeticExpression	
	//ArithmeticExpression expressions::Expression:
	//	AdditionExpression
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return pArithmeticExpression;
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}

	//AdditionExpression expressions::Expression:
	//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
	//	rightExpression=MultiplicationExpression)*
	public AdditionExpressionElements getAdditionExpressionAccess() {
		return pAdditionExpression;
	}
	
	public ParserRule getAdditionExpressionRule() {
		return getAdditionExpressionAccess().getRule();
	}

	//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
	//	PLUS='+' | MINUS='-';
	public AdditionOperatorElements getAdditionOperatorAccess() {
		return eAdditionOperator;
	}
	
	public EnumRule getAdditionOperatorRule() {
		return getAdditionOperatorAccess().getRule();
	}

	//MultiplicationExpression expressions::Expression:
	//	UnaryPreExpression | TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
	//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | TypeCastExpression))*
	public MultiplicationExpressionElements getMultiplicationExpressionAccess() {
		return pMultiplicationExpression;
	}
	
	public ParserRule getMultiplicationExpressionRule() {
		return getMultiplicationExpressionAccess().getRule();
	}

	//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
	//	TIMES='*' | DIVIDE='/' | MODULO='%';
	public MultiplicationOperatorElements getMultiplicationOperatorAccess() {
		return eMultiplicationOperator;
	}
	
	public EnumRule getMultiplicationOperatorRule() {
		return getMultiplicationOperatorAccess().getRule();
	}

	//// end of ArithmeticExpression
	//// UnaryPreExpression
	//UnaryPreExpression expressions::Expression:
	//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=TypeCastExpression
	public UnaryPreExpressionElements getUnaryPreExpressionAccess() {
		return pUnaryPreExpression;
	}
	
	public ParserRule getUnaryPreExpressionRule() {
		return getUnaryPreExpressionAccess().getRule();
	}

	//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
	//	NOT='not' | MINUS='-';
	public UnaryPreOperatorElements getUnaryPreOperatorAccess() {
		return eUnaryPreOperator;
	}
	
	public EnumRule getUnaryPreOperatorRule() {
		return getUnaryPreOperatorAccess().getRule();
	}

	//// end of UnaryPreExpression
	//TypeCastExpression expressions::Expression:
	//	Operand | {actionlanguage::TypeCastExpression}
	//	'(' dataType=[types::DataType|DATATYPE] ')' enclosedExpression=Operand
	public TypeCastExpressionElements getTypeCastExpressionAccess() {
		return pTypeCastExpression;
	}
	
	public ParserRule getTypeCastExpressionRule() {
		return getTypeCastExpressionAccess().getRule();
	}

	//// Operand
	//Operand expressions::Expression:
	//	'(' Expression ')' | LiteralExpression | ExtendedTypedNamedElementExpression | TimeValueExpression
	//	| OperationCall | TriggerMessageExpression | NoAttributeSelectorExpression
	public OperandElements getOperandAccess() {
		return pOperand;
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}

	//// end of Operand
	//LiteralExpression commonExpressions::LiteralExpression:
	//	{commonExpressions::LiteralExpression} value=Literal
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//Literal:
	//	NUMBER | BOOLEAN | INT | 'null';
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//TimeValueExpression actionlanguage::TimeValueExpression:
	//	timeValue=[valuetype::TimeValue|MINORMAXKEYWORD]
	public TimeValueExpressionElements getTimeValueExpressionAccess() {
		return pTimeValueExpression;
	}
	
	public ParserRule getTimeValueExpressionRule() {
		return getTimeValueExpressionAccess().getRule();
	}

	//terminal MINORMAXKEYWORD:
	//	'maxMsgDelay';
	public TerminalRule getMINORMAXKEYWORDRule() {
		return tMINORMAXKEYWORD;
	} 

	//ExtendedTypedNamedElementExpression expressions::Expression:
	//	TypedNamedElementExpression
	//	({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
	//	'->' position=PositionSelectorExpression
	//	| {actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
	//	incrementDecrementOperator=IncrementDecrementOperatorExpression)?
	public ExtendedTypedNamedElementExpressionElements getExtendedTypedNamedElementExpressionAccess() {
		return pExtendedTypedNamedElementExpression;
	}
	
	public ParserRule getExtendedTypedNamedElementExpressionRule() {
		return getExtendedTypedNamedElementExpressionAccess().getRule();
	}

	//TypedNamedElementExpression actionlanguage::TypedNamedElementExpression:
	//	typedNamedElement=[behavior::TypedNamedElement] elementAccessors+=(ArrayIndexExpression |
	//	AttributeAccessorExpression)*
	public TypedNamedElementExpressionElements getTypedNamedElementExpressionAccess() {
		return pTypedNamedElementExpression;
	}
	
	public ParserRule getTypedNamedElementExpressionRule() {
		return getTypedNamedElementExpressionAccess().getRule();
	}

	//ArrayIndexExpression actionlanguage::ArrayIndexExpression:
	//	'[' index=ArithmeticExpression ']'
	public ArrayIndexExpressionElements getArrayIndexExpressionAccess() {
		return pArrayIndexExpression;
	}
	
	public ParserRule getArrayIndexExpressionRule() {
		return getArrayIndexExpressionAccess().getRule();
	}

	//AttributeAccessorExpression actionlanguage::AttributeAccessorExpression:
	//	'.' attribute=[types::Attribute]
	public AttributeAccessorExpressionElements getAttributeAccessorExpressionAccess() {
		return pAttributeAccessorExpression;
	}
	
	public ParserRule getAttributeAccessorExpressionRule() {
		return getAttributeAccessorExpressionAccess().getRule();
	}

	//NoAttributeSelectorExpression actionlanguage::DiscreteInteractionEndpointReference:
	//	position=PositionSelectorExpression
	public NoAttributeSelectorExpressionElements getNoAttributeSelectorExpressionAccess() {
		return pNoAttributeSelectorExpression;
	}
	
	public ParserRule getNoAttributeSelectorExpressionRule() {
		return getNoAttributeSelectorExpressionAccess().getRule();
	}

	//PositionSelectorExpression actionlanguage::PositionSelector:
	//	kind=PositionSelectorKind ('->' successor=PositionSelectorExpression)?
	public PositionSelectorExpressionElements getPositionSelectorExpressionAccess() {
		return pPositionSelectorExpression;
	}
	
	public ParserRule getPositionSelectorExpressionRule() {
		return getPositionSelectorExpressionAccess().getRule();
	}

	//enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
	//	SELF='self' | FIRST='first' | LAST='last' | PREV='prev' | NEXT='next';
	public PositionSelectorKindElements getPositionSelectorKindAccess() {
		return ePositionSelectorKind;
	}
	
	public EnumRule getPositionSelectorKindRule() {
		return getPositionSelectorKindAccess().getRule();
	}

	//OperationCall actionlanguage::OperationCall:
	//	operation=[behavior::Operation] '(' (parameterBinding+=ParamaterBinding (',' parameterBinding+=ParamaterBinding)*)?
	//	')'
	public OperationCallElements getOperationCallAccess() {
		return pOperationCall;
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}

	//ParamaterBinding behavior::ParameterBinding:
	//	{behavior::ParameterBinding} parameter=[behavior::Parameter] ':=' value=Expression
	public ParamaterBindingElements getParamaterBindingAccess() {
		return pParamaterBinding;
	}
	
	public ParserRule getParamaterBindingRule() {
		return getParamaterBindingAccess().getRule();
	}

	//// TriggerMessageExpression
	//TriggerMessageExpression actionlanguage::TriggerMessageExpression:
	//	messageType=[msgtype::MessageType] '->' parameter=[behavior::Parameter]
	public TriggerMessageExpressionElements getTriggerMessageExpressionAccess() {
		return pTriggerMessageExpression;
	}
	
	public ParserRule getTriggerMessageExpressionRule() {
		return getTriggerMessageExpressionAccess().getRule();
	}

	//terminal NUMBER returns ecore::EBigDecimal:
	//	INT '.' INT;
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	} 

	//terminal BOOLEAN returns ecore::EBoolean:
	//	'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	} 

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//DATATYPE:
	//	ID ('[' INT ']')*;
	public DATATYPEElements getDATATYPEAccess() {
		return pDATATYPE;
	}
	
	public ParserRule getDATATYPERule() {
		return getDATATYPEAccess().getRule();
	}

	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
