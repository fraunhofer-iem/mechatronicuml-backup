/*
 * generated by Xtext
 */
package org.muml.storydiagram.expressions.common.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ExpressionsGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class LExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.LExpression");
		private final RuleCall cEquivalentParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Boolean Logic Layer    ------------------------------------------------
		//LExpression:
		//	Equivalent;
		@Override public ParserRule getRule() { return rule; }

		//Equivalent
		public RuleCall getEquivalentParserRuleCall() { return cEquivalentParserRuleCall; }
	}

	public class EquivalentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Equivalent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEquivalentLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEquivKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEquivalentParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equivalent LExpression:
		//	Implication ({Equivalent.left=current} 'equiv' right=Equivalent)?
		@Override public ParserRule getRule() { return rule; }

		//Implication ({Equivalent.left=current} 'equiv' right=Equivalent)?
		public Group getGroup() { return cGroup; }

		//Implication
		public RuleCall getImplicationParserRuleCall_0() { return cImplicationParserRuleCall_0; }

		//({Equivalent.left=current} 'equiv' right=Equivalent)?
		public Group getGroup_1() { return cGroup_1; }

		//{Equivalent.left=current}
		public Action getEquivalentLeftAction_1_0() { return cEquivalentLeftAction_1_0; }

		//'equiv'
		public Keyword getEquivKeyword_1_1() { return cEquivKeyword_1_1; }

		//right=Equivalent
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Equivalent
		public RuleCall getRightEquivalentParserRuleCall_1_2_0() { return cRightEquivalentParserRuleCall_1_2_0; }
	}

	public class ImplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Implication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDisjunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplyLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImplyKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightImplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Implication LExpression:
		//	Disjunction ({Imply.left=current} 'imply' right=Implication)?
		@Override public ParserRule getRule() { return rule; }

		//Disjunction ({Imply.left=current} 'imply' right=Implication)?
		public Group getGroup() { return cGroup; }

		//Disjunction
		public RuleCall getDisjunctionParserRuleCall_0() { return cDisjunctionParserRuleCall_0; }

		//({Imply.left=current} 'imply' right=Implication)?
		public Group getGroup_1() { return cGroup_1; }

		//{Imply.left=current}
		public Action getImplyLeftAction_1_0() { return cImplyLeftAction_1_0; }

		//'imply'
		public Keyword getImplyKeyword_1_1() { return cImplyKeyword_1_1; }

		//right=Implication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Implication
		public RuleCall getRightImplicationParserRuleCall_1_2_0() { return cRightImplicationParserRuleCall_1_2_0; }
	}

	public class DisjunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Disjunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cOrLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cOrKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cXorLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cXorKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightDisjunctionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Disjunction LExpression:
		//	Conjunction (({Or.left=current} 'or' | {Xor.left=current} 'xor') right=Disjunction)?
		@Override public ParserRule getRule() { return rule; }

		//Conjunction (({Or.left=current} 'or' | {Xor.left=current} 'xor') right=Disjunction)?
		public Group getGroup() { return cGroup; }

		//Conjunction
		public RuleCall getConjunctionParserRuleCall_0() { return cConjunctionParserRuleCall_0; }

		//(({Or.left=current} 'or' | {Xor.left=current} 'xor') right=Disjunction)?
		public Group getGroup_1() { return cGroup_1; }

		//({Or.left=current} 'or' | {Xor.left=current} 'xor')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Or.left=current} 'or'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Or.left=current}
		public Action getOrLeftAction_1_0_0_0() { return cOrLeftAction_1_0_0_0; }

		//'or'
		public Keyword getOrKeyword_1_0_0_1() { return cOrKeyword_1_0_0_1; }

		//{Xor.left=current} 'xor'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Xor.left=current}
		public Action getXorLeftAction_1_0_1_0() { return cXorLeftAction_1_0_1_0; }

		//'xor'
		public Keyword getXorKeyword_1_0_1_1() { return cXorKeyword_1_0_1_1; }

		//right=Disjunction
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Disjunction
		public RuleCall getRightDisjunctionParserRuleCall_1_1_0() { return cRightDisjunctionParserRuleCall_1_1_0; }
	}

	public class ConjunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Conjunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightConjunctionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Conjunction LExpression:
		//	Negation ({And.left=current} 'and' right=Conjunction)?
		@Override public ParserRule getRule() { return rule; }

		//Negation ({And.left=current} 'and' right=Conjunction)?
		public Group getGroup() { return cGroup; }

		//Negation
		public RuleCall getNegationParserRuleCall_0() { return cNegationParserRuleCall_0; }

		//({And.left=current} 'and' right=Conjunction)?
		public Group getGroup_1() { return cGroup_1; }

		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }

		//'and'
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//right=Conjunction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Conjunction
		public RuleCall getRightConjunctionParserRuleCall_1_2_0() { return cRightConjunctionParserRuleCall_1_2_0; }
	}

	public class NegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Negation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cNegatedParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cCExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Negation LExpression:
		//	'not' Negated
		//	| CExpression
		@Override public ParserRule getRule() { return rule; }

		//'not' Negated | CExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//'not' Negated
		public Group getGroup_0() { return cGroup_0; }

		//'not'
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//Negated
		public RuleCall getNegatedParserRuleCall_0_1() { return cNegatedParserRuleCall_0_1; }

		//CExpression
		public RuleCall getCExpressionParserRuleCall_1() { return cCExpressionParserRuleCall_1; }
	}

	public class NegatedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Negated");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotCExpressionParserRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		
		//Negated LExpression:
		//	{Not} not=CExpression
		@Override public ParserRule getRule() { return rule; }

		//{Not} not=CExpression
		public Group getGroup() { return cGroup; }

		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }

		//not=CExpression
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }

		//CExpression
		public RuleCall getNotCExpressionParserRuleCall_1_0() { return cNotCExpressionParserRuleCall_1_0; }
	}

	public class CExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.CExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cCompareParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVariableParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Compare Layer   ------------------------------------------------
		//CExpression LExpression:
		//	'(' LExpression ')' | Compare
		//	| BooleanValue
		//	| Variable
		@Override public ParserRule getRule() { return rule; }

		//'(' LExpression ')' | Compare | BooleanValue | Variable
		public Alternatives getAlternatives() { return cAlternatives; }

		//'(' LExpression ')'
		public Group getGroup_0() { return cGroup_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//LExpression
		public RuleCall getLExpressionParserRuleCall_0_1() { return cLExpressionParserRuleCall_0_1; }

		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//Compare
		public RuleCall getCompareParserRuleCall_1() { return cCompareParserRuleCall_1; }

		//BooleanValue
		public RuleCall getBooleanValueParserRuleCall_2() { return cBooleanValueParserRuleCall_2; }

		//Variable
		public RuleCall getVariableParserRuleCall_3() { return cVariableParserRuleCall_3; }
	}

	public class CompareElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Compare");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSomeValueParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cLessOrEqualLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cLessLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cGreaterOrEqualLeftAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final Action cGreaterLeftAction_1_3_0 = (Action)cGroup_1_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_3_1 = (Keyword)cGroup_1_3.eContents().get(1);
		private final Group cGroup_1_4 = (Group)cAlternatives_1.eContents().get(4);
		private final Action cEqualLeftAction_1_4_0 = (Action)cGroup_1_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_4_1 = (Keyword)cGroup_1_4.eContents().get(1);
		private final Group cGroup_1_5 = (Group)cAlternatives_1.eContents().get(5);
		private final Action cUnequalLeftAction_1_5_0 = (Action)cGroup_1_5.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_5_1 = (Keyword)cGroup_1_5.eContents().get(1);
		private final Group cGroup_1_6 = (Group)cAlternatives_1.eContents().get(6);
		private final Action cApproxLeftAction_1_6_0 = (Action)cGroup_1_6.eContents().get(0);
		private final Keyword cTildeKeyword_1_6_1 = (Keyword)cGroup_1_6.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightSomeValueParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//Compare CExpression:
		//	SomeValue ({LessOrEqual.left=current} '<='
		//	| {Less.left=current} '<'
		//	| {GreaterOrEqual.left=current} '>='
		//	| {Greater.left=current} '>'
		//	| {Equal.left=current} '='
		//	| {Unequal.left=current} '!='
		//	| {Approx.left=current} '~') right=SomeValue
		@Override public ParserRule getRule() { return rule; }

		//SomeValue ({LessOrEqual.left=current} '<=' | {Less.left=current} '<' | {GreaterOrEqual.left=current} '>=' |
		//{Greater.left=current} '>' | {Equal.left=current} '=' | {Unequal.left=current} '!=' | {Approx.left=current} '~')
		//right=SomeValue
		public Group getGroup() { return cGroup; }

		//SomeValue
		public RuleCall getSomeValueParserRuleCall_0() { return cSomeValueParserRuleCall_0; }

		//({LessOrEqual.left=current} '<=' | {Less.left=current} '<' | {GreaterOrEqual.left=current} '>=' | {Greater.left=current}
		//'>' | {Equal.left=current} '=' | {Unequal.left=current} '!=' | {Approx.left=current} '~')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{LessOrEqual.left=current} '<='
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{LessOrEqual.left=current}
		public Action getLessOrEqualLeftAction_1_0_0() { return cLessOrEqualLeftAction_1_0_0; }

		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_1_0_1() { return cLessThanSignEqualsSignKeyword_1_0_1; }

		//{Less.left=current} '<'
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{Less.left=current}
		public Action getLessLeftAction_1_1_0() { return cLessLeftAction_1_1_0; }

		//'<'
		public Keyword getLessThanSignKeyword_1_1_1() { return cLessThanSignKeyword_1_1_1; }

		//{GreaterOrEqual.left=current} '>='
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{GreaterOrEqual.left=current}
		public Action getGreaterOrEqualLeftAction_1_2_0() { return cGreaterOrEqualLeftAction_1_2_0; }

		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_1_2_1() { return cGreaterThanSignEqualsSignKeyword_1_2_1; }

		//{Greater.left=current} '>'
		public Group getGroup_1_3() { return cGroup_1_3; }

		//{Greater.left=current}
		public Action getGreaterLeftAction_1_3_0() { return cGreaterLeftAction_1_3_0; }

		//'>'
		public Keyword getGreaterThanSignKeyword_1_3_1() { return cGreaterThanSignKeyword_1_3_1; }

		//{Equal.left=current} '='
		public Group getGroup_1_4() { return cGroup_1_4; }

		//{Equal.left=current}
		public Action getEqualLeftAction_1_4_0() { return cEqualLeftAction_1_4_0; }

		//'='
		public Keyword getEqualsSignKeyword_1_4_1() { return cEqualsSignKeyword_1_4_1; }

		//{Unequal.left=current} '!='
		public Group getGroup_1_5() { return cGroup_1_5; }

		//{Unequal.left=current}
		public Action getUnequalLeftAction_1_5_0() { return cUnequalLeftAction_1_5_0; }

		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword_1_5_1() { return cExclamationMarkEqualsSignKeyword_1_5_1; }

		//{Approx.left=current} '~'
		public Group getGroup_1_6() { return cGroup_1_6; }

		//{Approx.left=current}
		public Action getApproxLeftAction_1_6_0() { return cApproxLeftAction_1_6_0; }

		//'~'
		public Keyword getTildeKeyword_1_6_1() { return cTildeKeyword_1_6_1; }

		//right=SomeValue
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//SomeValue
		public RuleCall getRightSomeValueParserRuleCall_2_0() { return cRightSomeValueParserRuleCall_2_0; }
	}

	public class SomeValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.SomeValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//SomeValue:
		//	StringValue
		//	| BooleanValue
		//	| AExpression;
		@Override public ParserRule getRule() { return rule; }

		//StringValue | BooleanValue | AExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//StringValue
		public RuleCall getStringValueParserRuleCall_0() { return cStringValueParserRuleCall_0; }

		//BooleanValue
		public RuleCall getBooleanValueParserRuleCall_1() { return cBooleanValueParserRuleCall_1; }

		//AExpression
		public RuleCall getAExpressionParserRuleCall_2() { return cAExpressionParserRuleCall_2; }
	}

	public class AExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.AExpression");
		private final RuleCall cAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Arithmetic Layer   ------------------------------------------------
		//AExpression:
		//	Addition;
		@Override public ParserRule getRule() { return rule; }

		//Addition
		public RuleCall getAdditionParserRuleCall() { return cAdditionParserRuleCall; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Addition AExpression:
		//	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*
		@Override public ParserRule getRule() { return rule; }

		//Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//(({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//({Plus.left=current} '+' | {Minus.left=current} '-')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Plus.left=current} '+'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Plus.left=current}
		public Action getPlusLeftAction_1_0_0_0() { return cPlusLeftAction_1_0_0_0; }

		//'+'
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }

		//{Minus.left=current} '-'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }

		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_1_0() { return cRightMultiplicationParserRuleCall_1_1_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultiLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cModLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cPercentSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPowerParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Multiplication AExpression:
		//	Power (({Multi.left=current} '*' | {Div.left=current} '/' | {Mod.left=current} '%') right=Power)*
		@Override public ParserRule getRule() { return rule; }

		//Power (({Multi.left=current} '*' | {Div.left=current} '/' | {Mod.left=current} '%') right=Power)*
		public Group getGroup() { return cGroup; }

		//Power
		public RuleCall getPowerParserRuleCall_0() { return cPowerParserRuleCall_0; }

		//(({Multi.left=current} '*' | {Div.left=current} '/' | {Mod.left=current} '%') right=Power)*
		public Group getGroup_1() { return cGroup_1; }

		//({Multi.left=current} '*' | {Div.left=current} '/' | {Mod.left=current} '%')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Multi.left=current} '*'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Multi.left=current}
		public Action getMultiLeftAction_1_0_0_0() { return cMultiLeftAction_1_0_0_0; }

		//'*'
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }

		//{Div.left=current} '/'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Div.left=current}
		public Action getDivLeftAction_1_0_1_0() { return cDivLeftAction_1_0_1_0; }

		//'/'
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }

		//{Mod.left=current} '%'
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Mod.left=current}
		public Action getModLeftAction_1_0_2_0() { return cModLeftAction_1_0_2_0; }

		//'%'
		public Keyword getPercentSignKeyword_1_0_2_1() { return cPercentSignKeyword_1_0_2_1; }

		//right=Power
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Power
		public RuleCall getRightPowerParserRuleCall_1_1_0() { return cRightPowerParserRuleCall_1_1_0; }
	}

	public class PowerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Power");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cPowLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Power AExpression:
		//	PrimaryExpression (({Pow.left=current} '^') right=PrimaryExpression)*
		@Override public ParserRule getRule() { return rule; }

		//PrimaryExpression (({Pow.left=current} '^') right=PrimaryExpression)*
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//(({Pow.left=current} '^') right=PrimaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//({Pow.left=current} '^')
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Pow.left=current}
		public Action getPowLeftAction_1_0_0() { return cPowLeftAction_1_0_0; }

		//'^'
		public Keyword getCircumflexAccentKeyword_1_0_1() { return cCircumflexAccentKeyword_1_0_1; }

		//right=PrimaryExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_1_1_0() { return cRightPrimaryExpressionParserRuleCall_1_1_0; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cAExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cNumberValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PrimaryExpression AExpression:
		//	'(' AExpression ')' | NumberValue
		//	| Variable
		@Override public ParserRule getRule() { return rule; }

		//'(' AExpression ')' | NumberValue | Variable
		public Alternatives getAlternatives() { return cAlternatives; }

		//'(' AExpression ')'
		public Group getGroup_0() { return cGroup_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//AExpression
		public RuleCall getAExpressionParserRuleCall_0_1() { return cAExpressionParserRuleCall_0_1; }

		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//NumberValue
		public RuleCall getNumberValueParserRuleCall_1() { return cNumberValueParserRuleCall_1; }

		//Variable
		public RuleCall getVariableParserRuleCall_2() { return cVariableParserRuleCall_2; }
	}

	public class NumberValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.NumberValue");
		private final Assignment cNumValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNumValueNUMBERParserRuleCall_0 = (RuleCall)cNumValueAssignment.eContents().get(0);
		
		//NumberValue:
		//	numValue=NUMBER;
		@Override public ParserRule getRule() { return rule; }

		//numValue=NUMBER
		public Assignment getNumValueAssignment() { return cNumValueAssignment; }

		//NUMBER
		public RuleCall getNumValueNUMBERParserRuleCall_0() { return cNumValueNUMBERParserRuleCall_0; }
	}

	public class NUMBERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.NUMBER");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//NUMBER EBigDecimal:
		//	INT ('.' INT)?
		@Override public ParserRule getRule() { return rule; }

		//INT ('.' INT)?
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//('.' INT)?
		public Group getGroup_1() { return cGroup_1; }

		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}

	public class BooleanValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.BooleanValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanValue:
		//	value=BOOLEAN;
		@Override public ParserRule getRule() { return rule; }

		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_0() { return cValueBOOLEANTerminalRuleCall_0; }
	}

	public class StringValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.StringValue");
		private final Assignment cStrValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStrValueSTRINGTerminalRuleCall_0 = (RuleCall)cStrValueAssignment.eContents().get(0);
		
		//StringValue:
		//	strValue=STRING;
		@Override public ParserRule getRule() { return rule; }

		//strValue=STRING
		public Assignment getStrValueAssignment() { return cStrValueAssignment; }

		//STRING
		public RuleCall getStrValueSTRINGTerminalRuleCall_0() { return cStrValueSTRINGTerminalRuleCall_0; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.Variable");
		private final Assignment cVarNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVarNameVARIABLE_VALUEParserRuleCall_0 = (RuleCall)cVarNameAssignment.eContents().get(0);
		
		//Variable:
		//	varName=VARIABLE_VALUE;
		@Override public ParserRule getRule() { return rule; }

		//varName=VARIABLE_VALUE
		public Assignment getVarNameAssignment() { return cVarNameAssignment; }

		//VARIABLE_VALUE
		public RuleCall getVarNameVARIABLE_VALUEParserRuleCall_0() { return cVarNameVARIABLE_VALUEParserRuleCall_0; }
	}

	public class VARIABLE_VALUEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.VARIABLE_VALUE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//VARIABLE_VALUE:
		//	ID
		//	| ID '.' ID;
		@Override public ParserRule getRule() { return rule; }

		//ID | ID '.' ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//ID '.' ID
		public Group getGroup_1() { return cGroup_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_0() { return cIDTerminalRuleCall_1_0; }

		//'.'
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_2() { return cIDTerminalRuleCall_1_2; }
	}
	
	
	private final LExpressionElements pLExpression;
	private final EquivalentElements pEquivalent;
	private final ImplicationElements pImplication;
	private final DisjunctionElements pDisjunction;
	private final ConjunctionElements pConjunction;
	private final NegationElements pNegation;
	private final NegatedElements pNegated;
	private final CExpressionElements pCExpression;
	private final CompareElements pCompare;
	private final SomeValueElements pSomeValue;
	private final AExpressionElements pAExpression;
	private final AdditionElements pAddition;
	private final MultiplicationElements pMultiplication;
	private final PowerElements pPower;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final NumberValueElements pNumberValue;
	private final NUMBERElements pNUMBER;
	private final BooleanValueElements pBooleanValue;
	private final TerminalRule tBOOLEAN;
	private final StringValueElements pStringValue;
	private final VariableElements pVariable;
	private final VARIABLE_VALUEElements pVARIABLE_VALUE;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public ExpressionsGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pLExpression = new LExpressionElements();
		this.pEquivalent = new EquivalentElements();
		this.pImplication = new ImplicationElements();
		this.pDisjunction = new DisjunctionElements();
		this.pConjunction = new ConjunctionElements();
		this.pNegation = new NegationElements();
		this.pNegated = new NegatedElements();
		this.pCExpression = new CExpressionElements();
		this.pCompare = new CompareElements();
		this.pSomeValue = new SomeValueElements();
		this.pAExpression = new AExpressionElements();
		this.pAddition = new AdditionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pPower = new PowerElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pNumberValue = new NumberValueElements();
		this.pNUMBER = new NUMBERElements();
		this.pBooleanValue = new BooleanValueElements();
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.muml.storydiagram.expressions.common.Expressions.BOOLEAN");
		this.pStringValue = new StringValueElements();
		this.pVariable = new VariableElements();
		this.pVARIABLE_VALUE = new VARIABLE_VALUEElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.muml.storydiagram.expressions.common.Expressions".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// Boolean Logic Layer    ------------------------------------------------
	//LExpression:
	//	Equivalent;
	public LExpressionElements getLExpressionAccess() {
		return pLExpression;
	}
	
	public ParserRule getLExpressionRule() {
		return getLExpressionAccess().getRule();
	}

	//Equivalent LExpression:
	//	Implication ({Equivalent.left=current} 'equiv' right=Equivalent)?
	public EquivalentElements getEquivalentAccess() {
		return pEquivalent;
	}
	
	public ParserRule getEquivalentRule() {
		return getEquivalentAccess().getRule();
	}

	//Implication LExpression:
	//	Disjunction ({Imply.left=current} 'imply' right=Implication)?
	public ImplicationElements getImplicationAccess() {
		return pImplication;
	}
	
	public ParserRule getImplicationRule() {
		return getImplicationAccess().getRule();
	}

	//Disjunction LExpression:
	//	Conjunction (({Or.left=current} 'or' | {Xor.left=current} 'xor') right=Disjunction)?
	public DisjunctionElements getDisjunctionAccess() {
		return pDisjunction;
	}
	
	public ParserRule getDisjunctionRule() {
		return getDisjunctionAccess().getRule();
	}

	//Conjunction LExpression:
	//	Negation ({And.left=current} 'and' right=Conjunction)?
	public ConjunctionElements getConjunctionAccess() {
		return pConjunction;
	}
	
	public ParserRule getConjunctionRule() {
		return getConjunctionAccess().getRule();
	}

	//Negation LExpression:
	//	'not' Negated
	//	| CExpression
	public NegationElements getNegationAccess() {
		return pNegation;
	}
	
	public ParserRule getNegationRule() {
		return getNegationAccess().getRule();
	}

	//Negated LExpression:
	//	{Not} not=CExpression
	public NegatedElements getNegatedAccess() {
		return pNegated;
	}
	
	public ParserRule getNegatedRule() {
		return getNegatedAccess().getRule();
	}

	//// Compare Layer   ------------------------------------------------
	//CExpression LExpression:
	//	'(' LExpression ')' | Compare
	//	| BooleanValue
	//	| Variable
	public CExpressionElements getCExpressionAccess() {
		return pCExpression;
	}
	
	public ParserRule getCExpressionRule() {
		return getCExpressionAccess().getRule();
	}

	//Compare CExpression:
	//	SomeValue ({LessOrEqual.left=current} '<='
	//	| {Less.left=current} '<'
	//	| {GreaterOrEqual.left=current} '>='
	//	| {Greater.left=current} '>'
	//	| {Equal.left=current} '='
	//	| {Unequal.left=current} '!='
	//	| {Approx.left=current} '~') right=SomeValue
	public CompareElements getCompareAccess() {
		return pCompare;
	}
	
	public ParserRule getCompareRule() {
		return getCompareAccess().getRule();
	}

	//SomeValue:
	//	StringValue
	//	| BooleanValue
	//	| AExpression;
	public SomeValueElements getSomeValueAccess() {
		return pSomeValue;
	}
	
	public ParserRule getSomeValueRule() {
		return getSomeValueAccess().getRule();
	}

	//// Arithmetic Layer   ------------------------------------------------
	//AExpression:
	//	Addition;
	public AExpressionElements getAExpressionAccess() {
		return pAExpression;
	}
	
	public ParserRule getAExpressionRule() {
		return getAExpressionAccess().getRule();
	}

	//Addition AExpression:
	//	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication AExpression:
	//	Power (({Multi.left=current} '*' | {Div.left=current} '/' | {Mod.left=current} '%') right=Power)*
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//Power AExpression:
	//	PrimaryExpression (({Pow.left=current} '^') right=PrimaryExpression)*
	public PowerElements getPowerAccess() {
		return pPower;
	}
	
	public ParserRule getPowerRule() {
		return getPowerAccess().getRule();
	}

	//PrimaryExpression AExpression:
	//	'(' AExpression ')' | NumberValue
	//	| Variable
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//NumberValue:
	//	numValue=NUMBER;
	public NumberValueElements getNumberValueAccess() {
		return pNumberValue;
	}
	
	public ParserRule getNumberValueRule() {
		return getNumberValueAccess().getRule();
	}

	//NUMBER EBigDecimal:
	//	INT ('.' INT)?
	public NUMBERElements getNUMBERAccess() {
		return pNUMBER;
	}
	
	public ParserRule getNUMBERRule() {
		return getNUMBERAccess().getRule();
	}

	//BooleanValue:
	//	value=BOOLEAN;
	public BooleanValueElements getBooleanValueAccess() {
		return pBooleanValue;
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//terminal BOOLEAN returns EBoolean:
	//	'true'
	//	| 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	} 

	//StringValue:
	//	strValue=STRING;
	public StringValueElements getStringValueAccess() {
		return pStringValue;
	}
	
	public ParserRule getStringValueRule() {
		return getStringValueAccess().getRule();
	}

	//Variable:
	//	varName=VARIABLE_VALUE;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//VARIABLE_VALUE:
	//	ID
	//	| ID '.' ID;
	public VARIABLE_VALUEElements getVARIABLE_VALUEAccess() {
		return pVARIABLE_VALUE;
	}
	
	public ParserRule getVARIABLE_VALUERule() {
		return getVARIABLE_VALUEAccess().getRule();
	}

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
