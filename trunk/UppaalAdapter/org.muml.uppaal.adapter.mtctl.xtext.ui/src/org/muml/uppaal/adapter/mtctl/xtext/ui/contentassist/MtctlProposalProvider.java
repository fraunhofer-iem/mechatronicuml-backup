/*
 * generated by Xtext
 */
package org.muml.uppaal.adapter.mtctl.xtext.ui.contentassist;

import java.util.Arrays;
import java.util.HashSet;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.xtext.AbstractElement;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.muml.uppaal.adapter.mtctl.MtctlFactory;
import org.muml.uppaal.adapter.mtctl.predicates.PredicatesFactory;
import org.muml.uppaal.adapter.mtctl.predicates.PredicatesPackage;
import org.muml.uppaal.adapter.mtctl.quantifiers.TemporalQuantifierExpr;
import org.muml.uppaal.adapter.mtctl.xtext.services.MtctlGrammarAccess;

import com.google.common.base.Function;
import com.google.inject.Inject;

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
public class MtctlProposalProvider extends org.muml.uppaal.adapter.mtctl.xtext.ui.contentassist.AbstractMtctlProposalProvider {
	@Inject
	MtctlGrammarAccess grammarAccess;
	
	public static final String[] keywordExclude = new String[] {">","<",">=","<=","==","!=","(",")","A[]","A<>","E<>","E[]"}; // list of keywords to exclude from auto-complete
	public static final HashSet<String> hashKeywordExclude = new HashSet<String>(Arrays.asList(keywordExclude));
	public static final HashSet<String> temporalQuantifiers = new HashSet<String>(Arrays.asList(new String[] {"AG", "AF", "EG", "EF"}));
	
	@Override
	public void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {

		if (hashKeywordExclude.contains(keyword.getValue()) || MtctlTemplateProposalProvider.templateNames.contains(keyword.getValue()) || keyword.getValue().length() == 1)
			return; // suppress <ignored keyword>, <keywords overruled by templates>, and <one char keywords>
		
		//suppress nested temporal quantifiers suggestions
		EObject context = contentAssistContext.getCurrentModel();
		if (temporalQuantifiers.contains((keyword.getValue()))) {
			while (context != null) {
				if (context instanceof TemporalQuantifierExpr)
					return;
				context = context.eContainer();
			}
		}

		super.completeKeyword(keyword, contentAssistContext, acceptor);
	}
	
	/**
	 * Calls getScope(modelContext, reference) and adds the returned elements to the proposals. 
	 */
	protected void completeAssignmentUsingScope(EObject modelContext, EReference reference, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		Function<IEObjectDescription, ICompletionProposal> factory = new DefaultProposalCreator(context, null, getQualifiedNameConverter());
		IScope scope = getScopeProvider().getScope(modelContext, reference);
		for (IEObjectDescription e : scope.getAllElements())
			acceptor.accept(factory.apply(e));
	}
	
	/*
	 * We override this method to correct the issue that the default proposal provider is not very smart at calling the ScopeProvider
	 * In particular, it calls getScope(context, reference) with references that do not exist in the supplied context:
	 * !context.eClass.getEAllReferences().contains(reference).
	 * That behavior makes it difficult to find the correct scope (most prominently, getScope(messageInBufferExpr, MumlElemExpr.elem) cannot
	 * distinguish whether the message (1st argument) or the buffer (2nd argument) is searched for, because both calls are the same.
	 * This implementation fixes that, then lets the default provider do its thing.
	 * 
	 * The context given by the caller is not the context that we are actually interested in, but potentially a higher-level element.
	 */
	@Override
	public void completeAssignment(Assignment assignment, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {
		if ("elem".equals(assignment.getFeature())) //ignore extraneous calls for MumlElemExpr.elem
			return;
		
		EObject currentModel = contentAssistContext.getCurrentModel();
		if (currentModel == null) //normalize empty models
			currentModel = MtctlFactory.eINSTANCE.createPropertyRepository();
		
		EObject elementWithRef = findFirstElementWithReference(currentModel, assignment.getFeature());
		if (elementWithRef != null) {	
			for (EReference reference : elementWithRef.eClass().getEAllReferences()) //find fitting EReference 
				if (reference.getName().equals(assignment.getFeature())) 
					completeAssignmentUsingScope(elementWithRef, reference, contentAssistContext, acceptor); //add appropriate items from scoping
		}
		
		super.completeAssignment(assignment, contentAssistContext, acceptor);
	}
	
	/**
	 * Searches the subtree rooted in model for the first element that possesses a reference with name referenceName
	 */
	private EObject findFirstElementWithReference(EObject model, String referenceName) {
		if (model == null)
			return null;
		
		//Check if model contains the reference
		for (EReference ref : model.eClass().getEAllReferences())
			if (ref.getName().equals(referenceName))
				return model;
		
		//Otherwise, check children of this model element
		for (EReference ref : model.eClass().getEAllReferences())
			if (ref.isContainment() && model.eGet(ref) instanceof EObject)
				return findFirstElementWithReference((EObject) model.eGet(ref), referenceName);
		
		return null;
	}

	
	/*
	 * Overriding to supply helpful proposals wherever comparisons may be expected.
	 * Without overriding, comparable references to the muml model are not included where appropriate
	 */
	@Override
	public void completeComparisonExpr_Lhs(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completeComparisonExpr_Lhs(model, assignment, context, acceptor);
		
		completeAssignmentUsingScope(PredicatesFactory.eINSTANCE.createComparisonExpr(), PredicatesPackage.eINSTANCE.getComparisonExpr_Lhs(), context, acceptor);
	}
	
	/*
	 * Overriding to supply keyword proposals for time units which are otherwise missing for some reason
	 */
	@Override
	public void complete_TimeUnitExpr(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		for (AbstractElement k : grammarAccess.getTimeUnitExprAccess().getAlternatives().getElements()) {
			if (k instanceof Keyword)
				completeKeyword((Keyword) k, context, acceptor);
		}
	}

}
