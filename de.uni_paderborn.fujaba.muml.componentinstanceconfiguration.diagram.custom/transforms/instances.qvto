transformation InstantiationTransformation(inout instance : InstancePackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.2.2');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.2.2');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.2.2');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.2.2');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.2.2');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

property NULL_COMPONENT_PART_HELPER : ComponentPart = object ComponentPart{};

main() {
	log("QVT-O Script \"instances.qvto\" started.");

	// process AtomicComponentInstances
	instance.rootObjects()[AtomicComponentInstance]->forEach(ci) {
		ci.portInstances := ci.componentType.createPortInstances(NULL_COMPONENT_PART_HELPER); // using helper instead of "null", because of QVTO-Bug
	};
	
	// process StructuredComponentInstances
	instance.rootObjects()[StructuredComponentInstance]->forEach(ci) {
		ci.portInstances := ci.componentType.createPortInstances(NULL_COMPONENT_PART_HELPER); // using helper instead of "null", because of QVTO-Bug
		ci.embeddedCIC := new ComponentInstanceConfiguration(ci.componentType.oclAsType(StructuredComponent));
		
		// Create ConnectorInstances after PortInstance.component and ComponentInstance.componentPart is set (see above)
		// This makes sure that the derivation of the PortInstance.portPart reference can work,
		// Which is necessary for the creation of the connector instances.
		ci.portInstances->forEach(i) {
			var part : ComponentPart := NULL_COMPONENT_PART_HELPER;
			if (not ci.componentPart.oclIsUndefined()) then {
				part := ci.componentPart;
			} endif;
			i.createConnectorInstances(part);
		};
		// make sure all created connectors are contained
		if (ci.container().oclIsKindOf(ComponentInstanceConfiguration)) then {
			ci.container().oclAsType(ComponentInstanceConfiguration).portConnectorInstances := ci.portInstances.portConnectorInstances;
		} endif;
		
	};
}

// Convenience query to cast a natural number as integer, using -1 as value for infinity.
query NaturalNumber::toInteger() : Integer {
	if (self.infinity) then {
		return -1;
	} endif;
	return self.value;
}

// Convenience query to get all Port Instances that have already been created for a port at a given ComponentInstance
query Port::portInstances(componentInstance : ComponentInstance) : Set(PortInstance) {
	return componentInstance.portInstances->select(i | i.type = self);
}


query Component::createPortInstances(part : ComponentPart) : Set(PortInstance) {
	var portInstances : Set(PortInstance);
	self.ports->forEach(port) {
		portInstances += port.createInstances(part)[PortInstance];
	};
	return portInstances;
}

// Creating multiple Port Instances for multi ports and one Port Instance for single ports.
query ConnectorEndpoint::createInstances(part : ComponentPart) : Set(ConnectorEndpointInstance) {
	return Set { self.createInstance(part) }
}
query DiscretePort::createInstances(part : ComponentPart) : Set(ConnectorEndpointInstance) {
	if (self.multiPort) then {
		var multiPortInstance : DiscreteMultiPortInstance := self.map multi(part);
		//return OrderedSet { multiPortInstance }
		return OrderedSet { multiPortInstance }[PortInstance]->union(multiPortInstance.subInteractionEndpointInstances[PortInstance])
	} endif;
	return self.createSubPortInstances(part);
}
query DiscretePort::createSubPortInstances(part : ComponentPart) : Set(PortInstance) {
	var subPortInstances : Set(PortInstance);
	var count : Integer := 0;
	while (count < self.cardinality.lowerBound.toInteger()) {
		var portInstance : PortInstance := self.createInstance(part).oclAsType(PortInstance);
		portInstance.name := self.name + (count + 1).toString();
		subPortInstances += portInstance;
		count := count + 1;
	};
	return subPortInstances
}

// Primitively creating and initializing one PortInstance by PortType
query ConnectorEndpoint::createInstance(part : ComponentPart) : ConnectorEndpointInstance {
	return self.map single(part);
}

// Connector instances
query Connector::otherEnd(thisEnd : ConnectorEndpoint) : ConnectorEndpoint {
	return self.connectorEndpoints->select(e | e != thisEnd)->first();
}
query ConnectorEndpointInstance::createConnectorInstances(part : ComponentPart) : Set(ConnectorInstance) {
	var connectorInstances : Set(ConnectorInstance);
		
	self.type.connectors
		
	//->reject(c | self.connectorInstances.type->includes(c))[PortConnector]
		
	[PortConnector]->forEach(portConnector) {
		var otherEnd : Port := portConnector.otherEnd(self.type).oclAsType(Port);
		otherEnd.resolve(PortInstance)->forEach(otherEndInstance) {
			if (not otherEndInstance.oclIsUndefined() and otherEndInstance != self and Set { self, otherEndInstance}.connectorInstances.type->excludes(portConnector)) then {
				connectorInstances += portConnector.createConnectorInstance(Set { self, otherEndInstance });
			} endif;
		}
	};
	return connectorInstances;
}
query Connector::createConnectorInstance(endpoints : Set(ConnectorEndpointInstance)) : ConnectorInstance {
	var connectorInstance : ConnectorInstance := self.primCreateConnectorInstance();
	connectorInstance.connectorEndpointInstances := endpoints;
	return connectorInstance;
}
query Connector::primCreateConnectorInstance() : ConnectorInstance {
	assert fatal (false) with log ("Tried to instantiate abstract class Connector.");
	return null;
}
query AssemblyConnector::primCreateConnectorInstance() : ConnectorInstance {
	return new AssemblyConnectorInstance(self);
}
query DelegationConnector::primCreateConnectorInstance() : ConnectorInstance {
	return new DelegationConnectorInstance(self);
}




// Constructors
constructor ComponentInstanceConfiguration::ComponentInstanceConfiguration(component : StructuredComponent) {
	name := component.name;
	component.embeddedComponentParts->select(p | p.componentType.oclIsKindOf(AtomicComponent))->forEach(part) {
		componentInstances += new AtomicComponentInstance(part.componentType.oclAsType(AtomicComponent), part);
	};
	component.embeddedComponentParts->select(p | p.componentType.oclIsKindOf(StructuredComponent))->forEach(part) {
		componentInstances += new StructuredComponentInstance(part.componentType.oclAsType(StructuredComponent), part);
	};
	// make sure all created connectors are contained
	portConnectorInstances->forEach(pci) {
		instance.removeElement(pci);
	};
	portConnectorInstances := componentInstances.portInstances.portConnectorInstances;
}

// TODO: Same code as below
constructor AtomicComponentInstance::AtomicComponentInstance(type : AtomicComponent, part : ComponentPart) {
	componentType := type;
	name := type.name;
	
	// Creating Port Instances also sets the opposite feature PortInstance.component
	portInstances := componentType.createPortInstances(part);

	// Set ComponentPart
	if (part != NULL_COMPONENT_PART_HELPER) then {
		componentPart := part;
	} endif;
	
	// Create ConnectorInstances after PortInstance.component and ComponentInstance.componentPart is set (see above)
	// This makes sure that the derivation of the PortInstance.portPart reference can work,
	// Which is necessary for the creation of the connector instances.
	portInstances->forEach(i) {
		i.connectorInstances := i.createConnectorInstances(part);
	};
}

// TODO: Same code as above
constructor StructuredComponentInstance::StructuredComponentInstance(type : StructuredComponent, part : ComponentPart) {
	componentType := type;
	name := type.name;
	
	// Creating Port Instances also sets the opposite feature PortInstance.component
	portInstances := componentType.createPortInstances(part);
	
	// Set ComponentPart
	if (part != NULL_COMPONENT_PART_HELPER) then {
		componentPart := part;
	} endif;
	
	// Create ConnectorInstances after PortInstance.component and ComponentInstance.componentPart is set (see above)
	// This makes sure that the derivation of the PortInstance.portPart reference can work,
	// Which is necessary for the creation of the connector instances.
	portInstances->forEach(i) {
		i.connectorInstances := i.createConnectorInstances(part);
	};
	
	embeddedCIC := new ComponentInstanceConfiguration(type);
}


constructor AssemblyConnectorInstance::AssemblyConnectorInstance(assembly : AssemblyConnector) {
	type := assembly;
}
constructor DelegationConnectorInstance::DelegationConnectorInstance(delegation : DelegationConnector) {
	type := delegation;
	
}

mapping ConnectorEndpoint::single(part : ComponentPart) : ConnectorEndpointInstance
	disjuncts DiscretePort::singleDiscrete, ContinuousPort::singleContinuous, HybridPort::singleHybrid;


mapping DiscretePort::multi(part : ComponentPart) : DiscreteMultiPortInstance {
	type := self;
	name := type.name;
	subInteractionEndpointInstances := self.createSubPortInstances(part)[DiscreteSinglePortInstance];
}
mapping DiscretePort::singleDiscrete(part : ComponentPart) : DiscreteSinglePortInstance {
	type := self;
}
mapping ContinuousPort::singleContinuous(part : ComponentPart) : ContinuousPortInstance {
	type := self;
}
mapping HybridPort::singleHybrid(part : ComponentPart) : HybridPortInstance {
	type := self;
}