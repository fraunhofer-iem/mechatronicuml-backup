import InstanceLibrary;
transformation InstantiationTransformation(inout instance : InstancePackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

property NULL_COMPONENT_PART_HELPER : ComponentPart = object ComponentPart{};
property NULL_PORT_PART_HELPER : PortPart = object PortPart{};

main() {
	log("QVT-O Script \"instances.qvto\" started.");

	// process AtomicComponentInstances
	instance.rootObjects()[AtomicComponentInstance]->forEach(ci) {
		ci.portInstances := ci.componentType.createPortInstances(NULL_COMPONENT_PART_HELPER); // using helper instead of "null", because of QVTO-Bug
	};
	
	// process StructuredComponentInstances
	instance.rootObjects()[StructuredComponentInstance]->forEach(ci) {
		// Remove old port instances from resource
		ci.portInstances->forEach(pi) {
			instance.removeElement(pi);
		};
		ci.portInstances := ci.componentType.createPortInstances(NULL_COMPONENT_PART_HELPER); // using helper instead of "null", because of QVTO-Bug
		
		// Remove old embedded cic from resource
		instance.removeElement(ci.embeddedCIC);
		ci.embeddedCIC := new ComponentInstanceConfiguration(ci.componentType.oclAsType(StructuredComponent));
		
		if (ci.container().oclIsKindOf(ComponentInstanceConfiguration)) then {
			// Remove old connector instances from resource
			ci.container().oclAsType(ComponentInstanceConfiguration).portConnectorInstances->forEach(pci) {
				instance.removeElement(pci);
			};
			ci.container().oclAsType(ComponentInstanceConfiguration).portConnectorInstances := Set { };
			
			// Add new connector instances
			ci.componentType[StructuredComponent].connectors->forEach(portConnector) {
				var endpoint1 : ConnectorEndpoint := portConnector.connectorEndpoints->first();
				var endpoint2 : ConnectorEndpoint := portConnector.connectorEndpoints->last();
				if (endpoint1 != endpoint2) then {
					endpoint1.resolve().oclAsSet()[PortInstance]->forEach(endpointInstance1) {
						endpoint2.resolve().oclAsSet()[PortInstance]->forEach(endpointInstance2) {
							if (not endpointInstance1.oclIsKindOf(DiscreteMultiPortInstance) and not endpointInstance2.oclIsKindOf(DiscreteMultiPortInstance) and ci.container().oclAsType(ComponentInstanceConfiguration).portConnectorInstances->select(connectorEndpointInstances->includes(endpointInstance1) or connectorEndpointInstances->includes(endpointInstance2))->isEmpty()) then {
								ci.container().oclAsType(ComponentInstanceConfiguration).portConnectorInstances += portConnector.createConnectorInstance(
									Set { endpointInstance1, endpointInstance2 }
								)[PortConnectorInstance];
							} endif;
						};
					};
				} endif;
			};
		} endif;
		
	};
	
	
	instance.removeElement(NULL_COMPONENT_PART_HELPER);
	instance.removeElement(NULL_PORT_PART_HELPER);
}








