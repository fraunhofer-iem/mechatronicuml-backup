/*
 * generated by Xtext
 */
package de.uni_paderborn.fujaba.muml.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ActionLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class EntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Entry");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cArrayInitializeExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Entry returns expressions::Expression:
		//	Block | Expression | ArrayInitializeExpression;
		@Override public ParserRule getRule() { return rule; }

		//Block | Expression | ArrayInitializeExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//Block
		public RuleCall getBlockParserRuleCall_0() { return cBlockParserRuleCall_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//ArrayInitializeExpression
		public RuleCall getArrayInitializeExpressionParserRuleCall_2() { return cArrayInitializeExpressionParserRuleCall_2; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionsExpressionStartRuleParserRuleCall_2_0 = (RuleCall)cExpressionsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block returns actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
		//	{actionlanguage::Block} "{" expressions+=ExpressionStartRule* "}";
		@Override public ParserRule getRule() { return rule; }

		//{actionlanguage::Block} "{" expressions+=ExpressionStartRule* "}"
		public Group getGroup() { return cGroup; }

		//{actionlanguage::Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//expressions+=ExpressionStartRule*
		public Assignment getExpressionsAssignment_2() { return cExpressionsAssignment_2; }

		//ExpressionStartRule
		public RuleCall getExpressionsExpressionStartRuleParserRuleCall_2_0() { return cExpressionsExpressionStartRuleParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitializeExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitializeExpressionAssignmentParserRuleCall_2_0 = (RuleCall)cInitializeExpressionAssignment_2.eContents().get(0);
		private final Assignment cLoopTestAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopTestExpressionParserRuleCall_3_0 = (RuleCall)cLoopTestAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCountingExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0 = (RuleCall)cCountingExpressionAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBlockAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBlockBlockParserRuleCall_7_0 = (RuleCall)cBlockAssignment_7.eContents().get(0);
		
		//// TODO: clarify if it makes sense to allow arbitrary expressions for
		//// the initializeExpression and countingExpression
		//ForLoop returns actionlanguage::ForLoop:
		//	"for" "(" initializeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//	block=Block;
		@Override public ParserRule getRule() { return rule; }

		//"for" "(" initializeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
		//block=Block
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//initializeExpression=Assignment
		public Assignment getInitializeExpressionAssignment_2() { return cInitializeExpressionAssignment_2; }

		//Assignment
		public RuleCall getInitializeExpressionAssignmentParserRuleCall_2_0() { return cInitializeExpressionAssignmentParserRuleCall_2_0; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_3() { return cLoopTestAssignment_3; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_3_0() { return cLoopTestExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }

		//countingExpression=ForLoopCountingExpression
		public Assignment getCountingExpressionAssignment_5() { return cCountingExpressionAssignment_5; }

		//ForLoopCountingExpression
		public RuleCall getCountingExpressionForLoopCountingExpressionParserRuleCall_5_0() { return cCountingExpressionForLoopCountingExpressionParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//block=Block
		public Assignment getBlockAssignment_7() { return cBlockAssignment_7; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_7_0() { return cBlockBlockParserRuleCall_7_0; }
	}

	public class ForLoopCountingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLoopCountingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_typedNamedElementExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0 = (RuleCall)cLhs_typedNamedElementExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIncrementDecrementOperatorAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cAssignOperatorAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0 = (RuleCall)cAssignOperatorAssignment_1_1_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_1_1.eContents().get(0);
		
		//ForLoopCountingExpression returns actionlanguage::Assignment:
		//	lhs_typedNamedElementExpression=TypedNamedElementExpression
		//	(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//	rhs_assignExpression=Expression);
		@Override public ParserRule getRule() { return rule; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		//(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//rhs_assignExpression=Expression)
		public Group getGroup() { return cGroup; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		public Assignment getLhs_typedNamedElementExpressionAssignment_0() { return cLhs_typedNamedElementExpressionAssignment_0; }

		//TypedNamedElementExpression
		public RuleCall getLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0() { return cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
		//rhs_assignExpression=Expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_0() { return cIncrementDecrementOperatorAssignment_1_0; }

		//UnaryPostIncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0() { return cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_1_0() { return cAssignOperatorAssignment_1_1_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_1_0_0; }

		//rhs_assignExpression=Expression
		public Assignment getRhs_assignExpressionAssignment_1_1_1() { return cRhs_assignExpressionAssignment_1_1_1; }

		//Expression
		public RuleCall getRhs_assignExpressionExpressionParserRuleCall_1_1_1_0() { return cRhs_assignExpressionExpressionParserRuleCall_1_1_1_0; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLoopTestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLoopTestExpressionParserRuleCall_2_0 = (RuleCall)cLoopTestAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		//WhileLoop returns actionlanguage::WhileLoop:
		//	"while" "(" loopTest=Expression ")" block=Block;
		@Override public ParserRule getRule() { return rule; }

		//"while" "(" loopTest=Expression ")" block=Block
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_2() { return cLoopTestAssignment_2; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_2_0() { return cLoopTestExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//block=Block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}

	public class DoWhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLoopTestAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopTestExpressionParserRuleCall_4_0 = (RuleCall)cLoopTestAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//DoWhileLoop returns actionlanguage::DoWhileLoop:
		//	"do" block=Block "while" "(" loopTest=Expression ");";
		@Override public ParserRule getRule() { return rule; }

		//"do" block=Block "while" "(" loopTest=Expression ");"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//block=Block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//loopTest=Expression
		public Assignment getLoopTestAssignment_4() { return cLoopTestAssignment_4; }

		//Expression
		public RuleCall getLoopTestExpressionParserRuleCall_4_0() { return cLoopTestExpressionParserRuleCall_4_0; }

		//");"
		public Keyword getRightParenthesisSemicolonKeyword_5() { return cRightParenthesisSemicolonKeyword_5; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIfConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfConditionExpressionParserRuleCall_2_0 = (RuleCall)cIfConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockBlockParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final Assignment cElseIfStatementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseIfStatementsElseIfStatementParserRuleCall_5_0 = (RuleCall)cElseIfStatementsAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cElseKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cElseBlockAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cElseBlockBlockParserRuleCall_6_1_0 = (RuleCall)cElseBlockAssignment_6_1.eContents().get(0);
		
		//IfStatement returns actionlanguage::IfStatement:
		//	"if" "(" ifCondition=Expression ")" ifBlock=Block elseIfStatements+=ElseIfStatement* ("else" elseBlock=Block)?;
		@Override public ParserRule getRule() { return rule; }

		//"if" "(" ifCondition=Expression ")" ifBlock=Block elseIfStatements+=ElseIfStatement* ("else" elseBlock=Block)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//ifCondition=Expression
		public Assignment getIfConditionAssignment_2() { return cIfConditionAssignment_2; }

		//Expression
		public RuleCall getIfConditionExpressionParserRuleCall_2_0() { return cIfConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//ifBlock=Block
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }

		//Block
		public RuleCall getIfBlockBlockParserRuleCall_4_0() { return cIfBlockBlockParserRuleCall_4_0; }

		//elseIfStatements+=ElseIfStatement*
		public Assignment getElseIfStatementsAssignment_5() { return cElseIfStatementsAssignment_5; }

		//ElseIfStatement
		public RuleCall getElseIfStatementsElseIfStatementParserRuleCall_5_0() { return cElseIfStatementsElseIfStatementParserRuleCall_5_0; }

		//("else" elseBlock=Block)?
		public Group getGroup_6() { return cGroup_6; }

		//"else"
		public Keyword getElseKeyword_6_0() { return cElseKeyword_6_0; }

		//elseBlock=Block
		public Assignment getElseBlockAssignment_6_1() { return cElseBlockAssignment_6_1; }

		//Block
		public RuleCall getElseBlockBlockParserRuleCall_6_1_0() { return cElseBlockBlockParserRuleCall_6_1_0; }
	}

	public class ElseIfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElseIfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElseifKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElseIfConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElseIfConditionExpressionParserRuleCall_2_0 = (RuleCall)cElseIfConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cElseIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElseIfBlockBlockParserRuleCall_4_0 = (RuleCall)cElseIfBlockAssignment_4.eContents().get(0);
		
		//ElseIfStatement returns actionlanguage::ElseIfStatement:
		//	"elseif" "(" elseIfCondition=Expression ")" elseIfBlock=Block;
		@Override public ParserRule getRule() { return rule; }

		//"elseif" "(" elseIfCondition=Expression ")" elseIfBlock=Block
		public Group getGroup() { return cGroup; }

		//"elseif"
		public Keyword getElseifKeyword_0() { return cElseifKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//elseIfCondition=Expression
		public Assignment getElseIfConditionAssignment_2() { return cElseIfConditionAssignment_2; }

		//Expression
		public RuleCall getElseIfConditionExpressionParserRuleCall_2_0() { return cElseIfConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//elseIfBlock=Block
		public Assignment getElseIfBlockAssignment_4() { return cElseIfBlockAssignment_4; }

		//Block
		public RuleCall getElseIfBlockBlockParserRuleCall_4_0() { return cElseIfBlockBlockParserRuleCall_4_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReturnStatement returns actionlanguage::ReturnStatement:
		//	{actionlanguage::ReturnStatement} "return" expression=Expression ";";
		@Override public ParserRule getRule() { return rule; }

		//{actionlanguage::ReturnStatement} "return" expression=Expression ";"
		public Group getGroup() { return cGroup; }

		//{actionlanguage::ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//"return"
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class OperationCallStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCallStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOperationCallParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//OperationCallStatement returns actionlanguage::OperationCall:
		//	OperationCall ";";
		@Override public ParserRule getRule() { return rule; }

		//OperationCall ";"
		public Group getGroup() { return cGroup; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_0() { return cOperationCallParserRuleCall_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class ExpressionStartRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionStartRule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDoWhileLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIfStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cReturnStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLocalVariableOrConstantDeclarationStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cOperationCallStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//ExpressionStartRule returns expressions::Expression:
		//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement |
		//	LocalVariableOrConstantDeclarationStatement | OperationCallStatement;
		@Override public ParserRule getRule() { return rule; }

		//Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement |
		//LocalVariableOrConstantDeclarationStatement | OperationCallStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_0() { return cAssignmentParserRuleCall_0; }

		//ForLoop
		public RuleCall getForLoopParserRuleCall_1() { return cForLoopParserRuleCall_1; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_2() { return cWhileLoopParserRuleCall_2; }

		//DoWhileLoop
		public RuleCall getDoWhileLoopParserRuleCall_3() { return cDoWhileLoopParserRuleCall_3; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_4() { return cIfStatementParserRuleCall_4; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_5() { return cReturnStatementParserRuleCall_5; }

		//LocalVariableOrConstantDeclarationStatement
		public RuleCall getLocalVariableOrConstantDeclarationStatementParserRuleCall_6() { return cLocalVariableOrConstantDeclarationStatementParserRuleCall_6; }

		//OperationCallStatement
		public RuleCall getOperationCallStatementParserRuleCall_7() { return cOperationCallStatementParserRuleCall_7; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhs_typedNamedElementExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0 = (RuleCall)cLhs_typedNamedElementExpressionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cAssignOperatorAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0 = (RuleCall)cAssignOperatorAssignment_1_0_0.eContents().get(0);
		private final Assignment cRhs_assignExpressionAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0 = (RuleCall)cRhs_assignExpressionAssignment_1_0_1.eContents().get(0);
		private final Assignment cIncrementDecrementOperatorAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Assignment
		//Assignment returns actionlanguage::Assignment:
		//	lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
		//	rhs_assignExpression=InitializeExpression | incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ";";
		@Override public ParserRule getRule() { return rule; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
		//rhs_assignExpression=InitializeExpression | incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ";"
		public Group getGroup() { return cGroup; }

		//lhs_typedNamedElementExpression=TypedNamedElementExpression
		public Assignment getLhs_typedNamedElementExpressionAssignment_0() { return cLhs_typedNamedElementExpressionAssignment_0; }

		//TypedNamedElementExpression
		public RuleCall getLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0() { return cLhs_typedNamedElementExpressionTypedNamedElementExpressionParserRuleCall_0_0; }

		//assignOperator=AssignOperator rhs_assignExpression=InitializeExpression |
		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//assignOperator=AssignOperator rhs_assignExpression=InitializeExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//assignOperator=AssignOperator
		public Assignment getAssignOperatorAssignment_1_0_0() { return cAssignOperatorAssignment_1_0_0; }

		//AssignOperator
		public RuleCall getAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0() { return cAssignOperatorAssignOperatorEnumRuleCall_1_0_0_0; }

		//rhs_assignExpression=InitializeExpression
		public Assignment getRhs_assignExpressionAssignment_1_0_1() { return cRhs_assignExpressionAssignment_1_0_1; }

		//InitializeExpression
		public RuleCall getRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0() { return cRhs_assignExpressionInitializeExpressionParserRuleCall_1_0_1_0; }

		//incrementDecrementOperator=UnaryPostIncrementDecrementOperator
		public Assignment getIncrementDecrementOperatorAssignment_1_1() { return cIncrementDecrementOperatorAssignment_1_1; }

		//UnaryPostIncrementDecrementOperator
		public RuleCall getIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0() { return cIncrementDecrementOperatorUnaryPostIncrementDecrementOperatorEnumRuleCall_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class InitializeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InitializeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrayInitializeExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNondeterministicChoiceExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// end of assignment
		//// initialize expression
		//InitializeExpression returns expressions::Expression:
		//	ArrayInitializeExpression | NondeterministicChoiceExpression | Expression;
		@Override public ParserRule getRule() { return rule; }

		//ArrayInitializeExpression | NondeterministicChoiceExpression | Expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrayInitializeExpression
		public RuleCall getArrayInitializeExpressionParserRuleCall_0() { return cArrayInitializeExpressionParserRuleCall_0; }

		//NondeterministicChoiceExpression
		public RuleCall getNondeterministicChoiceExpressionParserRuleCall_1() { return cNondeterministicChoiceExpressionParserRuleCall_1; }

		//Expression
		public RuleCall getExpressionParserRuleCall_2() { return cExpressionParserRuleCall_2; }
	}

	public class ArrayInitializeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayInitializeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsInitializeExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsInitializeExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// end of initialize expression
		//// array initialization
		//ArrayInitializeExpression returns actionlanguage::ArrayInitializeExpression:
		//	"[" expressions+=InitializeExpression ("," expressions+=InitializeExpression)* "]";
		@Override public ParserRule getRule() { return rule; }

		//"[" expressions+=InitializeExpression ("," expressions+=InitializeExpression)* "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//expressions+=InitializeExpression
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }

		//InitializeExpression
		public RuleCall getExpressionsInitializeExpressionParserRuleCall_1_0() { return cExpressionsInitializeExpressionParserRuleCall_1_0; }

		//("," expressions+=InitializeExpression)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//expressions+=InitializeExpression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }

		//InitializeExpression
		public RuleCall getExpressionsInitializeExpressionParserRuleCall_2_1_0() { return cExpressionsInitializeExpressionParserRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class LocalVariableOrConstantDeclarationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariableOrConstantDeclarationStatement");
		private final Assignment cVariableAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cVariableAlternatives_0 = (Alternatives)cVariableAssignment.eContents().get(0);
		private final RuleCall cVariableLocalVariableDeclarationParserRuleCall_0_0 = (RuleCall)cVariableAlternatives_0.eContents().get(0);
		private final RuleCall cVariableLocalConstantDeclarationParserRuleCall_0_1 = (RuleCall)cVariableAlternatives_0.eContents().get(1);
		
		//// end of array initialization
		//// local variable declaration
		//LocalVariableOrConstantDeclarationStatement returns actionlanguage::LocalVariableDeclarationStatement:
		//	variable=(LocalVariableDeclaration | LocalConstantDeclaration);
		@Override public ParserRule getRule() { return rule; }

		//variable=(LocalVariableDeclaration | LocalConstantDeclaration)
		public Assignment getVariableAssignment() { return cVariableAssignment; }

		//LocalVariableDeclaration | LocalConstantDeclaration
		public Alternatives getVariableAlternatives_0() { return cVariableAlternatives_0; }

		//LocalVariableDeclaration
		public RuleCall getVariableLocalVariableDeclarationParserRuleCall_0_0() { return cVariableLocalVariableDeclarationParserRuleCall_0_0; }

		//LocalConstantDeclaration
		public RuleCall getVariableLocalConstantDeclarationParserRuleCall_0_1() { return cVariableLocalConstantDeclarationParserRuleCall_0_1; }
	}

	public class LocalVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDataTypeDataTypeCrossReference_0_0 = (CrossReference)cDataTypeAssignment_0.eContents().get(0);
		private final RuleCall cDataTypeDataTypeDATATYPEParserRuleCall_0_0_1 = (RuleCall)cDataTypeDataTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInitializeExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitializeExpressionInitializeExpressionParserRuleCall_2_1_0 = (RuleCall)cInitializeExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//LocalVariableDeclaration returns behavior::Variable:
		//	dataType=[types::DataType|DATATYPE] name=ID (":=" initializeExpression=InitializeExpression)? ";";
		@Override public ParserRule getRule() { return rule; }

		//dataType=[types::DataType|DATATYPE] name=ID (":=" initializeExpression=InitializeExpression)? ";"
		public Group getGroup() { return cGroup; }

		//dataType=[types::DataType|DATATYPE]
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//[types::DataType|DATATYPE]
		public CrossReference getDataTypeDataTypeCrossReference_0_0() { return cDataTypeDataTypeCrossReference_0_0; }

		//DATATYPE
		public RuleCall getDataTypeDataTypeDATATYPEParserRuleCall_0_0_1() { return cDataTypeDataTypeDATATYPEParserRuleCall_0_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//(":=" initializeExpression=InitializeExpression)?
		public Group getGroup_2() { return cGroup_2; }

		//":="
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//initializeExpression=InitializeExpression
		public Assignment getInitializeExpressionAssignment_2_1() { return cInitializeExpressionAssignment_2_1; }

		//InitializeExpression
		public RuleCall getInitializeExpressionInitializeExpressionParserRuleCall_2_1_0() { return cInitializeExpressionInitializeExpressionParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class LocalConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cConstantConstKeyword_0_0 = (Keyword)cConstantAssignment_0.eContents().get(0);
		private final Assignment cDataTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDataTypeDataTypeCrossReference_1_0 = (CrossReference)cDataTypeAssignment_1.eContents().get(0);
		private final RuleCall cDataTypeDataTypeDATATYPEParserRuleCall_1_0_1 = (RuleCall)cDataTypeDataTypeCrossReference_1_0.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInitializeExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInitializeExpressionInitializeExpressionParserRuleCall_4_0 = (RuleCall)cInitializeExpressionAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LocalConstantDeclaration returns behavior::Variable:
		//	constant?="const" dataType=[types::DataType|DATATYPE] name=ID ":=" initializeExpression=InitializeExpression ";";
		@Override public ParserRule getRule() { return rule; }

		//constant?="const" dataType=[types::DataType|DATATYPE] name=ID ":=" initializeExpression=InitializeExpression ";"
		public Group getGroup() { return cGroup; }

		//constant?="const"
		public Assignment getConstantAssignment_0() { return cConstantAssignment_0; }

		//"const"
		public Keyword getConstantConstKeyword_0_0() { return cConstantConstKeyword_0_0; }

		//dataType=[types::DataType|DATATYPE]
		public Assignment getDataTypeAssignment_1() { return cDataTypeAssignment_1; }

		//[types::DataType|DATATYPE]
		public CrossReference getDataTypeDataTypeCrossReference_1_0() { return cDataTypeDataTypeCrossReference_1_0; }

		//DATATYPE
		public RuleCall getDataTypeDataTypeDATATYPEParserRuleCall_1_0_1() { return cDataTypeDataTypeDATATYPEParserRuleCall_1_0_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_3() { return cColonEqualsSignKeyword_3; }

		//initializeExpression=InitializeExpression
		public Assignment getInitializeExpressionAssignment_4() { return cInitializeExpressionAssignment_4; }

		//InitializeExpression
		public RuleCall getInitializeExpressionInitializeExpressionParserRuleCall_4_0() { return cInitializeExpressionInitializeExpressionParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class NondeterministicChoiceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NondeterministicChoiceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDataTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDataTypePrimitiveDataTypeCrossReference_0_0 = (CrossReference)cDataTypeAssignment_0.eContents().get(0);
		private final RuleCall cDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cDataTypePrimitiveDataTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cRangeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRangeRangeParserRuleCall_1_0 = (RuleCall)cRangeAssignment_1.eContents().get(0);
		
		//// end of local variable declaration
		//// nondeterministic choice expression
		//NondeterministicChoiceExpression returns actionlanguage::NondeterministicChoiceExpression:
		//	dataType=[types::PrimitiveDataType] range=Range;
		@Override public ParserRule getRule() { return rule; }

		//dataType=[types::PrimitiveDataType] range=Range
		public Group getGroup() { return cGroup; }

		//dataType=[types::PrimitiveDataType]
		public Assignment getDataTypeAssignment_0() { return cDataTypeAssignment_0; }

		//[types::PrimitiveDataType]
		public CrossReference getDataTypePrimitiveDataTypeCrossReference_0_0() { return cDataTypePrimitiveDataTypeCrossReference_0_0; }

		//ID
		public RuleCall getDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1() { return cDataTypePrimitiveDataTypeIDTerminalRuleCall_0_0_1; }

		//range=Range
		public Assignment getRangeAssignment_1() { return cRangeAssignment_1; }

		//Range
		public RuleCall getRangeRangeParserRuleCall_1_0() { return cRangeRangeParserRuleCall_1_0; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundLONGParserRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundLONGParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Range returns valuetype::Range:
		//	"<" lowerBound=LONG "," upperBound=LONG ">";
		@Override public ParserRule getRule() { return rule; }

		//"<" lowerBound=LONG "," upperBound=LONG ">"
		public Group getGroup() { return cGroup; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//lowerBound=LONG
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }

		//LONG
		public RuleCall getLowerBoundLONGParserRuleCall_1_0() { return cLowerBoundLONGParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//upperBound=LONG
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }

		//LONG
		public RuleCall getUpperBoundLONGParserRuleCall_3_0() { return cUpperBoundLONGParserRuleCall_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class LONGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LONG");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LONG returns ecore::ELong:
		//	INT;
		@Override public ParserRule getRule() { return rule; }

		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLogicalExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of nondeterministic choice expression
		//Expression returns expressions::Expression:
		//	LogicalExpression;
		@Override public ParserRule getRule() { return rule; }

		//LogicalExpression
		public RuleCall getLogicalExpressionParserRuleCall() { return cLogicalExpressionParserRuleCall; }
	}

	public class LogicalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalExpression");
		private final RuleCall cLogicalOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// LogicalExpression
		//LogicalExpression returns expressions::Expression:
		//	LogicalOrExpression;
		@Override public ParserRule getRule() { return rule; }

		//LogicalOrExpression
		public RuleCall getLogicalOrExpressionParserRuleCall() { return cLogicalOrExpressionParserRuleCall; }
	}

	public class LogicalOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOrOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalOrExpression returns expressions::Expression:
		//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//	rightExpression=LogicalAndExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup() { return cGroup; }

		//LogicalAndExpression
		public RuleCall getLogicalAndExpressionParserRuleCall_0() { return cLogicalAndExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
		//rightExpression=LogicalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalOrOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOrOperator
		public RuleCall getOperatorLogicalOrOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalOrOperatorEnumRuleCall_1_1_0; }

		//rightExpression=LogicalAndExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//LogicalAndExpression
		public RuleCall getRightExpressionLogicalAndExpressionParserRuleCall_1_2_0() { return cRightExpressionLogicalAndExpressionParserRuleCall_1_2_0; }
	}

	public class LogicalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalAndOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//LogicalAndExpression returns expressions::Expression:
		//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//	rightExpression=ComparisonExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
		//rightExpression=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::LogicalExpression.leftExpression=current}
		public Action getLogicalExpressionLeftExpressionAction_1_0() { return cLogicalExpressionLeftExpressionAction_1_0; }

		//operator=LogicalAndOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalAndOperator
		public RuleCall getOperatorLogicalAndOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalAndOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightExpressionComparisonExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonHigherOpExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//// end of LogicalExpression
		//// ComparisonExpression
		//ComparisonExpression returns expressions::Expression:
		//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//	operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
		//operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup() { return cGroup; }

		//ComparisonHigherOpExpression
		public RuleCall getComparisonHigherOpExpressionParserRuleCall_0() { return cComparisonHigherOpExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingEQNEQOperator
		//rightExpression=ComparisonHigherOpExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingEQNEQOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingEQNEQOperator
		public RuleCall getOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0() { return cOperatorComparingEQNEQOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ComparisonHigherOpExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ComparisonHigherOpExpression
		public RuleCall getRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0() { return cRightExpressionComparisonHigherOpExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonHigherOpExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonHigherOpExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArithmeticExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparingRelOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionArithmeticExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//ComparisonHigherOpExpression returns expressions::Expression:
		//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//	rightExpression=ArithmeticExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup() { return cGroup; }

		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall_0() { return cArithmeticExpressionParserRuleCall_0; }

		//({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
		//rightExpression=ArithmeticExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ComparisonExpression.leftExpression=current}
		public Action getComparisonExpressionLeftExpressionAction_1_0() { return cComparisonExpressionLeftExpressionAction_1_0; }

		//operator=ComparingRelOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparingRelOperator
		public RuleCall getOperatorComparingRelOperatorEnumRuleCall_1_1_0() { return cOperatorComparingRelOperatorEnumRuleCall_1_1_0; }

		//rightExpression=ArithmeticExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//ArithmeticExpression
		public RuleCall getRightExpressionArithmeticExpressionParserRuleCall_1_2_0() { return cRightExpressionArithmeticExpressionParserRuleCall_1_2_0; }
	}

	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticExpression");
		private final RuleCall cAdditionExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// end of ComparisonExpression
		//// ArithmeticExpression	
		//ArithmeticExpression returns expressions::Expression:
		//	AdditionExpression;
		@Override public ParserRule getRule() { return rule; }

		//AdditionExpression
		public RuleCall getAdditionExpressionParserRuleCall() { return cAdditionExpressionParserRuleCall; }
	}

	public class AdditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditionOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExpressionAssignment_1_2.eContents().get(0);
		
		//AdditionExpression returns expressions::Expression:
		//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//	rightExpression=MultiplicationExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicationExpression
		public RuleCall getMultiplicationExpressionParserRuleCall_0() { return cMultiplicationExpressionParserRuleCall_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
		//rightExpression=MultiplicationExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_0() { return cArithmeticExpressionLeftExpressionAction_1_0; }

		//operator=AdditionOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditionOperator
		public RuleCall getOperatorAdditionOperatorEnumRuleCall_1_1_0() { return cOperatorAdditionOperatorEnumRuleCall_1_1_0; }

		//rightExpression=MultiplicationExpression
		public Assignment getRightExpressionAssignment_1_2() { return cRightExpressionAssignment_1_2; }

		//MultiplicationExpression
		public RuleCall getRightExpressionMultiplicationExpressionParserRuleCall_1_2_0() { return cRightExpressionMultiplicationExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryPreExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cTypeCastExpressionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cArithmeticExpressionLeftExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0 = (RuleCall)cOperatorAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightExpressionAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final Alternatives cRightExpressionAlternatives_1_1_2_0 = (Alternatives)cRightExpressionAssignment_1_1_2.eContents().get(0);
		private final RuleCall cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(0);
		private final RuleCall cRightExpressionTypeCastExpressionParserRuleCall_1_1_2_0_1 = (RuleCall)cRightExpressionAlternatives_1_1_2_0.eContents().get(1);
		
		//MultiplicationExpression returns expressions::Expression:
		//	UnaryPreExpression | TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | TypeCastExpression))*;
		@Override public ParserRule getRule() { return rule; }

		//UnaryPreExpression | TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
		//operator=MultiplicationOperator rightExpression=(UnaryPreExpression | TypeCastExpression))*
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnaryPreExpression
		public RuleCall getUnaryPreExpressionParserRuleCall_0() { return cUnaryPreExpressionParserRuleCall_0; }

		//TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | TypeCastExpression))*
		public Group getGroup_1() { return cGroup_1; }

		//TypeCastExpression
		public RuleCall getTypeCastExpressionParserRuleCall_1_0() { return cTypeCastExpressionParserRuleCall_1_0; }

		//({commonExpressions::ArithmeticExpression.leftExpression=current} operator=MultiplicationOperator
		//rightExpression=(UnaryPreExpression | TypeCastExpression))*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{commonExpressions::ArithmeticExpression.leftExpression=current}
		public Action getArithmeticExpressionLeftExpressionAction_1_1_0() { return cArithmeticExpressionLeftExpressionAction_1_1_0; }

		//operator=MultiplicationOperator
		public Assignment getOperatorAssignment_1_1_1() { return cOperatorAssignment_1_1_1; }

		//MultiplicationOperator
		public RuleCall getOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0() { return cOperatorMultiplicationOperatorEnumRuleCall_1_1_1_0; }

		//rightExpression=(UnaryPreExpression | TypeCastExpression)
		public Assignment getRightExpressionAssignment_1_1_2() { return cRightExpressionAssignment_1_1_2; }

		//UnaryPreExpression | TypeCastExpression
		public Alternatives getRightExpressionAlternatives_1_1_2_0() { return cRightExpressionAlternatives_1_1_2_0; }

		//UnaryPreExpression
		public RuleCall getRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0() { return cRightExpressionUnaryPreExpressionParserRuleCall_1_1_2_0_0; }

		//TypeCastExpression
		public RuleCall getRightExpressionTypeCastExpressionParserRuleCall_1_1_2_0_1() { return cRightExpressionTypeCastExpressionParserRuleCall_1_1_2_0_1; }
	}

	public class UnaryPreExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPreExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnaryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorUnaryPreOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cEnclosedExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEnclosedExpressionTypeCastExpressionParserRuleCall_2_0 = (RuleCall)cEnclosedExpressionAssignment_2.eContents().get(0);
		
		//// end of ArithmeticExpression
		//// UnaryPreExpression
		//UnaryPreExpression returns expressions::Expression:
		//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=TypeCastExpression;
		@Override public ParserRule getRule() { return rule; }

		//{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=TypeCastExpression
		public Group getGroup() { return cGroup; }

		//{commonExpressions::UnaryExpression}
		public Action getUnaryExpressionAction_0() { return cUnaryExpressionAction_0; }

		//operator=UnaryPreOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//UnaryPreOperator
		public RuleCall getOperatorUnaryPreOperatorEnumRuleCall_1_0() { return cOperatorUnaryPreOperatorEnumRuleCall_1_0; }

		//enclosedExpression=TypeCastExpression
		public Assignment getEnclosedExpressionAssignment_2() { return cEnclosedExpressionAssignment_2; }

		//TypeCastExpression
		public RuleCall getEnclosedExpressionTypeCastExpressionParserRuleCall_2_0() { return cEnclosedExpressionTypeCastExpressionParserRuleCall_2_0; }
	}

	public class TypeCastExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeCastExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOperandParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cTypeCastExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cDataTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cDataTypeDataTypeCrossReference_1_2_0 = (CrossReference)cDataTypeAssignment_1_2.eContents().get(0);
		private final RuleCall cDataTypeDataTypeDATATYPEParserRuleCall_1_2_0_1 = (RuleCall)cDataTypeDataTypeCrossReference_1_2_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cEnclosedExpressionAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cEnclosedExpressionOperandParserRuleCall_1_4_0 = (RuleCall)cEnclosedExpressionAssignment_1_4.eContents().get(0);
		
		//// end of UnaryPreExpression
		//TypeCastExpression returns expressions::Expression:
		//	Operand | {actionlanguage::TypeCastExpression} "(" dataType=[types::DataType|DATATYPE] ")" enclosedExpression=Operand;
		@Override public ParserRule getRule() { return rule; }

		//Operand | {actionlanguage::TypeCastExpression} "(" dataType=[types::DataType|DATATYPE] ")" enclosedExpression=Operand
		public Alternatives getAlternatives() { return cAlternatives; }

		//Operand
		public RuleCall getOperandParserRuleCall_0() { return cOperandParserRuleCall_0; }

		//{actionlanguage::TypeCastExpression} "(" dataType=[types::DataType|DATATYPE] ")" enclosedExpression=Operand
		public Group getGroup_1() { return cGroup_1; }

		//{actionlanguage::TypeCastExpression}
		public Action getTypeCastExpressionAction_1_0() { return cTypeCastExpressionAction_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//dataType=[types::DataType|DATATYPE]
		public Assignment getDataTypeAssignment_1_2() { return cDataTypeAssignment_1_2; }

		//[types::DataType|DATATYPE]
		public CrossReference getDataTypeDataTypeCrossReference_1_2_0() { return cDataTypeDataTypeCrossReference_1_2_0; }

		//DATATYPE
		public RuleCall getDataTypeDataTypeDATATYPEParserRuleCall_1_2_0_1() { return cDataTypeDataTypeDATATYPEParserRuleCall_1_2_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//enclosedExpression=Operand
		public Assignment getEnclosedExpressionAssignment_1_4() { return cEnclosedExpressionAssignment_1_4; }

		//Operand
		public RuleCall getEnclosedExpressionOperandParserRuleCall_1_4_0() { return cEnclosedExpressionOperandParserRuleCall_1_4_0; }
	}

	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendedTypedNamedElementExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTimeValueExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cOperationCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTriggerMessageExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNoAttributeSelectorExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//// Operand
		//Operand returns expressions::Expression:
		//	"(" Expression ")" | LiteralExpression | ExtendedTypedNamedElementExpression | TimeValueExpression | OperationCall |
		//	TriggerMessageExpression | NoAttributeSelectorExpression;
		@Override public ParserRule getRule() { return rule; }

		//"(" Expression ")" | LiteralExpression | ExtendedTypedNamedElementExpression | TimeValueExpression | OperationCall |
		//TriggerMessageExpression | NoAttributeSelectorExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_1() { return cLiteralExpressionParserRuleCall_1; }

		//ExtendedTypedNamedElementExpression
		public RuleCall getExtendedTypedNamedElementExpressionParserRuleCall_2() { return cExtendedTypedNamedElementExpressionParserRuleCall_2; }

		//TimeValueExpression
		public RuleCall getTimeValueExpressionParserRuleCall_3() { return cTimeValueExpressionParserRuleCall_3; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall_4() { return cOperationCallParserRuleCall_4; }

		//TriggerMessageExpression
		public RuleCall getTriggerMessageExpressionParserRuleCall_5() { return cTriggerMessageExpressionParserRuleCall_5; }

		//NoAttributeSelectorExpression
		public RuleCall getNoAttributeSelectorExpressionParserRuleCall_6() { return cNoAttributeSelectorExpressionParserRuleCall_6; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//// end of Operand
		//LiteralExpression returns commonExpressions::LiteralExpression:
		//	{commonExpressions::LiteralExpression} value=Literal;
		@Override public ParserRule getRule() { return rule; }

		//{commonExpressions::LiteralExpression} value=Literal
		public Group getGroup() { return cGroup; }

		//{commonExpressions::LiteralExpression}
		public Action getLiteralExpressionAction_0() { return cLiteralExpressionAction_0; }

		//value=Literal
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_0() { return cValueLiteralParserRuleCall_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNUMBERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBOOLEANTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Keyword cNullKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Literal returns ecore::EString:
		//	NUMBER | BOOLEAN | INT | "null";
		@Override public ParserRule getRule() { return rule; }

		//NUMBER | BOOLEAN | INT | "null"
		public Alternatives getAlternatives() { return cAlternatives; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_0() { return cNUMBERTerminalRuleCall_0; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_1() { return cBOOLEANTerminalRuleCall_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }

		//"null"
		public Keyword getNullKeyword_3() { return cNullKeyword_3; }
	}

	public class TimeValueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimeValueExpression");
		private final Assignment cTimeValueAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cTimeValueTimeValueCrossReference_0 = (CrossReference)cTimeValueAssignment.eContents().get(0);
		private final RuleCall cTimeValueTimeValueMINORMAXKEYWORDTerminalRuleCall_0_1 = (RuleCall)cTimeValueTimeValueCrossReference_0.eContents().get(1);
		
		//TimeValueExpression returns actionlanguage::TimeValueExpression:
		//	timeValue=[valuetype::TimeValue|MINORMAXKEYWORD];
		@Override public ParserRule getRule() { return rule; }

		//timeValue=[valuetype::TimeValue|MINORMAXKEYWORD]
		public Assignment getTimeValueAssignment() { return cTimeValueAssignment; }

		//[valuetype::TimeValue|MINORMAXKEYWORD]
		public CrossReference getTimeValueTimeValueCrossReference_0() { return cTimeValueTimeValueCrossReference_0; }

		//MINORMAXKEYWORD
		public RuleCall getTimeValueTimeValueMINORMAXKEYWORDTerminalRuleCall_0_1() { return cTimeValueTimeValueMINORMAXKEYWORDTerminalRuleCall_0_1; }
	}

	public class ExtendedTypedNamedElementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExtendedTypedNamedElementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTypedNamedElementExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cPositionAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cPositionPositionSelectorExpressionParserRuleCall_1_0_2_0 = (RuleCall)cPositionAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cAssignmentLhs_typedNamedElementExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cIncrementDecrementOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0 = (RuleCall)cIncrementDecrementOperatorAssignment_1_1_1.eContents().get(0);
		
		//ExtendedTypedNamedElementExpression returns expressions::Expression:
		//	TypedNamedElementExpression
		//	({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "->"
		//	position=PositionSelectorExpression | // unary post increment/decrement			
		//	{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//	incrementDecrementOperator=IncrementDecrementOperatorExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//TypedNamedElementExpression ({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
		//"->" position=PositionSelectorExpression | // unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression)?
		public Group getGroup() { return cGroup; }

		//TypedNamedElementExpression
		public RuleCall getTypedNamedElementExpressionParserRuleCall_0() { return cTypedNamedElementExpressionParserRuleCall_0; }

		//({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "->"
		//position=PositionSelectorExpression | // unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "->"
		//position=PositionSelectorExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current}
		public Action getDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0() { return cDiscreteInteractionEndpointReferenceTypedNamedElementExpressionAction_1_0_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0_1() { return cHyphenMinusGreaterThanSignKeyword_1_0_1; }

		//position=PositionSelectorExpression
		public Assignment getPositionAssignment_1_0_2() { return cPositionAssignment_1_0_2; }

		//PositionSelectorExpression
		public RuleCall getPositionPositionSelectorExpressionParserRuleCall_1_0_2_0() { return cPositionPositionSelectorExpressionParserRuleCall_1_0_2_0; }

		//// unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		//incrementDecrementOperator=IncrementDecrementOperatorExpression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//// unary post increment/decrement			
		//{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
		public Action getAssignmentLhs_typedNamedElementExpressionAction_1_1_0() { return cAssignmentLhs_typedNamedElementExpressionAction_1_1_0; }

		//incrementDecrementOperator=IncrementDecrementOperatorExpression
		public Assignment getIncrementDecrementOperatorAssignment_1_1_1() { return cIncrementDecrementOperatorAssignment_1_1_1; }

		//IncrementDecrementOperatorExpression
		public RuleCall getIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0() { return cIncrementDecrementOperatorIncrementDecrementOperatorExpressionEnumRuleCall_1_1_1_0; }
	}

	public class TypedNamedElementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedNamedElementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypedNamedElementAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypedNamedElementTypedNamedElementCrossReference_0_0 = (CrossReference)cTypedNamedElementAssignment_0.eContents().get(0);
		private final RuleCall cTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1 = (RuleCall)cTypedNamedElementTypedNamedElementCrossReference_0_0.eContents().get(1);
		private final Assignment cElementAccessorsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cElementAccessorsAlternatives_1_0 = (Alternatives)cElementAccessorsAssignment_1.eContents().get(0);
		private final RuleCall cElementAccessorsArrayIndexExpressionParserRuleCall_1_0_0 = (RuleCall)cElementAccessorsAlternatives_1_0.eContents().get(0);
		private final RuleCall cElementAccessorsAttributeAccessorExpressionParserRuleCall_1_0_1 = (RuleCall)cElementAccessorsAlternatives_1_0.eContents().get(1);
		
		//TypedNamedElementExpression returns actionlanguage::TypedNamedElementExpression:
		//	typedNamedElement=[behavior::TypedNamedElement] elementAccessors+=(ArrayIndexExpression |
		//	AttributeAccessorExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//typedNamedElement=[behavior::TypedNamedElement] elementAccessors+=(ArrayIndexExpression | AttributeAccessorExpression)*
		public Group getGroup() { return cGroup; }

		//typedNamedElement=[behavior::TypedNamedElement]
		public Assignment getTypedNamedElementAssignment_0() { return cTypedNamedElementAssignment_0; }

		//[behavior::TypedNamedElement]
		public CrossReference getTypedNamedElementTypedNamedElementCrossReference_0_0() { return cTypedNamedElementTypedNamedElementCrossReference_0_0; }

		//ID
		public RuleCall getTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1() { return cTypedNamedElementTypedNamedElementIDTerminalRuleCall_0_0_1; }

		//elementAccessors+=(ArrayIndexExpression | AttributeAccessorExpression)*
		public Assignment getElementAccessorsAssignment_1() { return cElementAccessorsAssignment_1; }

		//ArrayIndexExpression | AttributeAccessorExpression
		public Alternatives getElementAccessorsAlternatives_1_0() { return cElementAccessorsAlternatives_1_0; }

		//ArrayIndexExpression
		public RuleCall getElementAccessorsArrayIndexExpressionParserRuleCall_1_0_0() { return cElementAccessorsArrayIndexExpressionParserRuleCall_1_0_0; }

		//AttributeAccessorExpression
		public RuleCall getElementAccessorsAttributeAccessorExpressionParserRuleCall_1_0_1() { return cElementAccessorsAttributeAccessorExpressionParserRuleCall_1_0_1; }
	}

	public class ArrayIndexExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayIndexExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexArithmeticExpressionParserRuleCall_1_0 = (RuleCall)cIndexAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ArrayIndexExpression returns actionlanguage::ArrayIndexExpression:
		//	"[" index=ArithmeticExpression "]";
		@Override public ParserRule getRule() { return rule; }

		//"[" index=ArithmeticExpression "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//index=ArithmeticExpression
		public Assignment getIndexAssignment_1() { return cIndexAssignment_1; }

		//ArithmeticExpression
		public RuleCall getIndexArithmeticExpressionParserRuleCall_1_0() { return cIndexArithmeticExpressionParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class AttributeAccessorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeAccessorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAttributeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cAttributeAttributeCrossReference_1_0 = (CrossReference)cAttributeAssignment_1.eContents().get(0);
		private final RuleCall cAttributeAttributeIDTerminalRuleCall_1_0_1 = (RuleCall)cAttributeAttributeCrossReference_1_0.eContents().get(1);
		
		//AttributeAccessorExpression returns actionlanguage::AttributeAccessorExpression:
		//	"." attribute=[types::Attribute];
		@Override public ParserRule getRule() { return rule; }

		//"." attribute=[types::Attribute]
		public Group getGroup() { return cGroup; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//attribute=[types::Attribute]
		public Assignment getAttributeAssignment_1() { return cAttributeAssignment_1; }

		//[types::Attribute]
		public CrossReference getAttributeAttributeCrossReference_1_0() { return cAttributeAttributeCrossReference_1_0; }

		//ID
		public RuleCall getAttributeAttributeIDTerminalRuleCall_1_0_1() { return cAttributeAttributeIDTerminalRuleCall_1_0_1; }
	}

	public class NoAttributeSelectorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NoAttributeSelectorExpression");
		private final Assignment cPositionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPositionPositionSelectorExpressionParserRuleCall_0 = (RuleCall)cPositionAssignment.eContents().get(0);
		
		//NoAttributeSelectorExpression returns actionlanguage::DiscreteInteractionEndpointReference:
		//	position=PositionSelectorExpression;
		@Override public ParserRule getRule() { return rule; }

		//position=PositionSelectorExpression
		public Assignment getPositionAssignment() { return cPositionAssignment; }

		//PositionSelectorExpression
		public RuleCall getPositionPositionSelectorExpressionParserRuleCall_0() { return cPositionPositionSelectorExpressionParserRuleCall_0; }
	}

	public class PositionSelectorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PositionSelectorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKindPositionSelectorKindEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSuccessorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSuccessorPositionSelectorExpressionParserRuleCall_1_1_0 = (RuleCall)cSuccessorAssignment_1_1.eContents().get(0);
		
		//PositionSelectorExpression returns actionlanguage::PositionSelector:
		//	kind=PositionSelectorKind ("->" successor=PositionSelectorExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//kind=PositionSelectorKind ("->" successor=PositionSelectorExpression)?
		public Group getGroup() { return cGroup; }

		//kind=PositionSelectorKind
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }

		//PositionSelectorKind
		public RuleCall getKindPositionSelectorKindEnumRuleCall_0_0() { return cKindPositionSelectorKindEnumRuleCall_0_0; }

		//("->" successor=PositionSelectorExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0() { return cHyphenMinusGreaterThanSignKeyword_1_0; }

		//successor=PositionSelectorExpression
		public Assignment getSuccessorAssignment_1_1() { return cSuccessorAssignment_1_1; }

		//PositionSelectorExpression
		public RuleCall getSuccessorPositionSelectorExpressionParserRuleCall_1_1_0() { return cSuccessorPositionSelectorExpressionParserRuleCall_1_1_0; }
	}

	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cOperationOperationCrossReference_0_0 = (CrossReference)cOperationAssignment_0.eContents().get(0);
		private final RuleCall cOperationOperationIDTerminalRuleCall_0_0_1 = (RuleCall)cOperationOperationCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterBindingAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_0_0 = (RuleCall)cParameterBindingAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterBindingAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterBindingParamaterBindingParserRuleCall_2_1_1_0 = (RuleCall)cParameterBindingAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//OperationCall returns actionlanguage::OperationCall:
		//	operation=[behavior::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)?
		//	")";
		@Override public ParserRule getRule() { return rule; }

		//operation=[behavior::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)? ")"
		public Group getGroup() { return cGroup; }

		//operation=[behavior::Operation]
		public Assignment getOperationAssignment_0() { return cOperationAssignment_0; }

		//[behavior::Operation]
		public CrossReference getOperationOperationCrossReference_0_0() { return cOperationOperationCrossReference_0_0; }

		//ID
		public RuleCall getOperationOperationIDTerminalRuleCall_0_0_1() { return cOperationOperationIDTerminalRuleCall_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_0() { return cParameterBindingAssignment_2_0; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_0_0() { return cParameterBindingParamaterBindingParserRuleCall_2_0_0; }

		//("," parameterBinding+=ParamaterBinding)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameterBinding+=ParamaterBinding
		public Assignment getParameterBindingAssignment_2_1_1() { return cParameterBindingAssignment_2_1_1; }

		//ParamaterBinding
		public RuleCall getParameterBindingParamaterBindingParserRuleCall_2_1_1_0() { return cParameterBindingParamaterBindingParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ParamaterBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParamaterBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterBindingAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cParameterParameterCrossReference_1_0 = (CrossReference)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_1_0_1 = (RuleCall)cParameterParameterCrossReference_1_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ParamaterBinding returns behavior::ParameterBinding:
		//	{behavior::ParameterBinding} parameter=[behavior::Parameter] ":=" value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//{behavior::ParameterBinding} parameter=[behavior::Parameter] ":=" value=Expression
		public Group getGroup() { return cGroup; }

		//{behavior::ParameterBinding}
		public Action getParameterBindingAction_0() { return cParameterBindingAction_0; }

		//parameter=[behavior::Parameter]
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }

		//[behavior::Parameter]
		public CrossReference getParameterParameterCrossReference_1_0() { return cParameterParameterCrossReference_1_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_1_0_1() { return cParameterParameterIDTerminalRuleCall_1_0_1; }

		//":="
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class TriggerMessageExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TriggerMessageExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMessageTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cMessageTypeMessageTypeCrossReference_0_0 = (CrossReference)cMessageTypeAssignment_0.eContents().get(0);
		private final RuleCall cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cMessageTypeMessageTypeCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParameterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cParameterParameterCrossReference_2_0 = (CrossReference)cParameterAssignment_2.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_2_0_1 = (RuleCall)cParameterParameterCrossReference_2_0.eContents().get(1);
		
		//// TriggerMessageExpression
		//TriggerMessageExpression returns actionlanguage::TriggerMessageExpression:
		//	messageType=[msgtype::MessageType] "->" parameter=[behavior::Parameter];
		@Override public ParserRule getRule() { return rule; }

		//messageType=[msgtype::MessageType] "->" parameter=[behavior::Parameter]
		public Group getGroup() { return cGroup; }

		//messageType=[msgtype::MessageType]
		public Assignment getMessageTypeAssignment_0() { return cMessageTypeAssignment_0; }

		//[msgtype::MessageType]
		public CrossReference getMessageTypeMessageTypeCrossReference_0_0() { return cMessageTypeMessageTypeCrossReference_0_0; }

		//ID
		public RuleCall getMessageTypeMessageTypeIDTerminalRuleCall_0_0_1() { return cMessageTypeMessageTypeIDTerminalRuleCall_0_0_1; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }

		//parameter=[behavior::Parameter]
		public Assignment getParameterAssignment_2() { return cParameterAssignment_2; }

		//[behavior::Parameter]
		public CrossReference getParameterParameterCrossReference_2_0() { return cParameterParameterCrossReference_2_0; }

		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_2_0_1() { return cParameterParameterIDTerminalRuleCall_2_0_1; }
	}

	public class DATATYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DATATYPE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//DATATYPE returns ecore::EString:
		//	ID ("[" INT "]")*;
		@Override public ParserRule getRule() { return rule; }

		//ID ("[" INT "]")*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("[" INT "]")*
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	
	
	public class UnaryPostIncrementDecrementOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPostIncrementDecrementOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryPostIncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class IncrementDecrementOperatorExpressionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "IncrementDecrementOperatorExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINCREMENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINCREMENTPlusSignPlusSignKeyword_0_0 = (Keyword)cINCREMENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDECREMENTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDECREMENTHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDECREMENTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum IncrementDecrementOperatorExpression returns actionlanguage::IncrementDecrementOperator:
		//	INCREMENT="++" | DECREMENT="--";
		public EnumRule getRule() { return rule; }

		//INCREMENT="++" | DECREMENT="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INCREMENT="++"
		public EnumLiteralDeclaration getINCREMENTEnumLiteralDeclaration_0() { return cINCREMENTEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getINCREMENTPlusSignPlusSignKeyword_0_0() { return cINCREMENTPlusSignPlusSignKeyword_0_0; }

		//DECREMENT="--"
		public EnumLiteralDeclaration getDECREMENTEnumLiteralDeclaration_1() { return cDECREMENTEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDECREMENTHyphenMinusHyphenMinusKeyword_1_0() { return cDECREMENTHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class AssignOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cASSIGNEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cASSIGNColonEqualsSignKeyword_0_0 = (Keyword)cASSIGNEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUS_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUS_EQUALPlusSignEqualsSignKeyword_1_0 = (Keyword)cPLUS_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMINUS_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMINUS_EQUALHyphenMinusEqualsSignKeyword_2_0 = (Keyword)cMINUS_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum AssignOperator returns actionlanguage::AssignOperator:
		//	ASSIGN=":=" | PLUS_EQUAL="+=" | MINUS_EQUAL="-=";
		public EnumRule getRule() { return rule; }

		//ASSIGN=":=" | PLUS_EQUAL="+=" | MINUS_EQUAL="-="
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASSIGN=":="
		public EnumLiteralDeclaration getASSIGNEnumLiteralDeclaration_0() { return cASSIGNEnumLiteralDeclaration_0; }

		//":="
		public Keyword getASSIGNColonEqualsSignKeyword_0_0() { return cASSIGNColonEqualsSignKeyword_0_0; }

		//PLUS_EQUAL="+="
		public EnumLiteralDeclaration getPLUS_EQUALEnumLiteralDeclaration_1() { return cPLUS_EQUALEnumLiteralDeclaration_1; }

		//"+="
		public Keyword getPLUS_EQUALPlusSignEqualsSignKeyword_1_0() { return cPLUS_EQUALPlusSignEqualsSignKeyword_1_0; }

		//MINUS_EQUAL="-="
		public EnumLiteralDeclaration getMINUS_EQUALEnumLiteralDeclaration_2() { return cMINUS_EQUALEnumLiteralDeclaration_2; }

		//"-="
		public Keyword getMINUS_EQUALHyphenMinusEqualsSignKeyword_2_0() { return cMINUS_EQUALHyphenMinusEqualsSignKeyword_2_0; }
	}

	public class LogicalOrOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOrOperator");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORVerticalLineVerticalLineKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalOrOperator returns commonExpressions::LogicOperator:
		//	OR="||";
		public EnumRule getRule() { return rule; }

		//OR="||"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }

		//"||"
		public Keyword getORVerticalLineVerticalLineKeyword_0() { return cORVerticalLineVerticalLineKeyword_0; }
	}

	public class LogicalAndOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAndOperator");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDAmpersandAmpersandKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum LogicalAndOperator returns commonExpressions::LogicOperator:
		//	AND="&&";
		public EnumRule getRule() { return rule; }

		//AND="&&"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }

		//"&&"
		public Keyword getANDAmpersandAmpersandKeyword_0() { return cANDAmpersandAmpersandKeyword_0; }
	}

	public class ComparingEQNEQOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingEQNEQOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUNEQUALLessThanSignGreaterThanSignKeyword_1_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
		//	EQUAL="==" | UNEQUAL="<>";
		public EnumRule getRule() { return rule; }

		//EQUAL="==" | UNEQUAL="<>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL="=="
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQUALEqualsSignEqualsSignKeyword_0_0() { return cEQUALEqualsSignEqualsSignKeyword_0_0; }

		//UNEQUAL="<>"
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_1() { return cUNEQUALEnumLiteralDeclaration_1; }

		//"<>"
		public Keyword getUNEQUALLessThanSignGreaterThanSignKeyword_1_0() { return cUNEQUALLessThanSignGreaterThanSignKeyword_1_0; }
	}

	public class ComparingRelOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparingRelOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLESSLessThanSignKeyword_0_0 = (Keyword)cLESSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGREATERGreaterThanSignKeyword_3_0 = (Keyword)cGREATEREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
		//	LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">";
		public EnumRule getRule() { return rule; }

		//LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">"
		public Alternatives getAlternatives() { return cAlternatives; }

		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_0() { return cLESSEnumLiteralDeclaration_0; }

		//"<"
		public Keyword getLESSLessThanSignKeyword_0_0() { return cLESSLessThanSignKeyword_0_0; }

		//LESS_OR_EQUAL="<="
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_1() { return cLESS_OR_EQUALEnumLiteralDeclaration_1; }

		//"<="
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_1_0; }

		//GREATER_OR_EQUAL=">="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_2() { return cGREATER_OR_EQUALEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0; }

		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_3() { return cGREATEREnumLiteralDeclaration_3; }

		//">"
		public Keyword getGREATERGreaterThanSignKeyword_3_0() { return cGREATERGreaterThanSignKeyword_3_0; }
	}

	public class AdditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
		//	PLUS="+" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class MultiplicationOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTIMESAsteriskKeyword_0_0 = (Keyword)cTIMESEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVIDESolidusKeyword_1_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODULOEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODULOPercentSignKeyword_2_0 = (Keyword)cMODULOEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
		//	TIMES="*" | DIVIDE="/" | MODULO="%";
		public EnumRule getRule() { return rule; }

		//TIMES="*" | DIVIDE="/" | MODULO="%"
		public Alternatives getAlternatives() { return cAlternatives; }

		//TIMES="*"
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration_0() { return cTIMESEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getTIMESAsteriskKeyword_0_0() { return cTIMESAsteriskKeyword_0_0; }

		//DIVIDE="/"
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_1() { return cDIVIDEEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDIVIDESolidusKeyword_1_0() { return cDIVIDESolidusKeyword_1_0; }

		//MODULO="%"
		public EnumLiteralDeclaration getMODULOEnumLiteralDeclaration_2() { return cMODULOEnumLiteralDeclaration_2; }

		//"%"
		public Keyword getMODULOPercentSignKeyword_2_0() { return cMODULOPercentSignKeyword_2_0; }
	}

	public class UnaryPreOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryPreOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNOTNotKeyword_0_0 = (Keyword)cNOTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
		//	NOT="not" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//NOT="not" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT="not"
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_0() { return cNOTEnumLiteralDeclaration_0; }

		//"not"
		public Keyword getNOTNotKeyword_0_0() { return cNOTNotKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class PositionSelectorKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "PositionSelectorKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSELFEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSELFSelfKeyword_0_0 = (Keyword)cSELFEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFIRSTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFIRSTFirstKeyword_1_0 = (Keyword)cFIRSTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLASTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLASTLastKeyword_2_0 = (Keyword)cLASTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cPREVEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cPREVPrevKeyword_3_0 = (Keyword)cPREVEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cNEXTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cNEXTNextKeyword_4_0 = (Keyword)cNEXTEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
		//	SELF="self" | FIRST="first" | LAST="last" | PREV="prev" | NEXT="next";
		public EnumRule getRule() { return rule; }

		//SELF="self" | FIRST="first" | LAST="last" | PREV="prev" | NEXT="next"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SELF="self"
		public EnumLiteralDeclaration getSELFEnumLiteralDeclaration_0() { return cSELFEnumLiteralDeclaration_0; }

		//"self"
		public Keyword getSELFSelfKeyword_0_0() { return cSELFSelfKeyword_0_0; }

		//FIRST="first"
		public EnumLiteralDeclaration getFIRSTEnumLiteralDeclaration_1() { return cFIRSTEnumLiteralDeclaration_1; }

		//"first"
		public Keyword getFIRSTFirstKeyword_1_0() { return cFIRSTFirstKeyword_1_0; }

		//LAST="last"
		public EnumLiteralDeclaration getLASTEnumLiteralDeclaration_2() { return cLASTEnumLiteralDeclaration_2; }

		//"last"
		public Keyword getLASTLastKeyword_2_0() { return cLASTLastKeyword_2_0; }

		//PREV="prev"
		public EnumLiteralDeclaration getPREVEnumLiteralDeclaration_3() { return cPREVEnumLiteralDeclaration_3; }

		//"prev"
		public Keyword getPREVPrevKeyword_3_0() { return cPREVPrevKeyword_3_0; }

		//NEXT="next"
		public EnumLiteralDeclaration getNEXTEnumLiteralDeclaration_4() { return cNEXTEnumLiteralDeclaration_4; }

		//"next"
		public Keyword getNEXTNextKeyword_4_0() { return cNEXTNextKeyword_4_0; }
	}
	
	private final EntryElements pEntry;
	private final BlockElements pBlock;
	private final ForLoopElements pForLoop;
	private final ForLoopCountingExpressionElements pForLoopCountingExpression;
	private final WhileLoopElements pWhileLoop;
	private final DoWhileLoopElements pDoWhileLoop;
	private final IfStatementElements pIfStatement;
	private final ElseIfStatementElements pElseIfStatement;
	private final ReturnStatementElements pReturnStatement;
	private final OperationCallStatementElements pOperationCallStatement;
	private final ExpressionStartRuleElements pExpressionStartRule;
	private final UnaryPostIncrementDecrementOperatorElements unknownRuleUnaryPostIncrementDecrementOperator;
	private final AssignmentElements pAssignment;
	private final IncrementDecrementOperatorExpressionElements unknownRuleIncrementDecrementOperatorExpression;
	private final AssignOperatorElements unknownRuleAssignOperator;
	private final InitializeExpressionElements pInitializeExpression;
	private final ArrayInitializeExpressionElements pArrayInitializeExpression;
	private final LocalVariableOrConstantDeclarationStatementElements pLocalVariableOrConstantDeclarationStatement;
	private final LocalVariableDeclarationElements pLocalVariableDeclaration;
	private final LocalConstantDeclarationElements pLocalConstantDeclaration;
	private final NondeterministicChoiceExpressionElements pNondeterministicChoiceExpression;
	private final RangeElements pRange;
	private final LONGElements pLONG;
	private final ExpressionElements pExpression;
	private final LogicalExpressionElements pLogicalExpression;
	private final LogicalOrExpressionElements pLogicalOrExpression;
	private final LogicalOrOperatorElements unknownRuleLogicalOrOperator;
	private final LogicalAndExpressionElements pLogicalAndExpression;
	private final LogicalAndOperatorElements unknownRuleLogicalAndOperator;
	private final ComparisonExpressionElements pComparisonExpression;
	private final ComparisonHigherOpExpressionElements pComparisonHigherOpExpression;
	private final ComparingEQNEQOperatorElements unknownRuleComparingEQNEQOperator;
	private final ComparingRelOperatorElements unknownRuleComparingRelOperator;
	private final ArithmeticExpressionElements pArithmeticExpression;
	private final AdditionExpressionElements pAdditionExpression;
	private final AdditionOperatorElements unknownRuleAdditionOperator;
	private final MultiplicationExpressionElements pMultiplicationExpression;
	private final MultiplicationOperatorElements unknownRuleMultiplicationOperator;
	private final UnaryPreExpressionElements pUnaryPreExpression;
	private final UnaryPreOperatorElements unknownRuleUnaryPreOperator;
	private final TypeCastExpressionElements pTypeCastExpression;
	private final OperandElements pOperand;
	private final LiteralExpressionElements pLiteralExpression;
	private final LiteralElements pLiteral;
	private final TimeValueExpressionElements pTimeValueExpression;
	private final TerminalRule tMINORMAXKEYWORD;
	private final ExtendedTypedNamedElementExpressionElements pExtendedTypedNamedElementExpression;
	private final TypedNamedElementExpressionElements pTypedNamedElementExpression;
	private final ArrayIndexExpressionElements pArrayIndexExpression;
	private final AttributeAccessorExpressionElements pAttributeAccessorExpression;
	private final NoAttributeSelectorExpressionElements pNoAttributeSelectorExpression;
	private final PositionSelectorExpressionElements pPositionSelectorExpression;
	private final PositionSelectorKindElements unknownRulePositionSelectorKind;
	private final OperationCallElements pOperationCall;
	private final ParamaterBindingElements pParamaterBinding;
	private final TriggerMessageExpressionElements pTriggerMessageExpression;
	private final TerminalRule tNUMBER;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tID;
	private final DATATYPEElements pDATATYPE;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public ActionLanguageGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pEntry = new EntryElements();
		this.pBlock = new BlockElements();
		this.pForLoop = new ForLoopElements();
		this.pForLoopCountingExpression = new ForLoopCountingExpressionElements();
		this.pWhileLoop = new WhileLoopElements();
		this.pDoWhileLoop = new DoWhileLoopElements();
		this.pIfStatement = new IfStatementElements();
		this.pElseIfStatement = new ElseIfStatementElements();
		this.pReturnStatement = new ReturnStatementElements();
		this.pOperationCallStatement = new OperationCallStatementElements();
		this.pExpressionStartRule = new ExpressionStartRuleElements();
		this.unknownRuleUnaryPostIncrementDecrementOperator = new UnaryPostIncrementDecrementOperatorElements();
		this.pAssignment = new AssignmentElements();
		this.unknownRuleIncrementDecrementOperatorExpression = new IncrementDecrementOperatorExpressionElements();
		this.unknownRuleAssignOperator = new AssignOperatorElements();
		this.pInitializeExpression = new InitializeExpressionElements();
		this.pArrayInitializeExpression = new ArrayInitializeExpressionElements();
		this.pLocalVariableOrConstantDeclarationStatement = new LocalVariableOrConstantDeclarationStatementElements();
		this.pLocalVariableDeclaration = new LocalVariableDeclarationElements();
		this.pLocalConstantDeclaration = new LocalConstantDeclarationElements();
		this.pNondeterministicChoiceExpression = new NondeterministicChoiceExpressionElements();
		this.pRange = new RangeElements();
		this.pLONG = new LONGElements();
		this.pExpression = new ExpressionElements();
		this.pLogicalExpression = new LogicalExpressionElements();
		this.pLogicalOrExpression = new LogicalOrExpressionElements();
		this.unknownRuleLogicalOrOperator = new LogicalOrOperatorElements();
		this.pLogicalAndExpression = new LogicalAndExpressionElements();
		this.unknownRuleLogicalAndOperator = new LogicalAndOperatorElements();
		this.pComparisonExpression = new ComparisonExpressionElements();
		this.pComparisonHigherOpExpression = new ComparisonHigherOpExpressionElements();
		this.unknownRuleComparingEQNEQOperator = new ComparingEQNEQOperatorElements();
		this.unknownRuleComparingRelOperator = new ComparingRelOperatorElements();
		this.pArithmeticExpression = new ArithmeticExpressionElements();
		this.pAdditionExpression = new AdditionExpressionElements();
		this.unknownRuleAdditionOperator = new AdditionOperatorElements();
		this.pMultiplicationExpression = new MultiplicationExpressionElements();
		this.unknownRuleMultiplicationOperator = new MultiplicationOperatorElements();
		this.pUnaryPreExpression = new UnaryPreExpressionElements();
		this.unknownRuleUnaryPreOperator = new UnaryPreOperatorElements();
		this.pTypeCastExpression = new TypeCastExpressionElements();
		this.pOperand = new OperandElements();
		this.pLiteralExpression = new LiteralExpressionElements();
		this.pLiteral = new LiteralElements();
		this.pTimeValueExpression = new TimeValueExpressionElements();
		this.tMINORMAXKEYWORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINORMAXKEYWORD");
		this.pExtendedTypedNamedElementExpression = new ExtendedTypedNamedElementExpressionElements();
		this.pTypedNamedElementExpression = new TypedNamedElementExpressionElements();
		this.pArrayIndexExpression = new ArrayIndexExpressionElements();
		this.pAttributeAccessorExpression = new AttributeAccessorExpressionElements();
		this.pNoAttributeSelectorExpression = new NoAttributeSelectorExpressionElements();
		this.pPositionSelectorExpression = new PositionSelectorExpressionElements();
		this.unknownRulePositionSelectorKind = new PositionSelectorKindElements();
		this.pOperationCall = new OperationCallElements();
		this.pParamaterBinding = new ParamaterBindingElements();
		this.pTriggerMessageExpression = new TriggerMessageExpressionElements();
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER");
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		this.pDATATYPE = new DATATYPEElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.uni_paderborn.fujaba.muml.ActionLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Entry returns expressions::Expression:
	//	Block | Expression | ArrayInitializeExpression;
	public EntryElements getEntryAccess() {
		return pEntry;
	}
	
	public ParserRule getEntryRule() {
		return getEntryAccess().getRule();
	}

	//Block returns actionlanguage::Block hidden(WS, ML_COMMENT, SL_COMMENT):
	//	{actionlanguage::Block} "{" expressions+=ExpressionStartRule* "}";
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// TODO: clarify if it makes sense to allow arbitrary expressions for
	//// the initializeExpression and countingExpression
	//ForLoop returns actionlanguage::ForLoop:
	//	"for" "(" initializeExpression=Assignment loopTest=Expression ";" countingExpression=ForLoopCountingExpression ")"
	//	block=Block;
	public ForLoopElements getForLoopAccess() {
		return pForLoop;
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}

	//ForLoopCountingExpression returns actionlanguage::Assignment:
	//	lhs_typedNamedElementExpression=TypedNamedElementExpression
	//	(incrementDecrementOperator=UnaryPostIncrementDecrementOperator | assignOperator=AssignOperator
	//	rhs_assignExpression=Expression);
	public ForLoopCountingExpressionElements getForLoopCountingExpressionAccess() {
		return pForLoopCountingExpression;
	}
	
	public ParserRule getForLoopCountingExpressionRule() {
		return getForLoopCountingExpressionAccess().getRule();
	}

	//WhileLoop returns actionlanguage::WhileLoop:
	//	"while" "(" loopTest=Expression ")" block=Block;
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//DoWhileLoop returns actionlanguage::DoWhileLoop:
	//	"do" block=Block "while" "(" loopTest=Expression ");";
	public DoWhileLoopElements getDoWhileLoopAccess() {
		return pDoWhileLoop;
	}
	
	public ParserRule getDoWhileLoopRule() {
		return getDoWhileLoopAccess().getRule();
	}

	//IfStatement returns actionlanguage::IfStatement:
	//	"if" "(" ifCondition=Expression ")" ifBlock=Block elseIfStatements+=ElseIfStatement* ("else" elseBlock=Block)?;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//ElseIfStatement returns actionlanguage::ElseIfStatement:
	//	"elseif" "(" elseIfCondition=Expression ")" elseIfBlock=Block;
	public ElseIfStatementElements getElseIfStatementAccess() {
		return pElseIfStatement;
	}
	
	public ParserRule getElseIfStatementRule() {
		return getElseIfStatementAccess().getRule();
	}

	//ReturnStatement returns actionlanguage::ReturnStatement:
	//	{actionlanguage::ReturnStatement} "return" expression=Expression ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return pReturnStatement;
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//OperationCallStatement returns actionlanguage::OperationCall:
	//	OperationCall ";";
	public OperationCallStatementElements getOperationCallStatementAccess() {
		return pOperationCallStatement;
	}
	
	public ParserRule getOperationCallStatementRule() {
		return getOperationCallStatementAccess().getRule();
	}

	//ExpressionStartRule returns expressions::Expression:
	//	Assignment | ForLoop | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement |
	//	LocalVariableOrConstantDeclarationStatement | OperationCallStatement;
	public ExpressionStartRuleElements getExpressionStartRuleAccess() {
		return pExpressionStartRule;
	}
	
	public ParserRule getExpressionStartRuleRule() {
		return getExpressionStartRuleAccess().getRule();
	}

	//enum UnaryPostIncrementDecrementOperator returns actionlanguage::IncrementDecrementOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public UnaryPostIncrementDecrementOperatorElements getUnaryPostIncrementDecrementOperatorAccess() {
		return unknownRuleUnaryPostIncrementDecrementOperator;
	}
	
	public EnumRule getUnaryPostIncrementDecrementOperatorRule() {
		return getUnaryPostIncrementDecrementOperatorAccess().getRule();
	}

	//// Assignment
	//Assignment returns actionlanguage::Assignment:
	//	lhs_typedNamedElementExpression=TypedNamedElementExpression (assignOperator=AssignOperator
	//	rhs_assignExpression=InitializeExpression | incrementDecrementOperator=UnaryPostIncrementDecrementOperator) ";";
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//enum IncrementDecrementOperatorExpression returns actionlanguage::IncrementDecrementOperator:
	//	INCREMENT="++" | DECREMENT="--";
	public IncrementDecrementOperatorExpressionElements getIncrementDecrementOperatorExpressionAccess() {
		return unknownRuleIncrementDecrementOperatorExpression;
	}
	
	public EnumRule getIncrementDecrementOperatorExpressionRule() {
		return getIncrementDecrementOperatorExpressionAccess().getRule();
	}

	//enum AssignOperator returns actionlanguage::AssignOperator:
	//	ASSIGN=":=" | PLUS_EQUAL="+=" | MINUS_EQUAL="-=";
	public AssignOperatorElements getAssignOperatorAccess() {
		return unknownRuleAssignOperator;
	}
	
	public EnumRule getAssignOperatorRule() {
		return getAssignOperatorAccess().getRule();
	}

	//// end of assignment
	//// initialize expression
	//InitializeExpression returns expressions::Expression:
	//	ArrayInitializeExpression | NondeterministicChoiceExpression | Expression;
	public InitializeExpressionElements getInitializeExpressionAccess() {
		return pInitializeExpression;
	}
	
	public ParserRule getInitializeExpressionRule() {
		return getInitializeExpressionAccess().getRule();
	}

	//// end of initialize expression
	//// array initialization
	//ArrayInitializeExpression returns actionlanguage::ArrayInitializeExpression:
	//	"[" expressions+=InitializeExpression ("," expressions+=InitializeExpression)* "]";
	public ArrayInitializeExpressionElements getArrayInitializeExpressionAccess() {
		return pArrayInitializeExpression;
	}
	
	public ParserRule getArrayInitializeExpressionRule() {
		return getArrayInitializeExpressionAccess().getRule();
	}

	//// end of array initialization
	//// local variable declaration
	//LocalVariableOrConstantDeclarationStatement returns actionlanguage::LocalVariableDeclarationStatement:
	//	variable=(LocalVariableDeclaration | LocalConstantDeclaration);
	public LocalVariableOrConstantDeclarationStatementElements getLocalVariableOrConstantDeclarationStatementAccess() {
		return pLocalVariableOrConstantDeclarationStatement;
	}
	
	public ParserRule getLocalVariableOrConstantDeclarationStatementRule() {
		return getLocalVariableOrConstantDeclarationStatementAccess().getRule();
	}

	//LocalVariableDeclaration returns behavior::Variable:
	//	dataType=[types::DataType|DATATYPE] name=ID (":=" initializeExpression=InitializeExpression)? ";";
	public LocalVariableDeclarationElements getLocalVariableDeclarationAccess() {
		return pLocalVariableDeclaration;
	}
	
	public ParserRule getLocalVariableDeclarationRule() {
		return getLocalVariableDeclarationAccess().getRule();
	}

	//LocalConstantDeclaration returns behavior::Variable:
	//	constant?="const" dataType=[types::DataType|DATATYPE] name=ID ":=" initializeExpression=InitializeExpression ";";
	public LocalConstantDeclarationElements getLocalConstantDeclarationAccess() {
		return pLocalConstantDeclaration;
	}
	
	public ParserRule getLocalConstantDeclarationRule() {
		return getLocalConstantDeclarationAccess().getRule();
	}

	//// end of local variable declaration
	//// nondeterministic choice expression
	//NondeterministicChoiceExpression returns actionlanguage::NondeterministicChoiceExpression:
	//	dataType=[types::PrimitiveDataType] range=Range;
	public NondeterministicChoiceExpressionElements getNondeterministicChoiceExpressionAccess() {
		return pNondeterministicChoiceExpression;
	}
	
	public ParserRule getNondeterministicChoiceExpressionRule() {
		return getNondeterministicChoiceExpressionAccess().getRule();
	}

	//Range returns valuetype::Range:
	//	"<" lowerBound=LONG "," upperBound=LONG ">";
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//LONG returns ecore::ELong:
	//	INT;
	public LONGElements getLONGAccess() {
		return pLONG;
	}
	
	public ParserRule getLONGRule() {
		return getLONGAccess().getRule();
	}

	//// end of nondeterministic choice expression
	//Expression returns expressions::Expression:
	//	LogicalExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// LogicalExpression
	//LogicalExpression returns expressions::Expression:
	//	LogicalOrExpression;
	public LogicalExpressionElements getLogicalExpressionAccess() {
		return pLogicalExpression;
	}
	
	public ParserRule getLogicalExpressionRule() {
		return getLogicalExpressionAccess().getRule();
	}

	//LogicalOrExpression returns expressions::Expression:
	//	LogicalAndExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalOrOperator
	//	rightExpression=LogicalAndExpression)*;
	public LogicalOrExpressionElements getLogicalOrExpressionAccess() {
		return pLogicalOrExpression;
	}
	
	public ParserRule getLogicalOrExpressionRule() {
		return getLogicalOrExpressionAccess().getRule();
	}

	//enum LogicalOrOperator returns commonExpressions::LogicOperator:
	//	OR="||";
	public LogicalOrOperatorElements getLogicalOrOperatorAccess() {
		return unknownRuleLogicalOrOperator;
	}
	
	public EnumRule getLogicalOrOperatorRule() {
		return getLogicalOrOperatorAccess().getRule();
	}

	//LogicalAndExpression returns expressions::Expression:
	//	ComparisonExpression ({commonExpressions::LogicalExpression.leftExpression=current} operator=LogicalAndOperator
	//	rightExpression=ComparisonExpression)*;
	public LogicalAndExpressionElements getLogicalAndExpressionAccess() {
		return pLogicalAndExpression;
	}
	
	public ParserRule getLogicalAndExpressionRule() {
		return getLogicalAndExpressionAccess().getRule();
	}

	//enum LogicalAndOperator returns commonExpressions::LogicOperator:
	//	AND="&&";
	public LogicalAndOperatorElements getLogicalAndOperatorAccess() {
		return unknownRuleLogicalAndOperator;
	}
	
	public EnumRule getLogicalAndOperatorRule() {
		return getLogicalAndOperatorAccess().getRule();
	}

	//// end of LogicalExpression
	//// ComparisonExpression
	//ComparisonExpression returns expressions::Expression:
	//	ComparisonHigherOpExpression ({commonExpressions::ComparisonExpression.leftExpression=current}
	//	operator=ComparingEQNEQOperator rightExpression=ComparisonHigherOpExpression)?;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return pComparisonExpression;
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//ComparisonHigherOpExpression returns expressions::Expression:
	//	ArithmeticExpression ({commonExpressions::ComparisonExpression.leftExpression=current} operator=ComparingRelOperator
	//	rightExpression=ArithmeticExpression)?;
	public ComparisonHigherOpExpressionElements getComparisonHigherOpExpressionAccess() {
		return pComparisonHigherOpExpression;
	}
	
	public ParserRule getComparisonHigherOpExpressionRule() {
		return getComparisonHigherOpExpressionAccess().getRule();
	}

	//enum ComparingEQNEQOperator returns commonExpressions::ComparingOperator:
	//	EQUAL="==" | UNEQUAL="<>";
	public ComparingEQNEQOperatorElements getComparingEQNEQOperatorAccess() {
		return unknownRuleComparingEQNEQOperator;
	}
	
	public EnumRule getComparingEQNEQOperatorRule() {
		return getComparingEQNEQOperatorAccess().getRule();
	}

	//enum ComparingRelOperator returns commonExpressions::ComparingOperator:
	//	LESS="<" | LESS_OR_EQUAL="<=" | GREATER_OR_EQUAL=">=" | GREATER=">";
	public ComparingRelOperatorElements getComparingRelOperatorAccess() {
		return unknownRuleComparingRelOperator;
	}
	
	public EnumRule getComparingRelOperatorRule() {
		return getComparingRelOperatorAccess().getRule();
	}

	//// end of ComparisonExpression
	//// ArithmeticExpression	
	//ArithmeticExpression returns expressions::Expression:
	//	AdditionExpression;
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return pArithmeticExpression;
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}

	//AdditionExpression returns expressions::Expression:
	//	MultiplicationExpression ({commonExpressions::ArithmeticExpression.leftExpression=current} operator=AdditionOperator
	//	rightExpression=MultiplicationExpression)*;
	public AdditionExpressionElements getAdditionExpressionAccess() {
		return pAdditionExpression;
	}
	
	public ParserRule getAdditionExpressionRule() {
		return getAdditionExpressionAccess().getRule();
	}

	//enum AdditionOperator returns commonExpressions::ArithmeticOperator:
	//	PLUS="+" | MINUS="-";
	public AdditionOperatorElements getAdditionOperatorAccess() {
		return unknownRuleAdditionOperator;
	}
	
	public EnumRule getAdditionOperatorRule() {
		return getAdditionOperatorAccess().getRule();
	}

	//MultiplicationExpression returns expressions::Expression:
	//	UnaryPreExpression | TypeCastExpression ({commonExpressions::ArithmeticExpression.leftExpression=current}
	//	operator=MultiplicationOperator rightExpression=(UnaryPreExpression | TypeCastExpression))*;
	public MultiplicationExpressionElements getMultiplicationExpressionAccess() {
		return pMultiplicationExpression;
	}
	
	public ParserRule getMultiplicationExpressionRule() {
		return getMultiplicationExpressionAccess().getRule();
	}

	//enum MultiplicationOperator returns commonExpressions::ArithmeticOperator:
	//	TIMES="*" | DIVIDE="/" | MODULO="%";
	public MultiplicationOperatorElements getMultiplicationOperatorAccess() {
		return unknownRuleMultiplicationOperator;
	}
	
	public EnumRule getMultiplicationOperatorRule() {
		return getMultiplicationOperatorAccess().getRule();
	}

	//// end of ArithmeticExpression
	//// UnaryPreExpression
	//UnaryPreExpression returns expressions::Expression:
	//	{commonExpressions::UnaryExpression} operator=UnaryPreOperator enclosedExpression=TypeCastExpression;
	public UnaryPreExpressionElements getUnaryPreExpressionAccess() {
		return pUnaryPreExpression;
	}
	
	public ParserRule getUnaryPreExpressionRule() {
		return getUnaryPreExpressionAccess().getRule();
	}

	//enum UnaryPreOperator returns commonExpressions::UnaryOperator:
	//	NOT="not" | MINUS="-";
	public UnaryPreOperatorElements getUnaryPreOperatorAccess() {
		return unknownRuleUnaryPreOperator;
	}
	
	public EnumRule getUnaryPreOperatorRule() {
		return getUnaryPreOperatorAccess().getRule();
	}

	//// end of UnaryPreExpression
	//TypeCastExpression returns expressions::Expression:
	//	Operand | {actionlanguage::TypeCastExpression} "(" dataType=[types::DataType|DATATYPE] ")" enclosedExpression=Operand;
	public TypeCastExpressionElements getTypeCastExpressionAccess() {
		return pTypeCastExpression;
	}
	
	public ParserRule getTypeCastExpressionRule() {
		return getTypeCastExpressionAccess().getRule();
	}

	//// Operand
	//Operand returns expressions::Expression:
	//	"(" Expression ")" | LiteralExpression | ExtendedTypedNamedElementExpression | TimeValueExpression | OperationCall |
	//	TriggerMessageExpression | NoAttributeSelectorExpression;
	public OperandElements getOperandAccess() {
		return pOperand;
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}

	//// end of Operand
	//LiteralExpression returns commonExpressions::LiteralExpression:
	//	{commonExpressions::LiteralExpression} value=Literal;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//Literal returns ecore::EString:
	//	NUMBER | BOOLEAN | INT | "null";
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//TimeValueExpression returns actionlanguage::TimeValueExpression:
	//	timeValue=[valuetype::TimeValue|MINORMAXKEYWORD];
	public TimeValueExpressionElements getTimeValueExpressionAccess() {
		return pTimeValueExpression;
	}
	
	public ParserRule getTimeValueExpressionRule() {
		return getTimeValueExpressionAccess().getRule();
	}

	//terminal MINORMAXKEYWORD:
	//	"maxMessageDelay" | "minMessageDelay";
	public TerminalRule getMINORMAXKEYWORDRule() {
		return tMINORMAXKEYWORD;
	} 

	//ExtendedTypedNamedElementExpression returns expressions::Expression:
	//	TypedNamedElementExpression
	//	({actionlanguage::DiscreteInteractionEndpointReference.typedNamedElementExpression=current} "->"
	//	position=PositionSelectorExpression | // unary post increment/decrement			
	//	{actionlanguage::Assignment.lhs_typedNamedElementExpression=current}
	//	incrementDecrementOperator=IncrementDecrementOperatorExpression)?;
	public ExtendedTypedNamedElementExpressionElements getExtendedTypedNamedElementExpressionAccess() {
		return pExtendedTypedNamedElementExpression;
	}
	
	public ParserRule getExtendedTypedNamedElementExpressionRule() {
		return getExtendedTypedNamedElementExpressionAccess().getRule();
	}

	//TypedNamedElementExpression returns actionlanguage::TypedNamedElementExpression:
	//	typedNamedElement=[behavior::TypedNamedElement] elementAccessors+=(ArrayIndexExpression |
	//	AttributeAccessorExpression)*;
	public TypedNamedElementExpressionElements getTypedNamedElementExpressionAccess() {
		return pTypedNamedElementExpression;
	}
	
	public ParserRule getTypedNamedElementExpressionRule() {
		return getTypedNamedElementExpressionAccess().getRule();
	}

	//ArrayIndexExpression returns actionlanguage::ArrayIndexExpression:
	//	"[" index=ArithmeticExpression "]";
	public ArrayIndexExpressionElements getArrayIndexExpressionAccess() {
		return pArrayIndexExpression;
	}
	
	public ParserRule getArrayIndexExpressionRule() {
		return getArrayIndexExpressionAccess().getRule();
	}

	//AttributeAccessorExpression returns actionlanguage::AttributeAccessorExpression:
	//	"." attribute=[types::Attribute];
	public AttributeAccessorExpressionElements getAttributeAccessorExpressionAccess() {
		return pAttributeAccessorExpression;
	}
	
	public ParserRule getAttributeAccessorExpressionRule() {
		return getAttributeAccessorExpressionAccess().getRule();
	}

	//NoAttributeSelectorExpression returns actionlanguage::DiscreteInteractionEndpointReference:
	//	position=PositionSelectorExpression;
	public NoAttributeSelectorExpressionElements getNoAttributeSelectorExpressionAccess() {
		return pNoAttributeSelectorExpression;
	}
	
	public ParserRule getNoAttributeSelectorExpressionRule() {
		return getNoAttributeSelectorExpressionAccess().getRule();
	}

	//PositionSelectorExpression returns actionlanguage::PositionSelector:
	//	kind=PositionSelectorKind ("->" successor=PositionSelectorExpression)?;
	public PositionSelectorExpressionElements getPositionSelectorExpressionAccess() {
		return pPositionSelectorExpression;
	}
	
	public ParserRule getPositionSelectorExpressionRule() {
		return getPositionSelectorExpressionAccess().getRule();
	}

	//enum PositionSelectorKind returns actionlanguage::PositionSelectorKind:
	//	SELF="self" | FIRST="first" | LAST="last" | PREV="prev" | NEXT="next";
	public PositionSelectorKindElements getPositionSelectorKindAccess() {
		return unknownRulePositionSelectorKind;
	}
	
	public EnumRule getPositionSelectorKindRule() {
		return getPositionSelectorKindAccess().getRule();
	}

	//OperationCall returns actionlanguage::OperationCall:
	//	operation=[behavior::Operation] "(" (parameterBinding+=ParamaterBinding ("," parameterBinding+=ParamaterBinding)*)?
	//	")";
	public OperationCallElements getOperationCallAccess() {
		return pOperationCall;
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}

	//ParamaterBinding returns behavior::ParameterBinding:
	//	{behavior::ParameterBinding} parameter=[behavior::Parameter] ":=" value=Expression;
	public ParamaterBindingElements getParamaterBindingAccess() {
		return pParamaterBinding;
	}
	
	public ParserRule getParamaterBindingRule() {
		return getParamaterBindingAccess().getRule();
	}

	//// TriggerMessageExpression
	//TriggerMessageExpression returns actionlanguage::TriggerMessageExpression:
	//	messageType=[msgtype::MessageType] "->" parameter=[behavior::Parameter];
	public TriggerMessageExpressionElements getTriggerMessageExpressionAccess() {
		return pTriggerMessageExpression;
	}
	
	public ParserRule getTriggerMessageExpressionRule() {
		return getTriggerMessageExpressionAccess().getRule();
	}

	//// end of TriggerMessageExpression
	//terminal NUMBER returns ecore::EBigDecimal:
	//	INT "." INT;
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	} 

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//DATATYPE returns ecore::EString:
	//	ID ("[" INT "]")*;
	public DATATYPEElements getDATATYPEAccess() {
		return pDATATYPE;
	}
	
	public ParserRule getDATATYPERule() {
		return getDATATYPEAccess().getRule();
	}

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
