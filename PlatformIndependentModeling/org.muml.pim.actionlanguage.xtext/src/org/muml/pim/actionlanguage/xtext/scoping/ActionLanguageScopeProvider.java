/*
 * generated by Xtext
 */
package org.muml.pim.actionlanguage.xtext.scoping;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.muml.core.expressions.Expression;
import org.muml.core.modelinstance.ModelElementCategory;
import org.muml.core.modelinstance.ModelInstancePlugin;
import org.muml.core.modelinstance.RootNode;
import org.muml.pim.actionlanguage.Assignment;
import org.muml.pim.actionlanguage.AttributeAccessorExpression;
import org.muml.pim.actionlanguage.Block;
import org.muml.pim.actionlanguage.LocalVariableDeclarationStatement;
import org.muml.pim.actionlanguage.NondeterministicChoiceExpression;
import org.muml.pim.actionlanguage.OperationCall;
import org.muml.pim.actionlanguage.TriggerMessageExpression;
import org.muml.pim.behavior.Operation;
import org.muml.pim.behavior.Parameter;
import org.muml.pim.behavior.ParameterBinding;
import org.muml.pim.behavior.TypedNamedElement;
import org.muml.pim.behavior.Variable;
import org.muml.pim.component.AtomicComponent;
import org.muml.pim.component.HybridPort;
import org.muml.pim.component.Port;
import org.muml.pim.connector.DiscreteInteractionEndpoint;
import org.muml.pim.msgtype.MessageType;
import org.muml.pim.pattern.AbstractCoordinationPattern;
import org.muml.pim.protocol.Role;
import org.muml.pim.realtimestatechart.Message;
import org.muml.pim.realtimestatechart.RealtimeStatechart;
import org.muml.pim.realtimestatechart.StateEvent;
import org.muml.pim.realtimestatechart.Synchronization;
import org.muml.pim.realtimestatechart.Transition;
import org.muml.pim.types.Attribute;
import org.muml.pim.types.DataType;
import org.muml.pim.types.PrimitiveDataType;
import org.muml.pim.types.StructureDataType;
import org.muml.pim.types.blackbox.TypesBlackbox;
import org.muml.pim.valuetype.TimeValue;

import com.google.inject.Inject;
import com.google.inject.Singleton;

/**
 * This class contains custom scoping description.
 *
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on how and when to use it
 *
 */
@Singleton
public class ActionLanguageScopeProvider extends AbstractDeclarativeScopeProvider implements IActionLanguageScopeProvider {
    protected List<TypedNamedElement> typedNamedElementList;
    private List<DataType> typeList;
    private List<Operation> operationList;
    private List<MessageType> messageTypeList;
    private List<Attribute> attributeList;
    private List<TimeValue> timeValueList;

    // TODO: make this string public in class TypeCategoryInitializer
    private static final String TYPES_CATEGORY_KEY = "org.muml.types.category";

    @Inject
    private IQualifiedNameProvider nameProvider;

    public ActionLanguageScopeProvider() {
        super();
        initLists();
    }

    IScope scope_TypedNamedElement(EObject context, EReference ref) {
        EObject container = context.eContainer();
        if (container instanceof Assignment && ((Assignment) container).getLhs_typedNamedElementExpression() == context) {
            // do not return hybrid in ports
            return createScope(filterConstants(filterHybridInPorts(getAvailableTypedNamedElementList(context))));
        }
        // do not filter hybrid out ports (see #375)
        return createScope(getAvailableTypedNamedElementList(context));
    }

    IScope scope_TimeValue(EObject context, EReference ref) {
        return createScope(timeValueList);
    }

    IScope scope_DataType(Variable variable, EReference ref) {
        return createScope(typeList);
    }

    IScope scope_AttributeAccessorExpression_attribute(AttributeAccessorExpression expression, EReference ref) {
        return createScope(attributeList);
    }

    IScope scope_TypedNamedElement_dataType(EObject context, EReference ref) {
        return createScope(typeList);
    }

    IScope scope_TypeCastExpression_dataType(EObject context, EReference ref) {
        return createScope(typeList);
    }

    IScope scope_NondeterministicChoiceExpression_dataType(NondeterministicChoiceExpression expression, EReference ref) {
        List<PrimitiveDataType> scopeList = new ArrayList<PrimitiveDataType>();
        for (DataType dataType : typeList) {
            if (isAllowedTypeForNondeterministicChoices(dataType) && dataType instanceof PrimitiveDataType) {
                scopeList.add((PrimitiveDataType) dataType);
                break;
            }
        }
        return createScope(scopeList);
    }

    // TODO using of strings is not nice, however, an enumeration in the types plugin is missing
    boolean isAllowedTypeForNondeterministicChoices(DataType dataType) {
        if (dataType.getName().equals("uint8") || dataType.getName().equals("uint16") || dataType.getName().equals("uint32")
                || dataType.getName().equals("uint64") || dataType.getName().equals("int8") || dataType.getName().equals("int16")
                || dataType.getName().equals("int32") || dataType.getName().equals("int64")) {
            return true;
        } else {
            return false;
        }
    }

    IScope scope_Operation(Object object, EReference ref) {
        return createScope(operationList);
    }

    IScope scope_MessageType(Object object, EReference ref) {
        return createScope(messageTypeList);
    }

    IScope scope_Parameter(Object object, EReference ref) {
        if (!(object instanceof EObject)) {
            return IScope.NULLSCOPE;
        }
        EObject eObject = (EObject) object;
        List<Parameter> parameterList = Collections.<Parameter>emptyList();
        if (eObject instanceof ParameterBinding && eObject.eContainer() instanceof OperationCall) {
            OperationCall operationCall = (OperationCall) ((EObject) object).eContainer();
            parameterList = getScopeForOperation(operationCall.getOperation());
        } else if (eObject instanceof TriggerMessageExpression) {
            parameterList = getScopeForTriggerMessageExpression((TriggerMessageExpression) eObject);
        }
        return createScope(parameterList);
    }

    @Override
    public void setScopeForEObject(EObject object) {
        initLists();
        if (!setScopeSwitch(object)) {
            throw new IllegalArgumentException("scope not found for object: " + object);
        }
    }

    protected boolean setScopeSwitch(EObject object) {
        if (object instanceof StateEvent) {
            setScopeForEObject((StateEvent) object);
        } else if (object instanceof Transition) {
            setScopeForEObject((Transition) object);
        } else if (object instanceof Message) {
            setScopeForEObject((Message) object);
        } else if (object instanceof Synchronization) {
            setScopeForEObject((Synchronization) object);
        } else if (object instanceof ParameterBinding) {
            setScopeForEObject((ParameterBinding) object);
        } else if (object instanceof Operation) {
            setScopeForEObject((Operation) object);
        } else if (object instanceof AbstractCoordinationPattern) {
            setScopeForEObject((AbstractCoordinationPattern) object);
        } else if (object instanceof RealtimeStatechart) {
            setScopeForRTSC(object);
        } else if (object != null) {
            setScopeSwitch(object.eContainer());
        } else {
            return false;
        }
        return true;
    }

    public void setScopeForEObject(StateEvent event) {
        // expected: doevent, entry- and exitevent
        setScopeForRTSC(event.eContainer().eContainer());
    }

    public void setScopeForEObject(Transition transition) {
        setScopeForRTSC(transition.getStatechart());
        if (transition.getTriggerMessageEvent() != null && transition.getTriggerMessageEvent().getMessage() != null) {
            messageTypeList = new ArrayList<MessageType>();
            messageTypeList.add(transition.getTriggerMessageEvent().getMessage().getInstanceOf());
        }
        // if transition uses one2ManyCommunicationSchema
        if (transition.getRaiseMessageEvent() != null && transition.getRaiseMessageEvent().getOneToManyCommunicationSchema() != null
                || transition.getTriggerMessageEvent() != null && transition.getTriggerMessageEvent().getOneToManyCommunicationSchema() != null) {
            typedNamedElementList.addAll(transition.getStatechart().getSubRoleSpecificVariables());
            operationList.addAll(transition.getStatechart().getSubRoleSpecificOperations());
        }
    }

    public void setScopeForEObject(Message message) {
        // expected: a raise or trigger message
        // this should be a transition
        setScopeForEObject(message.eContainer().eContainer());
    }

    public void setScopeForEObject(Synchronization synchronization) {
        // expected: synchronization for a transition
        // this should be a transition
        setScopeForEObject(synchronization.eContainer());
    }

    public void setScopeForEObject(ParameterBinding parameterBinding) {
        // either a transition or rtsc
        setScopeForEObject(parameterBinding.eContainer().eContainer().eContainer());
    }

    public void setScopeForEObject(Operation operation) {

        // if operation is embedded in an RTSC, add RTSC elements to scope
        if (operation.eContainer() instanceof RealtimeStatechart) {
            setScopeForRTSC(operation.eContainer());
        } else {
            // initialize containers -> has been done by setScopeForRTSC if
            // operation is embedded in RTSC
            typedNamedElementList = new ArrayList<TypedNamedElement>();
            initDataTypes(operation);
        }

        List<Parameter> parameterList = getScopeForOperation(operation);
        for (Parameter parameter : parameterList) {
            typedNamedElementList.add(parameter);
        }
    }

    // NOTE (Ingo)
    // Fix for bug #1120.
    // @marcus:
    // Variables can be contained at places other than RTSC (for example:
    // LocalVariableDeclarations).
    // Therefore we want to go upwards, until we find an RTSC.
    // By disabling this method we effectively get that behavior,
    // because setScopeSwitch() recursively calls itself with eContainer() until
    // an RTSC is found.
    // The other case (where a Variable is contained at an RTSC) should still
    // work, because then also the RTSC is found.

    // public void setScopeForEObject(Variable variable) {
    // setScopeForRTSC(variable.eContainer());
    // }

    public void setScopeForEObject(AbstractCoordinationPattern pattern) {
        typedNamedElementList = new ArrayList<TypedNamedElement>();
        typedNamedElementList.addAll(pattern.getPatternParameters());
    }

    private void setScopeForRTSC(EObject object) {
        if (!(object instanceof RealtimeStatechart)) {
            throw new IllegalArgumentException("object is no rtsc: " + object);
        }
        RealtimeStatechart rtsc = (RealtimeStatechart) object;
        typedNamedElementList = new ArrayList<TypedNamedElement>();
        typedNamedElementList.addAll(rtsc.getAllAvailableVariables());

        if (rtsc.getPortOrRoleStatechart().getBehavioralElement() instanceof Role
                && ((Role) rtsc.getPortOrRoleStatechart().getBehavioralElement()).getCoordinationProtocol() instanceof AbstractCoordinationPattern) {
            AbstractCoordinationPattern pattern = (AbstractCoordinationPattern) ((Role) rtsc.getPortOrRoleStatechart().getBehavioralElement())
                    .getCoordinationProtocol();
            typedNamedElementList.addAll(pattern.getPatternParameters());
        }
        if (rtsc.getPortOrRoleStatechart().getBehavioralElement() instanceof DiscreteInteractionEndpoint) {
            timeValueList = new ArrayList<TimeValue>();
            if (rtsc.getPortOrRoleStatechart().getBehavioralElement() instanceof Role) {
                Role role = (Role) rtsc.getPortOrRoleStatechart().getBehavioralElement();
                if (role.getRoleConnector() != null && role.getRoleConnector().getConnectorQualityOfServiceAssumptions() != null) {
                    timeValueList.add(role.getRoleConnector().getConnectorQualityOfServiceAssumptions().getMaxMessageDelay());
                }
            }
        }
        addHybridPorts(rtsc);
        operationList = new ArrayList<Operation>();
        operationList.addAll(rtsc.getAllAvailableOperations());

        initDataTypes(rtsc);
    }

    private void addHybridPorts(RealtimeStatechart rtsc) {
        AtomicComponent atomicComponent = null;
        if (rtsc.getBehavioralElement() == null && rtsc.isEmbedded()) {
            addHybridPorts(rtsc.getParentRegion().getParentState().getParentStatechart());
            return;
        } else if (rtsc.getBehavioralElement() instanceof AtomicComponent) {
            atomicComponent = (AtomicComponent) rtsc.getBehavioralElement();
        } else if (rtsc.getBehavioralElement() instanceof Port && ((Port) rtsc.getBehavioralElement()).getComponent() instanceof AtomicComponent) {
            atomicComponent = (AtomicComponent) ((Port) rtsc.getBehavioralElement()).getComponent();
        }
        if (atomicComponent != null) {
            for (Port port : atomicComponent.getPorts()) {
                if (port instanceof HybridPort) {
                    typedNamedElementList.add((TypedNamedElement) port);
                }
            }
        }
    }

    private void initDataTypes(EObject object) {
        RootNode rootNode = (RootNode) object.eResource().getContents().get(0);

        // init lists
        typeList = new ArrayList<DataType>();
        attributeList = new ArrayList<Attribute>();

        ModelElementCategory modelElementCategory = ModelInstancePlugin.getInstance().getModelElementCategoryRegistry().getModelElementCategory(rootNode,
                TYPES_CATEGORY_KEY, false);

        // fill lists
        List<EObject> types = new ArrayList<EObject>();

        if (modelElementCategory != null) {
            types.addAll(modelElementCategory.getModelElements());
        }
        if (object.eResource() != null && object.eResource().getResourceSet() != null) {
            types.addAll(TypesBlackbox.getPredefinedTypes(object.eResource().getResourceSet()));
        }

        for (EObject type : types) {
            typeList.add((DataType) type);

            if (type instanceof StructureDataType) {
                attributeList.addAll(((StructureDataType) type).getAttributes());
            }
        }

    }

    private List<Parameter> getScopeForOperation(Operation operation) {
        if (operation == null) {
            return Collections.<Parameter>emptyList();
        }
        return operation.getParameters();
    }

    private List<Parameter> getScopeForTriggerMessageExpression(TriggerMessageExpression triggerMessageExpression) {
        if (triggerMessageExpression.getMessageType() == null) {
            // should not happen
            return Collections.<Parameter>emptyList();
        }
        return triggerMessageExpression.getMessageType().getParameters();
    }

    private IScope createScope(List<? extends EObject> list) {
        if (list.isEmpty()) {
            return IScope.NULLSCOPE;
        }
        return Scopes.scopeFor(list, nameProvider, IScope.NULLSCOPE);
    }

    private void initLists() {
        typedNamedElementList = Collections.<TypedNamedElement>emptyList();
        operationList = Collections.<Operation>emptyList();
        messageTypeList = Collections.<MessageType>emptyList();
        attributeList = Collections.<Attribute>emptyList();
        timeValueList = Collections.<TimeValue>emptyList();
    }

    private List<TypedNamedElement> getAvailableTypedNamedElementList(EObject context) {
        List<TypedNamedElement> availableTypedNamedElementList = getLocalVariables(context);
        availableTypedNamedElementList.addAll(typedNamedElementList);
        return availableTypedNamedElementList;
    }

    private List<TypedNamedElement> filterHybridInPorts(List<TypedNamedElement> list) {
        List<TypedNamedElement> filteredList = new ArrayList<TypedNamedElement>();
        for (TypedNamedElement typedNamedElement : list) {
            if (typedNamedElement instanceof HybridPort) {
                HybridPort hybridPort = (HybridPort) typedNamedElement;
                if (hybridPort.isInPort()) {
                    continue;
                }
            }
            filteredList.add(typedNamedElement);
        }
        return filteredList;
    }

    // XXX: more or less a duplicate of filterHybridPorts (consider the usage
    // of some predicate filtering framework/simply refactor code a bit)
    private List<TypedNamedElement> filterConstants(List<TypedNamedElement> list) {
        List<TypedNamedElement> filteredList = new ArrayList<TypedNamedElement>();
        for (TypedNamedElement typedNamedElement : list) {
            if (typedNamedElement instanceof Variable && ((Variable) typedNamedElement).isConstant()) {
                continue;
            }
            filteredList.add(typedNamedElement);
        }
        return filteredList;
    }

    private List<TypedNamedElement> getLocalVariables(EObject object) {
        List<TypedNamedElement> localVariableList = new ArrayList<TypedNamedElement>();
        EObject container = object;
        EObject containedExpression = null;
        while (container != null) {
            if (container instanceof Block) {
                // add all local variable declarations which were defined
                // before the containedExpression
                for (Expression expression : ((Block) container).getExpressions()) {
                    if (expression == containedExpression) {
                        break;
                    } else if (expression instanceof LocalVariableDeclarationStatement) {
                        localVariableList.add(((LocalVariableDeclarationStatement) expression).getVariable());
                    }
                }
            }
            containedExpression = container;
            container = container.eContainer();
        }
        return localVariableList;
    }

}
