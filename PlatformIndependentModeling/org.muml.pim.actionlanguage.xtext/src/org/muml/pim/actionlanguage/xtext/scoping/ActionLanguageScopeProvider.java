/*
 * generated by Xtext
 */
package org.muml.pim.actionlanguage.xtext.scoping;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.muml.core.expressions.Expression;
import org.muml.core.modelinstance.ModelElementCategory;
import org.muml.core.modelinstance.ModelInstancePlugin;
import org.muml.core.modelinstance.RootNode;
import org.muml.pim.actionlanguage.Assignment;
import org.muml.pim.actionlanguage.AttributeAccessorExpression;
import org.muml.pim.actionlanguage.Block;
import org.muml.pim.actionlanguage.LocalVariableDeclarationStatement;
import org.muml.pim.actionlanguage.NondeterministicChoiceExpression;
import org.muml.pim.actionlanguage.OperationCall;
import org.muml.pim.actionlanguage.TriggerMessageExpression;
import org.muml.pim.behavior.Operation;
import org.muml.pim.behavior.Parameter;
import org.muml.pim.behavior.ParameterBinding;
import org.muml.pim.behavior.TypedNamedElement;
import org.muml.pim.behavior.Variable;
import org.muml.pim.component.AtomicComponent;
import org.muml.pim.component.HybridPort;
import org.muml.pim.component.Port;
import org.muml.pim.connector.DiscreteInteractionEndpoint;
import org.muml.pim.msgtype.MessageType;
import org.muml.pim.pattern.AbstractCoordinationPattern;
import org.muml.pim.protocol.Role;
import org.muml.pim.realtimestatechart.Message;
import org.muml.pim.realtimestatechart.RealtimeStatechart;
import org.muml.pim.realtimestatechart.StateEvent;
import org.muml.pim.realtimestatechart.Synchronization;
import org.muml.pim.realtimestatechart.Transition;
import org.muml.pim.types.Attribute;
import org.muml.pim.types.DataType;
import org.muml.pim.types.PredefinedTypesResourceFactory;
import org.muml.pim.types.PrimitiveDataType;
import org.muml.pim.types.StructureDataType;
import org.muml.pim.valuetype.TimeValue;

import com.google.inject.Inject;
import com.google.inject.Singleton;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 *
 */
@Singleton
public class ActionLanguageScopeProvider extends AbstractDeclarativeScopeProvider
		implements IActionLanguageScopeProvider {
	protected List<TypedNamedElement> typedNamedElementList;
	private List<DataType> typeList;
	private List<Operation> operationList;
	private List<MessageType> messageTypeList;
	private List<Attribute> attributeList;
	private List<TimeValue> timeValueList;

	// TODO: make this string public in class TypeCategoryInitializer
	private static final String TYPES_CATEGORY_KEY = "de.uni_paderborn.fujaba.muml.types.category";

	@Inject
	private IQualifiedNameProvider nameProvider;

	public ActionLanguageScopeProvider() {
		super();
		initLists();
	}

	IScope scope_TypedNamedElement(EObject context, EReference ref) {
		EObject container = context.eContainer();
		if (container instanceof Assignment
				&& ((Assignment) container).getLhs_typedNamedElementExpression() == context) {
			// do not return hybrid in ports
			return createScope(filterConstants(filterHybridInPorts(getAvailableTypedNamedElementList(context))));
		}
		// do not filter hybrid out ports (see #375)
		return createScope(getAvailableTypedNamedElementList(context));
	}

	IScope scope_TimeValue(EObject context, EReference ref) {
		return createScope(timeValueList);
	}

	IScope scope_DataType(Variable variable, EReference ref) {
		return createScope(typeList);
	}

	IScope scope_AttributeAccessorExpression_attribute(AttributeAccessorExpression expression, EReference ref) {
		return createScope(attributeList);
	}

	IScope scope_TypedNamedElement_dataType(EObject context, EReference ref) {
		return createScope(typeList);
	}

	IScope scope_TypeCastExpression_dataType(EObject context, EReference ref) {
		return createScope(typeList);
	}

	IScope scope_NondeterministicChoiceExpression_dataType(NondeterministicChoiceExpression expression,
			EReference ref) {
		List<PrimitiveDataType> scopeList = new ArrayList<PrimitiveDataType>();
		for (DataType dataType : typeList) {
			if (isAllowedTypeForNondeterministicChoices(dataType) && dataType instanceof PrimitiveDataType) {
				scopeList.add((PrimitiveDataType) dataType);
				break;
			}
		}
		return createScope(scopeList);
	}

	// TODO using of strings is not nice, however, an enumeration in the types plugin is missing
	boolean isAllowedTypeForNondeterministicChoices(DataType dataType){
	 if ((dataType.getName().equals("uint8") || (dataType.getName().equals("uint16")) 
			 || (dataType.getName().equals("uint32")) || (dataType.getName().equals("uint64")) 
			 || (dataType.getName().equals("int8")) || (dataType.getName().equals("int16")) 
			 || (dataType.getName().equals("int32"))) || (dataType.getName().equals("int64"))) {
		 return true;
	 } else return false;
	}
	
	IScope scope_Operation(Object object, EReference ref) {
		return createScope(operationList);
	}

	IScope scope_MessageType(Object object, EReference ref) {
		return createScope(messageTypeList);
	}

	IScope scope_Parameter(Object object, EReference ref) {
		if (!(object instanceof EObject)) {
			return IScope.NULLSCOPE;
		}
		EObject eObject = (EObject) object;
		List<Parameter> parameterList = Collections.<Parameter> emptyList();
		if ((eObject instanceof ParameterBinding) && eObject.eContainer() instanceof OperationCall) {
			OperationCall operationCall = (OperationCall) ((EObject) object).eContainer();
			parameterList = getScopeForOperation(operationCall.getOperation());
		} else if (eObject instanceof TriggerMessageExpression) {
			parameterList = getScopeForTriggerMessageExpression((TriggerMessageExpression) eObject);
		}
		return createScope(parameterList);
	}

	public void setScopeForEObject(EObject object) {
		initLists();
		if (!setScopeSwitch(object)) {
			throw new IllegalArgumentException("scope not found for object: " + object);
		}
	}

	protected boolean setScopeSwitch(EObject object) {
		if (object instanceof StateEvent) {
			setScopeForEObject((StateEvent) object);
		} else if (object instanceof Transition) {
			setScopeForEObject((Transition) object);
		} else if (object instanceof Message) {
			setScopeForEObject((Message) object);
		} else if (object instanceof Synchronization) {
			setScopeForEObject((Synchronization) object);
		} else if (object instanceof ParameterBinding) {
			setScopeForEObject((ParameterBinding) object);
		} else if (object instanceof Operation) {
			setScopeForEObject((Operation) object);
		} else if (object instanceof AbstractCoordinationPattern) {
			setScopeForEObject((AbstractCoordinationPattern) object);
		} else if (object instanceof RealtimeStatechart) {
			setScopeForRTSC((RealtimeStatechart) object);
		} else if (object != null) {
			setScopeSwitch(object.eContainer());
		} else {
			return false;
		}
		return true;
	}

	public void setScopeForEObject(StateEvent event) {
		// expected: doevent, entry- and exitevent
		setScopeForRTSC(event.eContainer().eContainer());
	}

	public void setScopeForEObject(Transition transition) {
		setScopeForRTSC(transition.getStatechart());
		if (transition.getTriggerMessageEvent() != null && transition.getTriggerMessageEvent().getMessage() != null) {
			messageTypeList = new ArrayList<MessageType>();
			messageTypeList.add(transition.getTriggerMessageEvent().getMessage().getInstanceOf());
		}
		// if transition uses one2ManyCommunicationSchema
		if ((transition.getRaiseMessageEvent() != null
				&& transition.getRaiseMessageEvent().getOneToManyCommunicationSchema() != null)
				|| (transition.getTriggerMessageEvent() != null
						&& transition.getTriggerMessageEvent().getOneToManyCommunicationSchema() != null)) {
			typedNamedElementList.addAll(transition.getStatechart().getSubRoleSpecificVariables());
			operationList.addAll(transition.getStatechart().getSubRoleSpecificOperations());
		}
	}

	public void setScopeForEObject(Message message) {
		// expected: a raise or trigger message
		// this should be a transition
		setScopeForEObject(message.eContainer().eContainer());
	}

	public void setScopeForEObject(Synchronization synchronization) {
		// expected: synchronization for a transition
		// this should be a transition
		setScopeForEObject(synchronization.eContainer());
	}

	public void setScopeForEObject(ParameterBinding parameterBinding) {
		// either a transition or rtsc
		setScopeForEObject(parameterBinding.eContainer().eContainer().eContainer());
	}

	public void setScopeForEObject(Operation operation) {

		// if operation is embedded in an RTSC, add RTSC elements to scope
		if (operation.eContainer() instanceof RealtimeStatechart) {
			setScopeForRTSC(operation.eContainer());
		} else {
			// initialize containers -> has been done by setScopeForRTSC if
			// operation is embedded in RTSC
			typedNamedElementList = new ArrayList<TypedNamedElement>();
			initDataTypes(operation);
		}

		List<Parameter> parameterList = getScopeForOperation(operation);
		for (Parameter parameter : parameterList) {
			typedNamedElementList.add(parameter);
		}
	}

	// NOTE (Ingo)
	// Fix for bug #1120.
	// @marcus:
	// Variables can be contained at places other than RTSC (for example:
	// LocalVariableDeclarations).
	// Therefore we want to go upwards, until we find an RTSC.
	// By disabling this method we effectively get that behavior,
	// because setScopeSwitch() recursively calls itself with eContainer() until
	// an RTSC is found.
	// The other case (where a Variable is contained at an RTSC) should still
	// work, because then also the RTSC is found.

	// public void setScopeForEObject(Variable variable) {
	// setScopeForRTSC(variable.eContainer());
	// }

	public void setScopeForEObject(AbstractCoordinationPattern pattern) {
		typedNamedElementList = new ArrayList<TypedNamedElement>();
		typedNamedElementList.addAll(pattern.getPatternParameters());
	}

	private void setScopeForRTSC(EObject object) {
		if (!(object instanceof RealtimeStatechart)) {
			throw new IllegalArgumentException("object is no rtsc: " + object);
		}
		RealtimeStatechart rtsc = (RealtimeStatechart) object;
		typedNamedElementList = new ArrayList<TypedNamedElement>();
		typedNamedElementList.addAll(rtsc.getAllAvailableVariables());

		if (rtsc.getPortOrRoleStatechart().getBehavioralElement() instanceof Role
				&& ((Role) rtsc.getPortOrRoleStatechart().getBehavioralElement())
						.getCoordinationProtocol() instanceof AbstractCoordinationPattern) {
			AbstractCoordinationPattern pattern = (AbstractCoordinationPattern) ((Role) rtsc.getPortOrRoleStatechart()
					.getBehavioralElement()).getCoordinationProtocol();
			typedNamedElementList.addAll(pattern.getPatternParameters());
		}
		if (rtsc.getPortOrRoleStatechart().getBehavioralElement() instanceof DiscreteInteractionEndpoint) {
			timeValueList = new ArrayList<TimeValue>();
			if (rtsc.getPortOrRoleStatechart().getBehavioralElement() instanceof Role) {
				Role role = (Role) rtsc.getPortOrRoleStatechart().getBehavioralElement();
				if (role.getRoleConnector() != null
						&& role.getRoleConnector().getConnectorQualityOfServiceAssumptions() != null) {
					timeValueList.add(
							role.getRoleConnector().getConnectorQualityOfServiceAssumptions().getMaxMessageDelay());
				}
			}
		}
		addHybridPorts(rtsc);
		operationList = new ArrayList<Operation>();
		operationList.addAll(rtsc.getAllAvailableOperations());
		
		initDataTypes(rtsc);
	}

	private void addHybridPorts(RealtimeStatechart rtsc) {
		AtomicComponent atomicComponent = null;
		if (rtsc.getBehavioralElement() == null && rtsc.isEmbedded()) {
			addHybridPorts(rtsc.getParentRegion().getParentState().getParentStatechart());
			return;
		} else if (rtsc.getBehavioralElement() instanceof AtomicComponent) {
			atomicComponent = (AtomicComponent) rtsc.getBehavioralElement();
		} else if (rtsc.getBehavioralElement() instanceof Port
				&& ((Port) rtsc.getBehavioralElement()).getComponent() instanceof AtomicComponent) {
			atomicComponent = (AtomicComponent) ((Port) rtsc.getBehavioralElement()).getComponent();
		}
		if (atomicComponent != null) {
			for (Port port : atomicComponent.getPorts()) {
				if (port instanceof HybridPort) {
					typedNamedElementList.add((TypedNamedElement) port);
				}
			}
		}
	}

	private void initDataTypes(EObject object) {
		RootNode rootNode = (RootNode) object.eResource().getContents().get(0);

		// init lists
		typeList = new ArrayList<DataType>();
		attributeList = new ArrayList<Attribute>();

		ModelElementCategory modelElementCategory = ModelInstancePlugin.getInstance().getModelElementCategoryRegistry()
				.getModelElementCategory(rootNode, TYPES_CATEGORY_KEY);

		// fill lists
		List<EObject> types = new ArrayList<EObject>();
		types.addAll(modelElementCategory.getModelElements());
		types.addAll(PredefinedTypesResourceFactory.getResource().getContents());

		for (EObject type : types) {
			typeList.add((DataType) type);

			if (type instanceof StructureDataType) {
				attributeList.addAll(((StructureDataType) type).getAttributes());
			}
		}

	}

	private List<Parameter> getScopeForOperation(Operation operation) {
		if (operation == null) {
			return Collections.<Parameter> emptyList();
		}
		return operation.getParameters();
	}

	private List<Parameter> getScopeForTriggerMessageExpression(TriggerMessageExpression triggerMessageExpression) {
		if (triggerMessageExpression.getMessageType() == null) {
			// should not happen
			return Collections.<Parameter> emptyList();
		}
		return triggerMessageExpression.getMessageType().getParameters();
	}

	private IScope createScope(List<? extends EObject> list) {
		if (list.isEmpty()) {
			return IScope.NULLSCOPE;
		}
		return Scopes.scopeFor(list, nameProvider, IScope.NULLSCOPE);
	}

	private void initLists() {
		typedNamedElementList = Collections.<TypedNamedElement> emptyList();
		operationList = Collections.<Operation> emptyList();
		messageTypeList = Collections.<MessageType> emptyList();
		attributeList = Collections.<Attribute> emptyList();
		timeValueList = Collections.<TimeValue> emptyList();
	}

	private List<TypedNamedElement> getAvailableTypedNamedElementList(EObject context) {
		List<TypedNamedElement> availableTypedNamedElementList = getLocalVariables(context);
		availableTypedNamedElementList.addAll(typedNamedElementList);
		return availableTypedNamedElementList;
	}

	private List<TypedNamedElement> filterHybridInPorts(List<TypedNamedElement> list) {
		List<TypedNamedElement> filteredList = new ArrayList<TypedNamedElement>();
		for (TypedNamedElement typedNamedElement : list) {
			if (typedNamedElement instanceof HybridPort) {
				HybridPort hybridPort = (HybridPort) typedNamedElement;
				if (hybridPort.isInPort()) {
					continue;
				}
			}
			filteredList.add(typedNamedElement);
		}
		return filteredList;
	}

	// XXX: more or less a duplicate of filterHybridPorts (consider the usage
	// of some predicate filtering framework/simply refactor code a bit)
	private List<TypedNamedElement> filterConstants(List<TypedNamedElement> list) {
		List<TypedNamedElement> filteredList = new ArrayList<TypedNamedElement>();
		for (TypedNamedElement typedNamedElement : list) {
			if (typedNamedElement instanceof Variable && ((Variable) typedNamedElement).isConstant()) {
				continue;
			}
			filteredList.add(typedNamedElement);
		}
		return filteredList;
	}

	private List<TypedNamedElement> getLocalVariables(EObject object) {
		List<TypedNamedElement> localVariableList = new ArrayList<TypedNamedElement>();
		EObject container = object;
		EObject containedExpression = null;
		while (container != null) {
			if (container instanceof Block) {
				// add all local variable declarations which were defined
				// before the containedExpression
				for (Expression expression : ((Block) container).getExpressions()) {
					if (expression == containedExpression) {
						break;
					} else if (expression instanceof LocalVariableDeclarationStatement) {
						localVariableList.add(((LocalVariableDeclarationStatement) expression).getVariable());
					}
				}
			}
			containedExpression = container;
			container = container.eContainer();
		}
		return localVariableList;
	}

}
