modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype modelinstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');
	
// Todo: the TriggerMessage2TriggerWithoutConsume should be replaced.
		
transformation SynthesisApproach(inout input:modelinstance);

property currentRealtimeStatechart : RealtimeStatechart;
main() {	
	var root : RootNode := input.rootObjects()[RootNode]->any(true);
	getRealtimeStatechartCategory().modelElements.oclAsType(RealtimeStatechart).map RTSC2RTSC();
}

query getRealtimeStatechartCategory() : ModelElementCategory {
	return input.rootObjects()[RootNode]->any(true).categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.realtimestatechart.category') -> any(true);
}
	
helper  isClockSubRoleSpecific(c : Clock): Boolean
{
	return currentRealtimeStatechart.subRoleSpecificClocks->includes(c);
}
helper isVariableSubRoleSpecific(v : Variable): Boolean
{
	return currentRealtimeStatechart.subRoleSpecificVariables->includes(v);
}
helper isOperationSubRoleSpecific(o : Operation): Boolean
{
	return currentRealtimeStatechart.subRoleSpecificOperations->includes(o);
}
mapping RealtimeStatechart :: RTSC2RTSC() : RealtimeStatechart {
		currentRealtimeStatechart:= self;
		name := self.name + "Impl";
		
		// **select non subrolespecific elements
		clocks += self.clocks.map Clock2Clock();
		
		variables += self.variables.map Variable2Variable();
		
		operations += self.operations.map Operation2Operation(self);
		//**
		states += self.map Rtsc2InitialState();
		
		if(not self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "multicastPossible");
		}endif;
		
		if(not self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "unicastPossible");
		}endif;
		
		if(not self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive)
				and (not t.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "MultiReceivePossible");
		}endif;
		
		if(not self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "error");
		}endif;
		
		if(not self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "singleReceivePossible");
		}endif;
		
		if(not self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "iteratePossible");
		}endif;
		// normally override the behavorialElement
		//behavioralElement := self.behavioralElement;
		getRealtimeStatechartCategory().modelElements +=result;		
	}
	
mapping RealtimeStatechart :: Rtsc2InitialState() : State {
		
		name := "Main";
		
		initial := true;
		
		embeddedRegions += self->map State2CoordinatorRegion(self,0);
		
		embeddedRegions += self.map State2SubroleRegion(self,1);
					
	}

mapping RealtimeStatechart :: State2CoordinatorRegion(context:OclAny, region:OclAny) : Region {
		
		priority := 2;
		
		parentState := context.oclAsType(State);
		
		embeddedStatechart := self.map RTSC2CoordinatorRTSC(context, region);
		
					
	}
	
mapping RealtimeStatechart :: State2SubroleRegion(context:OclAny, region:OclAny) : Region {
		
		priority := 1;
		
		parentState := context.oclAsType(State);
		
		embeddedStatechart := self.map RTSC2SubroleRTSC(context, region);
					
	}
	
mapping RealtimeStatechart :: RTSC2CoordinatorRTSC(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name := "coordinator";
		
		states += self.states.map States2StatesCoordinator(context, region);
		
		if(not self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate))->isEmpty()){
			variables += self.map Iterate2CurRoleVariable();
		}endif;
		
		if(not self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).delay.oclIsUndefined()))->isEmpty()){
			clocks += self.map TransferSchemataClock(context, region, "c_delay", true);
		}endif;
		
		transitions += self.transitions->select(t|t.triggerMessageEvent.oclIsUndefined() and t.raiseMessageEvent.oclIsUndefined()).map Transition2TransitionCoordinator(context, region);
		
		--transition with multicast not conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) and (t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2TransSendSyncCoordinator(context, region, false);
		--transition with multicast conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2TransSendSyncCoordinator(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2TransReceiveSyncCoordinator(context, region);
		
		
		--transition with unicast not conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) and (t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2TransSendSyncCoordinator(context, region, false);
		--transition with unicast conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2TransSendSyncCoordinator(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2TransReceiveSyncCoordinator(context, region);
		
		
		--transition with MultiReceive
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive) and (t.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map MultiReceive2TransSendSyncCoordinator(context, region, false);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map MultiReceive2TransSendSyncCoordinator(context, region, true);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive)).map MultiReceive2TransReceiveSyncCoordinator(context, region);
	
		--transition with singleReceive
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2TransSendSyncCoordinator(context, region);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2TransReceiveSyncCoordinator(context, region);
		
		--transition with iterate not conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate)).map Iterate2TransSendSyncCoordinator(context, region);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate)).map Iterate2TransReceiveDoneCoordinator(context, region);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate)).map Iterate2TransSendCoordinator(context, region);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate)).map Iterate2TransLastSendDoneCoordinator(context, region);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).terminationCondition.oclIsUndefined())).map Iterate2TransTerminationCoordinator(context, region);
		--transition with iterate conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Iterate2TransReceiveSyncCoordinator(context, region);
	
	
	}
	
mapping RealtimeStatechart :: RTSC2SubroleRTSC(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name := "subrole";
		
		states += self.states.map States2StatesSubrole(context, region);
		
		if(not self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "sendUnicast");
		}endif;
		
		if(not self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive))->isEmpty()){
			variables += self.map TransferSchemata2Variable(self, "consumeSingleReceive");
		}endif;
		
		--transitions without message
		transitions += self.transitions->select(t|t.triggerMessageEvent.oclIsUndefined() and t.raiseMessageEvent.oclIsUndefined()).map Transition2TransitionSubrole(context, region);
		transitions += self.transitions->select(t|t.triggerMessageEvent.oclIsUndefined() and t.raiseMessageEvent.oclIsUndefined()).map Transition2TransitionNotLastSubrole(context, region);
		transitions += self.transitions->select(t|t.triggerMessageEvent.oclIsUndefined() and t.raiseMessageEvent.oclIsUndefined()).map Transition2TransitionLastSubrole(context, region);
		
		--transition with multicast
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast)).map Multicast2TransSendSyncSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast)).map Multicast2TransReceiveSyncNotLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast)).map Multicast2TransReceiveSyncLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2TransSendSyncNotConditionSubrole(context, region, true); 
		
		--transition with unicast
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast)).map Unicast2TransSendSyncFirstSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) and (t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2TransSendSynNotFirstcSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast)).map Unicast2TransReceiveSyncNotLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast)).map Unicast2TransReceiveSyncLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2TransSendSyncNotConditionSubrole(context, region, true); 
		
		--transition with MultiReceive
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive)).map MultiReceive2TransSendSyncSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive)).map MultiReceive2TransReceiveSyncNotLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive)).map MultiReceive2TransReceiveSyncLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map MultiReceive2TransSendSyncNotConditionSubrole(context, region, true);
		
		--transition with singlereceive
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2TransSendSyncFirstSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2TransReceiveSyncNotLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2TransReceiveSyncLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2TransSendSyncNotConditionSubrole(context, region, true); 
		
		--transition with iterate
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate)).map Iterate2TransSendSyncSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate)).map Iterate2TransReceiveSyncNotLastSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Iterate2TransSendSyncNotConditionSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).terminationCondition.oclIsUndefined())).map Iterate2TransRecTerminationSubrole(context, region, true); 
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).terminationCondition.oclIsUndefined())).map Iterate2TransSendTerminationSubrole(context, region, true);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).terminationCondition.oclIsUndefined())).map Iterate2TransTerminationLastSubrole(context, region, true);
		
		operations += self.subRoleSpecificOperations.map Operation2Operation(context);
		
		variables += self.subRoleSpecificVariables->map Variable2Variable();
		
		clocks += self.subRoleSpecificClocks.map Clock2Clock();
				
	}
	
mapping State :: States2StatesCoordinator(context:OclAny, region:OclAny) : State {
		
		name := self.name;
		
		initial := self.initial;
		
		final := self.final;
		
		urgent := self.urgent;
		
	
		if(not self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate))->isEmpty()){
			
				entryEvent := self.map Iterate2CurRoleEntryEvent(context, region, 0);
			
		}else{
			entryEvent := self.entryEvent.map EntryEvent2EntryEventCoordinator(context, region);	
		}endif;
		
		exitEvent := self.exitEvent.map ExitEvent2ExitEventCoordinator(context, region);
		
		doEvent := self.doEvent.map Do2Do(context, region);
		
		invariants := self.invariants->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);
		
		--embedded Regions for transfer schemata
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2SourceRegionCoordinator(context, region);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2SourceRegionCoordinator(context, region);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive)).map MultiReceive2SourceRegionCoordinator(context, region);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2SourceRegionCoordinator(context, region);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Iterate2SourceRegionCoordinator(context, region);			
	}
	
mapping State :: States2StatesSubrole(context:OclAny, region:OclAny) : State {
		
		name := self.name;
		
		initial := self.initial;
		
		final := self.final;
		
		urgent := self.urgent;
		
		
		
		if((not self.entryEvent.oclIsUndefined()) and (not self.entryEvent.clockResets->select(c|isClockSubRoleSpecific(c))->isEmpty())){
			entryEvent := self.entryEvent.map EntryEvent2EntryEventSubrole(context, region);
		}endif;
		
		if((not self.exitEvent.oclIsUndefined()) and (not self.exitEvent.clockResets->select(c|isClockSubRoleSpecific(c))->isEmpty())){
			exitEvent := self.exitEvent.map ExitEvent2ExitEventCoordinator(context, region);
		}endif;
		
		invariants := self.invariants->select(c|isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);
		
		--embedded Regions for transfer schemata
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2SourceRegionSubrole(context, region);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2SourceRegionSubrole(context, region);	
		embeddedRegions += self.outgoingTransitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive)).map MultiReceive2SourceRegionSubrole(context, region);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(SingleReceive)).map SingleReceive2SourceRegionSubrole(context, region);	
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Iterate2SourceRegionSubrole(context, region);
					
	}
	

	

mapping Transition :: Transition2TransitionCoordinator(context:OclAny, region:OclAny) : Transition {
		
		source := self.source.oclAsType(State).map Vertex2VertexCoordinator(context, region);
		target := self.target.oclAsType(State).map Vertex2VertexCoordinator(context, region);
		
		priority := self.priority;
		
		clockResets := self.clockResets->select(c|not isClockSubRoleSpecific(c))->map Clock2Clock();
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(context, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		action := self.action.map Action2Action(context, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "switchState", true, 1);
		
		absoluteDeadlines := self.absoluteDeadlines->map AbsoluteDeadline2AbsoluteDeadline(context, region);
		
		relativeDeadline := self.relativeDeadline.map RelativeDeadline2RelativeDeadline(context, region);
		
		blockable := self.blockable;
		
		urgent := self.urgent;
						
	}
	
mapping Transition :: Transition2TransitionSubrole(context:OclAny, region:OclAny) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		target := self.map TransitionNoMessage2TransitionRecSyncSubrole(context, region);
		
		priority := self.priority;
		
		clockResets := self.clockResets->select(c|isClockSubRoleSpecific(c))->map Clock2Clock();
		
		clockConstraints := self.clockConstraints->map ClockConstraint2ClockConstraint(1, region);
		
		guard := self.guard.map Expression2Expression(1);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "switchState", true, 2);
		
	}
	
mapping Transition :: Transition2TransitionNotLastSubrole(context:OclAny, region:OclAny) : Transition {
		
		source := self.map TransitionNoMessage2TransitionRecSyncSubrole(context, region);
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		priority := 2;
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 1);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "switchState", true, 3);
		
	}
	
mapping Transition :: Transition2TransitionLastSubrole(context:OclAny, region:OclAny) : Transition {
		
		source := self.map TransitionNoMessage2TransitionRecSyncSubrole(context, region);
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		priority := 1;
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 2);
		
	}
	
mapping Transition :: TransitionNoMessage2TransitionRecSyncSubrole(context:OclAny, region:OclAny) : State {
		
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_SwitchState";
		
		parentStatechart := self.statechart.map RTSC2SubroleRTSC(context, region);
		
	}
	
----------------------------------------------------------XXXXXXXXXXXXXXXXX--MULTICAST--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------	
----------------------------------------------------------------Transfer Schema Multicast of Coordinator------------------------------------------------------------------
	
mapping Transition :: Multicast2TransSendSyncCoordinator(context:OclAny, region:OclAny, conditional:Boolean) : Transition {

		priority := self.priority;
		
		if(conditional){			
			source := self.map Multicast2StateCoordinator(context, region);
		}else{
			source := self.source.map Vertex2VertexCoordinator(context, region);
		}endif;
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
		
		if(not conditional){
			guard := self.guard.map Expression2Expression(context);
			clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(1, region);
		}endif;
		
		action := self.action.map Action2Action(context, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "multicast", true, 1);
			
	}

mapping Transition :: Multicast2SourceRegionCoordinator(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map Multicast2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: Multicast2SourceEmbeddedRTSCCoordinator(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "multicastCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map Multicast2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map Multicast2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: Multicast2TransCheckEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(2, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "multicastCheck", true, 2);
			
	}
	
mapping Transition :: Multicast2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "multicastCheckDone", false, 3);
		
		guard := self.map TransferSchemaGuard(context, region, "multicastPossible", true, 1);
			
	}
	
	
mapping Transition :: Multicast2StateCoordinator(context:OclAny, region:OclAny) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Sending";
		
		parentStatechart := self.statechart.map RTSC2CoordinatorRTSC(context, region);	
						
	}
	
mapping Transition :: Multicast2TransReceiveSyncCoordinator(context:OclAny, region:OclAny) : Transition {
	
		priority := self.priority;
		
		target := self.map Multicast2StateCoordinator(context, region);
		
		source := self.source.map Vertex2VertexCoordinator(context, region);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "multicastCheckDone", false, 4);
		
		if(self.guard.oclIsUndefined()){
			guard := self.map TransferSchemata2TypedNamedElementExpr(context, "multicastPossible",2);
		}else{
			guard := self.map TransferSchemaGuardAndPossibleGuard(context, 5, region, "multicastPossible", 2);
		}endif;
					
	}
	
----------------------------------------------------------------- Transfer Schema Multicast of Subrole-------------------------------------------------------------------
	
mapping Transition :: Multicast2TransSendSyncSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Multicast2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "multicast", true, 5);
		
		clockConstraints += self.clockConstraints->select(c|isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		action := self.raiseMessageEvent.oneToManyCommunicationSchema.action.map Action2Action(context, region);
		
		events += self.raiseMessageEvent.map Asynchronous2Asynchronous(context);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			guard := self.map TransferSchemaConditionAndPossibleGuard(context, 1, region, "multicastPossible", false, 3);
			priority := (self.priority-1)*2+2;
			
		}else{
			priority := self.priority;
		}endif;
		
	}
	
mapping Transition :: Multicast2TransReceiveSyncNotLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Multicast2StateSubrole(context, region, toplevel);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "multicast", true, 6);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 4);
					
	}
			
mapping Transition :: Multicast2TransReceiveSyncLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Multicast2StateSubrole(context, region, toplevel);		
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 5);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Multicast) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			action := self.map TransferSchemata2Action(context, "multicastPossible:=false", "multicastPossible", "false", 12);
			
		}endif;
					
	}
	
mapping Transition :: Multicast2StateSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Sending";
		
		parentStatechart := self.statechart.map RTSC2SubroleRTSC(context, region);			
					
	}
	
mapping Transition :: Multicast2SourceRegionSubrole(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexSubrole(context, region).oclAsType(State);
		
		embeddedStatechart := self.map Multicast2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: Multicast2SourceEmbeddedRTSCSubrole(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "multicastCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requested", false);
		
		transitions += self.map Multicast2RequestedIdleCheckSubrole(context, region);
		transitions += self.map Multicast2RequestedIdleCheckDoneSubrole(context, region);
		transitions += self.map Multicast2IdleRequestedFulfilledSubrole(context, region);
		transitions += self.map Multicast2IdleRequestedNotFulfilledSubrole(context, region);
					
	}
	
mapping Transition :: Multicast2RequestedIdleCheckSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 6);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "multicastCheck", true, 7);
					
	}
	
mapping Transition :: Multicast2RequestedIdleCheckDoneSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "multicastCheckDone", false, 8);
					
	}
	
mapping Transition :: Multicast2IdleRequestedFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(2);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "multicastCheck", true, 9);
		
		action := self.map TransferSchemata2Action(context, "multicastPossible:=true", "multicastPossible", "true", 10);
					
	}
	
mapping Transition :: Multicast2IdleRequestedNotFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemaNotCondition(3, region, 3);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "multicastCheck", true, 10);
					
	}
	
mapping Transition :: Multicast2TransSendSyncNotConditionSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Multicast2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "multicast", true, 11);--error
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
				
		guard := self.map TransferSchemaConditionAndPossibleGuard(context, 4, region, "multicastPossible", true, 11);
		
		priority := (self.priority-1)*2+1;
		
	}
	
----------------------------------------------------------XXXXXXXXXXXXXXXXX--UNICAST--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

------------------------------------------------------------Transfer Schema Unicast of Coordinator------------------------------------------------------------------
	
mapping Transition :: Unicast2TransSendSyncCoordinator(context:OclAny, region:OclAny, conditional:Boolean) : Transition {

		priority := self.priority;
		
		if(conditional){			
			source := self.map Unicast2StateCoordinator(context, region);
		}else{
			source := self.source.map Vertex2VertexCoordinator(context, region);
		}endif;
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
		
		if(not conditional){
			guard := self.guard.map Expression2Expression(context);
			
			clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(1, region);
		}endif;
		
		action := self.action.map Action2Action(1, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "unicast", true, 1);
			
	}

mapping Transition :: Unicast2SourceRegionCoordinator(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map Unicast2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: Unicast2SourceEmbeddedRTSCCoordinator(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "unicastCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map Unicast2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map Unicast2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: Unicast2TransCheckEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints.map ClockConstraint2ClockConstraint(2, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "unicastCheck", true, 2);
			
	}
	
mapping Transition :: Unicast2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "unicastCheckDone", false, 3);
		
		guard := self.map TransferSchemaGuard(context, region, "unicastPossible", true, 1);
			
	}
	
	
mapping Transition :: Unicast2StateCoordinator(context:OclAny, region:OclAny) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Sending";
		
		parentStatechart := self.statechart.map RTSC2CoordinatorRTSC(context, region);	
						
	}
	
mapping Transition :: Unicast2TransReceiveSyncCoordinator(context:OclAny, region:OclAny) : Transition {
	
		priority := self.priority;
		
		target := self.map Unicast2StateCoordinator(context, region);
		
		source := self.source.map Vertex2VertexCoordinator(context, region);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(1, region);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "unicastCheckDone", false, 4);
		
		if(self.guard.oclIsUndefined()){
			guard := self.map TransferSchemata2TypedNamedElementExpr(context, "unicastPossible",2);
		}else{
			guard := self.map TransferSchemaGuardAndPossibleGuard(context, 5, region, "unicastPossible", 2);
		}endif;
					
	}
	
--------------------------------------------------------------- Transfer Schema Unicast of Subrole----------------------------------------------------------------------
	
mapping Transition :: Unicast2TransSendSyncFirstSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {

		priority := (self.priority-1)*2+2;
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Unicast2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "unicast", true, 5);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		events += self.raiseMessageEvent.map Asynchronous2Asynchronous(context);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			guard := self.map TransferSchemaSingleSendAndPossibleGuard(context, 4, region,"sendUnicast", "unicastPossible", false, 3);
			
			if(self.action.oclIsUndefined()){
				action := self.map TransferSchemata2Action(context, "sendUnicast:=false", "sendUnicast", "false", 1)
			}else{
				action := self.map TransferSchemata2TwoActionsTransAct(context, "sendUnicast:=false", "sendUnicast", "false", 1);
			}endif;
			
		}else{	
			guard := self.map TransferSchemataLogicalExpression(context, region, "==", "first", 8);
			action := self.raiseMessageEvent.oneToManyCommunicationSchema.action.map Action2Action(context, region);
		}endif;
		
	}
	
mapping Transition :: Unicast2TransSendSynNotFirstcSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {

		priority := (self.priority-1)*2+1;
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Unicast2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "unicast", true, 12);--error
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "first", 9);
		
	}
	
mapping Transition :: Unicast2TransReceiveSyncNotLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Unicast2StateSubrole(context, region, toplevel);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "unicast", true, 6);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 4);
					
	}
			
mapping Transition :: Unicast2TransReceiveSyncLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Unicast2StateSubrole(context, region, toplevel);		
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 5);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Unicast) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			action := self.map TransferSchemata2Action(context, "unicastPossible:=false", "unicastPossible", "false", 12);
			
		}endif;
					
	}
	
mapping Transition :: Unicast2StateSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Sending";
		
		parentStatechart := self.statechart.map RTSC2SubroleRTSC(context, region);			
					
	}
	
mapping Transition :: Unicast2SourceRegionSubrole(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexSubrole(context, region).oclAsType(State);
		
		embeddedStatechart := self.map Unicast2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: Unicast2SourceEmbeddedRTSCSubrole(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "unicastCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requested", false);
		
		transitions += self.map Unicast2RequestedIdleCheckSubrole(context, region);
		transitions += self.map Unicast2RequestedIdleCheckDoneLastSubrole(context, region);
		transitions += self.map Unicast2RequestedIdleCheckDonePossibleSubrole(context, region);
		transitions += self.map Unicast2IdleRequestedFulfilledSubrole(context, region);
		transitions += self.map Unicast2IdleRequestedNotFulfilledSubrole(context, region);
					
	}
	
mapping Transition :: Unicast2RequestedIdleCheckSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map UnicastNotLastAndPossibleExpression(context, region, "unicastPossible", true, 60);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "unicastCheck", true, 7);
		
	}
	
mapping Transition :: Unicast2RequestedIdleCheckDoneLastSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "unicastCheckDone", false, 8);
					
	}
	
mapping Transition :: Unicast2RequestedIdleCheckDonePossibleSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 3;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map UnicastNotLastAndPossibleExpression(context, region, "unicastPossible", false, 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "unicastCheckDone", false, 9);
		
	}
	
mapping Transition :: Unicast2IdleRequestedFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(2);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "unicastCheck", true, 10);
		
		action := self.map TransferSchemata2TwoActions(context, "unicastPossible:=true; sendUnicast:=true", "unicastPossible", "sendUnicast", "true", 10);
					
	}
	
mapping Transition :: Unicast2IdleRequestedNotFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemaNotCondition(3, region, 3);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "unicastCheck", true, 11);
					
	}
	
mapping Transition :: Unicast2TransSendSyncNotConditionSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Unicast2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "unicast", true, 12);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
				
		guard := self.map TransferSchemaSingleSendAndPossibleGuard(context, 4, region,"sendUnicast", "unicastPossible", true, 11);
		
		priority := (self.priority-1)*2+1;
		
	}
	
mapping Transition :: UnicastNotLastAndPossibleExpression(context:OclAny, region:OclAny, varName:String, notOp: Boolean, transMapping: Integer) : LogicalExpression {

		leftExpression := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 10+transMapping);
		
		if(notOp){
			rightExpression := self.map TransferSchemaGuard(context, region, varName, true, transMapping);
		}else{
			rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName, transMapping);
		}endif;
		
		operator := LogicOperator::AND;
}	
	
----------------------------------------------------------XXXXXXXXXXXXXXXX--MultiReceive--XXXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

-------------------------------------------------------------Transfer Schema MultiReceive of Coordinator------------------------------------------------------------------
	
mapping Transition :: MultiReceive2TransSendSyncCoordinator(context:OclAny, region:OclAny, conditional:Boolean) : Transition {

		priority := self.priority;
			
		source := self.map MultiReceive2StateCoordinator(context, region);
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
				
		action := self.action.map Action2Action(context, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "MultiReceive", true, 1);
			
	}

mapping Transition :: MultiReceive2SourceRegionCoordinator(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map MultiReceive2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: MultiReceive2SourceEmbeddedRTSCCoordinator(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "MultiReceiveCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map MultiReceive2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map MultiReceive2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: MultiReceive2TransCheckEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "MultiReceiveCheck", true, 2);
			
	}
	
mapping Transition :: MultiReceive2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "MultiReceiveCheckDone", false, 3);
		
		if(self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			guard := self.map TransferSchemata2TypedNamedElementExpr(context, "error", 22);
		}else{
			guard := self.map TransferSchemaErrorOrNotPossibleGuard(context, region, "error", "MultiReceivePossible", true, 3);
		}endif;
		
		action := self.map TransferSchemata2Action(context, "error:=false", "error", "false", 20);
			
	}
	
	
mapping Transition :: MultiReceive2StateCoordinator(context:OclAny, region:OclAny) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Receiving";
		
		parentStatechart := self.statechart.map RTSC2CoordinatorRTSC(context, region);	
						
	}
	
mapping Transition :: MultiReceive2TransReceiveSyncCoordinator(context:OclAny, region:OclAny) : Transition {
	
		priority := self.priority;
		
		target := self.map MultiReceive2StateCoordinator(context, region);
		
		source := self.source.map Vertex2VertexCoordinator(context, region);
		
		clockConstraints += self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(1, region);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "MultiReceiveCheckDone", false, 4);
		
		if(self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			if(self.guard.oclIsUndefined()){
				guard := self.map TransferSchemaGuard(context, region, "error", false, 1);
			}else{
				guard := self.map TransferSchemaGuardAndNotPossibleGuard(context, 5, region, "error", 2);
			}endif;
		}else{
			if(self.guard.oclIsUndefined()){
				guard := self.map TransferSchemaNotVarAndVarGuard(context, region, "error", "MultiReceivePossible", true, 2)
			}else{
				guard := self.map TransferSchemaThreeVariablesGuard(context, 5, region, "error", "MultiReceivePossible", true, 2);
			}endif;
		}endif;	
					
	}
	
------------------------------------------------------------------ Transfer Schema MultiReceive of Subrole---------------------------------------------------------------
	
mapping Transition :: MultiReceive2TransSendSyncSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map MultiReceive2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "MultiReceive", true, 5);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		action := self.triggerMessageEvent.oneToManyCommunicationSchema.action.map Action2Action(context, region);
		
		events += self.triggerMessageEvent.map Asynchronous2Asynchronous(context);		
		
		if((not self.triggerMessageEvent.oclIsUndefined()) and (not self.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive) 
				and (not self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			priority := (self.priority-1)*2+2;
			
			guard := self.map TransferSchemaConditionAndPossibleGuard(context, 93, region, "MultiReceivePossible", false, 77);
			
		}else{
			priority := self.priority;
		}endif;
		
	}
	
mapping Transition :: MultiReceive2TransReceiveSyncNotLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map MultiReceive2StateSubrole(context, region, toplevel);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "MultiReceive", true, 6);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 4);
					
	}
			
mapping Transition :: MultiReceive2TransReceiveSyncLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map MultiReceive2StateSubrole(context, region, toplevel);		
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 5);
		
		if((not self.triggerMessageEvent.oclIsUndefined()) and (not self.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(MultiReceive) 
				and (not self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			action := self.map TransferSchemata2Action(context, "MultiReceivePossible:=false", "MultiReceivePossible", "false", 12);
			
		}endif;
					
	}
	
mapping Transition :: MultiReceive2StateSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Receiving";
		
		parentStatechart := self.statechart.map RTSC2SubroleRTSC(context, region);			
					
	}
	

mapping Transition :: MultiReceive2SourceRegionSubrole(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexSubrole(context, region).oclAsType(State);
		
		embeddedStatechart := self.map MultiReceive2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: MultiReceive2SourceEmbeddedRTSCSubrole(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "MultiReceiveCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requested", false);
		
		transitions += self.map MultiReceive2RequestedIdleCheckSubrole(context, region);
		transitions += self.map MultiReceive2RequestedIdleCheckDoneSubrole(context, region);
		transitions += self.map MultiReceive2IdleRequestedFulfilledSubrole(context, region);
		transitions += self.map MultiReceive2IdleRequestedNotFulfilledSubrole(context, region);
		
		if(not self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			transitions += self.map MultiReceive2IdleRequestedFulfilledNoMsgSubrole(context, region);
		}endif;	
					
	}
	
mapping Transition :: MultiReceive2RequestedIdleCheckSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 6);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "MultiReceiveCheck", true, 7);
					
	}
	
mapping Transition :: MultiReceive2RequestedIdleCheckDoneSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "MultiReceiveCheckDone", false, 8);
					
	}
	
mapping Transition :: MultiReceive2IdleRequestedFulfilledSubrole(context:OclAny, region:OclAny) : Transition {

		if(self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			priority := 2;
		}else{
			priority := 3;
		}endif;
			
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		if(not self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			guard := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(2);
			action := self.map TransferSchemata2Action(context, "MultiReceivePossible:=true", "MultiReceivePossible", "true", 13);
		}endif;
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "MultiReceiveCheck", true, 9);
		
		events += self.triggerMessageEvent.map TriggerMessage2TriggerWithoutConsume(1);
					
	}
	
mapping Transition :: MultiReceive2IdleRequestedFulfilledNoMsgSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(5);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "MultiReceiveCheck", true, 12);
		
		action := self.map TransferSchemata2Action(context, "error:=true", "error", "true", 10);
					
	}
	
mapping Transition :: MultiReceive2IdleRequestedNotFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		if(not self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			guard := self.map TransferSchemaNotCondition(3, region, 3);
		}else{
			action := self.map TransferSchemata2Action(context, "error:=true", "error", "true", 10);
		}endif;
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "MultiReceiveCheck", true, 10);
					
	}
	
mapping Transition :: MultiReceive2TransSendSyncNotConditionSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map MultiReceive2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "MultiReceive", true, 11);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
				
		guard := self.map TransferSchemaConditionAndPossibleGuard(context, 4, region, "MultiReceivePossible", true, 11);
		
		priority := (self.priority-1)*2+1;
		
	}

----------------------------------------------------------XXXXXXXXXXXXXXXXX--SINGLE-RECEIVE--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

--------------------------------------------------------------Transfer Schema SingleReceive of Coordinator------------------------------------------------------------------
	
mapping Transition :: SingleReceive2TransSendSyncCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := self.priority;
		
		source := self.map SingleReceive2StateCoordinator(context, region);
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
		
		action := self.action.map Action2Action(1, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "singleReceive", true, 1);
			
	}

mapping Transition :: SingleReceive2SourceRegionCoordinator(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map SingleReceive2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: SingleReceive2SourceEmbeddedRTSCCoordinator(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "singleReceiveCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map SingleReceive2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map SingleReceive2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: SingleReceive2TransCheckEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(2, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "singleReceiveCheck", true, 2);
			
	}
	
mapping Transition :: SingleReceive2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "singelReceiveCheckDone", false, 3);
		
		guard := self.map TransferSchemaGuard(context, region, "singleReceivePossible", true, 1);
			
	}
	
	
mapping Transition :: SingleReceive2StateCoordinator(context:OclAny, region:OclAny) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Receiving";
		
		parentStatechart := self.statechart.map RTSC2CoordinatorRTSC(context, region);	
						
	}
	
mapping Transition :: SingleReceive2TransReceiveSyncCoordinator(context:OclAny, region:OclAny) : Transition {
	
		priority := self.priority;
		
		target := self.map SingleReceive2StateCoordinator(context, region);
		
		source := self.source.map Vertex2VertexCoordinator(context, region);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "singleReceiveCheckDone", false, 4);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(1, region);
		
		if(self.guard.oclIsUndefined()){
			guard := self.map TransferSchemata2TypedNamedElementExpr(context, "singleReceivePossible",2);
		}else{
			guard := self.map TransferSchemaGuardAndPossibleGuard(context, 5, region, "singleReceivePossible", 2);
		}endif;
					
	}
	
--------------------------------------------------------------- Transfer Schema SingleReceive of Subrole------------------------------------------------------------------
	
mapping Transition :: SingleReceive2TransSendSyncFirstSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {

		priority := (self.priority-1)*2+2;
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map SingleReceive2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "singleReceive", true, 5);
		
		clockConstraints += self.clockConstraints->select(c|isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();	
		
		events += self.triggerMessageEvent.map Asynchronous2Asynchronous(context);
		
		guard := self.map TransferSchemaSingleSendAndPossibleGuard(context, 4, region,"consumeSingleReceive", "singleReceivePossible", false, 3);
		
		if(self.action.oclIsUndefined()){
			action := self.map TransferSchemata2Action(context, "consumeSingleReceive:=false", "consumeSingleReceive", "false", 1)
		}else{
			action := self.map TransferSchemata2TwoActionsTransAct(context, "consumeSingleReceive:=false", "consumeSingleReceive", "false", 1);
		}endif;
					
	}
	
mapping Transition :: SingleReceive2TransReceiveSyncNotLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map SingleReceive2StateSubrole(context, region, toplevel);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "singleReceive", true, 6);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 4);
					
	}
			
mapping Transition :: SingleReceive2TransReceiveSyncLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map SingleReceive2StateSubrole(context, region, toplevel);		
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 5);
				
		action := self.map TransferSchemata2Action(context, "singleReceivePossible:=false", "singleReceivePossible", "false", 12);
					
	}
	
mapping Transition :: SingleReceive2StateSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Receiving";
		
		parentStatechart := self.statechart.map RTSC2SubroleRTSC(context, region);			
					
	}
	
mapping Transition :: SingleReceive2SourceRegionSubrole(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexSubrole(context, region).oclAsType(State);
		
		embeddedStatechart := self.map SingleReceive2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: SingleReceive2SourceEmbeddedRTSCSubrole(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "singleReceiveCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requested", false);
		
		transitions += self.map SingleReceive2RequestedIdleCheckSubrole(context, region);
		transitions += self.map SingleReceive2RequestedIdleCheckDoneLastSubrole(context, region);
		transitions += self.map SingleReceive2RequestedIdleCheckDonePossibleSubrole(context, region);
		transitions += self.map SingleReceive2IdleRequestedFulfilledSubrole(context, region);
		transitions += self.map SingleReceive2IdleRequestedNotFulfilledSubrole(context, region);
					
	}
	
mapping Transition :: SingleReceive2RequestedIdleCheckSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map SingleReceiveNotLastAndPossibleExpression(context, region, "singleReceivePossible", true, 60);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "singleReceiveCheck", true, 7);
		
	}
	
mapping Transition :: SingleReceive2RequestedIdleCheckDoneLastSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "singleReceiveCheckDone", false, 8);
					
	}
	
mapping Transition :: SingleReceive2RequestedIdleCheckDonePossibleSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 3;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map SingleReceiveNotLastAndPossibleExpression(context, region, "singleReceivePossible", false, 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "singleReceiveCheckDone", false, 9);
		
	}
	
mapping Transition :: SingleReceive2IdleRequestedFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		if(not self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			guard := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(2);
		}endif;
			
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "singleReceiveCheck", true, 10);
		
		action := self.map TransferSchemata2TwoActions(context, "singleReceivePossible:=true; consumeSingleReceive:=true", "singleReceivePossible", "consumeSingleReceive", "true", 10);
		
		events += self.triggerMessageEvent.map TriggerMessage2TriggerWithoutConsume(1);
							
	}
	
mapping Transition :: SingleReceive2IdleRequestedNotFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "singleReceiveCheck", true, 11);
					
	}
	
mapping Transition :: SingleReceive2TransSendSyncNotConditionSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map SingleReceive2StateSubrole(context, region, toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "singleReceive", true, 12);--error
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
				
		guard := self.map TransferSchemaSingleSendAndPossibleGuard(context, 4, region,"consumeSingleReceive", "singleReceivePossible", true, 11);
		
		priority := (self.priority-1)*2+1;
		
	}
	
mapping Transition :: SingleReceiveNotLastAndPossibleExpression(context:OclAny, region:OclAny, varName:String, notOp: Boolean, transMapping: Integer) : LogicalExpression {

		leftExpression := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 10+transMapping);
		
		if(notOp){
			rightExpression := self.map TransferSchemaGuard(context, region, varName, true, transMapping);
		}else{
			rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName, transMapping);
		}endif;
		
		operator := LogicOperator::AND;
}


----------------------------------------------------------XXXXXXXXXXXXXXXXX--ITERATE--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

--------------------------------------------------------------Transfer Schema Iterate of Coordinator----------------------------------------------------------------------
	
mapping Transition :: Iterate2TransSendSyncCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := self.priority;
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
		 source := self.source.map Vertex2VertexCoordinator(context, region);
		 guard := self.guard.map Expression2Expression(context);
		 clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);
		}else{
			source := self.map Iterate2StateCoordinator(context, "IteratePossible", region);
		};
		
		target := self.map Iterate2StateCoordinator(context, "Waiting", region);
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
			synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "curRole", "iterate", true, 17);
		}else{
			synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "curRole", "iterate", true, 17);
		}endif;
		
		if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).delay.oclIsUndefined()){
			clockResets += context.oclAsType(RealtimeStatechart).map TransferSchemataClock(context, region, "c_delay", true);
		}endif;
	
	}
	
mapping Transition :: Iterate2TransReceiveDoneCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 2;
			
		source := self.map Iterate2StateCoordinator(context, "Waiting", region);
		
		target := self.map Iterate2StateCoordinator(context, "Sending", region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "curRole", "iterateDone", true, 2);
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
			guard := self.map IterateLogicalExpression(context, region, "<>", "last", 6);
		}else{
			guard := self.map IterateLogicalExpression(context, region, "<>", "first", 6);
		}endif;
		
		action := self.map Iterate2Action(context, region, 1);
			
	}
	
mapping Transition :: Iterate2TransSendCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
			
		target := self.map Iterate2StateCoordinator(context, "Waiting", region);
		
		source := self.map Iterate2StateCoordinator(context, "Sending", region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "curRole", "iterate", true, 3);
		
		if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).delay.oclIsUndefined()){
			clockResets += context.oclAsType(RealtimeStatechart).map TransferSchemataClock(context, region, "c_delay", true);
			clockConstraints += self.map Iterate2DelayClockConstraint(context, region, ComparingOperator::GREATER_OR_EQUAL, 1);
		}endif;
		
		if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).terminationCondition.oclIsUndefined()){
			guard := self.map IterateTeminationGuard(context, region);
		}endif;
			
	}
	
mapping Transition :: Iterate2TransLastSendDoneCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
			
		source := self.map Iterate2StateCoordinator(context, "Waiting", region);
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "curRole", "iterateDone", true, 4);
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
			guard := self.map IterateLogicalExpression(context, region, "==", "last", 9);
		}else{
			guard := self.map IterateLogicalExpression(context, region, "==", "first", 9);
		}endif;
	
		if(self.action.oclIsUndefined() and not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			action := self.map TransferSchemata2Action(context, "iteratePossible:=false", "iteratePossible", "false", 10);
		}else{
			if(self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined() and not self.action.oclIsUndefined()){
				action := self.action.map Action2Action(context, region);
			}else{
				if((not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()) and not self.action.oclIsUndefined()){
					action := self.map IterateConditionAction(context, region, 1);
				}endif;
			}endif;
		}endif;
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
			
	}
	
mapping Transition :: Iterate2TransTerminationCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 2;
			
		source := self.map Iterate2StateCoordinator(context, "Sending", region);
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "curRole", "iterateTerminated", true, 5);
		
		guard := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).terminationCondition.map Expression2Expression(1);
	
		if(self.action.oclIsUndefined() and not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()){
			action := self.map TransferSchemata2Action(context, "iteratePossible:=false", "iteratePossible", "false", 11);
		}else{
			if(self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined() and not self.action.oclIsUndefined()){
				action := self.action.map Action2Action(1, region);
			}else{
				if((not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()) and not self.action.oclIsUndefined()){
					action := self.map IterateConditionAction(context, region, 2);
				}endif;
			}endif;
		}endif;
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
			
	}
	
mapping Transition :: Iterate2DelayClockConstraint(context:OclAny, region:OclAny, comOp:ComparingOperator, transMapping:Integer) : ClockConstraint {
				
		clock := context.oclAsType(RealtimeStatechart).map TransferSchemataClock(context, region, "c_delay", true);
				
		operator := comOp;
		
		bound := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).delay.map TimeValue2TimeValue(transMapping, transMapping);
	}
	
mapping Transition :: IterateTeminationGuard(context:OclAny, region:OclAny) : UnaryExpression {

		enclosedExpression := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).terminationCondition.map Expression2Expression(context);		
		
		operator := UnaryOperator::NOT;
	
	}
	
mapping Transition :: IterateConditionAction(context:OclAny, region:OclAny, transMapping:Integer) : Action {

		name := self.action.name + "; iteratePossible:=false";
		
		result.expressions += self.map IterateConditionActionBlock(context, region, transMapping);		
	}
	
mapping Transition :: IterateConditionActionBlock(context:OclAny, region:OclAny, transMapping:Integer) : Block {

		result.expressions += self.action.expressions->first().oclAsType(Block).expressions.map Expression2Expression(transMapping);
		
		result.expressions += self.map TransferSchemata2Assignment(context, "iteratePossible", "false", 20+transMapping);
	}

mapping Transition :: Iterate2SourceRegionCoordinator(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map Iterate2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: Iterate2SourceEmbeddedRTSCCoordinator(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "iterateCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map Iterate2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map Iterate2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: Iterate2TransCheckEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(2, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "iterateCheck", true, 2);
			
	}
	
mapping Transition :: Iterate2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "iterateCheckDone", false, 3);
		
		guard := self.map TransferSchemaGuard(context, region, "iteratePossible", true, 1);
			
	}
	
	
mapping Transition :: Iterate2StateCoordinator(context:OclAny, stateName:String, region:OclAny) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_" + stateName;
		
		parentStatechart := self.statechart.map RTSC2CoordinatorRTSC(context, region);	
		
		if(stateName.equalsIgnoreCase("Sending") and not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).delay.oclIsUndefined()){
			invariants += self.map Iterate2DelayClockConstraint(context, region, ComparingOperator::LESS, 2);
		}endif;
						
	}
	
mapping Transition :: Iterate2TransReceiveSyncCoordinator(context:OclAny, region:OclAny) : Transition {
	
		priority := self.priority;
		
		target := self.map Iterate2StateCoordinator(context, "IteratePossible", region);
		
		source := self.source.map Vertex2VertexCoordinator(context, region);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "iterateCheckDone", false, 4);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(1, region);
		
		if(self.guard.oclIsUndefined()){
			guard := self.map TransferSchemata2TypedNamedElementExpr(context, "iteratePossible",2);
		}else{
			guard := self.map TransferSchemaGuardAndPossibleGuard(context, 2, region, "iteratePossible", 2);
		}endif;
					
	}
	
--------------------------------------------------------------------- Transfer Schema Iterate of Subrole-----------------------------------------------------------------
	
mapping Transition :: Iterate2TransSendSyncSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Iterate2StateSubrole(context, region, "Sending", toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "iterate", true, 5);--error
		
		clockConstraints += self.clockConstraints->select(c|isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(context, region);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		action := self.raiseMessageEvent.oneToManyCommunicationSchema.action.map Action2Action(context, region);
		
		events += self.raiseMessageEvent.map Asynchronous2Asynchronous(context);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			guard := self.map TransferSchemaConditionAndPossibleGuard(context, 1, region, "iteratePossible", false, 3);
			priority := (self.priority-1)*2+2;
			
		}else{
			priority := self.priority;
		}endif;
		
	}
	
mapping Transition :: Iterate2TransReceiveSyncNotLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Iterate2StateSubrole(context, region, "Sending", toplevel);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self", "iterateDone", true, 6);
					
	}
	
mapping Transition :: Iterate2TransRecTerminationSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Iterate2StateSubrole(context, region, "Terminated", toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "iterateTerminated", true, 7);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){

			priority := (self.priority-1)*2+2+1;
			
		}else{
			priority := self.priority+1;
		}endif;
		
	}
	
mapping Transition :: Iterate2TransSendTerminationSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Iterate2StateSubrole(context, region, "Terminated", toplevel);		
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
			synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "iterateTerminated", true, 8);
			guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 4);
		}else{
			synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.prev", "iterateTerminated", true, 8);
			guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "first", 4);
		}endif;	
					
	}
			
mapping Transition :: Iterate2TransTerminationLastSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Iterate2StateSubrole(context, region, "Terminated", toplevel);		
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
			guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 5)
		}else{
			guard := self.map TransferSchemataLogicalExpression(context, region, "==", "first", 5)
		}endif;
					
	}

	
mapping Transition :: Iterate2StateSubrole(context:OclAny, region:OclAny, stateName:String, toplevel:Boolean) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_" + stateName;
		
		parentStatechart := self.statechart.map RTSC2SubroleRTSC(context, region);			
					
	}
	
mapping Transition :: Iterate2SourceRegionSubrole(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexSubrole(context, region).oclAsType(State);
		
		embeddedStatechart := self.map Iterate2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: Iterate2SourceEmbeddedRTSCSubrole(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "iterateCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requested", false);
		
		transitions += self.map Iterate2RequestedIdleCheckSubrole(context, region);
		transitions += self.map Iterate2RequestedIdleCheckDoneSubrole(context, region);
		transitions += self.map Iterate2IdleRequestedFulfilledSubrole(context, region);
		transitions += self.map Iterate2IdleRequestedNotFulfilledSubrole(context, region);
					
	}
	
mapping Transition :: Iterate2RequestedIdleCheckSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 6);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "iterateCheck", true, 7);
					
	}
	
mapping Transition ::Iterate2RequestedIdleCheckDoneSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "iterateCheckDone", false, 8);
					
	}
	
mapping Transition :: Iterate2IdleRequestedFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(2);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "iterateCheck", true, 9);
		
		action := self.map TransferSchemata2Action(context, "iteratePossible:=true", "iteratePossible", "true", 10);
					
	}
	
mapping Transition :: Iterate2IdleRequestedNotFulfilledSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemaNotCondition(3, region, 3);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "iterateCheck", true, 10);
					
	}
	
mapping Transition :: Iterate2TransSendSyncNotConditionSubrole(context:OclAny, region:OclAny, toplevel:Boolean) : Transition {
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Iterate2StateSubrole(context, region, "Sending", toplevel);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "iterate", true, 11);--error
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
				
		guard := self.map TransferSchemaConditionAndPossibleGuard(context, 4, region, "iteratePossible", true, 11);
		
		priority := (self.priority-1)*2+1;
		
	}


----------------------------------------------------XXXXXXXXXXXXXXXX--MAPPINGS FOR ALL TRANSFER SCHEMATA--XXXXXXXXXXXXXXXXXX--------------------------------------------
	
--Transfer Schemata State
mapping Transition :: RegionState(context:OclAny, region:OclAny, StateName:String, ini:Boolean) : State {
		
		name := StateName;
		
		initial := ini;
		
	}
	
--Transfer Schemata Guard
mapping Transition :: TransferSchemaConditionAndPossibleGuard(context1:OclAny, context2:OclAny, region:OclAny, varName:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			leftExpression := self.map TransferSchemaNotCondition(context2, region, transMapping);
		}else{
			if(not self.raiseMessageEvent.oclIsUndefined()){
				leftExpression := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context2);
			}else{
				leftExpression := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context2);
			}endif;
			
		}endif;
		
		rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context1, varName, transMapping);
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaNotVarAndVarGuard(context:OclAny, region:OclAny, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			leftExpression := self.map TransferSchemaGuard(context, region, varName1, notOp, transMapping);
		}else{
			leftExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName1, transMapping);
		}endif;
		
		rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName2, transMapping);
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaGuardAndPossibleGuard(context1:OclAny, context2:OclAny, region:OclAny, varName:String, transMapping: Integer) : LogicalExpression {
		
		leftExpression := self.guard.map Expression2Expression(context2);
		
		rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context1, varName, transMapping);
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaGuardAndNotPossibleGuard(context1:OclAny, context2:OclAny, region:OclAny, varName:String, transMapping: Integer) : LogicalExpression {
		
		leftExpression := self.guard.map Expression2Expression(context2);
		
		rightExpression := self.map TransferSchemaGuard(context1, region, varName, true, transMapping);
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaSingleSendAndPossibleGuard(context1:OclAny, context2:OclAny, region:OclAny, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			leftExpression := self.map TransferSchemaGuard(context1, region, varName1, true, transMapping);
		}else{
			leftExpression := self.map TransferSchemata2TypedNamedElementExpr(context1, varName1, transMapping);
		}endif;
		
		rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context1, varName2, transMapping);
		
		operator := LogicOperator::AND;
}

mapping Transition :: TransferSchemaErrorOrNotPossibleGuard(context1:OclAny, region:OclAny, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			rightExpression := self.map TransferSchemaGuard(context1, region, varName2, true, transMapping);
		}else{
			rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context1, varName2, transMapping);
		}endif;
		
		leftExpression := self.map TransferSchemata2TypedNamedElementExpr(context1, varName1, transMapping);
		
		operator := LogicOperator::OR;
}

mapping Transition :: TransferSchemaThreeVariablesGuard(context1:OclAny, context2:OclAny, region:OclAny, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		rightExpression := self.map TransferSchemaSingleSendAndPossibleGuard(context1, context2, region, varName1, varName2, true, transMapping);
		
		leftExpression := self.guard.map Expression2Expression(context2);
		
		operator := LogicOperator::AND;
}
	
mapping Transition :: TransferSchemaNotCondition(context:OclAny, region:OclAny, transMapping: Integer) : UnaryExpression {

		if(not self.raiseMessageEvent.oclIsUndefined()){
			enclosedExpression := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context);
		}else{
			enclosedExpression := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context);
		}endif;	

		operator := UnaryOperator::NOT;
	
	}
	
mapping Transition :: TransferSchemaGuard(context:OclAny, region:OclAny, varName:String, op:Boolean, transMapping: Integer) : UnaryExpression {

		enclosedExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName, transMapping);
		
		if(op){
			operator := UnaryOperator::NOT;
		}endif
	
	}
	
mapping Transition :: TransferSchemata2TypedNamedElementExpr(context:OclAny, varName:String, transMapping: Integer) : TypedNamedElementExpression {
			
		typedNamedElement := context.oclAsType(RealtimeStatechart).map TransferSchemata2Variable(context, varName);
					
	}
	
mapping Transition :: Iterate2TypedNamedElementExpr(context:OclAny, varName:String, transMapping: Integer) : TypedNamedElementExpression {
			
		typedNamedElement := context.oclAsType(RealtimeStatechart).map Iterate2CurRoleVariable();
					
	}
	
mapping RealtimeStatechart :: TransferSchemata2Variable(context:OclAny, varName:String) : Variable {
		name := varName;
		constant := false;
		dataType := context.oclAsType(RealtimeStatechart).eContainer().oclAsType(ModelElementCategory).container().oclAsType(RootNode).categories->select(c|c.key.equalsIgnoreCase("de.uni_paderborn.fujaba.muml.types.category")).modelElements->at(2).oclAsType(DataType);
	};
	
mapping RealtimeStatechart :: Iterate2CurRoleVariable() : Variable {
		name := "curRole";
		constant := false;
		dataType := input.rootObjects()->selectByType(RealtimeStatechart)->any(true).behavioralElement.oclAsType(Role);
	}; 
	
--Transfer Schemata Action

mapping Transition :: TransferSchemata2Action(context:OclAny, actionName:String, varName:String, assignValue:String, transMapping:Integer) : Action {
	
		name := actionName;
		
		result.expressions += self.map TransferSchemata2Block(context, varName, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2Block(context:OclAny, varName:String, assignValue:String, transMapping:Integer) : Block {
		
		result.expressions += self.map TransferSchemata2Assignment(context, varName, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActions(context:OclAny, actionName:String, varName1:String, varName2:String, assignValue:String, transMapping:Integer) : Action {
	
		name := actionName;
		
		result.expressions += self.map TransferSchemata2TwoActionsBlock(context, varName1, varName2, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActionsBlock(context:OclAny, varName1:String, varName2:String, assignValue:String, transMapping:Integer) : Block {
		
		result.expressions += self.map TransferSchemata2Assignment(context, varName1, assignValue, 20+transMapping);
		result.expressions += self.map TransferSchemata2Assignment(context, varName2, assignValue, 21+transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActionsTransAct(context:OclAny, actionName:String, varName:String, assignValue:String, transMapping:Integer) : Action {
	
		name := actionName + ', ' + self.action.name;
		
		result.expressions += self.map TransferSchemata2TwoActionsTransActBlock(context, varName, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActionsTransActBlock(context:OclAny, varName1:String, assignValue:String, transMapping:Integer) : Block {
		
		result.expressions += self.map TransferSchemata2Assignment(context, varName1, assignValue, 20+transMapping);
		
		if(self.action.expressions->first().oclIsTypeOf(Block)){
			result.expressions += self.action.expressions.oclAsType(Block).expressions.map Expression2Expression(context);
		}else{
			result.expressions += self.action.expressions.map Expression2Expression(context);
		}endif;
			
	}
	
mapping Transition :: TransferSchemata2Assignment(context:OclAny, varName:String, assignValue:String, transMapping:Integer) : Assignment {
		
		lhs_typedNamedElementExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName, transMapping);
		
		assignOperator := AssignOperator::ASSIGN;
		
		rhs_assignExpression := self.map TransferSchemata2Literal(context, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2Literal(context:OclAny, assignValue:String, transMapping:Integer) : LiteralExpression {
		
		value := assignValue;		
		
	}

--Transfer Schemata Synchronization
	
mapping Transition :: TransferSchemata2Synchronization(context:OclAny, region:OclAny, syncKind:SynchronizationKind, selectorExp: String, channel:String, selector: Boolean, transMapping: Integer) : Synchronization {
		
		kind := syncKind;
		
		syncChannel := context.oclAsType(RealtimeStatechart).map TransferSchemataChannel(context, channel, selector);
		
		if(selectorExp.equalsIgnoreCase('self')){
			selectorExpression := self.map PositionSelfSelector(context, region, transMapping);
		}else{
			if(selectorExp.equalsIgnoreCase('first')){
				selectorExpression := self.map PositionFirst(context, region, transMapping);
			}else{
				if(selectorExp.equalsIgnoreCase('self.next')){
					selectorExpression := self.map PositionSelfNext(context, region, transMapping);
				}else{
					if(selectorExp.equalsIgnoreCase('self.prev')){
						selectorExpression := self.map PositionSelfPrev(context, region, transMapping);
					}else{
						if(selectorExp.equalsIgnoreCase('curRole')){
						selectorExpression := self.map Iterate2TypedNamedElementExpr(context, selectorExp, transMapping);
					}endif
					}endif;
				}endif;
			}endif;
		}endif;
	
	};
	
mapping Transition :: PositionSelfSelector(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::SELF;
			
	}
	
mapping Transition :: PositionSelfCondition(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::SELF;
			
	}
	
mapping  Transition :: PositionFirst(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::FIRST;
			
	}
	
mapping Transition :: PositionLast(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::LAST;
			
	}
	
mapping Transition :: PositionNext(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::NEXT;
			
	}
	
mapping Transition :: PositionPrev(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::PREV;
			
	}
	
mapping Transition :: PositionSelfNext(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::SELF;
		
		successor := self.map PositionNext(context, region, transMapping);
			
	}
	
mapping Transition :: PositionSelfPrev(context:OclAny, region:OclAny, transMapping: Integer) : PositionSelector {
		
		kind := PositionSelectorKind::SELF;
		
		successor := self.map PositionPrev(context, region, transMapping);
			
	}
	
mapping Transition :: PositionCurRoleNextPres(context:OclAny, region:OclAny, transMapping: Integer) : DiscreteInteractionEndpointReference {
		
		typedNamedElementExpression := self.map Iterate2TypedNamedElementExpr(context, "curRole", 20);
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
			position := self.map PositionNext(context, region, transMapping);
		}else{
			position := self.map PositionPrev(context, region, transMapping);
		}endif;
		
	}
	
mapping RealtimeStatechart :: TransferSchemataChannel(context:OclAny, channelName: String, selector: Boolean) : SynchronizationChannel {
		
		name := channelName;
		
		state := context.oclAsType(RealtimeStatechart).map Rtsc2InitialState();
		
		if(selector){
			selectorType := context.oclAsType(RealtimeStatechart).behavioralElement.oclAsType(Role);
		}endif;		
						
	}
	
--Transfer Schemata Guards, Clock Constraints, CLock Resets
	
mapping Transition :: TransferSchemataLogicalExpression(context:OclAny, region:OclAny, op: String, position:String, transMapping: Integer) : ComparisonExpression {
		
		if(position.equalsIgnoreCase("last")){
			rightExpression := self.map TransferSchemataEndpointReference(context, region, "last", transMapping);
		}else{
			rightExpression := self.map TransferSchemataEndpointReference(context, region, "first", transMapping);
		}endif;
		
		leftExpression := self.map TransferSchemataEndpointReference(context, region, "self", transMapping);		
		
		if(op.equalsIgnoreCase('==')){
			operator := core::expressions::common::ComparingOperator::EQUAL;
		}else{
			if(op.equalsIgnoreCase('<>')){
				operator := core::expressions::common::ComparingOperator::UNEQUAL;
			}endif;		
		}endif;
		
	}
	
mapping Transition :: IterateLogicalExpression(context:OclAny, region:OclAny, op: String, position:String, transMapping: Integer) : ComparisonExpression {
		
		if(position.equalsIgnoreCase("last")){
			rightExpression := self.map TransferSchemataEndpointReference(context, region, "last", transMapping);
		}else{
			rightExpression := self.map TransferSchemataEndpointReference(context, region, "first", transMapping);
		}endif;
		
		leftExpression := self.map Iterate2TypedNamedElementExpr(context, "curRole", transMapping);	
		
		if(op.equalsIgnoreCase('==')){
			operator := core::expressions::common::ComparingOperator::EQUAL;
		}else{
			if(op.equalsIgnoreCase('<>')){
				operator := core::expressions::common::ComparingOperator::UNEQUAL;
			}endif;		
		}endif;
		
	}
	
mapping Transition :: TransferSchemataEndpointReference(context:OclAny, region:OclAny, pos: String, transMapping: Integer) : DiscreteInteractionEndpointReference {
		
		if(pos.equalsIgnoreCase('self')){
			position := self.map PositionSelfCondition(context, region, transMapping);
		}else{
			if(pos.equalsIgnoreCase('last')){
				position := self.map PositionLast(context, region, transMapping);
			}else{
				position := self.map PositionFirst(context, region, transMapping);
			}endif;		
		}endif;

	}
	
mapping RealtimeStatechart :: TransferSchemataClock(context:OclAny, region:OclAny, clockName:String, toplevel:Boolean) : Clock {
		
		name := clockName;
		
		statechart := self.map RTSC2CoordinatorRTSC(context, region);
		
	}
	
mapping Transition :: TransferSchemataClockConstraint(context:OclAny, region:OclAny, clockName:String, op:ComparingOperator, val:Expression, timeUnit:TimeUnit, toplevel:Boolean) : ClockConstraint {
		
		clock := self.statechart.map TransferSchemataClock(context, region, clockName, toplevel);
		
		operator := op;
		
		bound := self.map TransferSchemataTimeValue(context, region, val, timeUnit);
		
	}
	
mapping Transition :: TransferSchemataTimeValue(context:OclAny, region:OclAny, val:Expression, timeUnit:TimeUnit) : TimeValue {

		value := val;
		
		unit := timeUnit;
		
	}
	
-----------------------------------------------------XXXXXXXXXXXXXXXX--GENERAL MAPPINGS TO COPY ELEMENTS--XXXXXXXXXXXXXXXXXX----------------------------------------------
	
-- Asynchronous Message Events

mapping AsynchronousMessageEvent :: TriggerMessage2TriggerWithoutConsume(context:OclAny) : AsynchronousMessageEvent {
		
		//kind := EventKind::TRIGGER_WITHOUT_CONSUME;
		
		message := self.message.map Message2Message(context);
		
	}

mapping TransitionEvent :: TransitionEvent2TransitionEvent(context:OclAny) : TransitionEvent disjuncts
		AsynchronousMessageEvent::Asynchronous2Asynchronous;
	
mapping AsynchronousMessageEvent :: Asynchronous2Asynchronous(context:OclAny) : AsynchronousMessageEvent {
		
		kind := self.kind;
		
		message := self.message.map Message2Message(context);
		
	}
	
mapping Message :: Message2Message(context:OclAny) : Message {
		
		instanceOf := self.instanceOf;
		
		parameterBinding += self.parameterBinding.map Binding2Binding(context);
		
	}
	
-- variables, operations, parametes... 
mapping TypedNamedElement :: TypedNamedElement2TypedNamedElement() : TypedNamedElement
		disjuncts Variable::Variable2Variable,Parameter::Parameter2Parameter;
	
	abstract mapping TypedNamedElement :: BasicTypedNamedElement2TypedNamedElement() : TypedNamedElement {
		name := self.name;
		dataType := self.dataType;		
	}
	
	mapping Variable :: Variable2Variable() : Variable inherits TypedNamedElement::BasicTypedNamedElement2TypedNamedElement {
		initializeExpression := self.initializeExpression.map Expression2Expression(input);
		constant := self.constant;
	};
		
	mapping Parameter :: Parameter2Parameter() : Parameter inherits TypedNamedElement::BasicTypedNamedElement2TypedNamedElement{
		
	};
	
	
	mapping ParameterBinding :: Binding2Binding(context:OclAny) : ParameterBinding {
		parameter := self.parameter;
		value := self.value.map Expression2Expression(context);
	}
	
mapping Operation :: Operation2Operation(context:OclAny) : Operation {
	
		name := self.name;
		returnType := self.returnType;
		implementations := self.implementations->map Expression2Expression(context);
		parameters := self.parameters->map Parameter2Parameter();
				
	}

-- Events

mapping State :: Iterate2CurRoleEntryEvent(context:OclAny, region:OclAny, transMapping:Integer) : EntryEvent {
 		
 		clockResets += self.entryEvent.clockResets.map Clock2Clock();
		
		action := self.map Iterate2Action(context, region, transMapping);
					
	}
	
mapping OclAny :: Iterate2Action(context:OclAny, region:OclAny, transMapping:Integer) : Action {
	
		if(self.oclIsTypeOf(State) and  not self.oclAsType(State).entryEvent.action.oclIsUndefined()){
			if(self.oclAsType(State).outgoingTransitions->select(t|t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst)->isEmpty()){
				name := self.oclAsType(State).entryEvent.action.name + "; curRole := last";
			}else{
				name := self.oclAsType(State).entryEvent.action.name + "; curRole := first";
			}endif;	
		}else{
			if(self.oclIsTypeOf(State)){
				if(self.oclAsType(State).outgoingTransitions->select(t|t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst)->isEmpty()){
					name := "curRole := last";
				}else{
					name := "curRole := first";
				}endif;
			}else{
				if(self.oclAsType(Transition).raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
					name := "curRole := curRole.next";
				}else{
					name := "curRole := curRole.prev";
				}endif;
			}endif;
		}endif;

		result.expressions += self.map Iterate2Block(context, transMapping);
		
	}
	
mapping OclAny :: Iterate2Block(context:OclAny, transMapping:Integer) : Block {

		if(self.oclIsTypeOf(State)){
			if(not self.oclAsType(State).outgoingTransitions->select(t|t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(Iterate) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst)->isEmpty()){
				result.expressions += self.oclAsType(State).outgoingTransitions->first().map Iterate2Assignment(context, "curRole", "first", false, transMapping);
			}else{
				result.expressions += self.oclAsType(State).outgoingTransitions->first().map Iterate2Assignment(context, "curRole", "last", false, transMapping);
			}endif;
			
		}else{
			if(self.oclAsType(Transition).raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(Iterate).startFromFirst){
				result.expressions += self.oclAsType(Transition).map Iterate2Assignment(context, "curRole", "first",true, transMapping);
			}else{
				result.expressions += self.oclAsType(Transition).map Iterate2Assignment(context, "curRole", "last",true, transMapping);
			}endif;
			
		}endif;
		
		if(self.oclIsTypeOf(State) and  not self.oclAsType(State).oclIsUndefined()){
			result.expressions += self.oclAsType(State).entryEvent.action.expressions->first().oclAsType(Block).expressions.map Expression2Expression(context);
		}endif;	
		
	}
	
mapping Transition :: Iterate2Assignment(context:OclAny, varName:String, assignValue:String, transition:Boolean, transMapping:Integer) : Assignment {
		
		lhs_typedNamedElementExpression := self.map Iterate2TypedNamedElementExpr(context, varName, transMapping);
		
		assignOperator := AssignOperator::ASSIGN;
		
		if(varName.equalsIgnoreCase("curRole") and transition){
			rhs_assignExpression := self.map PositionCurRoleNextPres(context, 0,1);
		}else{
			rhs_assignExpression := self.map TransferSchemata2Literal(context, assignValue, transMapping);
		}endif;
		
	}

mapping EntryEvent :: EntryEvent2EntryEventCoordinator(context:OclAny, region:OclAny) : EntryEvent {
		
		clockResets += self.clockResets.map Clock2Clock();
		
		action := self.action.map Action2Action(context, region);
					
	}
	
mapping ExitEvent :: ExitEvent2ExitEventCoordinator(context:OclAny, region:OclAny) : ExitEvent {
		
		clockResets += self.clockResets.map Clock2Clock();
		
		action := self.action.map Action2Action(context, region);
					
	}
	
mapping EntryEvent :: EntryEvent2EntryEventSubrole(context:OclAny, region:OclAny) : EntryEvent {
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		kind := self.kind;
					
	}
	

mapping ExitEvent :: ExitEvent2ExitEventSubrole(context:OclAny, region:OclAny) : ExitEvent {
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		kind := self.kind;
					
	}
	
mapping DoEvent :: Do2Do(context:OclAny, region:OclAny) : DoEvent {

		kind := self.kind;
	
		action := self.action.map Action2Action(context, region);
		
		period := self.period.map TimeValue2TimeValue(context, region);
			
	}
	
mapping Action :: Action2Action(context:OclAny, region:OclAny) : Action {
	
		name := self.name;
		
		result.expressions += self.expressions->map Expression2Expression(context);
		
	}
	

-- Entry/Exit Points and States

mapping Vertex :: Vertex2VertexCoordinator(context:OclAny, region:OclAny) : Vertex
		disjuncts State::States2StatesCoordinator, StateConnectionPoint::StateConnectionPoint2StateConnectionPointCoordinator;
		
mapping Vertex :: Vertex2VertexSubrole(context:OclAny, region:OclAny) : Vertex
		disjuncts State::States2StatesSubrole, StateConnectionPoint::StateConnectionPoint2StateConnectionPointSubrole;

mapping StateConnectionPoint :: StateConnectionPoint2StateConnectionPointCoordinator(context:OclAny, region:OclAny) : StateConnectionPoint
		disjuncts EntryPoint::EntryPoint2EntryPointCoordinator, ExitPoint::ExitPoint2ExitPointCoordinator;
		
mapping StateConnectionPoint :: StateConnectionPoint2StateConnectionPointSubrole(context:OclAny, region:OclAny) : StateConnectionPoint
		disjuncts EntryPoint::EntryPoint2EntryPointSubrole, ExitPoint::ExitPoint2ExitPointSubrole;
	
	mapping EntryPoint :: EntryPoint2EntryPointCoordinator(context:OclAny, region:OclAny) : EntryPoint {
		
		name := self.name;
		
	}
	
	mapping ExitPoint :: ExitPoint2ExitPointCoordinator(context:OclAny, region:OclAny) : ExitPoint {
		
		name := self.name;
		
	}
	
	mapping EntryPoint :: EntryPoint2EntryPointSubrole(context:OclAny, region:OclAny) : EntryPoint {
		
		name := self.name;
		
	}
	
	mapping ExitPoint :: ExitPoint2ExitPointSubrole(context:OclAny, region:OclAny) : ExitPoint {
		
		name := self.name;
		
	}

-- Clocks	
mapping Clock :: Clock2Clock() : Clock {
		
		name := self.name;
				
	}
	
mapping ClockConstraint :: ClockConstraint2ClockConstraint(context:OclAny, region:OclAny) : ClockConstraint {
				
		clock := self.clock.map Clock2Clock();
				
		operator := self.operator;
		
		bound := self.bound.map TimeValue2TimeValue(context, region);
	}
	
mapping TimeValue :: TimeValue2TimeValue(context:OclAny, region:OclAny) : TimeValue {
	
		value := self.value.map Expression2Expression(context);
		unit := self.unit;
		
	}
	
mapping AbsoluteDeadline :: AbsoluteDeadline2AbsoluteDeadline(context:OclAny, region:OclAny) : AbsoluteDeadline {
		
		upperBound := self.upperBound.map TimeValue2TimeValue(context, region);
		lowerBound := self.lowerBound.map TimeValue2TimeValue(context, region);
		
		clock := self.clock.map Clock2Clock();
		
	}
	
mapping RelativeDeadline :: RelativeDeadline2RelativeDeadline(context:OclAny, region:OclAny) : RelativeDeadline {
		
		upperBound := self.upperBound.map TimeValue2TimeValue(context, region);
		lowerBound := self.lowerBound.map TimeValue2TimeValue(context, region);
				
	}
	
	
	-- synchronizations
	
mapping SynchronizationChannel :: SyncChannel2SyncChannel(context:OclAny, region:OclAny) : SynchronizationChannel {
		
		name := self.name;
						
		selectorType := self.selectorType;		
						
	}
	
mapping Synchronization :: Synchronization2Synchronization(context:OclAny, region:OclAny) : Synchronization {
		
			kind := self.kind;
			
			syncChannel := self.syncChannel.map SyncChannel2SyncChannel(context, region);
			
			selectorExpression := self.selectorExpression.map Expression2Expression(context);
		
	}
	
	-- expressions
		
	mapping Expression :: Expression2Expression(context:OclAny) : Expression disjuncts
		LiteralExpression::Literal2Literal,
		UnaryExpression::Unary2Unary, 
		BinaryExpression::Binary2Binary,
		Block::Block2Block,
		Loop::Loop2Loop,
		Assignment::Assignment2Assignment,
		IfStatement::If2If,
		TypedNamedElementExpression::TypedNamedElementExpression2TypedNamedElementExpression,
		OperationCall::Call2Call,
		ReturnStatement::Return2Return,
		TriggerMessageExpression::Trigger2Trigger,
		DiscreteInteractionEndpointReference::EndpointReference2EndpointReference,
		PositionSelector::Position2Position,
		LocalVariableDeclarationStatement::Local2Local,
		NondeterministicChoiceExpression::Choice2Choice,
		Expression::failOnUnsupportedExpression;
		
	mapping Expression :: failOnUnsupportedExpression(context:OclAny) : Expression {
		init {
			assert fatal (false) with log('Unsupported expression type.')
		}
	}	
			
	mapping LiteralExpression :: Literal2Literal(context:OclAny) : LiteralExpression {
		
		value := self.value;		
		
	}
	
	mapping BinaryExpression :: Binary2Binary(context:OclAny) : BinaryExpression disjuncts
		ComparisonExpression::Comparison2Comparison,
		ArithmeticExpression::Arithmetic2Arithmetic,
		LogicalExpression::BinaryLogic2BinaryLogic;	
		
	
	mapping LogicalExpression :: BinaryLogic2BinaryLogic(context:OclAny) : LogicalExpression {
		
		leftExpression := self.leftExpression.map Expression2Expression(context);
		rightExpression := self.rightExpression.map Expression2Expression(context);
		
		operator := self.operator;
		
	}
		
	mapping UnaryExpression :: Unary2Unary(context:OclAny) : UnaryExpression {
				
		enclosedExpression := self.enclosedExpression.map Expression2Expression(context);
		
		operator := self.operator;
				
	}	
	
	mapping TypedNamedElementExpression :: TypedNamedElementExpression2TypedNamedElementExpression(context:OclAny) : TypedNamedElementExpression {
			
		typedNamedElement := self.typedNamedElement.map TypedNamedElement2TypedNamedElement();
					
					
	}
			
	mapping ComparisonExpression :: Comparison2Comparison(context:OclAny) : ComparisonExpression inherits BinaryExpression::Binary2BinaryPrimitive {
		
		operator := self.operator;
		
	}
	
	mapping ArithmeticExpression :: Arithmetic2Arithmetic(context:OclAny) : ArithmeticExpression inherits BinaryExpression::Binary2BinaryPrimitive {
		
		operator := self.operator;
		
	}
	
	abstract mapping BinaryExpression :: Binary2BinaryPrimitive(context:OclAny) : BinaryExpression {
		
		leftExpression := self.leftExpression.map Expression2Expression(context);
		rightExpression := self.rightExpression.map Expression2Expression(context);
		
	}
		
	mapping Block :: Block2Block(context:OclAny) : Block {
		
		result.expressions += self.expressions->map Expression2Expression(context);
		
	}
	
	mapping Loop :: Loop2Loop(context:OclAny) : Loop disjuncts
		WhileLoop::While2While,
		DoWhileLoop::DoWhile2DoWhile,
		ForLoop::For2For;
	
	mapping WhileLoop :: While2While(context:OclAny) : WhileLoop inherits Loop::Loop2LoopPrimitive{};
	
	mapping DoWhileLoop :: DoWhile2DoWhile(context:OclAny) : DoWhileLoop inherits Loop::Loop2LoopPrimitive{};

	mapping ForLoop :: For2For(context:OclAny) : ForLoop inherits Loop::Loop2LoopPrimitive {
		
		initializeExpression := self.initializeExpression.map Assignment2Assignment(context);
		countingExpression := self.countingExpression.map Assignment2Assignment(context);
			
	}
	
	abstract mapping Loop :: Loop2LoopPrimitive(context:OclAny) : Loop {
		
		block := self.block.map Block2Block(context);
		loopTest := self.loopTest.map Expression2Expression(context);
		
	}	
	
	mapping Assignment :: Assignment2Assignment(context:OclAny) : Assignment {
		
		lhs_typedNamedElementExpression := self.lhs_typedNamedElementExpression.map TypedNamedElementExpression2TypedNamedElementExpression(context);
		
		assignOperator := self.assignOperator;
		
		rhs_assignExpression := self.rhs_assignExpression.map Expression2Expression(context);
		
		incrementDecrementOperator := self.incrementDecrementOperator;
		
	}
	
	mapping IfStatement :: If2If(context:OclAny) : IfStatement {
	
		ifCondition := self.ifCondition.map Expression2Expression(context);
		
		ifBlock := self.ifBlock.map Block2Block(context);
		
		elseIfConditions := self.elseIfConditions->map Expression2Expression(context);
		
		elseIfBlocks := self.elseIfBlocks->map Block2Block(context);
		
		elseBlock := self.elseBlock.map Block2Block(context);
		
	}
	
	mapping OperationCall :: Call2Call(context:OclAny) : OperationCall {
		
		operation := self.operation.map Operation2Operation(context);
		
		parameterBinding := self.parameterBinding->map Binding2Binding(context);
		
	}
	
	mapping ReturnStatement :: Return2Return(context:OclAny) : ReturnStatement {
		
		expression := self.expression.map Expression2Expression(context);
		
	}
	
	mapping TriggerMessageExpression :: Trigger2Trigger(context:OclAny) : TriggerMessageExpression {
		
		messageType := self.messageType;
		parameter := self.parameter;
		
		
	}
	
	mapping DiscreteInteractionEndpointReference :: EndpointReference2EndpointReference(context:OclAny) : DiscreteInteractionEndpointReference {
		
		typedNamedElementExpression := self.typedNamedElementExpression.map TypedNamedElementExpression2TypedNamedElementExpression(context);
		
		position := self.position.map Position2Position(context);
		
	}
	
	mapping PositionSelector :: Position2Position(context:OclAny) : PositionSelector {
		
		kind := self.kind;
		successor := self.successor.map Position2Position(context);
		
	}
	
	mapping LocalVariableDeclarationStatement :: Local2Local(context:OclAny) : LocalVariableDeclarationStatement {
		
		variable := self.variable.map Variable2Variable();
		
	}
	
	mapping NondeterministicChoiceExpression :: Choice2Choice(context:OclAny) : NondeterministicChoiceExpression {
		
		range := self.range.map Range2Range(context);
		
		dataType := self.dataType;
		
	}
	
	mapping Range :: Range2Range(context:OclAny) : Range {
		
		lowerBound := self.lowerBound;
		upperBound := self.upperBound;
	}