import MUML2MUML;
import PatternProtocolTransformationLibrary;


modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype RTSCPackage uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype TypesPackage uses muml::types("http://www.fujaba.de/muml/0.4.0");
modeltype ValuetypePackage uses muml::valuetype("http://www.fujaba.de/muml/0.4.0");
modeltype MessageTypePackage uses muml::msgtype("http://www.fujaba.de/muml/0.4.0");
modeltype BehaviorPackage uses muml::behavior("http://www.fujaba.de/muml/0.4.0");
modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.4.0");
modeltype PatternPackage uses muml::pattern('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';

// @author sthiele2
transformation TransformPatternToProtocolStep1(inout input : ModelInstancePackage);


property variablesToParameter : Set(Variable);
property theProtocol : CoordinationProtocol;
main()
{ 
	var theRootNode : RootNode := input.rootObjects()[RootNode] -> any(true);
	var variablesToParameter := input.rootObjects()[Variable];
	theProtocol  := input.rootObjects()[CoordinationProtocol] -> any(true);
}

helper createPatternFromProtocol(root : RootNode)
{
	var newPattern : CoordinationPattern := new CoordinationPattern(theProtocol);	
	
	
	var statechartCategory : ModelElementCategory := getRealtimeStatechartCategory(root);
	newPattern.roleConnector := theProtocol.roleConnector.map RoleConnector2RoleConnector();
	theProtocol.roles->forEach(role)
	{
		var newRole := new Role(role,newPattern);		
		role.receiverMessageBuffer->forEach(buffer)
		{
			newRole.receiverMessageBuffer += new MessageBuffer(buffer,newRole);			
		};
		newRole.behavior := role.behavior.oclAsType(RealtimeStatechart).map RealtimeStatechart2RealtimeStatechart();
		//set behavorial element?? --> should be already considered when setting behavior of the role!
		statechartCategory.modelElements += newRole.behavior.oclAsType(RealtimeStatechart);
		newPattern.roles+= newRole;
		newPattern.roleConnector.connectorEndpoints+=newRole;
	};
	var patternCategory : ModelElementCategory := getPatternCategory(root);
	patternCategory.modelElements +=newPattern;
}

constructor CoordinationPattern::CoordinationPattern(protocol : CoordinationProtocol)
{
	_name := protocol.name;
}


mapping Variable::Variable2Parameter(): Parameter
{
		_name := self._name;
		_comment := self._comment;
		_dataType := self.dataType;
}

mapping actionlanguage::TypedNamedElementExpression:: TypedNamedElementExpression2Expression() :core::expressions::Expression {
    
    	init{
    	if(self._typedNamedElement.oclIsTypeOf(Variable) and variablesToParameter->includes(self._typedNamedElement.oclAsType(Variable)))  	
    	{
    		var pe  : ParameterExpression = new ParameterExpression();
    		pe.annotation := self._annotation.map EAnnotation2EAnnotation();
    		pe.extension := self._extension.map Extension2Extension();
    		pe.comment := self._comment;
    		pe.parameter := self._typedNamedElement.oclAsType(Variable).map Variable2Parameter();
    		result := pe;
   		 }
   		 else 
   		 {
   		 	var tne : TypedNamedElementExpression = new TypedNamedElementExpression();
   		 	tne.comment := self._comment;
    		tne.annotation := self._annotation.map EAnnotation2EAnnotation();
    		tne.extension := self._extension.map Extension2Extension();
    		tne.typedNamedElement := self._typedNamedElement.map TypedNamedElement2TypedNamedElement();
    		result := tne;
   		 }}
}

