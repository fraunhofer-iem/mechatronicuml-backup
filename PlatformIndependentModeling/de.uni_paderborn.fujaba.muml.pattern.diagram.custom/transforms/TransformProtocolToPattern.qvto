import PatternProtocolTransformationLibrary;


modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype RTSCPackage uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype TypesPackage uses muml::types("http://www.fujaba.de/muml/0.4.0");
modeltype ValuetypePackage uses muml::valuetype("http://www.fujaba.de/muml/0.4.0");
modeltype MessageTypePackage uses muml::msgtype("http://www.fujaba.de/muml/0.4.0");
modeltype BehaviorPackage uses muml::behavior("http://www.fujaba.de/muml/0.4.0");
modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.4.0");
modeltype PatternPackage uses muml::pattern('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';

// @author sthiele2
transformation TransformPatternToProtocolStep1(inout input : ModelInstancePackage);

property variablesToParameter : Set(Variable);
property theProtocol : CoordinationProtocol;
property theRootNode : RootNode;

main()
{ 	
	
	// fetch input
	
	theRootNode  := input.rootObjects()[RootNode] -> any(true);
		
		
	// not debug:
	variablesToParameter := input.rootObjects()[Variable];	
	theProtocol  := input.rootObjects()[CoordinationProtocol] -> any(true);
	
		
	// debug:	
	//variablesToParameter := getRealtimeStatechartCategory(theRootNode).modelElements.oclAsType(RealtimeStatechart)->at(2).variables;
	//theProtocol := getProtocolCategory(theRootNode).modelElements.oclAsType(CoordinationProtocol)->at(1);
	
		
	// check input
	assert fatal (theProtocol != null) with log ("CoordinationProtocol is null!" + theProtocol.name);
	assert fatal (theRootNode != null) with log ("RootNode is null!");  	
    assert fatal (variablesToParameter != null) with log ("variablesToParameter are null!");
	
	// start transformation
	createPatternFromProtocol();
}

helper createPatternFromProtocol()
{
	var newPattern : CoordinationPattern :=theProtocol.map CoordinationProtocol2CoordinationPattern();	
	var patternCategory : ModelElementCategory := getPatternCategory(theRootNode);	
	patternCategory.modelElements +=newPattern;
}

mapping muml::protocol::CoordinationProtocol:: CoordinationProtocol2CoordinationPattern() : muml::pattern::CoordinationPattern
{
	result.name := self.name;
	result.comment := self.comment;
	result.annotation := self.annotation.map transform().oclAsType(EAnnotation);		
	var statechartCategory : ModelElementCategory := getRealtimeStatechartCategory(theRootNode);	
	result.patternParameters := variablesToParameter.map transform().oclAsType(Parameter);
	self.roles->forEach(role)
	{
		// the role was already mapped in RoleConnector2RoleConnector
		var newRole : Role := role.map transform().oclAsType(Role);
		//newRole.behavior := role.behavior.oclAsType(RealtimeStatechart).map RealtimeStatechart2RealtimeStatechart();
		//set behavorial element?? --> should be already considered when setting behavior of the role!
		newRole.coordinationProtocol := result;
		statechartCategory.modelElements += newRole.behavior.oclAsType(RealtimeStatechart);

		result.roles+= newRole;
	};
	result._roleConnector := self.roleConnector.map transform().oclAsType(RoleConnector);
	result.roleConnector.coordinationProtocol := result;		
}

mapping Variable::Variable2Parameter(): Parameter
{
		_name := self._name;
		_comment := self._comment;
		_dataType := self.dataType;
		annotation := self.annotation.map transform().oclAsType(EAnnotation);
		extension := self.extension.map transform().oclAsType(core::Extension);
}
mapping muml::realtimestatechart::RealtimeStatechart :: transform() : EObject{
    	init {
    		result := self.map create();
    	}
    	var element := self.oclAsType(EObject);
			element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
			setValues(result, f, getValues(element, f));
			};
			
    	var resultingRTSC : RealtimeStatechart := result.oclAsType(muml::realtimestatechart::RealtimeStatechart);
    	
    	resultingRTSC._name := self._name;
    	resultingRTSC._comment := self._comment;
    	resultingRTSC._annotation := self._annotation.map transform().oclAsType(EAnnotation);
    	resultingRTSC._extension := self._extension.map transform().oclAsType(core::Extension);
   
    	resultingRTSC._operations := self._operations.map transform().oclAsType(Operation);
    	// only transform variables that are not converted into parameter
    	resultingRTSC._variables := (self._variables-(variablesToParameter)).map transform().oclAsType(Variable);
    	resultingRTSC._parentRegion := self._parentRegion.map transform().oclAsType(Region);
    	resultingRTSC._transitions := self._transitions.map transform().oclAsType(Transition);
    	resultingRTSC._states := self._states.map transform().oclAsType(State);
    	resultingRTSC._clocks := self._clocks.map transform().oclAsType(Clock);
   		 }
   		 
mapping Variable :: transform() : EObject {
		init{
			if(variablesToParameter->includes(self)) {
				result := self.map Variable2Parameter();
			}
			else {
				result := self.map create();
			}
			
		}	
}
