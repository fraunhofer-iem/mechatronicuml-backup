import PatternProtocolTransformationLibrary;

modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype RTSCPackage uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype TypesPackage uses muml::types("http://www.fujaba.de/muml/0.4.0");
modeltype ValuetypePackage uses muml::valuetype("http://www.fujaba.de/muml/0.4.0");
modeltype MessageTypePackage uses muml::msgtype("http://www.fujaba.de/muml/0.4.0");
modeltype BehaviorPackage uses muml::behavior("http://www.fujaba.de/muml/0.4.0");
modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.4.0");
modeltype PatternPackage uses muml::pattern('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';

// @author sthiele2
transformation TransformPatternToProtocolStep1(inout input : ModelInstancePackage);





property bindings : Set(ParameterBinding);
property theRootNode : RootNode;
main()
{ 
	// get the input parameters. There is exactly one root and exactly one coordination pattern	
	theRootNode := input.rootObjects()[RootNode] -> any(true);
	
	// Debug:
	//var patternCategory : ModelElementCategory := getPatternCategory(theRootNode); 
	//var thePattern : CoordinationPattern := patternCategory.modelElements->at(1).oclAsType(CoordinationPattern);
	//bindings := thePattern.legalConfigurations->at(1).parameterBindings;
	
	// not debug:	
	var thePattern : CoordinationPattern := input.rootObjects()[CoordinationPattern] -> any(true);
	bindings := input.rootObjects()[ParameterBinding];
	
	
	
	// check whether the input is correct: 
	assert fatal (thePattern != null) with log ("CoordinationPattern is null!" + thePattern.name);
	assert fatal (theRootNode != null) with log ("RootNode is null!");  	
    assert fatal (if(thePattern.patternParameters->size() > 0) then (bindings != null and bindings->size() = thePattern.patternParameters->size()) else true endif) with log ("Parameter Bindings are null!");
    assert fatal (if( bindings->size() >0) then bindings->size() = thePattern.patternParameters->size()  else true endif);
    
    // start transformation
	createProtocol(thePattern);
}
helper createProtocol(pattern : CoordinationPattern)
{
	var newProtocol : CoordinationProtocol := pattern.map CoordinationPattern2CoordinationProtocol();	
	var protocolCategory : ModelElementCategory := getProtocolCategory(theRootNode);
	protocolCategory.modelElements +=newProtocol;
}
mapping muml::pattern::CoordinationPattern :: CoordinationPattern2CoordinationProtocol() : muml::protocol::CoordinationProtocol
{	
	result.name := self.name;
	result.comment := self.comment;
	result.annotation := self.annotation.map transform().oclAsType(EAnnotation);		
	var statechartCategory : ModelElementCategory := getRealtimeStatechartCategory(theRootNode);	

	self.roles->forEach(role)
	{
		// the role was already mapped in RoleConnector2RoleConnector
		var newRole : Role := role.map transform().oclAsType(Role);
		//newRole.behavior := role.behavior.oclAsType(RealtimeStatechart).map RealtimeStatechart2RealtimeStatechart();
		//set behavorial element?? --> should be already considered when setting behavior of the role!
		
		//newRole.coordinationProtocol := result;
		
		statechartCategory.modelElements += newRole.behavior.oclAsType(RealtimeStatechart);
		result.roles+= newRole;
	};
	result._roleConnector := self.roleConnector.map transform().oclAsType(RoleConnector);
	
	//result.roleConnector.coordinationProtocol := result;
	
	result.adaptedFromPattern := self;
} 


mapping muml::behavior::Parameter:: Parameter2Variable(rtsc : RealtimeStatechart) : muml::behavior::Variable
{
	_constant := true;
	_name := self.name;
	_dataType:= self.dataType;
	_comment := self.comment;
}

mapping actionlanguage::TypedNamedElementExpression :: transform() : EObject {
	
	init {
		
		
		if(self.typedNamedElement.oclIsKindOf(Parameter)) {
			var refParameter : Parameter := self.typedNamedElement.oclAsType(Parameter);
			var rtsc : RealtimeStatechart := getHighestParentStatechart(self);
			var myExp : core::expressions::Expression =  getBoundExpressionToGivenParameter(refParameter);
			assert fatal (myExp != null) with log ("There is no parameter binding for the parameter"+ refParameter.name);
			if(rtsc = null or rtsc.oclIsInvalid()){
				// in case the rtsc is invalid means that the TypedNamedElementExpression referencing the Parameter is not contained in a rtsc but in a ConnectorQualityOfServiceAssumptions
				// therefore, just replace the TypedNamedElementExpression by the bounded expression defined in the ParameterBinding
				result:= myExp.copyParameterExpression()
			}
			else {
				
			result := self.map create();	
			var resultingExpression : TypedNamedElementExpression := result.oclAsType(TypedNamedElementExpression);		
			var boundedExpression : core::expressions::Expression =  getBoundExpressionToGivenParameter(refParameter);
			assert fatal (boundedExpression != null) with log ("There is no parameter binding for the parameter"+ refParameter.name);
			var mappedVariable : Variable :=refParameter.map Parameter2Variable(rtsc);
			var mappedrtsc: RealtimeStatechart := rtsc.resolveone(RealtimeStatechart);
			if(not mappedrtsc.variables->includes(mappedVariable)){
				mappedrtsc.variables+=mappedVariable;
				mappedVariable.initializeExpression := boundedExpression.copyParameterExpression();
			};
			resultingExpression.typedNamedElement := mappedVariable;
			};
		}
		else {
			result := self.map create();
			
		
			var resultingExpression : TypedNamedElementExpression := result.oclAsType(TypedNamedElementExpression);
			resultingExpression._annotation := self._annotation.map transform().oclAsType(EAnnotation);
			resultingExpression._extension := self._extension.map transform().oclAsType(core::Extension);
			resultingExpression.typedNamedElement := self.typedNamedElement.map transform().oclAsType(TypedNamedElement);
			
			var element := self.oclAsType(EObject);
			element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
			setValues(result, f, getValues(element, f));
			};
		};
		
		
	
	}

	
}



query getHighestParentStatechart(in expr : TypedNamedElementExpression) : RealtimeStatechart
{
	var root : EObject := expr;
	while((not root.oclIsKindOf(ConnectorQualityOfServiceAssumptions) and not root.oclIsKindOf(RealtimeStatechart)))
	{
		root := root.eContainer();		
		assert fatal (not root.oclIsInvalid()) with log ("The parameter "+ expr.typedNamedElement.name + " is not contained in a RealtimeStatechart or a ConnectorQualityOfServiceAssumptions!");
	
	};
	if(root.oclIsKindOf(ConnectorQualityOfServiceAssumptions))
	{
		return null;
	}else
	{
		return root.oclAsType(RealtimeStatechart).getHighestParentStatechart()
	}
	endif;		
}
	
	
query getBoundExpressionToGivenParameter(in parameter : Parameter) : core::expressions::Expression {	
	if (bindings->one(p : ParameterBinding | p.parameter=parameter))
	{
		log ("parameter binding found for parameter: "+ parameter.name);
		return bindings->any(p : ParameterBinding | p.parameter=parameter).value;
	} endif;
	return null;
}		

helper core::expressions::Expression :: copyParameterExpression() : core::expressions::Expression {
	if(self.oclIsKindOf(core::expressions::common::LiteralExpression)) {
		return self.clone().oclAsType(core::expressions::common::LiteralExpression);
	}
	else
		assert fatal (false) with log ("ParameterBinding may only define a LiteralExpression!");
}