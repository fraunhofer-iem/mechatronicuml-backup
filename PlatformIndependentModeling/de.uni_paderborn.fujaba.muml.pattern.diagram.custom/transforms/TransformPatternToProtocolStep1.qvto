import MUML2MUML;
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype RTSCPackage uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype TypesPackage uses muml::types("http://www.fujaba.de/muml/0.4.0");
modeltype ValuetypePackage uses muml::valuetype("http://www.fujaba.de/muml/0.4.0");
modeltype MessageTypePackage uses muml::msgtype("http://www.fujaba.de/muml/0.4.0");
modeltype BehaviorPackage uses muml::behavior("http://www.fujaba.de/muml/0.4.0");
modeltype ModelInstancePackage uses modelinstance("http://www.fujaba.de/modelinstance/0.4.0");
modeltype PatternPackage uses muml::pattern('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';

// @author sthiele2
transformation TransformPatternToProtocolStep1(inout input : ModelInstancePackage);
property bindings : Set(ParameterBinding);
//property parameter2VariableDict : Dict(Parameter, Variable);
main()
{ 
// get the input parameters. There is exactly one root and exactly one coordination pattern
	
	// test case: get Pattern P10
	var theRootNode : RootNode := input.rootObjects()[RootNode] -> any(true);		
	//var thePattern : CoordinationPattern := getPatternCategory(theRootNode).modelElements->select(p | p.oclAsType(CoordinationPattern).name.equalsIgnoreCase("P10"))->any(true).oclAsType(CoordinationPattern);
	//bindings :=thePattern.legalConfigurations->any(true).parameterBindings;
	
	
	assert warning (false)  with log ("Transformation PatternToProtocol Started!");
	var thePattern : CoordinationPattern := input.rootObjects()[CoordinationPattern] -> any(true);
	assert fatal (thePattern != null) with log ("CoordinationPattern is null!" + thePattern.name);

	//var theRootNode : RootNode := thePattern.eContainer().eContainer().oclAsType(RootNode);
	assert fatal (theRootNode != null) with log ("RootNode is null!");
	
	
    bindings := input.rootObjects()[ParameterBinding];
    //bindings-> forEach(parameterBinding)
    //{
    //	parameter2RTSC->put(parameterBinding.parameter, Set{});
    //};
    
    assert fatal (bindings != null) with log ("Parameter Bindings are null!");
    
	createProtocol(thePattern, theRootNode);
   
    assert warning (false)  with log ("Transformation PatternToProtocol Finished");
    
//	input.objects()[ParameterExpression];
	//theRootNode.oclAsType(EObject)->asSet()->closure(e:EObject|e.eContents()->collect(oclAsType(EObject)))[ParameterExpression];
}


constructor Variable::Variable(parameter : Parameter)
{
	_constant := true;
	_name := parameter.name;
	_dataType:= parameter.dataType;
	_comment :=parameter.comment;
}

helper createProtocol(pattern : CoordinationPattern, root : RootNode)
{
	var newProtocol : CoordinationProtocol := new CoordinationProtocol(pattern);
	var statechartCategory : ModelElementCategory := getRealtimeStatechartCategory(root);
	newProtocol.roleConnector := pattern.roleConnector.map RoleConnector2RoleConnector();
	pattern.roles->forEach(role)
	{
		var newRole := new Role(role,newProtocol);		
		role.receiverMessageBuffer->forEach(buffer)
		{
			newRole.receiverMessageBuffer += new MessageBuffer(buffer,newRole);			
		};
		newRole.behavior := role.behavior.oclAsType(RealtimeStatechart).map RealtimeStatechart2RealtimeStatechart();
		//set behavorial element?? --> should be already considered when setting behavior of the role!
		statechartCategory.modelElements += newRole.behavior.oclAsType(RealtimeStatechart);
		newProtocol.roles+= newRole;
		newProtocol.roleConnector.connectorEndpoints+=newRole;
	};
	newProtocol.adaptedFromPattern += pattern;
	var protocolCategory : ModelElementCategory := getProtocolCategory(root);
	protocolCategory.modelElements +=newProtocol;
}





query getRealtimeStatechartCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.realtimestatechart.category') -> any(true);
}
query getProtocolCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.protocol.category') -> any(true);
}
query getPatternCategory(in theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.pattern.category') -> any(true);
}
helper copyMessageBuffer(protocol : CoordinationProtocol, pattern : CoordinationPattern)
{
	protocol.verificationConstraintRepositories
}

constructor muml::constraint::VerificationConstraintRepository::VerificationConstraintRepository(rep : muml::constraint::VerificationConstraintRepository)
{
	
}
constructor CoordinationProtocol::CoordinationProtocol(pattern : CoordinationPattern) {	
	name:=pattern.name;	
	comment := pattern.comment;
	
}
constructor MessageBuffer::MessageBuffer(buffer : MessageBuffer, sourceRole : Role)
{
	name := buffer.name;
	bufferSize := new NaturalNumber(buffer.bufferSize);
	comment := buffer.comment;
	buffer.messageType->forEach(type)
	{
		messageType+= type;
	};
	bufferOverflowAvoidanceStrategy := buffer.bufferOverflowAvoidanceStrategy;
	discreteInteractionEndpoint := sourceRole;
	
}
constructor Role::Role(roleToCopy : Role, protocol : CoordinationProtocol)
{
	// behavior is missing --> maybe we can use the existing transformation for copying the role to port properties
	//roleconnector is read only
	name :=  roleToCopy.name;
	// no new objects, since it is a reference to a given message type!
	senderMessageTypes := roleToCopy.senderMessageTypes; 
	receiverMessageTypes := roleToCopy.receiverMessageTypes;
	comment := roleToCopy.comment;
	// role 
	coordinationProtocol := protocol;
	
	cardinality := new Cardinality(roleToCopy.cardinality);
	
}
constructor Cardinality::Cardinality(c :Cardinality)
{
	lowerBound := new NaturalNumber(c.lowerBound);
	upperBound := new NaturalNumber(c.upperBound);
}

constructor NaturalNumber::NaturalNumber(nn : NaturalNumber)
{
	value := nn.value;
	infinity := nn.infinity;	
}


mapping muml::realtimestatechart::RealtimeStatechart :: RealtimeStatechart2RealtimeStatechart() : muml::realtimestatechart::RealtimeStatechart{
    	_name := self._name;
    	_comment := self._comment;
    	_annotation := self._annotation.map EAnnotation2EAnnotation();
    	_extension := self._extension.map Extension2Extension();
    //	_behavioralElement := self._behavioralElement.map BehavioralElement2BehavioralElement();
    	_operations := self._operations.map Operation2Operation();
    	_variables := self._variables.map Variable2Variable();
    	_parentRegion := self._parentRegion.map Region2Region();
    	_transitions := self._transitions.map Transition2Transition();
    	_states := self._states.map State2State();
    	_clocks := self._clocks.map Clock2Clock();
   		 }
mapping core::expressions::Expression :: Expression2Expression() : core::expressions::Expression disjuncts core::expressions::common::LiteralExpression::LiteralExpression2LiteralExpression, actionlanguage::TypedNamedElementExpression::TypedNamedElementExpression2TypedNamedElementExpression, actionlanguage::LocalVariableDeclarationStatement::LocalVariableDeclarationStatement2LocalVariableDeclarationStatement, actionlanguage::IfStatement::IfStatement2IfStatement, actionlanguage::ReturnStatement::ReturnStatement2ReturnStatement, actionlanguage::Assignment::Assignment2Assignment, core::expressions::TextualExpression::TextualExpression2TextualExpression, actionlanguage::NondeterministicChoiceExpression::NondeterministicChoiceExpression2NondeterministicChoiceExpression, actionlanguage::PositionSelector::PositionSelector2PositionSelector, actionlanguage::ArrayInitializeExpression::ArrayInitializeExpression2ArrayInitializeExpression, actionlanguage::DiscreteInteractionEndpointReference::DiscreteInteractionEndpointReference2DiscreteInteractionEndpointReference, actionlanguage::TriggerMessageExpression::TriggerMessageExpression2TriggerMessageExpression, actionlanguage::Block::Block2Block, core::expressions::common::BinaryExpression::BinaryExpression2BinaryExpression, core::expressions::common::UnaryExpression::UnaryExpression2UnaryExpression, actionlanguage::OperationCall::OperationCall2OperationCall, actionLanguage::ParameterExpression :: ParameterExpression2Expression,actionLanguage::TimeValueExpression ::TimeValueExpression2TimeValueExpression;

mapping actionLanguage::TimeValueExpression ::TimeValueExpression2TimeValueExpression() : actionLanguage::TimeValueExpression{    	
    	_comment := comment;
    	_timeValue := timeValue.map TimeValue2TimeValue();  
    	_annotation := annotation.map EAnnotation2EAnnotation();
   		 }      	



property parameterAndRTSC2Variable : Dict(Parameter, Dict(RealtimeStatechart,Variable));


mapping actionLanguage::ParameterExpression :: ParameterExpression2Expression() : core::expressions::Expression {		
	init {
		var rtsc2 : RealtimeStatechart := getHighestParentStatechart(self);
		var myExp : core::expressions::Expression =  getBoundExpressionToGivenParameter(self.parameter);
		
		assert fatal (myExp != null) with log ("There is no parameter binding for the parameter"+ self.parameter.name);
		if(rtsc2 =null)
		{			
			result := myExp.map Expression2Expression();
		}
		else
		{
			var rtsc: RealtimeStatechart := rtsc2.resolveone(RealtimeStatechart);
			var dictionary : Dict(RealtimeStatechart, Variable) := parameterAndRTSC2Variable->get(self.parameter);
			var variable : Variable;
			if(dictionary->oclIsInvalid()  or dictionary=null) then
			{
				// case no parameter in parameterAndRTSC2Variable yet
				dictionary := Dict{};
				parameterAndRTSC2Variable->put(self.parameter, dictionary);
				variable := new Variable(self.parameter);
				variable.initializeExpression := myExp.map Expression2Expression();
				rtsc.variables+=variable;
				dictionary ->put(rtsc,variable);				
			}
			else 
			{
				variable := dictionary->get(rtsc);
				// case no variable for parameter created in rtsc
				if(variable.oclIsInvalid())
				{
					variable := new Variable(self.parameter);
					variable.initializeExpression := myExp.map Expression2Expression();
					rtsc.variables+=variable;
					dictionary->put(rtsc, variable);
				}		
				endif;							
			}endif;	
			result := new TypedNamedElementExpression(variable);
					
		}endif;	
	
		//result := myExp.map Expression2Expression();
		}
	}
constructor TypedNamedElementExpression ::TypedNamedElementExpression(variable : Variable)
{
	_typedNamedElement := variable;
	_annotation := annotation.map EAnnotation2EAnnotation();
}
query getHighestParentStatechart(in expr : ParameterExpression) : RealtimeStatechart
{
	var root : EObject := expr;
	while(root.oclIsTypeOf(core::expressions::Expression))
	{
		root := root.eContainer();		
	};
	if(root.eContainer().oclIsKindOf(ConnectorQualityOfServiceAssumptions))
	{
		return null;
	}endif;
	
	while(not root.oclIsTypeOf(RealtimeStatechart))
	{
		root:=root.eContainer();		
		assert fatal (not root.oclIsInvalid()) with log ("The parameter "+ expr.parameter.name + " is not contained in a RealtimeStatechart or a ConnectorQualityOfServiceAssumptions!");
	};
	return root.oclAsType(RealtimeStatechart).getHighestParentStatechart();	
}
	
	
	query getBoundExpressionToGivenParameter(in parameter : Parameter) : core::expressions::Expression {	
	if (bindings->one(p : ParameterBinding | p.parameter=parameter))
	{
		log ("parameter binding found for parameter: "+ parameter.name);
		return bindings->any(p : ParameterBinding | p.parameter=parameter).value;
	} endif;
	return null;
}		
   		 

mapping muml::protocol::RoleConnector :: RoleConnector2RoleConnector() : muml::protocol::RoleConnector{
    	_comment := self._comment;
    	_annotation := self._annotation.map EAnnotation2EAnnotation();
    	_extension := self._extension.map Extension2Extension();
    	//_connectorEndpoints := self._connectorEndpoints.map ConnectorEndpoint2ConnectorEndpoint();
    	//_coordinationProtocol := self._coordinationProtocol.map AbstractCoordinationSpecification2AbstractCoordinationSpecification();
    	_connectorQualityOfServiceAssumptions := self._connectorQualityOfServiceAssumptions.map ConnectorQualityOfServiceAssumptions2ConnectorQualityOfServiceAssumptions();
   		 }


