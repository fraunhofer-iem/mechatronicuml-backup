transformation InstantiationTransformation(inout input : ComponentPackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');

modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
 
	var components := input.rootObjects()[StructuredComponent];	

	// Editor supplies StructuredComponent in rootInput.
	// In case we want to run this transformation differently (for debugging), we search for StructuredComponents.
	if (components->isEmpty()) then {
		components := StructuredComponent.allInstances();
	} endif;
	
	components->forEach(component) {
	
		-- Disconnect invalid PortParts
		component.embeddedComponentParts.portParts->select(p | not p.isValid())->forEach(pp) {
			pp.coordinationProtocolPart := null;
		};
		
		-- Remove empty CoordinationProtocolParts
		var coordinationProtocolParts := component.coordinationProtocolParts;
		coordinationProtocolParts->select(portParts->isEmpty())->forEach(p) {
			input.removeElement(p);
		};
		
		--coordinationProtocolParts->forEach(p) {
		--	input.removeElement(p);
		--};





		-- Merge CoordinationProtocolParts that can reach each other
		--component.coordinationProtocolParts->forEach(p, q) {
		--	if (p != q and p.coordinationProtocol = q.coordinationProtocol and p.isReachable(q)) then {
		--		p.portParts += q.portParts;
		--		input.removeElement(q);
		--	} endif;
		--};
		
		
		
		--component.connectors[AssemblyConnector]->forEach(a) {
		--	component.coordinationProtocolParts->forEach(p) {
		--		if (p.portParts->intersection(a.connectorEndpoints[PortPart])->isEmpty()) then {
		--			
		--		} endif;
		--	};
		--};
		
		// Create or reuse CoordinationProtocolParts for all valid PortParts
		component.embeddedComponentParts.portParts->select(p | p.isValid())->forEach(p) {
			var refinedRole := p.refinedRole;
			
			-- Find all PortParts that are reachable via AssemblyConnectors
			var reachablePortParts := p.allReachablePortParts();

			-- Find CoordinationProtocolPart that already contains any PortPart that is reachable via AssemblyConnectors.
			var coordinationProtocolPart := component.coordinationProtocolParts->any(c | not c.portParts->intersection(reachablePortParts)->isEmpty());
		
			-- Make sure we have one CoordinationProtocolPart to add to; if none was found, create a new one
			if (coordinationProtocolPart = null) then {
				coordinationProtocolPart := new CoordinationProtocolPart(refinedRole.coordinationProtocol.oclAsType(CoordinationProtocol));
				p.componentPart.parentComponent.coordinationProtocolParts += coordinationProtocolPart;
			} endif;
			
			-- Associate this PortPart with the Coordination Protocol Part
			p.coordinationProtocolPart := coordinationProtocolPart;
		};
	};
}

query PortPart::isValid() : Boolean {
	return self.connectors[AssemblyConnector]->notEmpty() and self.refinedRole != null
	-- commenting out the following line seems to make the workaround r4009 unnecessary!  
	-- and self.allReachablePortParts().coordinationProtocolPart->asSet()->excluding(self.coordinationProtocolPart)->isEmpty();
	;
}

query CoordinationProtocolPart::isReachable(p : CoordinationProtocolPart) : Boolean {
	return self.portParts->select(pp | p.isReachable(pp))->notEmpty();
}

query CoordinationProtocolPart::isReachable(portPart : PortPart) : Boolean {
	return self.portParts.allReachablePortParts()->excludes(portPart);
}

query PortPart::allReachablePortParts() : OrderedSet(PortPart) {
	return OrderedSet{ self }->closure(connectors[AssemblyConnector].portParts);
}
constructor CoordinationProtocolPart::CoordinationProtocolPart(p : CoordinationProtocol) {
	coordinationProtocol := p;
}