transformation InstantiationTransformation(inout input : ComponentPackage);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype ProtocolPackage uses muml::protocol('http://www.fujaba.de/muml/0.4.0');

modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
 
	var components := input.rootObjects()[StructuredComponent];	

	// Editor supplies StructuredComponent in rootInput.
	// In case we want to run this transformation differently (for debugging), we search for StructuredComponents.
	if (components->isEmpty()) then {
		components := input.objects()[StructuredComponent]
	} endif;
	
	components->forEach(component) {
	
		-- find assemblies
		var assemblies := component.embeddedComponentParts.portParts.connectors[AssemblyConnector];
		
		-- good assemblies only have PortParts with the same CS
		var goodAssemblies := assemblies->select(a | a.connectorEndpoints[PortPart].portType->excluding(null)[DiscretePort].refinedRole->excluding(null).coordinationProtocol->excluding(null)->asSet()->size() = 1);

		-- 1: Find necessary coordination specifications (CS)
		var newCS := goodAssemblies.connectorEndpoints[PortPart].portType->excluding(null)[DiscretePort].refinedRole->excluding(null).coordinationProtocol->excluding(null)[AbstractCoordinationSpecification]->asSet();
		var oldCS := component.coordinationProtocolParts.coordinationProtocol->excluding(null)[AbstractCoordinationSpecification]->asSet();
		var removedCS := oldCS - newCS;
		var addedCS   := newCS - oldCS;
		
		-- 1A: Delete Coordination Specification Parts for removed CS
		if (removedCS->notEmpty()) {
			component.coordinationProtocolParts := component.coordinationProtocolParts->reject(CPP | removedCS->includes(CPP.coordinationProtocol));
		} endif;
		
		-- 1B: Add Coordination Specication Parts for added CS
		if (addedCS->notEmpty()) {
			-- XXX currently we only create new parts for CoordinationProtocols, NOT PATTERNS, NOT VARIANTS. 
			-- XXX Because the metamodel does not allow us to!
			-- XXX CoordinationProtocolPart.coordinationProtocol should be of type AbstractCoordinationSpecification.
			-- XXX That's why we filter here:
			addedCS[CoordinationProtocol]->forEach(CS) {
				component.coordinationProtocolParts += new CoordinationProtocolPart(CS);				
			};
		} endif;
		
		
		-- Connect every port part to the right CS part
		component.embeddedComponentParts.portParts->forEach(portPart) {
			var CS := portPart.portType->excluding(null)[DiscretePort].refinedRole->excluding(null).coordinationProtocol->excluding(null)->any(true);
			portPart.coordinationProtocolPart := component.coordinationProtocolParts->select(CPP | CPP.coordinationProtocol = CS)->any(true);
		};
	};
}

constructor CoordinationProtocolPart::CoordinationProtocolPart(CS : CoordinationProtocol) {
	coordinationProtocol := CS;
} 