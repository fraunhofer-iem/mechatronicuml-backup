library LoadBalancing;
import common.AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');

----------------------------------------------------------XXXXXXXXXXXXXXXXX--UNICAST--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

property loadBalancing : String = "loadBalancing";
property loadBalancingCheckDone : String = "loadBalancingCheckDone";
property loadBalancingCheck : String = "loadBalancingCheck";
property loadBalancingDone : String = "loadBalancingDone";
property neverHadATask : Variable;
property freeForWork: Variable;
property freeForWorkName : String = "freeForWork";
property neverHadATaskName : String = "neverHadATask";
property taskPlannedName : String = "taskPlanned";
property loadBalancingtaskMessageClockName : String = "c_taksMsg";
property loadBalancingTaskMessageClock : Clock ;
property loadBalancingPossibleName : String = "loadBalancingPossible";


// lazy initialisation of LoadBalancing specific variables and clocks that may only exist ones (not for every LoadBalancing instance as it usually is the case):
helper getNeverHadATaskVariable() : Variable {
	if(neverHadATask.oclIsUndefined()) {
		neverHadATask := new Variable();
		neverHadATask.name := neverHadATaskName;
		neverHadATask.dataType := getBooleanPrimitiveDataType(rootNode);
		neverHadATask.initializeExpression := new LiteralExpression();
		neverHadATask.initializeExpression.oclAsType(LiteralExpression).value := "true";
	};
	return neverHadATask;
}

helper getFreeForWorkVariable() : Variable {
	if(freeForWork.oclIsUndefined()) {
		freeForWork := new Variable();
		freeForWork.name := freeForWorkName;
		freeForWork.dataType := getBooleanPrimitiveDataType(rootNode);
		freeForWork.initializeExpression := new LiteralExpression();
		freeForWork.initializeExpression.oclAsType(LiteralExpression).value := "true";
	};
	return freeForWork;
}

helper getLoadBalancingClockTaskPlanned() : Clock {
	if(loadBalancingTaskMessageClock.oclIsUndefined()) {
		loadBalancingTaskMessageClock := new Clock();
		loadBalancingTaskMessageClock.name := loadBalancingtaskMessageClockName;
	};
	
	return loadBalancingTaskMessageClock;
}
------------------------------------------------------------Transfer Schema LoadBalancing of Coordinator------------------------------------------------------------------
	
mapping Transition :: LoadBalancing2TransSendSyncCoordinator(context:OclAny, region:RealtimeStatechart, conditional:Boolean, toplevel : Boolean) : Transition {

		priority := self.priority;
		
		if(conditional){			
			source := self.map LoadBalancing2StateCoordinator(context, region, toplevel);
		}else{
			source := self.source.map Vertex2VertexCoordinator(context, region);
		} ;
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
		
		if(not conditional){
			guard := self.guard.map Expression2Expression(context);
			
			clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(result);
		}endif;
		// @author: sthiele2 changed first paramter of Action2Action from 1 to context
		action := self.action.map Action2Action(context, region);
		
		synchronization := self.TransferSchemata2Synchronization( loadBalancing,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
			
	}

// @author: sthiele2
mapping Transition :: LoadBalancing2CoordinatorStartTransition(context:OclAny, region:RealtimeStatechart, toplevel : Boolean) : Transition {
	// this mapping creates an outgoing transition from the (mapped) source of the schema transition to a first intermediate state
	source := self.source.map Vertex2VertexCoordinator(context, region);
	target := self.map Schema2CoordinatorIntermediateState(context,region,1,loadBalancingDLCName,toplevel);
	priority := self.priority;
	guard := self.guard.map Expression2Expression(result);		
	clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(result);
	
	synchronization := self. TransferSchemata2Synchronization( loadBalancingCheckDone,SynchronizationKind::SEND);
}

// @author: sthiele2
mapping Transition :: LoadBalancing2CoordinatorIntermediateTransition(context:OclAny, region:RealtimeStatechart, toplevel : Boolean): Transition
{
	// creates the transition from intermediate state 1 to intermediate state 2
	source := self.map Schema2CoordinatorIntermediateState(context,region,1, loadBalancingDLCName,toplevel);
	target := self.map Schema2CoordinatorIntermediateState(context,region,2,loadBalancingDLCName,toplevel);	
	priority := 1;
	if(not self.relativeDeadline.oclIsUndefined())
	{
		result.clockConstraints += self. RelativeDeadline2ClockConstraint(true, ComparingOperator::GREATER_OR_EQUAL, loadBalancingDLCName );
	};
	synchronization := self.TransferSchemata2Synchronization( loadBalancing,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
}

// @author: sthiele2
mapping Transition :: LoadBalancing2CoordinatorEndTransition(context:OclAny, region:RealtimeStatechart, toplevel: Boolean): Transition
{
	// creates a transition from intermediate state 2 to the (mapped) target of the schema transition 
	source := self.map Schema2CoordinatorIntermediateState(context,region,2,loadBalancingDLCName, toplevel);
	target := self.target.map Vertex2VertexCoordinator(context,region);
	priority := 1;
	result.clockResets :=  self.clockResets->select(c| not isClockSubRoleSpecific(c)).map Clock2Clock();
	result.action := self.action.map Action2Action(context,region);
	synchronization :=self.TransferSchemata2Synchronization(loadBalancingDone,SynchronizationKind::RECEIVE);	
}


mapping Transition :: LoadBalancing2SourceRegionCoordinator(context:OclAny, region:RealtimeStatechart) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map LoadBalancing2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: LoadBalancing2SourceEmbeddedRTSCCoordinator(context:OclAny, region:RealtimeStatechart) : RealtimeStatechart {
		
		name:= "loadBalancingCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map LoadBalancing2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map LoadBalancing2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: LoadBalancing2TransCheckEmbeddedCoordinator(context:OclAny, region:RealtimeStatechart) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints.map ClockConstraint2ClockConstraint(result);
		
		guard := self.guard.map Expression2Expression(result);
		
		synchronization :=	self. TransferSchemata2Synchronization(  loadBalancingCheck,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
			
	}
	
mapping Transition :: LoadBalancing2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:RealtimeStatechart) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
		synchronization := self. TransferSchemata2Synchronization( loadBalancingCheckDone,SynchronizationKind::RECEIVE);
		
		guard := self. TransferSchemaGuard( "loadBalancingPossible", UnaryOperator::NOT);
			
	}
	
	
mapping Transition :: LoadBalancing2StateCoordinator(context:OclAny, region:RealtimeStatechart, toplevel: Boolean) : State {
	
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_Sending";
		
		parentStatechart := self.statechart.map RTSC2CoordinatorRTSC(context,toplevel);	
						
	}
	
mapping Transition :: LoadBalancing2TransReceiveSyncCoordinator(context:OclAny, region:RealtimeStatechart, toplevel : Boolean) : Transition {
	
		priority := self.priority;
		
		target := self.map LoadBalancing2StateCoordinator(context, region,toplevel);
		
		source := self.source.map Vertex2VertexCoordinator(context, region);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(result);		
		
		synchronization := self.TransferSchemata2Synchronization( loadBalancingCheckDone,SynchronizationKind::RECEIVE);
		
		if(self.guard.oclIsUndefined()){
			guard := self. Schema2TypedNamedElementExpression(self.map Transition2SubroleSpecificBooleanVaribale("loadBalancingPossible"));
		}else{
			guard := self.Transition2LogicalExpression(LogicOperator::AND, self.guard.map Expression2Expression(new LogicalExpression()),self.Schema2TypedNamedElementExpression(self.map Transition2SubroleSpecificBooleanVaribale("loadBalancingPossible")));
		};
					
	}
	
--------------------------------------------------------------- Transfer Schema LoadBalancing of Subrole----------------------------------------------------------------------
	
mapping Transition :: LoadBalancing2TransSendSyncFirstSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {

		priority := (self.priority-1)*2+2;
		
		source := self.map Transition2StateSubrole(region, self.source, true);
		
		target := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);
				
		synchronization := self.TransferSchemata2Synchronization(  loadBalancing,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
						
		events += self.raiseMessageEvent.map Asynchronous2Asynchronous(context);
		
		clockResets += self.clockResets->map Clock2Clock();
		
		action := self.action.map Action2Action(result,region);
		
		if(action.oclIsUndefined()) {
			action := new Action();
			action.name := "";
		};
		
		// distinguish variants of LoadBalancing: maxWCET or responseMessage 
		var lb : muml::realtimestatechart::one_to_n_schemata::LoadBalancing :=
			self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::LoadBalancing);
		
		if (not lb.asynchronousMessageEvent.oclIsUndefined()) {
			action.name := action.name + freeForWorkName + ":= false";	
			action.expressions +=self.Transition2Block( self. Schema2TypedNamedElementAssignmentExpression( AssignOperator::ASSIGN, getFreeForWorkVariable(),	self.Schema2LiterarExpression("false")));
		
		}else if(not lb.maxWorkingTime.oclIsUndefined()) {
			action.name := action.name + neverHadATaskName + ":= false";	
			action.expressions +=self.Transition2Block( self. Schema2TypedNamedElementAssignmentExpression( AssignOperator::ASSIGN, getNeverHadATaskVariable(),	self.Schema2LiterarExpression("false")));
			clockResets += getLoadBalancingClockTaskPlanned();
		};		
				
		guard := self.Schema2TypedNamedElementExpression(self.map Transition2SubroleSpecificBooleanVaribale(taskPlannedName));
		
	}
	
mapping Transition :: LoadBalancing2TransSendSynNotFirstcSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {

		priority := (self.priority-1)*2+1;
		
		source := self.map Transition2StateSubrole(region,self.source, true);
		
		target := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);
					
		synchronization :=self. TransferSchemata2Synchronization(loadBalancing,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);--error
		
		guard := self.TransferSchemaGuard(taskPlannedName,UnaryOperator::NOT);	
		
	}
	
mapping Transition :: LoadBalancing2TransReceiveSyncNotLastSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		source := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);
		
		synchronization := 	self.TransferSchemata2Synchronization( loadBalancing,SynchronizationKind::SEND, PositionSelectorKind::SELF, PositionSelectorKind::NEXT);
		
		guard := self.TransferSchemataComparisonExpression(PositionSelectorKind::LAST, ComparingOperator::UNEQUAL);
					
	}
			
mapping Transition :: LoadBalancing2TransReceiveSyncLastSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		source := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);		
		
		guard := self. TransferSchemataComparisonExpression(PositionSelectorKind::LAST, ComparingOperator::EQUAL);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){			
			
			action := self. TransferSchemata2Action("loadBalancingPossible:=false", loadBalancingPossibleName, "false");
			
		}endif;
			
		result.synchronization :=self. TransferSchemata2Synchronization(loadBalancingDone,SynchronizationKind::SEND);		
	}

	
mapping Transition :: LoadBalancing2SourceRegionSubrole(context:OclAny, region:RealtimeStatechart) : Region {
		
		priority := self.priority;
		
		parentState := self.map Transition2StateSubrole(region,self.source, true);
		
		embeddedStatechart := self.map LoadBalancing2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: LoadBalancing2SourceEmbeddedRTSCSubrole(context:OclAny, region:RealtimeStatechart) : RealtimeStatechart {
		
		name:= "loadBalancingCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requested", false);
		states += self.map RegionState(context, region, "Check", false);
		
		transitions += self.map LoadBalancing2TransitionFromIdleToCheck(context,region);
					
		if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::LoadBalancing).responseMessage.oclIsUndefined()) {
			transitions += self.map LoadBalancingResponseMessage2TransitionFromCheckToRequested1(context,region);
			transitions += self.map LoadBalancingResponseMessage2TransitionFromCheckToRequested2(context,region);
		};
		if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::LoadBalancing).maxWorkingTime.oclIsUndefined()) {
			
		};
		
		transitions += self.map LoadBalancing2TransitionFromRequestedToIdle1(context,region);
		transitions += self.map LoadBalancing2TransitionFromRequestedToIdle2(context,region);
		transitions += self.map LoadBalancing2TransitionFromRequestedToIdle3(context,region);
	}

mapping Transition :: LoadBalancing2TransitionFromIdleToCheck(context:OclAny, region:RealtimeStatechart) : Transition {
		
		priority := 1;
		
		source := self.map RegionState(context,region,"Idle",true);
		
		target := self.map RegionState(context,region,"Check",false);
		
		synchronization := self.TransferSchemata2Synchronization(loadBalancingCheck, SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
}

mapping Transition :: LoadBalancingResponseMessage2TransitionFromCheckToRequested1(context:OclAny,region:RealtimeStatechart) : Transition {
		
		priority := 1;
		
		source := self.map RegionState(context,region,"Check",false);
		
		target := self.map RegionState(context,region,"Requested",false);		
		
		result.guard := self.TransferSchemataLogicalExpression(self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2UnaryExpression(result,UnaryOperator::NOT),self.TransferSchemaGuard(getFreeForWorkVariable(), UnaryOperator::NOT),LogicOperator::OR);

		action := self.TransferSchemata2Action(taskPlannedName + " := false;",taskPlannedName,"false");		
}


mapping Transition :: LoadBalancingResponseMessage2TransitionFromCheckToRequested2(context:OclAny,region:RealtimeStatechart) : Transition {
		
		priority :=2;
		
		source := self.map RegionState(context,region,"Check",false);
		
		target := self.map RegionState(context,region,"Requested",false);		
		
		result.guard := self.TransferSchemataLogicalExpression(self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(result),self.TransferSchemaGuard(getFreeForWorkVariable(),null),LogicOperator::AND);
		
		action := self.TransferSchemata2TwoActions(loadBalancingPossibleName + " := true; " + taskPlannedName + " := true;",loadBalancingPossibleName, taskPlannedName, "true");
		
}

mapping Transition :: LoadBalancing2TransitionFromRequestedToIdle1(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 1;
		
		target := self.map RegionState(context,region,"Check",false);
		
		source := self.map RegionState(context,region,"Requested",false);	
		
		guard := self.TransferSchemataComparisonExpression(PositionSelectorKind::LAST,ComparingOperator::EQUAL);
		
		synchronization := self.TransferSchemata2Synchronization(loadBalancingCheckDone, SynchronizationKind::SEND);
		
}

mapping Transition :: LoadBalancing2TransitionFromRequestedToIdle2(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 2;
		
		target := self.map RegionState(context,region,"Check",false);
		
		source := self.map RegionState(context,region,"Requested",false);	
		
		guard := self.TransferSchemataLogicalExpression(self.TransferSchemataComparisonExpression(PositionSelectorKind::LAST,ComparingOperator::UNEQUAL), self.TransferSchemaGuard(loadBalancingPossibleName, UnaryOperator::NOT),LogicOperator::AND);
		
		synchronization := self.TransferSchemata2Synchronization(loadBalancingCheck, SynchronizationKind::SEND,PositionSelectorKind::SELF, PositionSelectorKind::NEXT);
		
}

mapping Transition :: LoadBalancing2TransitionFromRequestedToIdle3(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 3;
		
		target := self.map RegionState(context,region,"Check",false);
		
		source := self.map RegionState(context,region,"Requested",false);	
		
		guard := self.TransferSchemataLogicalExpression(self.TransferSchemataComparisonExpression(PositionSelectorKind::LAST,ComparingOperator::UNEQUAL), self.Schema2TypedNamedElementExpression(self.map Transition2SubroleSpecificBooleanVaribale(loadBalancingPossibleName)),LogicOperator::AND);
		
		synchronization := self.TransferSchemata2Synchronization(loadBalancingCheck, SynchronizationKind::SEND,PositionSelectorKind::SELF, PositionSelectorKind::NEXT);
		
}






