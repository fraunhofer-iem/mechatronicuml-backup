library Multicast;
import common.AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');

----------------------------------------------------------XXXXXXXXXXXXXXXXX--MULTICAST--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------	
property multicastCheckDone : String = "multicastCheckDone";
property multicast : String = "multicast";
property multicastDone : String = "multicastDone";
property multicastCheck : String = "multicastCheck";

----------------------------------------------------------------Transfer Schema Multicast of Coordinator------------------------------------------------------------------

// @author: sthiele2
mapping Transition :: Multicast2CoordinatorStartTransition(context:OclAny, region:RealtimeStatechart,toplevel : Boolean) : Transition {
	// this mapping creates an outgoing transition from the (mapped) source of the schema transition to a first intermediate state
	source := self.source.map Vertex2VertexCoordinator(context, region);
	target := self.map Schema2CoordinatorIntermediateState(context,region,1,multicastDLCName,toplevel);
	priority := self.priority;
	guard := self.guard.map Expression2Expression(result);		
	clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(result);
	
	synchronization := self. TransferSchemata2Synchronization(  multicastCheckDone,SynchronizationKind::RECEIVE);
}

// @author: sthiele2
mapping Transition :: Multicast2CoordinatorIntermediateTransition(context:OclAny, region:RealtimeStatechart,toplevel : Boolean): Transition
{
	// creates the transition from intermediate state 1 to intermediate state 2
	source := self.map Schema2CoordinatorIntermediateState(context,region,1,multicastDLCName,toplevel);
	target := self.map Schema2CoordinatorIntermediateState(context,region,2,multicastDLCName,toplevel);	
	priority := 1;
	if(not self.relativeDeadline.oclIsUndefined())
	{
		result.clockConstraints += self. RelativeDeadline2ClockConstraint( true, ComparingOperator::GREATER_OR_EQUAL, multicastDLCName );
	};
	
	synchronization := self. TransferSchemata2Synchronization( multicast,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
}

// @author: sthiele2
mapping Transition :: Multicast2CoordinatorEndTransition(context:OclAny, region:RealtimeStatechart, toplevel : Boolean): Transition
{
	// creates a transition from intermediate state 2 to the (mapped) target of the schema transition 
	source := self.map Schema2CoordinatorIntermediateState(context,region, 2, multicastDLCName,toplevel);
	target := self.target.map Vertex2VertexCoordinator(context,region);
	priority := 1;
	result.clockResets :=  self.clockResets->select(c| not isClockSubRoleSpecific(c)).map Clock2Clock();
	result.action := self.action.map Action2Action(context,region);
	
	synchronization := self. TransferSchemata2Synchronization(multicastDone,SynchronizationKind::RECEIVE);
}

	
------------- non Conditional Coordinator Mappings	
mapping Transition :: NonConditionalMulticast2TranssitionFromSourceToIntermediate(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {

		priority := self.priority;
						
		source := self.source.map Vertex2VertexCoordinator(context, region);
		
		target := self.map Schema2CoordinatorIntermediateState(context, region,1, multicastDLCName, toplevel);
		
		synchronization := self. TransferSchemata2Synchronization(  multicast,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
		
		clockConstraints := self.clockConstraints.map ClockConstraint2ClockConstraint(result);
		
		guard := self.guard.map Expression2Expression(result);
}

mapping Transition :: NonConditionalMulticast2TransitionFromIntermediateToTarget(context:OclAny, region:RealtimeStatechart,  toplevel:Boolean) : Transition{
	
		priority := 1;
		
		source := self.map Schema2CoordinatorIntermediateState(context,region, 1,multicastDLCName, toplevel);
	
		target := self.target.map Vertex2VertexCoordinator(context,region);
		
		action := self.action.map Action2Action(context, region);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
	
		synchronization := self. TransferSchemata2Synchronization(  multicastDone,SynchronizationKind::RECEIVE);	
}

---------------- Coordinator Mappings for Embedded State

mapping Transition :: Multicast2SourceRegionCoordinator(context:OclAny, region:RealtimeStatechart) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map Multicast2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: Multicast2SourceEmbeddedRTSCCoordinator(context:OclAny, region:RealtimeStatechart) : RealtimeStatechart {
		
		name:= "multicastCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map Multicast2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map Multicast2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: Multicast2TransCheckEmbeddedCoordinator(context:OclAny, region:RealtimeStatechart) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(result);
		
		guard := self.guard.map Expression2Expression(context);
		
		synchronization := 	self. TransferSchemata2Synchronization( multicastCheck,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
			
	}
	
mapping Transition :: Multicast2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:RealtimeStatechart) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
	
		
		synchronization :=  self. TransferSchemata2Synchronization( multicastCheckDone,SynchronizationKind::RECEIVE);
		
		guard := self. TransferSchemaGuard( "multicastPossible", UnaryOperator::NOT);
			
	}
	
	

	

	
----------------------------------------------------------------- Transfer Schema Multicast of Subrole-------------------------------------------------------------------
	
mapping Transition :: Multicast2TransSendSyncSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
		
		source := self.map Transition2StateSubrole(region,self.source, true);
		
		target := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);
		
		synchronization := self.TransferSchemata2Synchronization( multicast,SynchronizationKind::RECEIVE  ,PositionSelectorKind::SELF);
		
		clockConstraints += self.clockConstraints->select(c|isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(result);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		action := self.raiseMessageEvent.oneToManyCommunicationSchema.action.map Action2Action(context, region);
		
		events += self.raiseMessageEvent.map Asynchronous2Asynchronous(context);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			guard := self.map TransferSchemaConditionAndPossibleGuard(context, 1, region, "multicastPossible", false, 3);
			priority := (self.priority-1)*2+2;
			
		}else{
			priority := self.priority;
		};
		
		
	}
	
mapping Transition :: Multicast2TransReceiveSyncNotLastSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		source := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);	
		
		synchronization := self. TransferSchemata2Synchronization( multicast,SynchronizationKind::SEND, PositionSelectorKind::SELF, PositionSelectorKind::NEXT);
		
		guard := self.  TransferSchemataLogicalExpression(PositionSelectorKind::LAST, ComparingOperator::UNEQUAL);
					
	}
			
mapping Transition :: Multicast2TransReceiveSyncLastSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		source := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);		
		
		guard := self.  TransferSchemataLogicalExpression(PositionSelectorKind::LAST, ComparingOperator::EQUAL);
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			action := self. TransferSchemata2Action("multicastPossible:=false", "multicastPossible", "false");
			
		}endif;
		synchronization := self. TransferSchemata2Synchronization( multicastDone,SynchronizationKind::SEND);			
	}
	

	
mapping Transition :: Multicast2SourceRegionSubrole(context:OclAny, region:RealtimeStatechart) : Region {
		
		priority := self.priority;
		
		parentState := self.map Transition2StateSubrole(region,self.source, true).oclAsType(State);
		
		embeddedStatechart := self.map Multicast2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: Multicast2SourceEmbeddedRTSCSubrole(context:OclAny, region:RealtimeStatechart) : RealtimeStatechart {
		
		name:= "multicastCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requested", false);
		
		transitions += self.map Multicast2RequestedIdleCheckSubrole(context, region);
		transitions += self.map Multicast2RequestedIdleCheckDoneSubrole(context, region);
		transitions += self.map Multicast2IdleRequestedFulfilledSubrole(context, region);
		transitions += self.map Multicast2IdleRequestedNotFulfilledSubrole(context, region);
					
	}
	
mapping Transition :: Multicast2RequestedIdleCheckSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.  TransferSchemataLogicalExpression(PositionSelectorKind::LAST, ComparingOperator::UNEQUAL);
		
		synchronization := self.TransferSchemata2Synchronization( "multicastCheck", SynchronizationKind::SEND, PositionSelectorKind::SELF, PositionSelectorKind::NEXT);
					
	}
	
mapping Transition :: Multicast2RequestedIdleCheckDoneSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self. TransferSchemataLogicalExpression(PositionSelectorKind::LAST, ComparingOperator::EQUAL);
		
		synchronization := self.TransferSchemata2Synchronization(multicastCheckDone,SynchronizationKind::SEND);
					
	}
	
mapping Transition :: Multicast2IdleRequestedFulfilledSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 2;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(2);
		
		synchronization := 	self.TransferSchemata2Synchronization(multicastCheck,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
		
		action := self. TransferSchemata2Action( "multicastPossible:=true", "multicastPossible", "true");
					
	}
	
mapping Transition :: Multicast2IdleRequestedNotFulfilledSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map TransferSchemaNotCondition(3, region, 3);

		synchronization := self.TransferSchemata2Synchronization(multicastCheck,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
					
	}
	
mapping Transition :: Multicast2TransSendSyncNotConditionSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
		
		source := self.map Transition2StateSubrole(region,self.source, true);
		
		target := self.map Schema2SubroleIntermediateState(context, region,1, toplevel);
		
		synchronization := self.TransferSchemata2Synchronization(multicast,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
				
		guard := self.map TransferSchemaConditionAndPossibleGuard(context, 4, region, "multicastPossible", true, 11);
		
		priority := (self.priority-1)*2+1;
		
	}
	