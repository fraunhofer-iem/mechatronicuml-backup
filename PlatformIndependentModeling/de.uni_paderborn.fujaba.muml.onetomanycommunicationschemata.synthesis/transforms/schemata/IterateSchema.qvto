library Iterate;
import common.AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');

----------------------------------------------------------XXXXXXXXXXXXXXXXX--ITERATE--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------	
property iterateCheckDone : String = "iterateCheckDone";
property iterate : String = "iterate";
property iterateDone : String = "iterateDone";
property iterateCheck : String = "iterateCheck";
property iterateDLCName : String = "DLC_Iterate";
property iteratePossibleName : String = "iteratePossible";
property terminateIterationName : String = "terminate";
property iterateDelayVariableName : String = "iterateDelay";
property sendIterateName : String = "sendIterate";
property iterateDelayClockName : String = "Delay_Clock";

----------------------------------------------------------------Transfer Schema Iterate of Coordinator------------------------------------------------------------------

// @author: sthiele2
mapping Transition :: Iterate2CoordinatorStartTransition(context:OclAny, region:RealtimeStatechart) : Transition {
	// this mapping creates an outgoing transition from the (mapped) source of the schema transition to a first intermediate state
	source := self.source.map Vertex2VertexCoordinator(context);
	target := self.map Schema2CoordinatorIntermediateState(context,1,iterateDLCName);
	priority := self.priority;
	guard := self.guard.map multiTransform().oclAsType(Expression);	
	if(not self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->isEmpty()) {
		urgent := false;
	};		
	clockConstraints += self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))-> map multiTransform().oclAsType(ClockConstraint);
	
	synchronization := self. createSynchronization(  iterateCheckDone,SynchronizationKind::RECEIVE);
}

// @author: sthiele2
mapping Transition :: Iterate2CoordinatorIntermediateTransition(context:OclAny, region:RealtimeStatechart): Transition
{
	// creates the transition from intermediate state 1 to intermediate state 2
	source := self.map Schema2CoordinatorIntermediateState(context,1,iterateDLCName);
	target := self.map Schema2CoordinatorIntermediateState(context,2,iterateDLCName);	
	priority := 1;
	if(not self.relativeDeadline.oclIsUndefined())
	{
		urgent := false;
		result.clockConstraints += self. RelativeDeadline2ClockConstraint( true, ComparingOperator::GREATER_OR_EQUAL, iterateDLCName );
	};
	if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).startFromFirst) {
		synchronization := self. createSynchronization( iterate,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
	}
	else {
		synchronization := self. createSynchronization( iterate,SynchronizationKind::SEND, PositionSelectorKind::LAST);
	};
}

// @author: sthiele2
mapping Transition :: Iterate2CoordinatorEndTransition(context:OclAny, region:RealtimeStatechart): Transition
{
	// creates a transition from intermediate state 2 to the (mapped) target of the schema transition 
	source := self.map Schema2CoordinatorIntermediateState(context, 2, iterateDLCName);
	target := self.target.map Vertex2VertexCoordinator(context);
	priority := 1;
	result.clockResets :=  self.clockResets->select(c| not isClockSubRoleSpecific(c)).map transform().oclAsType(Clock);
	
	if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.oclIsUndefined()) {
		
		result.action := self.createActionWithVariableAssignmentBlock(terminateIterationName +  " := false;",terminateIterationName,"false");
		if(not self.action.name.oclIsUndefined()) {
			result.action.name := result.action.name + self.action.name;
		};
		result.action.expressions += self.action.expressions.map multiTransform().oclAsType(Expression);
		
	} else {
		result.action := self.action.map multiTransform().oclAsType(Action);
	};
	
	synchronization := self. createSynchronization(iterateDone,SynchronizationKind::RECEIVE);
}

	
------------- non Conditional Coordinator Mappings	
mapping Transition :: NonConditionalIterate2TranssitionFromSourceToIntermediate(context:OclAny, region:RealtimeStatechart) : Transition {

		priority := self.priority;
						
		source := self.source.map Vertex2VertexCoordinator(context);
		
		target := self.map Schema2CoordinatorIntermediateState(context,1, iterateDLCName);
		
		synchronization := self. createSynchronization(  iterate,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
		
		if(not self.clockConstraints->isEmpty())
			urgent := false;
		clockConstraints += self.clockConstraints->map multiTransform().oclAsType(ClockConstraint);
		
		guard := self.guard.map multiTransform().oclAsType(Expression);
}

mapping Transition :: NonConditionalIterate2TransitionFromIntermediateToTarget(context:OclAny, region:RealtimeStatechart) : Transition{
	
		priority := 1;
		
		source := self.map Schema2CoordinatorIntermediateState(context, 1,iterateDLCName);
	
		target := self.target.map Vertex2VertexCoordinator(context);
		
		action := self.action.map multiTransform().oclAsType(Action);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map transform().oclAsType(Clock);
	
		synchronization := self. createSynchronization(  iterateDone,SynchronizationKind::RECEIVE);	
}

---------------- Coordinator Mappings for Embedded State

mapping Transition :: Iterate2SourceRegionCoordinator(context:OclAny, region:RealtimeStatechart) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context).oclAsType(State);
		
		embeddedStatechart := self.map Iterate2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: Iterate2SourceEmbeddedRTSCCoordinator(context:OclAny, region:RealtimeStatechart) : RealtimeStatechart {
		
		name:= "iterateCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context,  "Idle", true);
		states += self.map RegionState(context,  "Requesting", false);
		
		transitions += self.map Iterate2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map Iterate2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: Iterate2TransCheckEmbeddedCoordinator(context:OclAny, region:RealtimeStatechart) : Transition {

		priority := 1;
		
		source := self.map RegionState(context,  "Idle", true);
		
		target := self.map RegionState(context,  "Requesting", false);
		if(not self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->isEmpty()) 
			urgent := false;			
		clockConstraints += self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map multiTransform().oclAsType(ClockConstraint);
	
		guard := self.guard.map multiTransform().oclAsType(Expression);
		
		synchronization := 	self. createSynchronization( iterateCheck,SynchronizationKind::SEND, PositionSelectorKind::FIRST);
			
	}
	
mapping Transition :: Iterate2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:RealtimeStatechart) : Transition {

		priority := 1;
		
		target := self.map RegionState(context,  "Idle", true);
		
		source := self.map RegionState(context,  "Requesting", false);
		
	
		
		synchronization :=  self. createSynchronization( iterateCheckDone,SynchronizationKind::RECEIVE);
		
		guard := self. createUnaryExpressionEnclosingTypedNamedElementExpression( iteratePossibleName, UnaryOperator::NOT);
			
	}
	
	

	

	
----------------------------------------------------------------- Transfer Schema Iterate of Subrole-------------------------------------------------------------------
	
mapping Transition :: Iterate2TransSendSyncSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
		
		priority := 1; 
		
		source := self.map Transition2StateSubrole(region,self.source, true);
		
		target := self.map Schema2SubroleIntermediateState(context,1);
		
		synchronization := self.createSynchronization( iterate,SynchronizationKind::RECEIVE  ,PositionSelectorKind::SELF);
		
		if(not self.clockConstraints->select(c|isClockSubRoleSpecific(c.clock))->isEmpty())
			urgent := false;
				
		clockConstraints += self.clockConstraints->select(c|isClockSubRoleSpecific(c.clock))->map multiTransform().oclAsType(ClockConstraint);
	
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map transform().oclAsType(Clock);
		
		action := new Action();
		
		action.name :="";
		
		if(not self.raiseMessageEvent.oneToManyCommunicationSchema.action.oclIsUndefined()) {
			action.expressions += self.raiseMessageEvent.oneToManyCommunicationSchema.action.expressions.map multiTransform().oclAsType(Expression);
			action.name :=  action.name + self.raiseMessageEvent.oneToManyCommunicationSchema.action.name;
		};
		
		action.expressions+= self.createBlockWithVariableAssignment(iterateDelayVariableName,"true");
		
		action.name := action.name + " " + iterateDelayVariableName + " := true";
		
		events += self.raiseMessageEvent.map multiTransform().oclAsType(TransitionEvent);
		
		var leftExpression : Expression := 	self.createUnaryExpressionEnclosingTypedNamedElementExpression(terminateIterationName, UnaryOperator::NOT);
		var rightExpression : Expression := createTypedNamedElementExpression(self.map Schema2BooleanVariable(sendIterateName));
		
		guard := new LogicalExpression(leftExpression, rightExpression, LogicOperator::AND);
				
	}
	
	
	
	
mapping Transition :: Iterate2TransSendSyncNotConditionSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
		
		source := self.map Transition2StateSubrole(region,self.source, true);
		
		target := self.map Schema2SubroleIntermediateState(context,1);
		
		synchronization := self.createSynchronization(iterate,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
		
		action := self.createActionWithVariableAssignmentBlock(iterateDelayVariableName + " := false;",iterateDelayVariableName,"false");			
		
		var leftExpression : Expression := 	self.createUnaryExpressionEnclosingTypedNamedElementExpression(terminateIterationName, UnaryOperator::NOT);
		var rightExpression : Expression := self.createUnaryExpressionEnclosingTypedNamedElementExpression(sendIterateName, UnaryOperator::NOT);
		guard :=  new LogicalExpression(leftExpression, rightExpression, LogicOperator::AND);
				
		priority :=2;
		
	}
	

mapping Transition :: Iterate2IdleToIntermediate2SubroleRegion(context: OclAny, region: RealtimeStatechart, toplevel:Boolean) : Transition {
	
	priority := 3;
	
	source := self.map Transition2StateSubrole(region,self.source, true);
		
	target := self.map Schema2SubroleIntermediateState(context,2);
	
	guard := createTypedNamedElementExpression(self.map Schema2BooleanVariable(terminateIterationName));
		
}


mapping Transition :: Iterate2Transition1Intermediate1ToIntermedediate2SubroleRegion(context:OclAny, region: RealtimeStatechart, toplevel: Boolean) : Transition {
	
	priority := 1;
	
	source := self.map Schema2SubroleIntermediateState(context, 1);
	
	target := self.map Schema2SubroleIntermediateState(context, 2);
	
	var expr1 :=  self.createUnaryExpressionEnclosingTypedNamedElementExpression(terminateIterationName, UnaryOperator::NOT);
	var expr2 := createTypedNamedElementExpression(self.map Schema2BooleanVariable(iterateDelayVariableName));
		
	var logic := new LogicalExpression(expr1,expr2,LogicOperator::AND);
	
	var logic2 : Expression;
	if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.oclIsUndefined()) {
		var expr3 := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate)
		.terminationCondition.map multiTransform().oclAsType(Expression);
		var expr4 := new UnaryExpression();
		expr4.enclosedExpression := expr3;
		expr4.operator := UnaryOperator::NOT;
		logic2 := new LogicalExpression(logic,expr4, LogicOperator::AND);
	}
	else {
		logic2 := logic;
	};
	
	guard := logic2;
	
	if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.oclIsUndefined()) {	
		urgent := false;
		clockConstraints += self.createClockConstraint(iterateDelayClockName, self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.map multiTransform().oclAsType(TimeValue), ComparingOperator:: GREATER_OR_EQUAL);
	};
	
}

mapping Transition :: Iterate2Transition2Intermediate1ToIntermedediate2SubroleRegion(context:OclAny, region: RealtimeStatechart, toplevel: Boolean) : Transition {
	
	priority := 2;
	
	source := self.map Schema2SubroleIntermediateState(context, 1);
	
	target := self.map Schema2SubroleIntermediateState(context, 2);
	
	var expr1 :=  self.createUnaryExpressionEnclosingTypedNamedElementExpression(terminateIterationName, UnaryOperator::NOT);
	var expr2 := self.createUnaryExpressionEnclosingTypedNamedElementExpression(iterateDelayVariableName, UnaryOperator::NOT);
	var logic := new LogicalExpression(expr1,expr2,LogicOperator::AND);
	
	var logic2 : Expression;
	if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.oclIsUndefined()) {
		var expr3 := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate)
		.terminationCondition.map multiTransform().oclAsType(Expression);
		var expr4 := new UnaryExpression();
		expr4.enclosedExpression := expr3;
		expr4.operator := UnaryOperator::NOT;
		logic2 := new LogicalExpression(logic,expr4, LogicOperator::AND);
	}
	else {
		logic2 := logic;
	};
	
	guard := logic2;
	
}

mapping Transition :: Iterate2Transition3Intermediate1ToIntermedediate2SubroleRegion(context:OclAny, region: RealtimeStatechart, toplevel: Boolean) : Transition {
	
	priority := 3;
	
	source := self.map Schema2SubroleIntermediateState(context, 1);
	
	target := self.map Schema2SubroleIntermediateState(context, 2);
	
	var expr1 :=  createTypedNamedElementExpression(self.map Schema2BooleanVariable(terminateIterationName));
		
	var expr2 := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.map multiTransform().oclAsType(Expression);
	
	guard := new LogicalExpression(expr1,expr2,LogicOperator::OR);
	
	action := self.createActionWithVariableAssignmentBlock(terminateIterationName + ":= true;",terminateIterationName,"true");
	
}

mapping Transition :: Iterate2TransReceiveSyncNotLastSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
	
		priority := 2;
		
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		source := self.map Schema2SubroleIntermediateState(context,2);	
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).startFromFirst) {
			synchronization := self. createSynchronization( iterate,SynchronizationKind::SEND, PositionSelectorKind::SELF, PositionSelectorKind::NEXT);
			guard := createComparisonExpressionForSelectorKind(PositionSelectorKind::LAST, ComparingOperator::UNEQUAL);
		}
		else {
			synchronization := self. createSynchronization( iterate,SynchronizationKind::SEND, PositionSelectorKind::SELF, PositionSelectorKind::PREV);
			guard :=  createComparisonExpressionForSelectorKind(PositionSelectorKind::FIRST, ComparingOperator::UNEQUAL);
		}endif;		
	}
			
mapping Transition :: Iterate2TransReceiveSyncLastSubrole(context:OclAny, region:RealtimeStatechart, toplevel:Boolean) : Transition {
	
		priority := 1;
		
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		source := self.map Schema2SubroleIntermediateState(context,2);		
		
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).startFromFirst) {
			guard := createComparisonExpressionForSelectorKind(PositionSelectorKind::LAST, ComparingOperator::EQUAL);			
		}		
		else {
			guard := createComparisonExpressionForSelectorKind(PositionSelectorKind::FIRST, ComparingOperator::EQUAL);	
		}endif;	
		
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate) 
				and (not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())){
				
			action := self. createActionWithVariableAssignmentBlock("iteratePossible:=false", iteratePossibleName, "false");
			
		}endif;
		synchronization := self. createSynchronization( iterateDone,SynchronizationKind::SEND);
	}
	

	
mapping Transition :: Iterate2SourceRegionSubrole(context:OclAny, region:RealtimeStatechart) : Region {
		
		priority := self.priority;
		
		parentState := self.map Transition2StateSubrole(region,self.source, true).oclAsType(State);
		
		embeddedStatechart := self.map Iterate2SourceEmbeddedRTSCSubrole(context, region);
					
	}
	
mapping Transition :: Iterate2SourceEmbeddedRTSCSubrole(context:OclAny, region:RealtimeStatechart) : RealtimeStatechart {
		
		name:= "iterateCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context,  "Idle", true);
		states += self.map RegionState(context,  "Requested", false);
		
		transitions += self.map Iterate2RequestedIdleCheckSubrole(context, region);
		transitions += self.map Iterate2RequestedIdleCheckDoneSubrole(context, region);
		transitions += self.map Iterate2IdleRequestedFulfilledSubrole(context, region);
		transitions += self.map Iterate2IdleRequestedNotFulfilledSubrole(context, region);
					
	}
	
mapping Transition :: Iterate2RequestedIdleCheckSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context,  "Requested", false);
		
		target := self.map RegionState(context,  "Idle", true);
		
		guard := createComparisonExpressionForSelectorKind(PositionSelectorKind::LAST, ComparingOperator::UNEQUAL);
		
		synchronization := self.createSynchronization( "iterateCheck", SynchronizationKind::SEND, PositionSelectorKind::SELF, PositionSelectorKind::NEXT);
					
	}
	
mapping Transition :: Iterate2RequestedIdleCheckDoneSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context,  "Requested", false);
		
		target := self.map RegionState(context,  "Idle", true);
		
		guard := createComparisonExpressionForSelectorKind(PositionSelectorKind::LAST, ComparingOperator::EQUAL);
		
		synchronization := self.createSynchronization(iterateCheckDone,SynchronizationKind::SEND);
					
	}
	
mapping Transition :: Iterate2IdleRequestedFulfilledSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 2;
				
		target := self.map RegionState(context,  "Requested", false);
		
		source := self.map RegionState(context,  "Idle", true);
		
		guard := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map multiTransform().oclAsType(Expression);
		
		synchronization := 	self.createSynchronization(iterateCheck,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
		
		action := self.createActionWithTwoVariableAssignments(iteratePossibleName + " :=true; " + sendIterateName + ":= true;",iteratePossibleName, sendIterateName,"true");
					
	}
	
mapping Transition :: Iterate2IdleRequestedNotFulfilledSubrole(context:OclAny, region:RealtimeStatechart) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context,  "Requested", false);
		
		source := self.map RegionState(context,  "Idle", true);
		
		guard := self. TransferSchemaNotCondition();

		synchronization := self.createSynchronization(iterateCheck,SynchronizationKind::RECEIVE, PositionSelectorKind::SELF);
					
	}

	