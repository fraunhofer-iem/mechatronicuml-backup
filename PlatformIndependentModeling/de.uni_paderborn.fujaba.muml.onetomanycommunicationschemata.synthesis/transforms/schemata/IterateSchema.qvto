library IterateSchema;
import common.AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype modelinstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');
	
// @author: sthiele2 -- Implementation of the Iterate-Schema that can be reduced to multicast schemas.
---------------------------------------------------------XXXXXXXXXXXXXXXXX--ITERATE--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------
property IterateDelayTimeClockName : String = "DelayClock_Iterate";
property IterateDLC_ClockName : String = "DLC_Iterate";
property iterateRoleVariableName : String = "curRole";
property lastPosition : PositionSelectorKind;
property firstPosition : PositionSelectorKind;
property nextPosition : PositionSelectorKind;

--------------------------------------------------------------Transfer Schema Iterate of Coordinator----------------------------------------------------------------------

helper Transition :: determinePositionKindSelectors()
{	
	if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).startFromFirst) {
		lastPosition := PositionSelectorKind::LAST;
		firstPosition := PositionSelectorKind::FIRST;
		nextPosition := PositionSelectorKind::NEXT;
	}
	else {
		lastPosition := PositionSelectorKind::FIRST;
		firstPosition := PositionSelectorKind::LAST;	
		nextPosition := PositionSelectorKind::PREV;
	};
}

helper Transition :: disassembleIterateSchema(){
	
	self.determinePositionKindSelectors();

	self.statechart.variables+= self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType());
	self.statechart.clocks += self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDLC_ClockName);
	if(self.iterateDefinesDelay()){
		self.statechart.clocks += self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDelayTimeClockName);		
	};
	self.statechart.transitions+= self.map Iterate2TransitionFromSourceToIntermediate();
	self.statechart.transitions+= self.map Iterate2Transition1FromIntermediateToTarget();
	if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.oclIsUndefined()){
		self.statechart.transitions+= self.map Iterate2Transition2FromIntermediateToTarget();
	};
	
	self.statechart.transitions+= self.map Iterate2SelfTransitionOfIntermediate();
	
	self.statechart.states += self.map Schema2IntermediateState(1);
	
}

mapping Transition :: Iterate2TransitionFromSourceToIntermediate() : Transition
{
	priority := 1;
	
	source := self.source;
	
	target := self.map Schema2IntermediateState(1);
	
	// set the conditions
	clockConstraints := self.clockConstraints.deepclone().oclAsType(ClockConstraint);
	
	guard := self.guard.deepclone().oclAsType(Expression);	
	
	// set the entry events of the iterate source state
	var sourceState : State := source.oclAsType(State); 
	if(sourceState.entryEvent.oclIsUndefined()){
			sourceState.entryEvent := new EntryEvent();
		};	
		
	if(self.iterateDefinesDelay()){			
		sourceState.entryEvent.kind := EventKind::RAISE;
		sourceState.entryEvent.clockResets+= self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDLC_ClockName);
	};
	if(sourceState.entryEvent.action.oclIsUndefined()){
		sourceState.entryEvent.action := new Action();	
		sourceState.entryEvent.action.name := "";	
	};
	sourceState.entryEvent.action.name := sourceState.entryEvent.action.name + " "+ iterateRoleVariableName+ " := " + firstPosition.toString();
	var variable : Variable := self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType());
	
	//  set the entry action of the source state depending on the startFromFirst flag	
	sourceState.entryEvent.action.expressions += self.map Transition2Block(self.map Schema2TypedNamedElementAssignmentExpression(sourceState,AssignOperator::ASSIGN,variable,self.map TransferSchemataEndpointReference(result,firstPosition)));	
	
	// create the condition for the multicast call!
			
	var firstmulticastCondition : Expression  :=self.map Transition2ComparisonExpression(result, ComparingOperator::EQUAL,self.map Schema2TypedNamedElementExpression(result,variable),self.map TransferSchemataEndpointReference(result,PositionSelectorKind::SELF));
	var secondmulticastCondition := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.deepclone().oclAsType(Expression);
	
	var multicastCondition : Expression;
	if(not secondmulticastCondition.oclIsUndefined()){
		multicastCondition := self.map Transition2LogicalExpression(result,LogicOperator::AND,firstmulticastCondition,secondmulticastCondition);
	}else{
		multicastCondition := firstmulticastCondition;
	}endif;
	
	events += self.raiseMessageEvent.oneToManyCommunicationSchema.map Schema2multicastCall(result,multicastCondition,self.raiseMessageEvent.oneToManyCommunicationSchema.action.deepclone().oclAsType(Action));
	
}


mapping OneToManyCommunicationSchema :: Schema2multicastCall(context : OclAny, condition : Expression, action : Action): AsynchronousMessageEvent{	
	kind := EventKind::RAISE;
	message := self.asynchronousMessageEvent.message.map Message2Message(result);	
	oneToManyCommunicationSchema := self.map Schema2multicast(context,condition,action);
}

mapping OneToManyCommunicationSchema ::Schema2multicast(context : OclAny, _condition : Expression, _action : Action) : muml::realtimestatechart::one_to_n_schemata::Multicast{
	result.condition :=  _condition;
	result.action := _action;
}


query Transition :: getPortOrRoleAsDataType() : DataType{
	return self.statechart.getPortOrRoleStatechart().behavioralElement.oclAsType(muml::types::DataType);
}




mapping Transition :: Iterate2Transition1FromIntermediateToTarget() : Transition{
	
	priority := 1;
	
	source := self.map Schema2IntermediateState(1);
	
	target := self.target;
	
	if(self.transitionDefinesRelativeDeadline()){
		clockConstraints+= self.map RelativeDeadline2ClockConstraint(result, result, true, ComparingOperator::GREATER_OR_EQUAL, IterateDLC_ClockName);
	}endif;
	
	
	var lhs : Expression :=  self.map Schema2TypedNamedElementExpression(result,self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType()));
		
	//TransferSchemataEndpointReference(context:OclAny, region:OclAny, pos: String, transMapping: Integer)
	
	var rhs : Expression := self.map TransferSchemataEndpointReference(result,lastPosition);
	guard := self.map Transition2ComparisonExpression(result, ComparingOperator::EQUAL,lhs, rhs);
	
	action := self.action.deepclone().oclAsType(Action);
	if(action.oclIsUndefined()){
		action := new Action();
		action.name :="";
	};
	
	var rhsAss : Expression := self.map TransferSchemataEndpointReference(result,firstPosition);
	action.name := action.name + iterateRoleVariableName + ":=" + firstPosition.toString();
	action.expressions+= self.map Transition2Block(self.map Schema2TypedNamedElementAssignmentExpression(result,AssignOperator::ASSIGN, self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType()),rhsAss));
	
	clockResets := self.clockResets;
}

mapping Transition :: Iterate2Transition2FromIntermediateToTarget(): Transition{
	
	priority := 3;
	
	source := self.map Schema2IntermediateState(1);
	
	target := self.target;
	
	if(self.transitionDefinesRelativeDeadline()){
		clockConstraints+= self.map RelativeDeadline2ClockConstraint(result, result, true, ComparingOperator::GREATER_OR_EQUAL, IterateDLC_ClockName);
	}endif;
	
	action := self.action.deepclone().oclAsType(Action);
	
	guard := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.deepclone().oclAsType(Expression);
	
	clockResets := self.clockResets;
	

}

mapping Transition :: Iterate2SelfTransitionOfIntermediate() : Transition {
	
	priority := 2;
	
	source := self.map Schema2IntermediateState(1);
	
	target := self.map Schema2IntermediateState(1);
	
	if(self.iterateDefinesDelay()){
		clockConstraints+=self.map Transition2ClockConstraint(result,IterateDelayTimeClockName,self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.map TimeValue2TimeValue(result,result), ComparingOperator::GREATER_OR_EQUAL);
	};
	
	var lhs : Expression :=  self.map Schema2TypedNamedElementExpression(result,self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType()));
			
	var rhs : Expression  := self.map TransferSchemataEndpointReference(result,lastPosition);	
	guard := self.map Transition2ComparisonExpression(result, ComparingOperator::UNEQUAL,lhs, rhs);
	
	// create the condition for the multicast call!
	
	var variable : Variable := self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType());		
	
	var firstmulticastCondition : Expression  :=self.map Transition2ComparisonExpression(result, ComparingOperator::EQUAL,self.map Schema2TypedNamedElementExpression(1,variable),self.map TransferSchemataEndpointReference(result,PositionSelectorKind::SELF));
	
	var secondmulticastCondition := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.deepclone().oclAsType(Expression);
	
	var multicastCondition : Expression;
	if(not secondmulticastCondition.oclIsUndefined()){
		multicastCondition := self.map Transition2LogicalExpression(result,LogicOperator::AND,firstmulticastCondition,secondmulticastCondition);
	}else{
		multicastCondition := firstmulticastCondition;
	}endif;
	
	events += self.raiseMessageEvent.oneToManyCommunicationSchema.map Schema2multicastCall(result,multicastCondition,self.raiseMessageEvent.oneToManyCommunicationSchema.action.deepclone().oclAsType(Action));
	
	// create actions:
	var assRHS : Expression	:= self.map TransferSchemataEndpointReference(result, nextPosition, variable);	
	
	var assignment : Expression := self.map Schema2TypedNamedElementAssignmentExpression(2, AssignOperator::ASSIGN, variable, assRHS);
	
	
	action := new Action();
	action.name := iterateRoleVariableName +" := " +iterateRoleVariableName + ".next";
	action.expressions+= self.map Transition2Block(assignment);
}




	

query Transition :: iterateDefinesDelay(): Boolean{
		return not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.oclIsUndefined();
}

query Transition :: transitionDefinesRelativeDeadline(): Boolean{
		return not self.relativeDeadline.oclIsUndefined();
}

//creates an intermediate state in the input Realtimestatechart. This is necessary in case of schemata that can be
// transformed expressed by other schematas. 

mapping  Transition :: Schema2IntermediateState(stateID : Integer) : State {
	
		name := self.source.name + "_Intermediate_"+ stateID.toString()+ "_" + self.target.name  ;
				
		parentStatechart := self.statechart;		
		
		if(self.iterateDefinesDelay()){
			entryEvent := new EntryEvent();
			result.entryEvent.kind := EventKind::RAISE;
			result.entryEvent.clockResets+= self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDelayTimeClockName);
		}endif;
	
		if(self.transitionDefinesRelativeDeadline())
		{
			invariants+=self.map RelativeDeadline2ClockConstraint(result, result, false, ComparingOperator::LESS_OR_EQUAL, IterateDLC_ClockName);
		}endif;
	}
	

