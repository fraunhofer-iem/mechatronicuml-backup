import SchemaSpecificMUML2MUML;
library AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype realtimestatechart uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype modelinstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');


property unicastDLCName : String = "DLC_unicast";
property multicastDLCName : String = "DLC_multicast";
property singleReceiveDLCName : String = "DLC_singleReceive";
property multiReceiveDLCName : String = "DLC_multiReceive";

property variableNamesDict : Dict(String, Integer);	
property usedClockNames : Dict(String,Integer);

property multicastSubRoleSpecificVariableName : String = "sendMulticast";

property intermediateStateCount : Integer = 0;

mapping Transition::Transition2SubroleSpecificBooleanVaribale(varName : String): Variable
{
	var namePrefix : String = "";
		if(variableNamesDict->hasKey(varName)) {
			var nr : Integer := variableNamesDict->get(varName);			
			namePrefix := (nr + 1).toString();
			variableNamesDict->put(varName, nr+1);
		}
		else {
			variableNamesDict ->put(varName, 1);
			namePrefix := 1.toString();
		};
	result.name := varName + "_"+ namePrefix;
//	result.initializeExpression := new LiteralExpression();
//	result.initializeExpression.oclAsType(LiteralExpression).value := "false";
	result.dataType := getBooleanPrimitiveDataType(self.statechart.getHighestParentStatechart().eContainer().eContainer().oclAsType(RootNode));
}

query getBooleanPrimitiveDataType(theRootNode : RootNode) : muml::types::PrimitiveDataType {
	var types2 : ModelElementCategory := theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.types.category') -> any(true);
	var data : PrimitiveDataType := types2.oclAsType(ModelElementCategory).modelElements
	->select(element | element.oclIsTypeOf(muml::types::PrimitiveDataType) and (element.oclAsType(muml::types::PrimitiveDataType).primitiveType = PrimitiveTypes::BOOLEAN))
	->any(true).oclAsType(muml::types::PrimitiveDataType);
	return data;
	}


// @author: sthiele2 -- creates an intermediate state in the subrole region
mapping  Transition :: Schema2SubroleIntermediateState(context:OclAny, region:RealtimeStatechart, stateID : Integer,toplevel : Boolean) : State {
	
		name := self.source.name + "_Intermediate_"+ stateID.toString()+ "_" + self.target.name  ;
				
		parentStatechart := self.RTSC2SubroleSchemaRTSC(context.oclAsType(RealtimeStatechart));		
					
	}



//@author: sthiele2 -- creates a clock for in order to disassamble a deadline at a schema-specifying-transition
mapping Transition :: TransitionDeadline2CoordinatorDeadlineClock(clockName : String) : Clock
{	
	var nameSuffix : String := "";
	if(usedClockNames->hasKey(clockName))
	{
		var nr : Integer := usedClockNames->get(clockName);
		usedClockNames->put(clockName,nr+1);
		nameSuffix := (nr+1).toString();
	}
	else
	{
		nameSuffix :=  1.toString();
		usedChannelNames->put(clockName,1);	
	};
	result.name := clockName +"_".concat(nameSuffix);
}	

//@author: sthiele2 -- creates a clock constraint in order to disassamble a deadline at a schema-specifying-transition
mapping  Transition :: RelativeDeadline2ClockConstraint(context:OclAny, region:RealtimeStatechart, mapLowerBound : Boolean, operator :ComparingOperator, clockName : String) : ClockConstraint
{
		var timeValue : TimeValue;
		if(mapLowerBound)
		{
			result.bound := self.relativeDeadline.lowerBound.map TimeValue2TimeValue(context,region);
		}
		else
		{
			result.bound := self.relativeDeadline.upperBound.map TimeValue2TimeValue(context,region);
		}endif;
		result.operator := operator;
		result.clock := self.map TransitionDeadline2CoordinatorDeadlineClock(clockName);
}

mapping Transition :: Transition2ClockConstraint(context : OclAny, clockName : String, _timeValue : TimeValue, compareOperator : ComparingOperator): ClockConstraint{
	result.bound := _timeValue;
	result.clock := self.map TransitionDeadline2CoordinatorDeadlineClock(clockName);
	result.operator:= compareOperator;
}


mapping Transition :: Schema2PositionKindSelector(context : OclAny, region : OclAny, identifier : EObject, _kind : PositionSelectorKind, _successor : PositionSelectorKind) : PositionSelector{
	
		kind := _kind;
		
		successor := self.map Schema2PositionKindSelector(context,region,identifier,_successor);
}

mapping Transition :: Schema2PositionKindSelector(context : OclAny, region : OclAny, identifier : EObject, _kind : PositionSelectorKind) : PositionSelector{
	
		kind := _kind;
}
	
	--Transfer Schemata Guards, Clock Constraints, CLock Resets
	
mapping Transition :: TransferSchemataLogicalExpression( context:EObject, position:PositionSelectorKind, compOperator : ComparingOperator) : ComparisonExpression {
				
		rightExpression := self.map TransferSchemataEndpointReference(result, position);
		
		leftExpression := self.map TransferSchemataEndpointReference(result, PositionSelectorKind::SELF);
				
		operator := compOperator;
				
	}
	


	

	
mapping Transition :: TransferSchemataTimeValue(context:OclAny, region:RealtimeStatechart, val:Expression, timeUnit:TimeUnit) : TimeValue {

		value := val;
		
		unit := timeUnit;
		
	}
	
----------------------------------------------------XXXXXXXXXXXXXXXX--MAPPINGS FOR ALL TRANSFER SCHEMATA--XXXXXXXXXXXXXXXXXX--------------------------------------------
	
--Transfer Schemata State
mapping Transition :: RegionState(context:OclAny, region:RealtimeStatechart, StateName:String, ini:Boolean) : State {
		
		name := StateName;
		
		initial := ini;
		
	}
	
--Transfer Schemata Guard
mapping Transition :: TransferSchemaConditionAndPossibleGuard(context1:OclAny, context2:OclAny, region:RealtimeStatechart, varName:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			leftExpression := self.map TransferSchemaNotCondition(context2, region, transMapping);
		}else{
			if(not self.raiseMessageEvent.oclIsUndefined()){
				leftExpression := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(result);
			}else{
				leftExpression := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(result);
			}endif;
			
		}endif;
		
		rightExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName));
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaNotVarAndVarGuard(context:OclAny, region:RealtimeStatechart, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			leftExpression := self.map TransferSchemaGuard(result, varName1, notOp);
		}else{
			leftExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName1));
		}endif;
		
		rightExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName2));
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaGuardAndPossibleGuard(context1:OclAny, context2:OclAny, region:RealtimeStatechart, varName:String, transMapping: Integer) : LogicalExpression {
		
		leftExpression := self.guard.map Expression2Expression(context2);
		
		rightExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName));
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaGuardAndNotPossibleGuard(context1:OclAny, context2:OclAny, region:RealtimeStatechart, varName:String, transMapping: Integer) : LogicalExpression {
		
		leftExpression := self.guard.map Expression2Expression(context2);
		
		rightExpression := self.map TransferSchemaGuard(result, varName, true);
		
		operator := LogicOperator::AND;
	
	}
	
mapping Transition :: TransferSchemaSingleSendAndPossibleGuard(context1:OclAny, context2:OclAny, region:RealtimeStatechart, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			leftExpression := self.map TransferSchemaGuard(result, varName1, true);
		}else{
			leftExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName1));
		}endif;
		
		rightExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName2));
		
		operator := LogicOperator::AND;
}

mapping Transition :: TransferSchemaErrorOrNotPossibleGuard(context1:OclAny, region:RealtimeStatechart, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		if(notOp){
			rightExpression := self.map TransferSchemaGuard(result, varName2, true);
		}else{
			rightExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName2));
		}endif;
		
		leftExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName1));
		
		operator := LogicOperator::OR;
}

mapping Transition :: TransferSchemaThreeVariablesGuard(context1:OclAny, context2:OclAny, region:RealtimeStatechart, varName1:String, varName2:String, notOp:Boolean, transMapping: Integer) : LogicalExpression {
		
		rightExpression := self.map TransferSchemaSingleSendAndPossibleGuard(context1, context2, region, varName1, varName2, true, transMapping);
		
		leftExpression := self.guard.map Expression2Expression(context2);
		
		operator := LogicOperator::AND;
}
	
mapping Transition :: TransferSchemaNotCondition(context:OclAny, region:RealtimeStatechart, transMapping: Integer) : UnaryExpression {

		if(not self.raiseMessageEvent.oclIsUndefined()){
			enclosedExpression := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context);
		}else{
			enclosedExpression := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context);
		}endif;	

		operator := UnaryOperator::NOT;
	
	}
	
mapping Transition :: TransferSchemaGuard(context:OclAny, varName:String, op:Boolean) : UnaryExpression {

		enclosedExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName));
		
		if(op){
			operator := UnaryOperator::NOT;
		}endif
	
	}
	

	
// @author: sthiele2
mapping Transition :: Schema2CoordinatorIntermediateState(context:OclAny, region:RealtimeStatechart, intermediateStateNumber : Integer, clockName : String,toplevel : Boolean) : State
{
	// use a counter for unique intermediate state names
	intermediateStateCount := intermediateStateCount + 1;
	
	// creates an intermediate state in the coordinator region
	if(not self.relativeDeadline.oclIsUndefined())
	{
		invariants += self.map RelativeDeadline2ClockConstraint(intermediateStateNumber,region, false, ComparingOperator::LESS_OR_EQUAL, clockName);
	}endif;
	result.parentStatechart := self.statechart.map RTSC2CoordinatorRTSC(context, toplevel);	
	result.name := self.source.name + "_Intermediate_"+ intermediateStateNumber.toString()+ "_" + self.target.name + "_" + intermediateStateCount.toString();
}




--Transfer Schemata Action

mapping Transition :: TransferSchemata2Action(context:OclAny, actionName:String, varName:String, assignValue:String, transMapping:Integer) : Action {
	
		name := actionName;
		
		result.expressions += self.map TransferSchemata2Block(context, varName, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2Block(context:OclAny, varName:String, assignValue:String, transMapping:Integer) : Block {
		
		result.expressions += self.map TransferSchemata2Assignment(context, varName, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActions(context:OclAny, actionName:String, varName1:String, varName2:String, assignValue:String, transMapping:Integer) : Action {
	
		name := actionName;
		
		result.expressions += self.map TransferSchemata2TwoActionsBlock(context, varName1, varName2, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActionsBlock(context:OclAny, varName1:String, varName2:String, assignValue:String, transMapping:Integer) : Block {
		
		result.expressions += self.map TransferSchemata2Assignment(context, varName1, assignValue, 20+transMapping);
		result.expressions += self.map TransferSchemata2Assignment(context, varName2, assignValue, 21+transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActionsTransAct(context:OclAny, actionName:String, varName:String, assignValue:String, transMapping:Integer) : Action {
	
		name := actionName + ', ' + self.action.name;
		
		result.expressions += self.map TransferSchemata2TwoActionsTransActBlock(context, varName, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2TwoActionsTransActBlock(context:OclAny, varName1:String, assignValue:String, transMapping:Integer) : Block {
		
		result.expressions += self.map TransferSchemata2Assignment(context, varName1, assignValue, 20+transMapping);
		
		if(self.action.expressions->first().oclIsTypeOf(Block)){
			result.expressions += self.action.expressions.oclAsType(Block).expressions.map Expression2Expression(context);
		}else{
			result.expressions += self.action.expressions.map Expression2Expression(context);
		}endif;
			
	}
	
mapping Transition :: TransferSchemata2Assignment(context:OclAny, varName:String, assignValue:String, transMapping:Integer) : Assignment {
		
		lhs_typedNamedElementExpression := self.map Schema2TypedNamedElementExpression(result,self.map Transition2SubroleSpecificBooleanVaribale(varName));
		
		assignOperator := AssignOperator::ASSIGN;
		
		rhs_assignExpression := self.map TransferSchemata2Literal(context, assignValue, transMapping);
		
	}
	
mapping Transition :: TransferSchemata2Literal(context:OclAny, assignValue:String, transMapping:Integer) : LiteralExpression {
		
		value := assignValue;		
		
	}

--Transfer Schemata Synchronization



mapping Transition :: TransferSchemata2Synchronization(rtsc : RealtimeStatechart,identifier : EObject,  channelName : String, syncKind : SynchronizationKind) : Synchronization{

	kind := syncKind;
	syncChannel := _rtsc.map TransferSchemataChannel( channelName, false,self);
}

mapping Transition :: TransferSchemata2Synchronization(context : RealtimeStatechart,identifier : EObject, channelName : String,   syncKind : SynchronizationKind, selectorKind : PositionSelectorKind) : Synchronization{
	
	kind := syncKind;
	syncChannel := context.map TransferSchemataChannel(channelName,true, self);
	selectorExpression := self.map Schema2PositionKindSelector(result,result,result, selectorKind);
}
mapping Transition :: TransferSchemata2Synchronization(context : RealtimeStatechart,identifier : EObject, channelName : String,   syncKind : SynchronizationKind, selectorKind : PositionSelectorKind, successorKind : PositionSelectorKind) : Synchronization{
	
	kind := syncKind;
	syncChannel := context.map TransferSchemataChannel(channelName,true, self);
	selectorExpression := self.map Schema2PositionKindSelector(result,result,result, selectorKind, successorKind);
}
	//dict->hasKey(transition);
	//dict->get(transition);
	//dict->put(transition,1);
	//if(dict->hasKey(transition))
	// dict-> 
property usedChannelNames : Dict(String,Integer); // stores how often a channel with a certain name exists. Used for enumerating the channel names in case of multiple occurences of the same schema
mapping RealtimeStatechart :: TransferSchemataChannel(channelName: String, selector: Boolean, schemaTransition : Transition ) : SynchronizationChannel {
		
		if(usedChannelNames->hasKey(channelName))
		{
			var nr : Integer := usedChannelNames->get(channelName);
			usedChannelNames->put(channelName,nr +1);
			name := channelName + (nr+1).toString();
			
		}
		else
		{
			name := channelName + 1.toString();
			usedChannelNames->put(channelName,1);	
		};		
		state := self.map Rtsc2InitialState();
		
		if(selector){
			assert fatal (self.behavioralElement.oclIsKindOf(Role) or self.behavioralElement.oclIsKindOf(muml::component::DiscretePort)) with log ("behavorial Element must be DiscretePort or Role!");
			selectorType := self.behavioralElement.oclAsType(DataType);			
		}endif;		
						
	}


mapping Vertex :: Vertex2VertexCoordinator(context:OclAny, region:RealtimeStatechart) : Vertex
		disjuncts State::States2StatesCoordinator, StateConnectionPoint::StateConnectionPoint2StateConnectionPointCoordinator;
		




mapping RealtimeStatechart :: Rtsc2InitialState() : State {
		
		name := "Main";
		
		initial := true;
		
		embeddedRegions += self->map State2CoordinatorRegion(self);
		
		embeddedRegions += self.map State2SubroleRegion(self);
					
	}
	
mapping Transition :: RTSC2SubroleSchemaRTSC(sourceRealtimeStatechart:RealtimeStatechart) : RealtimeStatechart {
		assert fatal (false) with log ("Do not go here!");	
}


mapping RealtimeStatechart :: State2CoordinatorRegion(context:RealtimeStatechart) : Region {
		
		priority := 2;
		
		//parentState := context.oclAsType(State);
		
		embeddedStatechart := self.map RTSC2CoordinatorRTSC(context,true); 
}
	
mapping RealtimeStatechart :: State2SubroleRegion(context:OclAny) : Region {
		
		priority := 1;
		
	//	parentState := context.oclAsType(State);
		
		embeddedStatechart := self.map RTSC2SubroleRTSC();					
	}	
	
mapping RealtimeStatechart :: RTSC2SubroleRTSC() : RealtimeStatechart {

		assert fatal (false) with log ("Do not go here!");	
}	

mapping State :: States2StatesCoordinator(context:OclAny, region:RealtimeStatechart) : State{
	
	assert fatal (false) with log ("Do not go here!");
}
	
mapping RealtimeStatechart :: RTSC2CoordinatorRTSC(context:OclAny, highlevel: Boolean) : RealtimeStatechart {

		assert fatal (false) with log ("Do not go here!");
}

mapping RealtimeStatechart :: RTSC2CoordinatorRTSC(context:OclAny, region:RealtimeStatechart) : RealtimeStatechart {

		assert fatal (false) with log ("Do not go here!");
}


	
-- to coordinator
mapping Transition :: Transition2TransitionCoordinator(context:OclAny, region:RealtimeStatechart) : Transition {
		
		source := self.source.oclAsType(State).map Vertex2VertexCoordinator(context, region);
		target := self.target.oclAsType(State).map Vertex2VertexCoordinator(context, region);
		
		priority := self.priority;
		
		clockResets := self.clockResets->select(c|not isClockSubRoleSpecific(c))->map Clock2Clock();
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(context, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		action := self.action.map Action2Action(context, region);
		
		synchronization := self.synchronization.map Synchronization2Synchronization(context,region);
		
		absoluteDeadlines := self.absoluteDeadlines->map AbsoluteDeadline2AbsoluteDeadline(context, region);
		
		relativeDeadline := self.relativeDeadline.map RelativeDeadline2RelativeDeadline(context, region);
		
		blockable := self.blockable;
		
		urgent := self.urgent;
						
	}
	
	mapping Transition :: Transition2TransitionSubrole(context:OclAny, region:RealtimeStatechart, toplevel : Boolean) : Transition {
		
		source := self.map Transition2StateSubrole(region,self.source, true);

		target := self.map TransitionNoMessage2TransitionRecSyncSubrole(context, region, toplevel);
		
		priority := self.priority;
		
		clockResets := self.clockResets->select(c|isClockSubRoleSpecific(c))->map Clock2Clock();
		
		clockConstraints := self.clockConstraints->map ClockConstraint2ClockConstraint(1, region);
		
		guard := self.guard.map Expression2Expression(1);
		synchronization := self.map TransferSchemata2Synchronization(context.oclAsType(RealtimeStatechart),result,  "switchState",SynchronizationKind::RECEIVE  ,PositionSelectorKind::SELF);
		
		
	}
	
mapping Transition :: Transition2StateSubrole(inout containerRegion : RealtimeStatechart, state:Vertex,_initial: Boolean): State {
		
		name := state.name;
		
		result.initial := _initial;
		
		containerRegion.states += result;	
		
		
}
mapping Transition :: Transition2TransitionNotLastSubrole(context:OclAny, region:RealtimeStatechart,toplevel : Boolean) : Transition {
		
		source := self.map TransitionNoMessage2TransitionRecSyncSubrole(context, region, toplevel);
		
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		priority := 2;
		
		guard := self.map TransferSchemataLogicalExpression(result, PositionSelectorKind::LAST, ComparingOperator::UNEQUAL);
		
		synchronization := self.map TransferSchemata2Synchronization(context.oclAsType(RealtimeStatechart),result,  "switchState",SynchronizationKind::SEND  ,PositionSelectorKind::SELF,PositionSelectorKind::NEXT);
		
		
	}
	
mapping Transition :: Transition2TransitionLastSubrole(context:OclAny, region:RealtimeStatechart,toplevel : Boolean) : Transition {
		
		source := self.map TransitionNoMessage2TransitionRecSyncSubrole(context, region, toplevel);
		target := self.map Transition2StateSubrole(region,self.target, false);
		
		priority := 1;
		
		guard := self.map TransferSchemataLogicalExpression(result,PositionSelectorKind::LAST, ComparingOperator::EQUAL);
		
	}
	
mapping Transition :: TransitionNoMessage2TransitionRecSyncSubrole(context:OclAny, region:RealtimeStatechart,toplevel : Boolean) : State {
		
		name := self.source.name + "_" + self.target.name + "_" + self.priority.toString() +"_SwitchState";
	
		parentStatechart := self.RTSC2SubroleSchemaRTSC(context.oclAsType(RealtimeStatechart));
		
	}
	
mapping Expression :: Expression2UnaryExpression(context : OclAny, _operator : UnaryOperator) : UnaryExpression{
		
		result.operator := _operator;
		
		result.enclosedExpression := self.map Expression2Expression(context);
}	


mapping Transition :: Transition2Block(blockExpressions : Set(Expression)) : Block {
	result.expressions+=blockExpressions;
}

mapping Transition :: Transition2Block(blockExpression : Expression) : Block{
	init{
		result := self.map Transition2Block(Set{blockExpression});
	}
}
mapping Transition:: Transition2ComparisonExpression(context : OclAny, comparingoperator : ComparingOperator,lhs:Expression, rhs:Expression): core::expressions::common::ComparisonExpression{
	result.leftExpression := lhs;
	result.rightExpression :=rhs;
	result.operator := comparingoperator;	
}

mapping Transition:: Transition2LogicalExpression(context : OclAny, logicoperator : LogicOperator, lhs:Expression, rhs:Expression): core::expressions::common::LogicalExpression{
	result.leftExpression := lhs;
	result.rightExpression :=rhs;
	result.operator := logicoperator;
}



----------------------------------------------** new transformations that should replace the old ones ** 
mapping Transition :: TransferSchemataEndpointReference(identifier : EObject, positionSelectorKind: PositionSelectorKind, referencedTypedNamedElement : TypedNamedElement) : DiscreteInteractionEndpointReference {
	position := self.map Schema2PositionKindSelector(result,result,identifier, positionSelectorKind);
	typedNamedElementExpression := self.map Schema2TypedNamedElementExpression(result,referencedTypedNamedElement);
}

mapping Transition :: TransferSchemataEndpointReference(identifier : EObject, positionSelectorKind: PositionSelectorKind) : DiscreteInteractionEndpointReference {
	position := self.map Schema2PositionKindSelector(result,result,identifier, positionSelectorKind);	
}


mapping Transition :: Schema2TypedNamedElementAssignmentExpression(context : OclAny,operator : AssignOperator, referencedElement : TypedNamedElement, assignedExpression : Expression) : actionlanguage::Assignment{

	result.lhs_typedNamedElementExpression := self.map Schema2TypedNamedElementExpression(result,referencedElement);
	result.rhs_assignExpression := assignedExpression;
	result.assignOperator := operator;
}



mapping Transition :: Schema2LiteralExpression(context : OclAny, _value : String) : core::expressions::common::LiteralExpression{
	value := _value;
	
}

mapping Transition :: Schema2TypedNamedElementExpression(context : OclAny,referencedElement : TypedNamedElement) : TypedNamedElementExpression{
	
	typedNamedElement := referencedElement;
}

mapping Transition :: Schema2Variable(_name : String, _type : DataType) : Variable{
	result.name := _name;
	result.dataType := _type;
}
