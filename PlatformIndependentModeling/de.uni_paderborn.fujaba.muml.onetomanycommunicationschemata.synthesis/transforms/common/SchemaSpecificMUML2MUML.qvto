library SchemaSpecificMUML2MUML;
import ModelcopyLibrary;

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');


helper  isClockSubRoleSpecific(c : Clock): Boolean
{
	
}
helper isVariableSubRoleSpecific(v : Variable): Boolean
{
	
}
helper isOperationSubRoleSpecific(o : Operation): Boolean
{
	
}

property internalVariables			: Set(Variable);
property internalOperations			: Set(Operation);
property internalClocks				: Set(Clock);
property internalSynchronizations	: Set(SynchronizationChannel);

// helpers that are needed to deepCopy Elements. In order to simplify the helpers, they use internally the MUML2MUML library. 
// When a Variable is acces
// It is not possible to use self.deepclone() since references to other elements should reference the mapped elements instead of the original values, as it is done in deepClone()


	mapping TypedNamedElement :: transform() : EObject disjuncts 
		Variable::transform,
		Parameter::transform,
		TypedNamedElement::failOnUnsupportedTypedNamedElement;
	
	mapping TypedNamedElement::failOnUnsupportedTypedNamedElement() : EObject {
		
		init {
			assert fatal (false) with log("The TypedNamedElement "+self.toString()+" is unsupported.")
		}
	}
	
	
	mapping actionlanguage::TriggerMessageExpression :: transform() : EObject {
		init {
			result := self.map create();
		}
		var element := self.oclAsType(TriggerMessageExpression);
		var resultingElement : TriggerMessageExpression := result.oclAsType(TriggerMessageExpression);
		resultingElement.messageType := self.messageType;
		resultingElement.parameter := self.parameter;
		
		resultingElement.annotation := self._annotation.map transform().oclAsType(EAnnotation);
	    resultingElement._extension := self._extension.map transform().oclAsType(Extension);
	    	
		element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
			setValues(result, f, getValues(element, f));
		};
	}

	mapping actionLanguage::NondeterministicChoiceExpression ::transform() : EObject {
		init {
			result := self.map create();
		}
		var element := self.oclAsType(actionLanguage::NondeterministicChoiceExpression);
		var resultingElement : actionLanguage::NondeterministicChoiceExpression := result.oclAsType(actionLanguage::NondeterministicChoiceExpression);
		resultingElement.range := self.range.map transform().oclAsType(Range);
		resultingElement.dataType := self.dataType;
		
		resultingElement.annotation := self._annotation.map transform().oclAsType(EAnnotation);
	    resultingElement._extension := self._extension.map transform().oclAsType(Extension);
	    	
		element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
			setValues(result, f, getValues(element, f));
		};	
	}
	
-- variables, operations, parametes...



	mapping Variable :: transform() : EObject {
		init {
			if(internalVariables->includes(self)){
				result := self.map create();
				
				var resultingElement : behavior::Variable := result.oclAsType(behavior::Variable);
		
				resultingElement.dataType := self.dataType;
				resultingElement.initializeExpression := self.initializeExpression.map multiTransform().oclAsType(Expression);
				resultingElement.annotation := self._annotation.map transform().oclAsType(EAnnotation);
			    resultingElement._extension := self._extension.map transform().oclAsType(Extension);
				
				var element := self.oclAsType(behavior::Variable);	    	
				element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
					setValues(result, f, getValues(element, f));
				};		
			}
			else {
				result := self;
			}			
		}			
	}	

		mapping Operation :: transform() : EObject {
		init {
			if(internalOperations->includes(self)){
				result := self.map create();
				
				var resultingElement : behavior::Operation := result.oclAsType(behavior::Operation);
		
				resultingElement.returnType := self.returnType;
				
				resultingElement.implementations := self.implementations->map transform().oclAsType(Expression);
				resultingElement.annotation := self._annotation.map transform().oclAsType(EAnnotation);
			    resultingElement._extension := self._extension.map transform().oclAsType(Extension);
			    resultingElement.parameters := self.parameters -> map transform().oclAsType(Parameter);
			    
			    var element := self.oclAsType(behavior::Operation);			    	
				element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
					setValues(result, f, getValues(element, f));
				};		
			}
			else {
				result := self;
			}			
		}			
	}

	mapping Parameter :: transform() : EObject {
		init{
			result := self.map create ();			
		}
		
		var resultingElement : Parameter := result.oclAsType(Parameter);
		resultingElement.dataType := self.dataType;
		
		var element := self.oclAsType(behavior::Operation);			    	
			element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
				setValues(result, f, getValues(element, f));
		};
		
	}

		-- synchronizations
	mapping SynchronizationChannel :: transform() : EObject {
		init {
			if(internalSynchronizations->includes(self)){
				result := self.map create();
				
				var resultingElement : SynchronizationChannel := result.oclAsType(SynchronizationChannel);
		
		
				resultingElement.annotation := self._annotation.map transform().oclAsType(EAnnotation);
			    resultingElement._extension := self._extension.map transform().oclAsType(Extension);
				resultingElement.selectorType := self.selectorType;
				resultingElement.state := self.state.map transform().oclAsType(State);
			    
			    var element := self.oclAsType(SynchronizationChannel);			    	
				element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
					setValues(result, f, getValues(element, f));
				};		
			}
			else {
				result := self;
			}			
		}		
	}
	
	-- Clocks	
	
	mapping Clock :: transform() : EObject {
		init {
			if(internalClocks->includes(self)){
				result := self.map create();
				
				var resultingElement : Clock := result.oclAsType(Clock);		
		
				resultingElement.annotation := self._annotation.map transform().oclAsType(EAnnotation);
			    resultingElement._extension := self._extension.map transform().oclAsType(Extension);
			 	resultingElement.statechart := self.statechart.map transform().oclAsType(RealtimeStatechart);
			    
			    var element := self.oclAsType(Clock);			    	
				element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
					setValues(result, f, getValues(element, f));
				};		
			}
			else {
				result := self;
			}			
		}		
	}

	mapping muml::realtimestatechart::AsynchronousMessageEvent :: transform() : EObject {
		init {
			result := self.map create();
		}
		
		var resultingElement : AsynchronousMessageEvent := result.oclAsType(AsynchronousMessageEvent);
		resultingElement.message := self.message.map transform().oclAsType(Message);
		
		var element := self.oclAsType(Clock);			    	
		element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
			setValues(result, f, getValues(element, f));
		};			
	}
	
	mapping muml::realtimestatechart::Message :: transform() : EObject {
		init {
			result := self.map create();
		}
		
		var resultingElement : Message := result.oclAsType(Message);
		resultingElement.annotation := self._annotation.map transform().oclAsType(EAnnotation);
		resultingElement._extension := self._extension.map transform().oclAsType(Extension);
		resultingElement.instanceOf := self.instanceOf;
		resultingElement.parameterBinding := self.parameterBinding.map transform().oclAsType(ParameterBinding);
		
		var element := self.oclAsType(Clock);			    	
		element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
			setValues(result, f, getValues(element, f));
		};	
	}