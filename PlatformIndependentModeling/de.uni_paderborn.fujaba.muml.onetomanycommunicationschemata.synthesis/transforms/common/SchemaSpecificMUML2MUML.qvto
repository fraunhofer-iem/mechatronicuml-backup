library SchemaSpecificMUML2MUML;
import MUML2MUMLContext;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');


helper  isClockSubRoleSpecific(c : Clock): Boolean
{
	
}
helper isVariableSubRoleSpecific(v : Variable): Boolean
{
	
}
helper isOperationSubRoleSpecific(o : Operation): Boolean
{
	
}

property internalVariables			: Set(Variable);
property internalOperations			: Set(Operation);
property internalClocks				: Set(Clock);
property internalSynchronizations	: Set(SynchronizationChannel);

// helpers that are needed to deepCopy Elements. In order to simplify the helpers, they use internally the MUML2MUML library. 
// When a Variable is acces
// It is not possible to use self.deepclone() since references to other elements should reference the mapped elements instead of the original values, as it is done in deepClone()

property counter : Integer = 1;

helper Expression :: cloneExpression() : Expression {
	counter := counter +1;
	return self.map Expression2Expression(counter);
}

helper Action :: cloneAction() : Action {
	counter := counter + 1;
	return self.map Action2Action(counter);
}

helper DoEvent :: cloneDoEvent() : DoEvent {
	counter := counter + 1;
	return self.map DoEvent2DoEvent(counter);
}

helper AsynchronousMessageEvent :: cloneAsynchronousMessageEvent() : AsynchronousMessageEvent{
	counter := counter +1;
	return self.map AsynchronousMessageEvent2AsynchronousMessageEvent(counter);
	
}

helper ClockConstraint :: cloneClockConstraint() : ClockConstraint {
	counter := counter + 1; 
	return self.map ClockConstraint2ClockConstraint(counter);
}
	-- expressions

		
mapping Expression :: failOnUnsupportedExpression(context:OclAny) : Expression {
	init {
		assert fatal (false) with log('Unsupported expression type.')
	}
}	
			
		
mapping UnaryExpression :: Unary2Unary(context:OclAny) : UnaryExpression {
			
	enclosedExpression := self.enclosedExpression.map Expression2Expression(context);
	
	operator := self.operator;
			
}	
	
	
	mapping actionlanguage::TypedNamedElementExpression :: TypedNamedElementExpression2TypedNamedElementExpression(context : OclAny) : actionlanguage::TypedNamedElementExpression{
    	_comment := self._comment;
    	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
    	_extension := self._extension.map Extension2Extension(context);
    	_typedNamedElement := self._typedNamedElement.map TypedNamedElement2TypedNamedElement();
    	_elementAccessors := self._elementAccessors.map ElementAccessorExpression2ElementAccessorExpression(context);
   		 }
		
	mapping TypedNamedElement:: TypedNamedElement2TypedNamedElement() : TypedNamedElement {
		init {
			result := null;
			if(self.oclIsTypeOf(muml::behavior::Variable)){
				result :=  self.oclAsType(muml::behavior::Variable).map Variable2Variable();
			};
			if(self.oclIsTypeOf(muml::behavior::Parameter)){
				result :=  self.oclAsType(muml::behavior::Parameter).map Parameter2Parameter();
			};
			
			assert fatal (not (result = null)) with log ("Error: The result may not be null! Probably an additional type check is necessary!");
			
		}
	}

	mapping actionlanguage::OperationCall :: OperationCall2OperationCall(context : OclAny) : actionlanguage::OperationCall{
	    	_comment := self._comment;
	    	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
	    	_extension := self._extension.map Extension2Extension(context);
	    	_operation := self._operation.map Operation2Operation();
	    	_parameterBinding := self._parameterBinding.map ParameterBinding2ParameterBinding(context);
	   		 }


	mapping actionlanguage::TriggerMessageExpression :: TriggerMessageExpression2TriggerMessageExpression(context : OclAny) : actionlanguage::TriggerMessageExpression{
	    	_comment := self._comment;
	    	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
	    	_extension := self._extension.map Extension2Extension(context);
	    	_messageType := self._messageType;
	    	_parameter := self._parameter;
	   		 }

	mapping actionlanguage::LocalVariableDeclarationStatement :: LocalVariableDeclarationStatement2LocalVariableDeclarationStatement(context : OclAny) : actionlanguage::LocalVariableDeclarationStatement{
	    	_comment := self._comment;
	    	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
	    	_extension := self._extension.map Extension2Extension(context);
	    	_variable := self._variable.map Variable2Variable();
	   		 }
	   		 
	mapping actionlanguage::NondeterministicChoiceExpression :: NondeterministicChoiceExpression2NondeterministicChoiceExpression(context : OclAny) : actionlanguage::NondeterministicChoiceExpression{
	    	_comment := self._comment;
	    	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
	    	_extension := self._extension.map Extension2Extension(context);
	    	_range := self._range.map Range2Range(context);
	    	_dataType := self._dataType;
	   		 }

	
-- variables, operations, parametes... 

	abstract mapping TypedNamedElement :: BasicTypedNamedElement2TypedNamedElement() : TypedNamedElement {
		name := self.name;
		dataType := self.dataType;		
	}
	
	mapping Variable :: Variable2Variable() : Variable inherits TypedNamedElement::BasicTypedNamedElement2TypedNamedElement {
		init{
			if(internalVariables->includes(self))
			{
				result := new Variable();
				result.initializeExpression := self.initializeExpression.map Expression2Expression("INPUT");
				result.constant := self.constant;

			}
			else
			{
				result := self;
			}			
		}
	};
		
		
		
mapping muml::behavior::ParameterBinding :: ParameterBinding2ParameterBinding(context : OclAny) : muml::behavior::ParameterBinding{
	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
	_extension := self._extension.map Extension2Extension(context);
	_parameter := self._parameter.map Parameter2Parameter();
	_value := self._value.map Expression2Expression(context);
	 }
	

	
mapping Operation :: Operation2Operation() : Operation {
		init{
			if(internalOperations->includes(self))
			{
				result := new Operation();
				result.name := self.name;
				result.returnType := self.returnType;
				result.implementations := self.implementations->cloneExpression();
				result.parameters := self.parameters->map Parameter2Parameter();
			}
			else
			{
				result := self;
			}
		}			
	}			
	

	mapping muml::behavior::Parameter :: Parameter2Parameter() : muml::behavior::Parameter{
	    	counter := counter +1;
	    	_name := self._name;
	    	_comment := self._comment;
	    	_annotation := self._annotation.map EAnnotation2EAnnotation(counter);
	    	_extension := self._extension.map Extension2Extension(counter);
	    	_dataType := self.dataType;
	   		 }	

		-- synchronizations
	
mapping SynchronizationChannel :: SyncChannel2SyncChannel(context:OclAny) : SynchronizationChannel {		
		init{
			if(internalSynchronizations->includes(self))
			{
				result := new SynchronizationChannel();
				result.name := self.name;							
				result.selectorType := self.selectorType;		
			}
			else
			{
				result := self;
			}
		}		
	}



	
	-- Clocks	
mapping Clock :: Clock2Clock() : Clock {
		init{
			if(internalClocks->includes(self))
			{
				result := new Clock();
				result.name := self.name;	
			}
			else
			{
				result := self;
			}		
		}		
	}
	mapping muml::realtimestatechart::ClockConstraint :: ClockConstraint2ClockConstraint(context : OclAny) : muml::realtimestatechart::ClockConstraint{
	    	_operator := self._operator;
	    	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
	    	_extension := self._extension.map Extension2Extension(context);
	    	_bound := self._bound.map TimeValue2TimeValue(context);
	    	_clock := self._clock.map Clock2Clock();
	   		 }	

mapping AbsoluteDeadline :: AbsoluteDeadline2AbsoluteDeadline(context:OclAny) : AbsoluteDeadline {		
		upperBound := self.upperBound.map TimeValue2TimeValue(context);
		lowerBound := self.lowerBound.map TimeValue2TimeValue(context);		
		clock := self.clock.map Clock2Clock();		
	}

mapping EntryEvent :: EntryEvent2EntryEventCoordinator(context:OclAny, region:RealtimeStatechart) : EntryEvent {
		
		clockResets += self.clockResets.map Clock2Clock();
		
		action := self.action.map Action2Action(context);
					
	}
	
mapping ExitEvent :: ExitEvent2ExitEventCoordinator(context:OclAny, region:RealtimeStatechart) : ExitEvent {
		
		clockResets += self.clockResets.map Clock2Clock();
		
		action := self.action.map Action2Action(context);
					
	}
	
mapping EntryEvent :: EntryEvent2EntryEventSubrole(context:OclAny, region:RealtimeStatechart) : EntryEvent {
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		kind := self.kind;
					
	}
	

mapping ExitEvent :: ExitEvent2ExitEventSubrole(context:OclAny, region:RealtimeStatechart) : ExitEvent {
		
		clockResets += self.clockResets->select(c|isClockSubRoleSpecific(c)).map Clock2Clock();
		
		kind := self.kind;
					
	}
	

	


mapping AsynchronousMessageEvent :: AsynchronousMessageEvent2AsynchronousMessageEvent(context:OclAny) : AsynchronousMessageEvent {
		
		kind := self.kind;
		
		message := self.message.map Message2Message(context);
		
	}
	

mapping muml::realtimestatechart::Message :: Message2Message(context : OclAny) : muml::realtimestatechart::Message{
    	_annotation := self._annotation.map EAnnotation2EAnnotation(context);
    	_extension := self._extension.map Extension2Extension(context);
    	_instanceOf := self._instanceOf;
    	_parameterBinding := self._parameterBinding.map ParameterBinding2ParameterBinding(context);
   		 }
	   		 

