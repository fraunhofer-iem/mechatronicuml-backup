library IterateSchema;
import AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype modelinstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');
	
----------------------------------------------------------XXXXXXXXXXXXXXXXX--ITERATE--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

--------------------------------------------------------------Transfer Schema Iterate of Coordinator----------------------------------------------------------------------

property IterateDelayTimeClockName : String = "Clock_IterateDelay";

mapping Transition :: Iterate2TransitionFromSourceToIntermediate() : Transition
{
	
	source := self.source;
	
	target := self.map Schema2IntermediateState(1);
	
	clockConstraints := self.clockConstraints;
	
	guard := self.guard;
	
	
}

mapping Transition :: Iterate2TransitionFromIntermediateToTarget() : Transition{
	
	source := self.map Schema2IntermediateState(1);
	
	clockResets := self.clockResets;
	
	action := self.action;
	
	
}
mapping Transition :: Iterate2SelfTransitionOfIntermediate() : Transition {
	
		
}



// @author: sthiele2 -- creates an intermediate state in the input Realtimestatechart. This is necessary in case of schemata that can be
// transformed expressed by other schematas. 

mapping  Transition :: Schema2IntermediateState(stateID : Integer) : State {
	
		name := self.source.name + "_Intermediate_"+ stateID.toString()+ "_" + self.target.name  ;
				
		parentStatechart := self.statechart;		
		
		entryEvent := new EntryEvent();
	
		result.entryEvent.kind := EventKind::RAISE;
	
		result.entryEvent.clockResets+= self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDelayTimeClockName);
	
		// map the effects of the transition to the states exit effects	
		exitEvent := new ExitEvent();
	
		result.exitEvent.kind:= EventKind::RAISE;
	
		result.exitEvent.clockResets+=self.clockResets;
	
		result.exitEvent.action := self.action;		
		
		
	}
	

