library IterateSchema;
import AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype modelinstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');
	
// @author: sthiele2 -- Implementation of the Iterate-Schema that can be reduced to unicast schemas.

---------------------------------------------------------XXXXXXXXXXXXXXXXX--ITERATE--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

--------------------------------------------------------------Transfer Schema Iterate of Coordinator----------------------------------------------------------------------

property IterateDelayTimeClockName : String = "Clock_IterateDelay";
property IterateDLC_ClockName : String = "Iterate_DLC";
property iterateRoleVariableName : String = "curRole";

helper Transition :: disassembleIterateSchema(){
		
	self.statechart.variables+= self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType());
	self.statechart.clocks += self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDLC_ClockName);
	if(self.iterateDefinesDelay()){
		rtsc.oclAsType(RealtimeStatechart).clocks += self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDelayTimeClockName);		
	};
	self.statechart.transitions+= self.map Iterate2TransitionFromSourceToIntermediate();
	self.statechart.transitions+= self.map Iterate2Transition1FromIntermediateToTarget();
	self.statechart.transitions+= self.map Iterate2Transition2FromIntermediateToTarget();
	self.statechart.transitions+= self.map Iterate2SelfTransitionOfIntermediate();
	
	self.statechart.states += self.map Schema2IntermediateState(1);
	
}

mapping Transition :: Iterate2TransitionFromSourceToIntermediate() : Transition
{
	priority := 1;
	
	source := self.source;
	
	target := self.map Schema2IntermediateState(1);
	
	// set the conditions
	clockConstraints := self.clockConstraints;
	
	guard := self.guard;	
	
	// set the entry events of the iterate source state
	var sourceState : State := source.oclAsType(State); 
	if(sourceState.entryEvent.oclIsUndefined()){
		sourceState.entryEvent := new EntryEvent();
	};
	sourceState.entryEvent.kind := EventKind::RAISE;
	sourceState.entryEvent.clockResets+= self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDLC_ClockName);
	
	if(sourceState.entryEvent.action.oclIsUndefined()){
		sourceState.entryEvent.action := new Action();	
		sourceState.entryEvent.action.name := "";	
	};
	sourceState.entryEvent.action.name := sourceState.entryEvent.action.name + "curRole := last";
	var variable : Variable := self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType());
	sourceState.entryEvent.action.expressions += self.map Transition2Block(self.map Schema2TypedNamedElementAssignmentExpression(sourceState,AssignOperator::ASSIGN,variable,self.map TransferSchemataEndpointReference(result, result,"last",1)));
	
	// create the condition for the unicast call!
			
	var firstunicastCondition : Expression  :=self.map Transition2ComparisonExpression(result, ComparingOperator::EQUAL,self.map Schema2TypedNamedElementExpression(result,variable),self.map TransferSchemataEndpointReference(result,result,"self",2));
	var secondunicastCondition := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(result);
	
	var unicastCondition : Expression;
	if(not secondunicastCondition.oclIsUndefined()){
		unicastCondition := self.map Transition2LogicalExpression(result,LogicOperator::AND,firstunicastCondition,secondunicastCondition);
	}else{
		unicastCondition := firstunicastCondition;
	}endif;
	
	events += self.raiseMessageEvent.oneToManyCommunicationSchema.map Schema2UnicastCall(result,unicastCondition,self.action.map Action2Action(result,1));
	
}


mapping OneToManyCommunicationSchema :: Schema2UnicastCall(context : OclAny, condition : Expression, action : Action): AsynchronousMessageEvent{	
	kind := EventKind::RAISE;
	message := self.asynchronousMessageEvent.message.map Message2Message(result);	
	oneToManyCommunicationSchema := self.map Schema2Unicast(context,condition,action);
}

mapping OneToManyCommunicationSchema ::Schema2Unicast(context : OclAny, _condition : Expression, _action : Action) : muml::realtimestatechart::one_to_n_schemata::Unicast{
	result.condition :=  _condition;
	result.action := _action;
}


query Transition :: getPortOrRoleAsDataType() : DataType{
	return self.statechart.getPortOrRoleStatechart().behavioralElement.oclAsType(muml::types::DataType);
}



mapping Transition :: Schema2TypedNamedElementAssignmentExpression(context : OclAny,operator : AssignOperator, referencedElement : TypedNamedElement, assignedExpression : Expression) : actionlanguage::Assignment{

	result.lhs_typedNamedElementExpression := self.map Schema2TypedNamedElementExpression(result,referencedElement);
	result.rhs_assignExpression := assignedExpression;
	result.assignOperator := operator;
}



mapping Transition :: Schema2LiteralExpression(context : OclAny, _value : String) : core::expressions::common::LiteralExpression{
	value := _value;
	
}

mapping Transition :: Schema2TypedNamedElementExpression(context : OclAny,referencedElement : TypedNamedElement) : TypedNamedElementExpression{
	
	typedNamedElement := referencedElement;
}

mapping Transition :: Schema2Variable(_name : String, _type : DataType) : Variable{
	result.name := _name;
	result.dataType := _type;
}

mapping Transition :: Iterate2Transition1FromIntermediateToTarget() : Transition{
	
	priority := 1;
	
	source := self.map Schema2IntermediateState(1);
	
	target := self.target;
	
	if(self.transitionDefinesRelativeDeadline()){
			clockConstraints+= self.map RelativeDeadline2ClockConstraint(result, result, false, ComparingOperator::LESS_OR_EQUAL, IterateDLC_ClockName);
		}endif;
	var lhs : Expression :=  self.map Schema2TypedNamedElementExpression(result,self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType()));
	var rhs : Expression := self.map Schema2PositionKindSelector(result,result,result,PositionSelectorKind::LAST);
	guard := self.map Transition2ComparisonExpression(result, ComparingOperator::EQUAL,lhs, rhs);
	
	action := self.action.map Action2Action(result,result);
	if(action.oclIsUndefined()){
		action := new Action();
		action.name :="";
	};
	action.name := action.name + iterateRoleVariableName + ":=" + PositionSelectorKind::FIRST.toString();
	action.expressions+= self.map Transition2Block(self.map Schema2TypedNamedElementAssignmentExpression(result,AssignOperator::ASSIGN, self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType()),rhs));
	
	clockResets := self.clockResets;
}

mapping Transition :: Iterate2Transition2FromIntermediateToTarget(): Transition{
	
	priority := 3;
	
	source := self.map Schema2IntermediateState(1);
	
	target := self.target;
	
	if(self.transitionDefinesRelativeDeadline()){
			clockConstraints+= self.map RelativeDeadline2ClockConstraint(result, result, false, ComparingOperator::LESS_OR_EQUAL, IterateDLC_ClockName);
		}endif;
	
	
	var rhs : Expression := self.map Schema2PositionKindSelector(result,result,result,PositionSelectorKind::FIRST);

	
	action := self.action.map Action2Action(result,result);
	
	guard := self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.map Expression2Expression(result);
	
	clockResets := self.clockResets;
	

}

mapping Transition :: Iterate2SelfTransitionOfIntermediate() : Transition {
	
	priority := 2;
	
	source := self.map Schema2IntermediateState(1);
	
	target := self.map Schema2IntermediateState(1);
	
	if(self.iterateDefinesDelay()){
		self.map Transition2ClockConstraint(result,IterateDelayTimeClockName,self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.map TimeValue2TimeValue(result,result));
	};
	
	var lhs : Expression :=  self.map Schema2TypedNamedElementExpression(result,self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType()));
	var rhs : Expression := self.map Schema2PositionKindSelector(result,result,result,PositionSelectorKind::LAST);
	guard := self.map Transition2ComparisonExpression(result, ComparingOperator::UNEQUAL,lhs, rhs);
	
	// create the condition for the unicast call!
	
	var variable : Variable := self.map Schema2Variable(iterateRoleVariableName, self.getPortOrRoleAsDataType());		
	
	var firstunicastCondition : Expression  :=self.map Transition2ComparisonExpression(result, ComparingOperator::EQUAL,self.map Schema2TypedNamedElementExpression(1,variable),self.map TransferSchemataEndpointReference(result,result,"self",2));
	
	var secondunicastCondition := self.raiseMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(result);
	
	var unicastCondition : Expression;
	if(not secondunicastCondition.oclIsUndefined()){
		unicastCondition := self.map Transition2LogicalExpression(result,LogicOperator::AND,firstunicastCondition,secondunicastCondition);
	}else{
		unicastCondition := firstunicastCondition;
	}endif;
	
	events += self.raiseMessageEvent.oneToManyCommunicationSchema.map Schema2UnicastCall(result,unicastCondition,self.action.map Action2Action(result,1));
	
	// create actions:
	var assRHS : Expression := self.map TransferSchemataEndpointReference(result, PositionSelectorKind::NEXT, variable);
	var assignment : Expression := self.map Schema2TypedNamedElementAssignmentExpression(2, AssignOperator::ASSIGN, variable, assRHS);
	
	
	action := new Action();
	action.name := iterateRoleVariableName +" := " +iterateRoleVariableName + ".next";
	action.expressions+= self.map Transition2Block(assignment);
}



mapping Transition :: TransferSchemataEndpointReference(identifier : EObject, positionSelectorKind: PositionSelectorKind, referencedTypedNamedElement : TypedNamedElement) : DiscreteInteractionEndpointReference {
	position := self.map Schema2PositionKindSelector(result,result,identifier, positionSelectorKind);
	typedNamedElementExpression := self.map Schema2TypedNamedElementExpression(result,referencedTypedNamedElement);
}

mapping Transition :: TransferSchemataEndpointReference(identifier : EObject, positionSelectorKind: PositionSelectorKind) : DiscreteInteractionEndpointReference {
		init{
			result := self.map TransferSchemataEndpointReference(identifier,positionSelectorKind,null);
		}	
}
	

query Transition :: iterateDefinesDelay(): Boolean{
		return not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.oclIsUndefined();
}

query Transition :: transitionDefinesRelativeDeadline(): Boolean{
		return not self.relativeDeadline.oclIsUndefined();
}

//creates an intermediate state in the input Realtimestatechart. This is necessary in case of schemata that can be
// transformed expressed by other schematas. 

mapping  Transition :: Schema2IntermediateState(stateID : Integer) : State {
	
		name := self.source.name + "_Intermediate_"+ stateID.toString()+ "_" + self.target.name  ;
				
		parentStatechart := self.statechart;		
		
		if(self.iterateDefinesDelay()){
			entryEvent := new EntryEvent();
			result.entryEvent.kind := EventKind::RAISE;
			result.entryEvent.clockResets+= self.map TransitionDeadline2CoordinatorDeadlineClock(IterateDelayTimeClockName);
		}endif;
	
		if(self.transitionDefinesRelativeDeadline())
		{
			invariants+=self.map RelativeDeadline2ClockConstraint(result, result, false, ComparingOperator::LESS_OR_EQUAL, IterateDLC_ClockName);
		}endif;
	}
	

