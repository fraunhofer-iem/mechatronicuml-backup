library UniReceive;
import AllSchemataMappings;
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype modelinstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');

----------------------------------------------------------XXXXXXXXXXXXXXXXX--SINGLE-RECEIVE--XXXXXXXXXXXXXXXXX-------------------------------------------------------------------------

--------------------------------------------------------------Transfer Schema SingleReceive of Coordinator------------------------------------------------------------------
	
mapping Transition :: SingleReceive2TransitionFromIntermediate2ToTarget(context:OclAny, region:OclAny) : Transition {
		// creates in the coordinator region the transition from the intermediate state 2 to the (mapped) target state of the schema transition
		priority := 1;
		
		source := self.map Schema2CoordinatorIntermediateState(context,region,2,singleReceiveDLCName );
		
		target := self.target.map Vertex2VertexCoordinator(context, region);
		
		clockResets += self.clockResets->select(c|not isClockSubRoleSpecific(c)).map Clock2Clock();
		
		action := self.action.map Action2Action(context, region);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "singleReceiveDone", false, 1);
			
	}

mapping Transition :: SingleReceive2SourceRegionCoordinator(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexCoordinator(context, region).oclAsType(State);
		
		embeddedStatechart := self.map SingleReceive2SourceEmbeddedRTSCCoordinator(context, region);
					
	}
	
mapping Transition :: SingleReceive2SourceEmbeddedRTSCCoordinator(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "singleReceiveCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
		states += self.map RegionState(context, region, "Requesting", false);
		
		transitions += self.map SingleReceive2TransCheckEmbeddedCoordinator(context, region);
		transitions += self.map SingleReceive2TransCheckDoneEmbeddedCoordinator(context, region);
					
	}
	
mapping Transition :: SingleReceive2TransCheckEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		source := self.map RegionState(context, region, "Idle", true);
		
		target := self.map RegionState(context, region, "Requesting", false);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(2, region);
		
		guard := self.guard.map Expression2Expression(context);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "first", "singleReceiveCheck", true, 2);
			
	}
	
mapping Transition :: SingleReceive2TransCheckDoneEmbeddedCoordinator(context:OclAny, region:OclAny) : Transition {

		priority := 1;
		
		target := self.map RegionState(context, region, "Idle", true);
		
		source := self.map RegionState(context, region, "Requesting", false);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "singelReceiveCheckDone", false, 3);
			
	}
//mapping  Transition :: RelativeDeadline2ClockConstraint(context:OclAny, region: OclAny, mapLowerBound : Boolean, operator :ComparingOperator, clockName : String) : ClockConstraint
	
	
mapping Transition :: SingleReceive2TransitionFromIntermediate1ToIntermediate2(context : OclAny, region: OclAny): Transition{
	priority := 1;
	
	target := self.map Schema2CoordinatorIntermediateState(context,region, 2, singleReceiveDLCName);
	
	source := self.map Schema2CoordinatorIntermediateState(context, region, 1, singleReceiveDLCName);
	//invariants += self.map RelativeDeadline2ClockConstraint(intermediateStateNumber,region, false, ComparingOperator::LESS_OR_EQUAL, clockName);
	clockConstraints += self.map RelativeDeadline2ClockConstraint(result, region, false, ComparingOperator::GREATER_OR_EQUAL, singleReceiveDLCName);
}
	
mapping Transition :: SingleReceive2TransitionFromSourceToIntermediate1(context:OclAny, region:OclAny) : Transition {
	
		priority := self.priority;
		
		target := self.map Schema2CoordinatorIntermediateState(context,region,1,singleReceiveDLCName);
		
		source := self.source.map Vertex2VertexCoordinator(context, region);		
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "", "singleReceivePossible", false, 4);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(self, 1);
		
						
	}
	
--------------------------------------------------------------- Transfer Schema SingleReceive of Subrole------------------------------------------------------------------
	
// @author: sthiele2 -- this mapping generates the transition from the source of the schema-transition to an intermediate state
mapping Transition :: SingleReceive2TransitionFromSourceToIntermediate(context:OclAny, region:OclAny) : Transition {

		priority := (self.priority);
		
		source := self.source.map Vertex2VertexSubrole(context, region);
		
		target := self.map Schema2SubroleIntermediateState(context,region,1);
	
		guard :=self.map TransferSchemata2TypedNamedElementExpr(context, "consumeSingleReceive", 1);
	}
	

 
// @author sthiele2 -- one of the transitions from intermediate state to target state in the subrole-region
mapping Transition :: SingleReceive2Transition1FromIntermediateToReceivedSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Schema2SubroleIntermediateState(context,region,1);	
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "singleReceive", true, 6);
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 4);
					
	}
	
// @author sthiele2 -- one of the transitions from intermediate state to target state in the subrole-region			
mapping Transition :: SingleReceive2Transition2FromIntermediateToReceivedSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
		
		target := self.target.map Vertex2VertexSubrole(context, region);
		
		source := self.map Schema2SubroleIntermediateState(context,region,1);	
		
		guard := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 5);
				
		action := self.map TransferSchemata2Action(context, "consumeSingleReceive:=false", "consumeSingleReceive", "false", 12);
			
		synchronization := self.map TransferSchemata2Synchronization(context,region, SynchronizationKind::SEND,"","singleReceiveDone",false, 6 );			
	}
	
mapping Transition :: SingleReceive2SourceRegionSubrole(context:OclAny, region:OclAny) : Region {
		
		priority := self.priority;
		
		parentState := self.source.map Vertex2VertexSubrole(context, region).oclAsType(State);
		
		embeddedStatechart := self.map SingleReceive2SourceEmbeddedRTSCSubrole(context, region);					
	}

// @author: sthiele2 -- creates the embedded rtsc of the schema transition's source node in the subrole region	
mapping Transition :: SingleReceive2SourceEmbeddedRTSCSubrole(context:OclAny, region:OclAny) : RealtimeStatechart {
		
		name:= "singleReceiveCheck" + "_" + self.source.name + "_" + self.target.name + "_" + self.priority.toString();
		
		states += self.map RegionState(context, region, "Idle", true);
	
		states += self.map RegionState(context, region, "Requested", false);	
	
		transitions += self.map SingleReceive2Transition1FromRequestedToIdle(context,region);
	
		transitions += self.map SingleReceive2Transition2FromRequestedToIdle(context,region);
	
		transitions += self.map SingleReceive2TransitionFromIdleToRequested(context,region);					
		
		transitions += self.map SingleReceive2TransitionFromEmbeddedStateToStateExitPoint(context,region);		
		
	}

// @author: sthiele2 -- creates a transition from the exit point of the schema-transition's source to the intermediate state in the subrole region
mapping Transition :: SingleReceive2TransitionFromStateExitPointToIntermediateStateOfSubRole(context : OclAny, region : OclAny) : Transition{
		priority := 1;
		
		source := self.map SingleReceive2StateExitPoint(context,region);
		
		target := self.map Schema2SubroleIntermediateState(context,region,1);
		
		action := self.map TransferSchemata2Action(context,"consumeSingleReceive := true","consumeSingleReceive", "true", 12);
		
		if(not self.triggerMessageEvent.oneToManyCommunicationSchema.action.oclIsUndefined())
			{
				action.expressions += self.triggerMessageEvent.oneToManyCommunicationSchema.action.expressions.map Expression2Expression(context);
			};
}


mapping Transition :: SingleReceive2TransitionFromEmbeddedStateToStateExitPoint(context : OclAny, region : OclAny) : Transition {
		priority := 3;
		
		source := self.map RegionState(context, region, "Requested", false);	
		
		target := self.map SingleReceive2StateExitPoint(context,region);
		
		if(not self.guard.oclIsUndefined() and not self.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())
		{
			guard := self.map TransferSchemaGuardAndLocalConditions(context);
		}
		else if(not self.guard.oclIsUndefined())
		{
			guard := self.guard.map Expression2Expression(context);
		}
		else
		{
			guard := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context);
		}
		endif;
		
		synchronization := self.map TransferSchemata2Synchronization(context,region, SynchronizationKind::SEND, "","singleReceivePossible",false,7);
		
		
		events += self.triggerMessageEvent.map Asynchronous2Asynchronous(context);
		
		clockConstraints := self.clockConstraints->select(c|not isClockSubRoleSpecific(c.clock))->map ClockConstraint2ClockConstraint(1, result);
				
		}
		

mapping Transition :: TransferSchemaGuardAndLocalConditions(context : OclAny) : expressions::common::LogicalExpression
{
		leftExpression := self.guard.map Expression2Expression(context);
		rightExpression := self.triggerMessageEvent.oneToManyCommunicationSchema.condition.map Expression2Expression(context);
		operator := LogicOperator::AND;	
}
	
mapping Transition :: SingleReceive2StateExitPoint(context : OclAny, region : OclAny) : ExitPoint {
		result.name := self.source.name + "_Requested_ExitPoint";
		
		result.state := self.source.map Vertex2VertexSubrole(context, region).oclAsType(State);		
		}
		

	
mapping Transition :: SingleReceive2Transition1FromRequestedToIdle(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map SingleReceiveLastAndPossibleExpression(context,region,"consumeSingleReceive",true, 100);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "singleReceiveCheckDone", false, 8);
					
	}
	
mapping Transition :: SingleReceive2Transition2FromRequestedToIdle(context:OclAny, region:OclAny) : Transition {
	
		priority := 2;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map SingleReceiveNotLastAndPossibleExpression(context,region,"consumeSingleReceive",true, 3);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "self.next", "singleReceive", true, 8);
					
	}
	
mapping Transition :: SingleReceive2RequestedIdleCheckDonePossibleSubrole(context:OclAny, region:OclAny) : Transition {
	
		priority := 3;
				
		source := self.map RegionState(context, region, "Requested", false);
		
		target := self.map RegionState(context, region, "Idle", true);
		
		guard := self.map SingleReceiveNotLastAndPossibleExpression(context, region, "singleReceivePossible", false, 7);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::SEND, "", "singleReceiveCheckDone", false, 9);
		
	}
	
mapping Transition :: SingleReceive2TransitionFromIdleToRequested(context:OclAny, region:OclAny) : Transition {
	
		priority := 1;
				
		target := self.map RegionState(context, region, "Requested", false);
		
		source := self.map RegionState(context, region, "Idle", true);
		
		synchronization := self.map TransferSchemata2Synchronization(context, region, SynchronizationKind::RECEIVE, "self", "singleReceiveCheck", true, 11);
					
	}
	
mapping Transition :: SingleReceiveNotLastAndPossibleExpression(context:OclAny, region:OclAny, varName:String, notOp: Boolean, transMapping: Integer) : LogicalExpression {

		leftExpression := self.map TransferSchemataLogicalExpression(context, region, "<>", "last", 10+transMapping);
		
		if(notOp){
			rightExpression := self.map UnaryOperatorTransferSchemata2TypedNamedElementExpr(context, varName, transMapping, UnaryOperator::NOT);
		}else{
			rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName, transMapping);
		}endif;
		
		operator := LogicOperator::AND;
}

mapping Transition :: UnaryOperatorTransferSchemata2TypedNamedElementExpr(context : OclAny, varName : String, transMapping: Integer, _operator : UnaryOperator): UnaryExpression
{
	result.operator := _operator;
	
	result.enclosedExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName, transMapping);
	
}
mapping Transition :: SingleReceiveLastAndPossibleExpression(context:OclAny, region:OclAny, varName:String, notOp: Boolean, transMapping: Integer) : LogicalExpression {

		leftExpression := self.map TransferSchemataLogicalExpression(context, region, "==", "last", 10+transMapping);
		
		if(notOp){
			rightExpression := self.map UnaryOperatorTransferSchemata2TypedNamedElementExpr(context, varName, transMapping, UnaryOperator::NOT);
		}else{
			rightExpression := self.map TransferSchemata2TypedNamedElementExpr(context, varName, transMapping);
		}endif;
		
		operator := LogicOperator::AND;
}