import common.AllSchemataMappings;
import schemata.Multicast;
import schemata.Unicast;
import schemata.MultiReceive;
import schemata.UniReceive;
import schemata.IterateSchema;
import schemata.LoadBalancing;
import normalisations;

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/0.3.1');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/0.3.1');
modeltype behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype actionLanguage uses 'http://www.fujaba.de/muml/actionlanguage/0.4.0';
modeltype valuetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype storydriven uses 'http://www.storydriven.org/core/0.3.1';
modeltype modelinstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype schemata uses muml::realtimestatechart::one_to_n_schemata('http://www.fujaba.de/muml/0.4.0');
modeltype types uses muml::types('http://www.fujaba.de/muml/0.4.0');

--------------------------------------------- 		
transformation DisassembleOneToManySchemataInDiscreteInteractionEndpoint(inout input:rtsc);

property currentRealtimeStatechart : RealtimeStatechart;
property schemaCount : Integer =0; // counter for the schemata in order to enumerate the realtimestatechart names

main() {
	var debugging : Boolean := true;
 	//debug:
	currentRealtimeStatechart := getRealtimeStatechartCategory(input.rootObjects()[RootNode]->any(true)).modelElements->asOrderedSet()->at(1).oclAsType(RealtimeStatechart);
	// not debug:
	//currentRealtimeStatechart := input.rootObjects()[RealtimeStatechart]->any(true);		
	disassembleDiscreteInteractionPointRTSC(currentRealtimeStatechart);
	
	if( not debugging ) {
		// when deleting the original/input statechart, we only have to consider the case when the currentRealtimeStatechart was contained in a ModelElementCategory.
		// Otherwise, it is embedded in a region. In this case it is deleted anyways.
		if(currentRealtimeStatechart.eContainer().oclIsTypeOf(ModelElementCategory)) {
			currentRealtimeStatechart.eContainer().oclAsType(ModelElementCategory).modelElements := currentRealtimeStatechart.eContainer().oclAsType(ModelElementCategory).modelElements->excluding(currentRealtimeStatechart);
		}
	};
}

helper disassembleDiscreteInteractionPointRTSC(inputRTSC : RealtimeStatechart) : RealtimeStatechart
{	
	currentRealtimeStatechart := inputRTSC;
	rootNode :=currentRealtimeStatechart.getHighestParentStatechart().eContainer().eContainer().oclAsType(RootNode);
	assert fatal (currentRealtimeStatechart.behavioralElement.oclIsKindOf(muml::connector::DiscreteInteractionEndpoint)) with log ("The specified RealtimeStatechart must be the behavior of a discrete port or a role!");
	
	// step 1: normalize transitions that define two schemata:
	normalize(currentRealtimeStatechart);
	// step 2: disassemble schematas
	return currentRealtimeStatechart.map RTSC2RTSC();	
}

query getRealtimeStatechartCategory(theRootNode : RootNode) : ModelElementCategory {
	return theRootNode.categories -> select(c : ModelElementCategory | c.key = 'de.uni_paderborn.fujaba.muml.realtimestatechart.category') -> any(true);
}

query getRealtimeStatechartCategory(): ModelElementCategory
{
	return currentRealtimeStatechart.eContainer().oclAsType(ModelElementCategory);
}
helper  isClockSubRoleSpecific(c : Clock): Boolean
{
	return currentRealtimeStatechart.subRoleSpecificClocks->includes(c);
}
helper isVariableSubRoleSpecific(v : Variable): Boolean
{
	return currentRealtimeStatechart.subRoleSpecificVariables->includes(v);
}
helper isOperationSubRoleSpecific(o : Operation): Boolean
{
	return currentRealtimeStatechart.subRoleSpecificOperations->includes(o);
}	


mapping RealtimeStatechart :: RTSC2RTSC() : RealtimeStatechart {		
		
		var allRTSCs : Set(RealtimeStatechart) := self->closure(states.oclAsType(State).embeddedRegions.oclAsType(Region).embeddedStatechart)->append(self);
		internalClocks := allRTSCs.clocks;
		internalVariables := allRTSCs.variables;
		internalSynchronizations := allRTSCs.states.channels;
		-- check whether every unicast defines a condition!
		assert fatal (self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and
		 t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) and (t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->isEmpty()
		) with log ("Unicast must define a condition!");		
		
		name := self.name + "Impl";
		
		// **select non subrolespecific elements
		clocks += self.clocks.map Clock2Clock();
		
		variables += self.variables.map Variable2Variable();
		
		operations += self.operations.map Operation2Operation();
		// the proper transformation
		states += self.map Rtsc2InitialState();
		
		// if the one-to-many-coordination-schema defined a condition, we need a boolean variable that checks whether the schema eexecution works or not.
		
		allRTSCs.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->forEach(transition){
			var newVar : Variable := transition.map Schema2BooleanVariable(multicastPossibleName);
			var initExpression := new LiteralExpression();
			initExpression.value := "false";
			newVar.initializeExpression := initExpression;
			variables +=newVar ;
			
		};
		
		allRTSCs.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->forEach(transition){
			var newVar : Variable := transition.map Schema2BooleanVariable(loadBalancingPossibleName);
			var initExpression := new LiteralExpression();
			initExpression.value := "false";
			newVar.initializeExpression := initExpression;
			variables +=newVar ;
		};
		
		allRTSCs.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->forEach(transition){		
			var newVar : Variable := transition.map Schema2BooleanVariable(unicastPossibleName);
			var initExpression := new LiteralExpression();
			initExpression.value := "false";
			newVar.initializeExpression := initExpression;
			variables +=newVar ;
		};
		
		// iterate without condition?? 
		allRTSCs.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->forEach(transition){		
			var newVar : Variable := transition.map Schema2BooleanVariable(terminateIterationName);
			var initExpression := new LiteralExpression();
			initExpression.value := "false";
			newVar.initializeExpression := initExpression;			
			variables +=newVar ;
			
			newVar := transition.map Schema2BooleanVariable(iteratePossibleName);
			initExpression := new LiteralExpression();
			initExpression.value := "false";
			newVar.initializeExpression := initExpression;			
			variables +=newVar ;
			
			if(not transition.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.oclIsUndefined()) {
				clocks += transition.map TransitionDeadline2CoordinatorDeadlineClock(iterateDelayClockName);
			};
		};
			
				
		allRTSCs.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive))->forEach(transition){
			var newVar : Variable := transition.map Schema2BooleanVariable(consumeSingleReceiveName);
			var initExpression := new LiteralExpression();
			initExpression.value := "false";
			newVar.initializeExpression := initExpression;
			variables +=newVar ;
			
			newVar := transition.map Schema2BooleanVariable(singleReceivePossibleName);
			initExpression := new LiteralExpression();
			initExpression.value := "false";
			newVar.initializeExpression := initExpression;
			variables +=newVar ;
		};		
		
		// normally override the behavorialElement
		behavioralElement := self.behavioralElement;
		getRealtimeStatechartCategory().modelElements +=result;
	}
	

	
mapping RealtimeStatechart :: RTSC2CoordinatorRTSC(context:OclAny) : RealtimeStatechart {		
		
		result.name := self.name;
		var region : RealtimeStatechart := result;
		
		if(self = currentRealtimeStatechart){	
			parentRegion := self.map State2CoordinatorRegion(self);
		}
		else {
			parentRegion := self.parentRegion.map EmbeddedRegion2EmbeddedCoordinatorRegion(context );
		} endif;
		
		
	
		
		states += self.states.map States2StatesCoordinator(context);
		
		transitions += self.transitions->select(t|t.triggerMessageEvent.oclIsUndefined() and t.raiseMessageEvent.oclIsUndefined()).map Transition2TransitionCoordinator(context, region);
		
		--transition with multicast not conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map NonConditionalMulticast2TranssitionFromSourceToIntermediate(context, region);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map NonConditionalMulticast2TransitionFromIntermediateToTarget(context, region);
		
		// @author sthiele2 -- these are the new mappings for the multicast coordinator region
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2CoordinatorStartTransition(context, region);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2CoordinatorIntermediateTransition(context, region);
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2CoordinatorEndTransition(context, region);
		
		
		// @author: sthiele2 -- there is no unicast without condition anymore!
		--transition with unicast  conditional
		transitions += self.transitions->select(t|(not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2CoordinatorStartTransition(context, region);
		transitions += self.transitions->select(t|  (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2CoordinatorIntermediateTransition(context, region);
		transitions += self.transitions->select(t| (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2CoordinatorEndTransition(context, region);
			
		--transition with MultiReceive
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map MultiReceive2TransitionFromSourceToIntermediateCoordinator(context, region);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map MultiReceive2TransitionFromIntermediateToTargetCoordinator(context, region);
		
		--transition with singleReceive
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2TransitionFromSourceToIntermediate1(context, region);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2TransitionFromIntermediate1ToIntermediate2(context,region);
		transitions += self.transitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2TransitionFromIntermediate2ToTarget(context,region);
		
		--transitions with LoadBalancing
		self.transitions->forEach(t) {
		
			if(not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined() and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing)) {
				transitions += t.map LoadBalancing2CoordinatorStartTransition(context, region);
				transitions += t.map LoadBalancing2CoordinatorIntermediateTransition(context,region);
				transitions += t.map LoadBalancing2CoordinatorEndTransition(context,region);
			};
			
			if(not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined() and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate)) {
				transitions += t.map Iterate2CoordinatorStartTransition(context, region);
				transitions += t.map Iterate2CoordinatorIntermediateTransition(context,region);
				transitions += t.map Iterate2CoordinatorEndTransition(context,region);
			};
		
		};
		
		
		// @author: sthiele2 -- add clocks for the implementation of the relative deadlines
		clocks += self.transitions->select(t|(not t.relativeDeadline.oclIsUndefined()) and (not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast)).map TransitionDeadline2CoordinatorDeadlineClock(unicastDLCName);
		clocks += self.transitions->select(t|(not t.relativeDeadline.oclIsUndefined()) and (not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast)).map TransitionDeadline2CoordinatorDeadlineClock(multicastDLCName);
		clocks += self.transitions->select(t|(not t.relativeDeadline.oclIsUndefined()) and (not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map TransitionDeadline2CoordinatorDeadlineClock(singleReceiveDLCName);
		clocks += self.transitions->select(t|(not t.relativeDeadline.oclIsUndefined()) and (not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map TransitionDeadline2CoordinatorDeadlineClock(multiReceiveDLCName);
		clocks += self.transitions->select(t|(not t.relativeDeadline.oclIsUndefined()) and (not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map TransitionDeadline2CoordinatorDeadlineClock(loadBalancingDLCName);
			
		self.behavioralElement.oclAsType(muml::connector::DiscreteInteractionEndpoint).coordinatorBehavior := result;
		}
	
mapping RealtimeStatechart :: RTSC2SubroleRTSC() : RealtimeStatechart {
		name := "subrole";
		
		// add one main state on toplevel of subrole statechart
		var mainState = new State();
			
		mainState.name := "subrole Main";
		mainState.initial := true;
		
		// add embedded reigon for every used schema
		var prio : Integer := 1;
		
		var allRTSCs : Set(RealtimeStatechart) := self->closure(states.oclAsType(State).embeddedRegions.oclAsType(Region).embeddedStatechart)->append(self);
		allRTSCs.transitions
			->select(t|not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined())		
		->union(allRTSCs.transitions
			->select(t|not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()))		
		->forEach(t) {			
			if(not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined() and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsKindOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing)) {
				// add global subrole clocks and variables for LoadBalancing:
				var lb : muml::realtimestatechart::one_to_n_schemata::LoadBalancing := t.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::LoadBalancing);
				// distinguish variants of LoadBalancing: maxWCET or responseMessage 
				if(not lb.maxWorkingTime.oclIsUndefined()) {
					clocks+= getLoadBalancingTaskMessageClock();
					variables += getNeverHadATaskVariable();
				};
				if(not lb.responseMessage.oclIsUndefined()) {
					variables += getFreeForWorkVariable();
				};
			};
			mainState.embeddedRegions += t.map OneToManyCommunicationSchema2SubroleRegion(self, prio);
			prio := prio +1;
		};		
		
		states += mainState;		
		
		self.behavioralElement.oclAsType(muml::connector::DiscreteInteractionEndpoint).subroleBehavior := result;
}

mapping Transition:: OneToManyCommunicationSchema2SubroleRegion(sourceRealtimeStatechart : RealtimeStatechart, _priority : Integer): Region {
		
		result.priority := _priority;
		
		result.embeddedStatechart := self.map RTSC2SubroleSchemaRTSC(sourceRealtimeStatechart);		
}



mapping Transition :: RTSC2SubroleSchemaRTSC(sourceRealtimeStatechart:RealtimeStatechart) : RealtimeStatechart {
		
		schemaCount := schemaCount + 1;
		
		name := "subrole schema statechart" + schemaCount.toString();
		
		var region : RealtimeStatechart := result;		
		var context = sourceRealtimeStatechart;
		var toplevel = false;
		
		
		// add subrole specific schema variables: 
		
		self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->forEach(transition){
			variables += transition.map Schema2BooleanVariable(sendUnicastName);
		};
		
		self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->forEach(transition){
			variables += transition.map Schema2BooleanVariable(sendMulticastName);
		};
		
		self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing) 
				and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()))->forEach(transition){
			variables += transition.map Schema2BooleanVariable(taskPlannedName);
		};
		
		self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) 
				and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate))			
				->forEach(transition){
				if(not transition.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.oclIsUndefined()) {
					variables += transition.map Schema2BooleanVariable(sendIterateName);
				};
				if(not transition.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.oclIsUndefined()) {
					variables += transition.map Schema2BooleanVariable(iterateDelayVariableName);
				};					
		};
		
		// add the source and target of the schema transition to the subrole schema realtimestatechart
		states += self.map Transition2StateSubrole(region, self.source,true);		
		 
		states += self.map Transition2StateSubrole(region, self.target,false);		
		
		transitions += self.map Transition2TransitionFromSourceToTarget(region);
		
		--transitions with LoadBalancing
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing)).map LoadBalancing2TransSendSyncFirstSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing)).map LoadBalancing2TransReceiveSyncNotLastSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing)).map LoadBalancing2TransReceiveSyncLastSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing)).map LoadBalancing2TransSendSynNotFirstcSubrole(context, region);
		
		
		--transitions with Iterate
		if(self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate)) {
			
			transitions += self.map Iterate2Transition1Intermediate1ToIntermedediate2SubroleRegion(context,region,false);
			transitions += self.map Iterate2Transition2Intermediate1ToIntermedediate2SubroleRegion(context,region,false);
			
			if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).terminationCondition.oclIsUndefined()) {
				transitions += self.map Iterate2Transition3Intermediate1ToIntermedediate2SubroleRegion(context,region,false);
			};
			transitions += self.map Iterate2TransSendSyncSubrole(context,region,false);
			transitions += self.map Iterate2TransSendSyncNotConditionSubrole(context,region,false);
			transitions += self.map Iterate2IdleToIntermediate2SubroleRegion(context,region,false);
			
			transitions += self.map Iterate2TransReceiveSyncNotLastSubrole(context,region,false);
			transitions += self.map Iterate2TransReceiveSyncLastSubrole(context,region,false);
		};
		
		
		--transition with multicast
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast)).map Multicast2TransSendSyncSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast)).map Multicast2TransReceiveSyncNotLastSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast)).map Multicast2TransReceiveSyncLastSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2TransSendSyncNotConditionSubrole(context, region); 
		
		--transition with unicast
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast)).map Unicast2TransSendSyncFirstSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast)).map Unicast2TransReceiveSyncNotLastSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast)).map Unicast2TransReceiveSyncLastSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2TransSendSyncNotConditionSubrole(context, region); 
		
		--transition with MultiReceive
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map MultiReceive2TransitionFromSourceToIntermediateState1Subrole(context, region);
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map MultiReceive2Transition1FromIntermediate1ToIntermediate2Subrole(context, region);
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map MultiReceive2Transition2FromIntermediate1ToIntermediate2Subrole(context);
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map MultiReceive2Transition1FromIntermediate2ToTarget(context, region);
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive)).map MultiReceive2Transition2FromIntermediate2ToTarget(context, region);
		
		-- if MultiReceive is conditional, add one more transition
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map MultiReceive2TransitionFromSourceToIntermediate2Subrole(context, region);
		
		--transition with singlereceive
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2TransitionFromSourceToIntermediate(context, region);
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2Transition1FromIntermediateToReceivedSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2Transition2FromIntermediateToReceivedSubrole(context, region);
		transitions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2TransitionFromStateExitPointToIntermediateStateOfSubRole(context,region);
				
		-- add variable assignments to Entry Events of intermediate states of multicast and iterate 
		
		if((not self.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined()) and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast)) {
			
			var intermediateState1 : State := self.map Schema2SubroleIntermediateState(context, 1);
			if(intermediateState1.entryEvent.oclIsUndefined()) {
				
				intermediateState1.entryEvent := new EntryEvent();
				
				intermediateState1.entryEvent.kind := EventKind::RAISE;
							
			};
			if(intermediateState1.entryEvent.action.oclIsUndefined()) {
				intermediateState1.entryEvent.action := new Action();
				intermediateState1.entryEvent.action.name := "";
			};
			intermediateState1.entryEvent.action.expressions += self.TransferSchemata2AssignmentBlock(sendMulticastName, "false");
			intermediateState1.entryEvent.action.name := intermediateState1.entryEvent.action.name + " " + sendMulticastName + " := false;";
		};
		
		if((not self.raiseMessageEvent.oclIsUndefined()) and (not self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and self.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate)) {
			
			var intermediateState1 : State := self.map Schema2SubroleIntermediateState(context, 1);
			if(intermediateState1.entryEvent.oclIsUndefined()) {
				
				intermediateState1.entryEvent := new EntryEvent();
				
				intermediateState1.entryEvent.kind := EventKind::RAISE;
							
			};
			if(intermediateState1.entryEvent.action.oclIsUndefined()) {
				intermediateState1.entryEvent.action := new Action();
				intermediateState1.entryEvent.action.name := "";
			};
			intermediateState1.entryEvent.action.expressions += self.TransferSchemata2AssignmentBlock(sendIterateName, "false");
			intermediateState1.entryEvent.action.name := intermediateState1.entryEvent.action.name + " " + sendIterateName + " := false;";
			
			if(not self.raiseMessageEvent.oneToManyCommunicationSchema.oclAsType(muml::realtimestatechart::one_to_n_schemata::Iterate).delay.oclIsUndefined()) {
				intermediateState1.entryEvent.clockResets += self.map TransitionDeadline2CoordinatorDeadlineClock(iterateDelayClockName);
			};
		};
				
		operations += sourceRealtimeStatechart.subRoleSpecificOperations.map Operation2Operation();
		
		variables += sourceRealtimeStatechart.subRoleSpecificVariables->map Variable2Variable();
		
		clocks += sourceRealtimeStatechart.subRoleSpecificClocks.map Clock2Clock();
				
	}

mapping Transition :: Transition2TransitionFromSourceToTarget(container : RealtimeStatechart) : Transition {
		
		priority := 1;
		
		target :=  self.map Transition2StateSubrole(container, self.source,true);
		
		source := self.map Transition2StateSubrole(container, self.target, false);
}

mapping State :: States2StatesCoordinator(context:OclAny) : State {
		
		self.parentStatechart.map RTSC2CoordinatorRTSC(context);
		
		name := self.name;
		
		initial := self.initial;
		
		final := self.final;
		
		urgent := self.urgent;				
	
		entryEvent := self.entryEvent.map EntryEvent2EntryEventCoordinator(context,null);			
		
		// @author: sthiele2 -- add clock resets for the source states of schema transitions 
		self.outgoingTransitions->select(t|((not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined())
		or (not t.triggerMessageEvent.oclIsUndefined() and not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined())
		 ))->forEach(t){
			if(entryEvent.oclIsUndefined())
			{
				entryEvent :=  new EntryEvent();
				entryEvent.kind := EventKind::RAISE;
			}; 
		
			var block : Block;
			
			var raiseSchema : OneToManyCommunicationSchema := t.raiseMessageEvent.oneToManyCommunicationSchema;
			if(raiseSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast))  
			{
				if(entryEvent.action.oclIsUndefined()) {
					entryEvent.action := new Action();
					entryEvent.action.name := "";				
				};
				block := new Block();
				entryEvent.action.name := entryEvent.action.name.concat(" unicastPossible := false;");
				block.expressions += t. createTypedNamedElementAssignmentExpression(AssignOperator::ASSIGN,t.map Schema2BooleanVariable(unicastPossibleName),t. Schema2LiterarExpression("false")  );
				if(not t.relativeDeadline.oclIsUndefined()) {
					entryEvent.clockResets += t.map TransitionDeadline2CoordinatorDeadlineClock(unicastDLCName);
				};
			}
			else if (raiseSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast))
			{						
				if(not raiseSchema.condition.oclIsUndefined()) {
					if(entryEvent.action.oclIsUndefined()) {
						entryEvent.action := new Action();
						entryEvent.action.name := "";				
					};		
					entryEvent.action.name := entryEvent.action.name.concat(" multicastPossible := false;");
					block := new Block();
					block.expressions += t.createTypedNamedElementAssignmentExpression(AssignOperator::ASSIGN,t.map Schema2BooleanVariable(multicastPossibleName),t.map Schema2LiterarExpression("false")  );
				};
				if(not t.relativeDeadline.oclIsUndefined()) {
					if(entryEvent.action.oclIsUndefined()) {
						entryEvent.action := new Action();
						entryEvent.action.name := "";				
					};		
					entryEvent.clockResets += t.map TransitionDeadline2CoordinatorDeadlineClock(unicastDLCName);
				};
			}
			else if (raiseSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing)) {
				if(entryEvent.action.oclIsUndefined()) {
					entryEvent.action := new Action();
					entryEvent.action.name := "";				
				};
				entryEvent.action.name := entryEvent.action.name.concat(" loadBalancingPossible := false;");
				block := new Block();
				block.expressions += t.createTypedNamedElementAssignmentExpression(AssignOperator::ASSIGN,t.map Schema2BooleanVariable(loadBalancingPossibleName),t. Schema2LiterarExpression("false")  );
			}
			else if (raiseSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate)) {
				if(entryEvent.action.oclIsUndefined()) {
					entryEvent.action := new Action();
					entryEvent.action.name := "";				
				};
				entryEvent.action.name := entryEvent.action.name.concat(" iteratePossible := false;");
				block := new Block();
				block.expressions += t.createTypedNamedElementAssignmentExpression(AssignOperator::ASSIGN,t.map Schema2BooleanVariable(iteratePossibleName),t. Schema2LiterarExpression("false")  );
				entryEvent.action.name.concat(" terminate := false;");
				block.expressions += t.createTypedNamedElementAssignmentExpression(AssignOperator::ASSIGN,t.map Schema2BooleanVariable(terminateIterationName),t. Schema2LiterarExpression("false")  );
			};
			var triggerSchema : OneToManyCommunicationSchema := t.triggerMessageEvent.oneToManyCommunicationSchema;
			if(triggerSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive))
			{
				if(not t.relativeDeadline.oclIsUndefined()) {
					entryEvent.clockResets += t.map TransitionDeadline2CoordinatorDeadlineClock(singleReceiveDLCName)
				};
			}else if(triggerSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::MultiReceive))
			{
				if(not t.relativeDeadline.oclIsUndefined()) {
					entryEvent.clockResets += t.map TransitionDeadline2CoordinatorDeadlineClock(multiReceiveDLCName);
				};
			};
			if(block.expressions->size() > 0) {
				entryEvent.action.expressions += block;
			};
		};
		
		
		exitEvent := self.exitEvent.map ExitEvent2ExitEventCoordinator(context, null);
		
		doEvent := self.doEvent.cloneDoEvent();
		
		invariants := self.invariants->select(c|not isClockSubRoleSpecific(c.clock)).map ClockConstraint2ClockConstraint(result);
	
	
		-- copy the embedded regions of the state:
		embeddedRegions += self.embeddedRegions.map EmbeddedRegion2EmbeddedCoordinatorRegion(context);
		
		-- add embedded Regions for transfer schemata
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2SourceRegionCoordinator(context);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2SourceRegionCoordinator(context);
		embeddedRegions += self.outgoingTransitions->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map LoadBalancing2SourceRegionCoordinator(context);
	
		embeddedRegions += self.outgoingTransitions->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2SourceRegionCoordinator(context);
		
	}

mapping Region :: EmbeddedRegion2EmbeddedCoordinatorRegion(context : OclAny) : Region{
	
		result.priority := self.priority;		
		result.parentState := self.parentState.map States2StatesCoordinator(context);
		result.embeddedStatechart := self.embeddedStatechart.map RTSC2CoordinatorRTSC(context);	
}



mapping Transition::Transition2StateSubrole(inout containerRegion : RealtimeStatechart, state:Vertex,_initial: Boolean):State {
		name := state.name;
		
		result.initial := _initial;
		
		containerRegion.states += result;
		
		if(_initial) { 
		--embedded Regions for transfer schemata
			embeddedRegions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Multicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Multicast2SourceRegionSubrole(result, containerRegion);
			embeddedRegions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Unicast) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Unicast2SourceRegionSubrole(result, containerRegion);	
			embeddedRegions += self->asSet()->select(t|(not t.triggerMessageEvent.oclIsUndefined()) and (not t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.triggerMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::SingleReceive)).map SingleReceive2SourceRegionSubrole(result, containerRegion);	
			embeddedRegions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::LoadBalancing) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map LoadBalancing2SourceRegionSubrole(result, containerRegion);	
			embeddedRegions += self->asSet()->select(t|(not t.raiseMessageEvent.oclIsUndefined()) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsUndefined()) and t.raiseMessageEvent.oneToManyCommunicationSchema.oclIsTypeOf(muml::realtimestatechart::one_to_n_schemata::Iterate) and (not t.raiseMessageEvent.oneToManyCommunicationSchema.condition.oclIsUndefined())).map Iterate2SourceRegionSubrole(result, containerRegion);	
			
		};
}

	


	


