grammar de.uni_paderborn.fujaba.muml.verification.uppaal.Mtctl with org.eclipse.xtext.common.Terminals

import "platform:/resource/de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl/model/Mtctl.ecore" as mtctl
import "platform:/resource/de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl/model/Mtctl.ecore#//BooleanLogic" as mtctl
import "platform:/resource/de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl/model/Mtctl.ecore#//Comparables" as mtctl
import "platform:/resource/de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl/model/Mtctl.ecore#//Predicates" as mtctl
import "platform:/resource/de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl/model/Mtctl.ecore#//Quantifiers" as mtctl
import "platform:/resource/de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl/model/Mtctl.ecore#//Sets" as mtctl

import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//realtimestatechart" as realtimestatechart
import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//types" as types
import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//behavior" as behavior
import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//component" as component
import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//valuetype" as valuetype
import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//msgtype" as msgtype
import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//protocol" as protocol
import "platform:/resource/de.uni_paderborn.fujaba.muml/model/muml.ecore#//connector" as connector
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

PropertyRepository returns mtctl::PropertyRepository:
	(properties+=Property)*
;

Property returns mtctl::Property hidden(WS, ML_COMMENT):
	expression=Expression ';' (comment=SL_COMMENT)?
;

Expression returns mtctl::Expression:
	LeadsToExpr
;

//Binary operators (increasing precedence)
LeadsToExpr returns mtctl::Expression:
	TimeIntervalExpr ({mtctl::LeadsToExpr.leftOpd=current} 'leadsTo' rightOpd=TimeIntervalExpr)*
;

TimeIntervalExpr returns mtctl::Expression:
	'timeInterval' {mtctl::TimeIntervalExpr} lhs=ImplyExpr '[' lower=INT ',' upper=INT ']' rhs=ImplyExpr | ImplyExpr //TODO use units from action lang
;

ImplyExpr returns mtctl::Expression:
	AndExpr ({mtctl::ImplyExpr.leftOpd=current} 'implies' rightOpd=AndExpr)*
;

AndExpr returns mtctl::Expression:
	OrExpr ({mtctl::AndExpr.leftOpd=current} 'and' rightOpd=OrExpr)*
;

OrExpr returns mtctl::Expression:
	NotExpr ({mtctl::OrExpr.leftOpd=current} 'or' rightOpd=NotExpr)*
;

//Unary operators
NotExpr returns mtctl::Expression:
	'not' {mtctl::NotExpr} opd=NotExpr | QuantifierExpr
;

QuantifierExpr returns mtctl::Expression:
	UniversalQuantExpr | ExistentialQuantExpr | TemporalQuantifierExpr | AtomExpr
;

UniversalQuantExpr returns mtctl::QuantifierExpr:
	'forall' '(' {mtctl::UniversalQuantExpr} var=VariableBinding ')' formula=(NotExpr)
;

ExistentialQuantExpr returns mtctl::QuantifierExpr:
	'exists' '(' {mtctl::ExistenceQuantExpr} var=VariableBinding ')' formula=(NotExpr)
;

VariableBinding returns mtctl::BoundVariable:
	name=ID ':' set=SetExpr
;

TemporalQuantifierExpr returns mtctl::Expression:
	EFExpr | AFExpr | EGExpr | AGExpr
;

EFExpr returns mtctl::TemporalQuantifierExpr:
	('EF' | 'E<>') {mtctl::EFExpr} expr=NotExpr
;

AFExpr returns mtctl::TemporalQuantifierExpr:
	('AF' | 'A<>') {mtctl::AFExpr} expr=NotExpr
;

EGExpr returns mtctl::TemporalQuantifierExpr:
	('EG' | 'E[]') {mtctl::EGExpr} expr=NotExpr
;

AGExpr returns mtctl::TemporalQuantifierExpr:
	('AG' | 'A[]') {mtctl::AGExpr} expr=NotExpr
;

//Bottom of precedence chain.
AtomExpr returns mtctl::Expression:
	'(' Expression ')' | PredicateExpr | ComparisonExpr
;

//Predicates
PredicateExpr returns mtctl::Expression:
	TrueExpr | FalseExpr | DeadlockExpr | BufferOverflowExpr | StateExpr | MessageExpr | TransitionExpr
;

DeadlockExpr returns mtctl::DeadlockExpr:
	{mtctl::DeadlockExpr} 'deadlock'
;

BufferOverflowExpr returns mtctl::BufferOverflowExpr:
	{mtctl::BufferOverflowExpr} 'bufferOverflow'
;

TrueExpr returns mtctl::TrueExpr:
	{mtctl::TrueExpr} 'true'
;

FalseExpr returns mtctl::FalseExpr:
	{mtctl::FalseExpr} 'false'
;

StateExpr returns mtctl::PredicateExpr:
	StateActiveExpr | SubstateOfExpr | StateInStatechartExpr
;

StateActiveExpr returns mtctl::StateActiveExpr:
	'stateActive' '(' state=StateMapExpr ')'
;

SubstateOfExpr returns mtctl::SubstateOfExpr:
	'substateOf' '(' state=StateMapExpr ','	superstate=StateMapExpr ')'
;

StateInStatechartExpr returns mtctl::StateInStatechartExpr:
	'stateInStatechart' '(' state = StateMapExpr ',' statechart = StatechartMapExpr ')'
;

MessageExpr returns mtctl::PredicateExpr:
	MessageInBufferExpr | MessageInTransitExpr
;

MessageInTransitExpr returns mtctl::MessageInTransitExpr:
	'messageInTransit' '(' message=MessageMapExpr ')'
;

MessageInBufferExpr returns mtctl::MessageInBufferExpr:
	'messageInBuffer' '(' message=MessageMapExpr ',' buffer=BufferMapExpr ')'
;

TransitionExpr returns mtctl::PredicateExpr:
	TransitionFiringExpr
;

TransitionFiringExpr returns mtctl::TransitionFiringExpr:
	'transitionFiring' '(' transition=TransitionMapExpr ')'
;

//Comparisons
ComparisonExpr returns mtctl::Expression:
	{mtctl::ComparisonExpr} lhs=MapExpr op=ComparisonOp rhs=MapExpr
;

enum ComparisonOp returns mtctl::ComparisonOp:
	EQUALS='==' | GREATER='>' | GREATER_OR_EQUAL='>=' | LESS='<' | LESS_OR_EQUAL='<=' | NOT_EQUAL='!='
;

//Expressions usable in comparisons. Starting with MapExpressions arranged by return type
MapExpr returns mtctl::MapExpr:
	MumlElemExpr | BufferMessageCountExpr | ConstExpr | SourceStateExpr | TargetStateExpr
;

IntegerMapExpr returns mtctl::MapExpr:
	MumlElemExpr | BufferMessageCountExpr | ConstExpr
;

TransitionMapExpr returns mtctl::MapExpr:
	MumlElemExpr
;

StateMapExpr returns mtctl::MapExpr:
	MumlElemExpr | SourceStateExpr | TargetStateExpr
;

StatechartMapExpr returns mtctl::MapExpr:
	MumlElemExpr
;

BufferMapExpr returns mtctl::MapExpr:
	MumlElemExpr
;

MessageMapExpr returns mtctl::MapExpr:
	MumlElemExpr
;

BufferMessageCountExpr returns mtctl::BufferMsgCountExpr:
	'bufferMessageCount' '(' buffer=BufferMapExpr ')'
;

SourceStateExpr returns mtctl::SourceStateExpr:
	'sourceState' '(' transition=TransitionMapExpr ')'
;

TargetStateExpr returns mtctl::TargetStateExpr:
	'targetState' '(' transition=TransitionMapExpr ')'
;

MumlElemExpr returns mtctl::MumlElemExpr:
	elem=[ecore::EObject|QualifiedName]
;

ConstExpr returns mtctl::ConstExpr:
	val=EInt (timeUnit=TimeUnitExpr)?
;

TimeUnitExpr returns valuetype::TimeUnit:
	'd' | 'h' | 'm' | 's' | 'ms' | 'Âµs' | 'ns'
;

//Sets
SetExpr returns mtctl::SetExpr:
	IntervalSetExpr | {mtctl::StateSetExpr} 'States' | {mtctl::TransitionSetExpr} 'Transitions' | {mtctl::MessageSetExpr} 'MessageTypes' | {mtctl::ClockSetExpr} 'Clocks' | {mtctl::BufferSetExpr} 'Buffers'
;

IntervalSetExpr returns mtctl::SetExpr:
	{mtctl::IntervalSetExpr} '[' lowerVal=INT ',' upperVal=INT ']'
;

//Other necessary definitions
QualifiedName:
	ID ('.' ID)*
;


EInt returns ecore::EInt:
	'-'? INT
;