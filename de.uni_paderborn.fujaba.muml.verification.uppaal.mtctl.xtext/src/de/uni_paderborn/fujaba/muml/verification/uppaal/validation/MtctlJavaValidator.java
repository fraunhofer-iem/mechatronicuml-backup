/*
* generated by Xtext
*/
package de.uni_paderborn.fujaba.muml.verification.uppaal.validation;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import de.uni_paderborn.fujaba.muml.behavior.Variable;
import de.uni_paderborn.fujaba.muml.realtimestatechart.Clock;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.BufferMsgCountExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.ConstExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.MumlElemExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Predicates.ComparisonExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Predicates.ComparisonOp;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Predicates.DynamicPredicateExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Quantifiers.BoundVariable;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Quantifiers.QuantifierExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Quantifiers.TemporalQuantifierExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Sets.ClockSetExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Sets.IntervalSetExpr;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class MtctlJavaValidator extends de.uni_paderborn.fujaba.muml.verification.uppaal.validation.AbstractMtctlJavaValidator {

	@Check
	public void checkTemporallyQuantified(final DynamicPredicateExpr expr) { //Check whether every predicate is bound to a TemporalQuantifier
		EObject parent = expr;
		while (parent != null) {
			if (parent instanceof TemporalQuantifierExpr)
				return;
			parent = parent.eContainer();
		}
		
		error(expr.eClass().getName()+" must be bound to a Temporal Quantifier such as \"AG\"", null);
	}
	
	@Check 
	public void checkTemporallyQuantified(final TemporalQuantifierExpr expr) { //Disallow using nested TemporalQuantifiers
		EObject parent = expr.eContainer();
		while (parent != null) {
			if (parent instanceof TemporalQuantifierExpr) {
				error("TemporalQuantifiers must not be nested", null);
				return;
			}
			parent = parent.eContainer();
		}
	}
	
	@Check
	public void checkHiddenBoundVariable(final QuantifierExpr expr) { //give a warning when quantifier variables are shadowing one another
		EObject parent = expr.eContainer();
		while (parent != null) {
			if (parent instanceof QuantifierExpr && expr.getVar().getName().equals(((QuantifierExpr) parent).getVar().getName()))
				warning("The variable "+expr.getVar().getName()+" is shadowed", null);
			parent = parent.eContainer();
		}
	}
	
	/**
	 * Given an EObject, determines whether it can be used in an inequality
	 */
	private boolean isInequalityComparable(EObject obj) {
		if (obj instanceof ConstExpr || obj instanceof BufferMsgCountExpr || obj instanceof Variable || obj instanceof Clock)
			return true;
		if (obj instanceof BoundVariable)
			if (((BoundVariable) obj).getSet() instanceof IntervalSetExpr || ((BoundVariable) obj).getSet() instanceof ClockSetExpr)
				return true;
		if (obj instanceof MumlElemExpr)
			return isInequalityComparable(((MumlElemExpr) obj).getElem());
		
		return false;
	}
	
	@Check
	public void checkComparisonType(final ComparisonExpr expr) { //make sure that inequalities are only used on naturally ordered elements
		if (isInequalityComparable(expr.getLhs()) && isInequalityComparable(expr.getRhs()))
			return;
		if (expr.getOp().equals(ComparisonOp.EQUALS) || expr.getOp().equals(ComparisonOp.NOT_EQUAL))
			return;
		error(expr.getOp().toString() + " is not allowed here",null);
	}
	
	@Check
	public void checkClockComparisonTimeUnits(final ConstExpr expr) { //make sure that every ConstExpr has its TimeUnit set iff it's used in a clock comparison
		boolean isUsedInClockComparison = false;
		
		if (expr.eContainer() instanceof ComparisonExpr) { //set isUsedInClockComparison appropriately
			ComparisonExpr parent = (ComparisonExpr) expr.eContainer();
			isUsedInClockComparison = (parent.getLhs() instanceof MumlElemExpr && ((MumlElemExpr) parent.getLhs()).getElem() instanceof Clock)
										|| (parent.getRhs() instanceof MumlElemExpr && ((MumlElemExpr) parent.getRhs()).getElem() instanceof Clock);
		}
		
		if (isUsedInClockComparison && (expr.getTimeUnit() == null))
			error("Time unit missing", null);
		if (!isUsedInClockComparison && (expr.getTimeUnit() != null))
			error("Not expecting time unit", null);
	}
}
