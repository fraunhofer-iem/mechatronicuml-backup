/*
* generated by Xtext
*/
package de.uni_paderborn.fujaba.muml.verification.uppaal.validation;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import de.uni_paderborn.fujaba.muml.behavior.Variable;
import de.uni_paderborn.fujaba.muml.connector.MessageBuffer;
import de.uni_paderborn.fujaba.muml.realtimestatechart.Clock;
import de.uni_paderborn.fujaba.muml.realtimestatechart.Transition;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.BufferMsgCountExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.ConstExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.MapExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.MumlElemExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.SourceStateExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Comparables.TargetStateExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Predicates.ComparisonExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Predicates.ComparisonOp;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Predicates.DynamicPredicateExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Quantifiers.BoundVariable;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Quantifiers.QuantifierExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Quantifiers.TemporalQuantifierExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Sets.ClockSetExpr;
import de.uni_paderborn.fujaba.muml.verification.uppaal.mtctl.Sets.IntervalSetExpr;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class MtctlJavaValidator extends de.uni_paderborn.fujaba.muml.verification.uppaal.validation.AbstractMtctlJavaValidator {

	@Check
	public void checkTemporallyQuantified(final DynamicPredicateExpr expr) { //Check whether every predicate is bound to a TemporalQuantifier
		EObject parent = expr;
		while (parent != null) {
			if (parent instanceof TemporalQuantifierExpr)
				return;
			parent = parent.eContainer();
		}
		
		error(expr.eClass().getName()+" must be bound to a Temporal Quantifier such as \"AG\"", null);
	}
	
	@Check 
	public void checkTemporallyQuantified(final TemporalQuantifierExpr expr) { //Disallow using nested TemporalQuantifiers
		EObject parent = expr.eContainer();
		while (parent != null) {
			if (parent instanceof TemporalQuantifierExpr) {
				error("TemporalQuantifiers must not be nested", null);
				return;
			}
			parent = parent.eContainer();
		}
	}
	
	@Check
	public void checkHiddenBoundVariable(final QuantifierExpr expr) { //give a warning when quantifier variables are shadowing one another
		EObject parent = expr.eContainer();
		while (parent != null) {
			if (parent instanceof QuantifierExpr && expr.getVar().getName().equals(((QuantifierExpr) parent).getVar().getName()))
				warning("The variable "+expr.getVar().getName()+" is shadowed", null);
			parent = parent.eContainer();
		}
	}
	
	/**
	 * Given an EObject, determines whether it can be used in an inequality
	 */
	private boolean isInequalityComparable(EObject obj) {
		if (obj instanceof ConstExpr || obj instanceof BufferMsgCountExpr || obj instanceof Variable || obj instanceof Clock)
			return true;
		if (obj instanceof BoundVariable)
			if (((BoundVariable) obj).getSet() instanceof IntervalSetExpr || ((BoundVariable) obj).getSet() instanceof ClockSetExpr)
				return true;
		if (obj instanceof MumlElemExpr)
			return isInequalityComparable(((MumlElemExpr) obj).getElem());
		
		return false;
	}
	
	@Check
	public void checkComparisonOperators(final ComparisonExpr expr) { //make sure that inequalities are only used on naturally ordered elements
		if (isInequalityComparable(expr.getLhs()) && isInequalityComparable(expr.getRhs()))
			return;
		if (expr.getOp().equals(ComparisonOp.EQUALS) || expr.getOp().equals(ComparisonOp.NOT_EQUAL))
			return;
		error(expr.getOp().toString() + " is not allowed here",null);
	}

	@Check
	public void checkTypesOfComparables(final ComparisonExpr compExpr) { //make sure that the types of elements in comparisons are compatible
		int states = 0; // indicates the number of states used in expr, can be 0, 1 or 2
		int transitions = 0;
		int clockValues = 0; //clocks or constants
		int numerals = 0; //variables or constants
		int buffers = 0;
		// one of these int variables should reach 2 in valid comparisons
		
		for (MapExpr expr : new MapExpr[] {compExpr.getLhs(), compExpr.getRhs()}) {
			if (expr == null)
				return;
			
			if (expr instanceof MumlElemExpr) {
				EObject elem = ((MumlElemExpr) expr).getElem();
				if (elem instanceof de.uni_paderborn.fujaba.muml.realtimestatechart.State)
					states++;
				if (elem instanceof Transition)
					transitions++;
				if (elem instanceof Clock)
					clockValues++;
				if (elem instanceof Variable)
					numerals++;
				if (elem instanceof MessageBuffer)
					buffers++;
			}
			
			if (expr instanceof ConstExpr){
				clockValues++;
				numerals++;
			}
			
			if (expr instanceof SourceStateExpr || expr instanceof TargetStateExpr)
				states++;
			
			if (expr instanceof BufferMsgCountExpr)
				numerals++;
		}
		
		if (states == 2 || transitions == 2 || clockValues == 2 || numerals == 2 || buffers == 2)
			return;
		error("You cannot compare objects of these types", null);
	}
	
	@Check
	public void checkClockComparisonTimeUnits(final ConstExpr expr) { //make sure that every ConstExpr has its TimeUnit set iff it's used in a clock comparison
		boolean isUsedInClockComparison = false;
		
		if (expr.eContainer() instanceof ComparisonExpr) { //set isUsedInClockComparison appropriately
			ComparisonExpr parent = (ComparisonExpr) expr.eContainer();
			isUsedInClockComparison = (parent.getLhs() instanceof MumlElemExpr && ((MumlElemExpr) parent.getLhs()).getElem() instanceof Clock)
										|| (parent.getRhs() instanceof MumlElemExpr && ((MumlElemExpr) parent.getRhs()).getElem() instanceof Clock);
		}
		
		if (isUsedInClockComparison && (expr.getTimeUnit() == null))
			error("Time unit missing", null);
		if (!isUsedInClockComparison && (expr.getTimeUnit() != null))
			error("Not expecting time unit", null);
	}
}
