/*
* generated by Xtext
*/
package de.uni_paderborn.fujaba.muml.verification.uppaal.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class MtctlGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class PropertyRepositoryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyRepository");
		private final Assignment cPropertiesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPropertiesPropertyParserRuleCall_0 = (RuleCall)cPropertiesAssignment.eContents().get(0);
		
		//PropertyRepository returns mtctl::PropertyRepository:
		//	properties+=Property*;
		public ParserRule getRule() { return rule; }

		//properties+=Property*
		public Assignment getPropertiesAssignment() { return cPropertiesAssignment; }

		//Property
		public RuleCall getPropertiesPropertyParserRuleCall_0() { return cPropertiesPropertyParserRuleCall_0; }
	}

	public class PropertyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Property");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCommentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommentSL_COMMENTTerminalRuleCall_2_0 = (RuleCall)cCommentAssignment_2.eContents().get(0);
		
		//Property returns mtctl::Property hidden(WS, ML_COMMENT):
		//	Expression ";" comment=SL_COMMENT?;
		public ParserRule getRule() { return rule; }

		//Expression ";" comment=SL_COMMENT?
		public Group getGroup() { return cGroup; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }

		//comment=SL_COMMENT?
		public Assignment getCommentAssignment_2() { return cCommentAssignment_2; }

		//SL_COMMENT
		public RuleCall getCommentSL_COMMENTTerminalRuleCall_2_0() { return cCommentSL_COMMENTTerminalRuleCall_2_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLeadsToExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression returns mtctl::Expression:
		//	LeadsToExpr;
		public ParserRule getRule() { return rule; }

		//LeadsToExpr
		public RuleCall getLeadsToExprParserRuleCall() { return cLeadsToExprParserRuleCall; }
	}

	public class LeadsToExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LeadsToExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTimeIntervalExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLeadsToExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeadsToKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdTimeIntervalExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		////Binary operators (increasing precedence)
		//LeadsToExpr returns mtctl::Expression:
		//	TimeIntervalExpr ({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=TimeIntervalExpr)*;
		public ParserRule getRule() { return rule; }

		//TimeIntervalExpr ({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=TimeIntervalExpr)*
		public Group getGroup() { return cGroup; }

		//TimeIntervalExpr
		public RuleCall getTimeIntervalExprParserRuleCall_0() { return cTimeIntervalExprParserRuleCall_0; }

		//({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=TimeIntervalExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::LeadsToExpr.leftOpd=current}
		public Action getLeadsToExprLeftOpdAction_1_0() { return cLeadsToExprLeftOpdAction_1_0; }

		//"leadsTo"
		public Keyword getLeadsToKeyword_1_1() { return cLeadsToKeyword_1_1; }

		//rightOpd=TimeIntervalExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//TimeIntervalExpr
		public RuleCall getRightOpdTimeIntervalExprParserRuleCall_1_2_0() { return cRightOpdTimeIntervalExprParserRuleCall_1_2_0; }
	}

	public class TimeIntervalExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimeIntervalExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTimeIntervalKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cTimeIntervalExprAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cLhsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cLhsImplyExprParserRuleCall_0_2_0 = (RuleCall)cLhsAssignment_0_2.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cLowerAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cLowerINTTerminalRuleCall_0_4_0 = (RuleCall)cLowerAssignment_0_4.eContents().get(0);
		private final Keyword cCommaKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Assignment cUpperAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cUpperINTTerminalRuleCall_0_6_0 = (RuleCall)cUpperAssignment_0_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_7 = (Keyword)cGroup_0.eContents().get(7);
		private final Assignment cRhsAssignment_0_8 = (Assignment)cGroup_0.eContents().get(8);
		private final RuleCall cRhsImplyExprParserRuleCall_0_8_0 = (RuleCall)cRhsAssignment_0_8.eContents().get(0);
		private final RuleCall cImplyExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TimeIntervalExpr returns mtctl::Expression:
		//	"timeInterval" {mtctl::TimeIntervalExpr} lhs=ImplyExpr "[" lower=INT "," upper=INT "]" rhs=ImplyExpr | //TODO use units from action lang
		//	ImplyExpr;
		public ParserRule getRule() { return rule; }

		//"timeInterval" {mtctl::TimeIntervalExpr} lhs=ImplyExpr "[" lower=INT "," upper=INT "]" rhs=ImplyExpr | //TODO use units from action lang
		//ImplyExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//"timeInterval" {mtctl::TimeIntervalExpr} lhs=ImplyExpr "[" lower=INT "," upper=INT "]" rhs=ImplyExpr
		public Group getGroup_0() { return cGroup_0; }

		//"timeInterval"
		public Keyword getTimeIntervalKeyword_0_0() { return cTimeIntervalKeyword_0_0; }

		//{mtctl::TimeIntervalExpr}
		public Action getTimeIntervalExprAction_0_1() { return cTimeIntervalExprAction_0_1; }

		//lhs=ImplyExpr
		public Assignment getLhsAssignment_0_2() { return cLhsAssignment_0_2; }

		//ImplyExpr
		public RuleCall getLhsImplyExprParserRuleCall_0_2_0() { return cLhsImplyExprParserRuleCall_0_2_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_3() { return cLeftSquareBracketKeyword_0_3; }

		//lower=INT
		public Assignment getLowerAssignment_0_4() { return cLowerAssignment_0_4; }

		//INT
		public RuleCall getLowerINTTerminalRuleCall_0_4_0() { return cLowerINTTerminalRuleCall_0_4_0; }

		//","
		public Keyword getCommaKeyword_0_5() { return cCommaKeyword_0_5; }

		//upper=INT
		public Assignment getUpperAssignment_0_6() { return cUpperAssignment_0_6; }

		//INT
		public RuleCall getUpperINTTerminalRuleCall_0_6_0() { return cUpperINTTerminalRuleCall_0_6_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_7() { return cRightSquareBracketKeyword_0_7; }

		//rhs=ImplyExpr
		public Assignment getRhsAssignment_0_8() { return cRhsAssignment_0_8; }

		//ImplyExpr
		public RuleCall getRhsImplyExprParserRuleCall_0_8_0() { return cRhsImplyExprParserRuleCall_0_8_0; }

		////TODO use units from action lang
		//ImplyExpr
		public RuleCall getImplyExprParserRuleCall_1() { return cImplyExprParserRuleCall_1; }
	}

	public class ImplyExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImplyExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplyExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImpliesKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdAndExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		//ImplyExpr returns mtctl::Expression:
		//	AndExpr ({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*;
		public ParserRule getRule() { return rule; }

		//AndExpr ({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*
		public Group getGroup() { return cGroup; }

		//AndExpr
		public RuleCall getAndExprParserRuleCall_0() { return cAndExprParserRuleCall_0; }

		//({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::ImplyExpr.leftOpd=current}
		public Action getImplyExprLeftOpdAction_1_0() { return cImplyExprLeftOpdAction_1_0; }

		//"implies"
		public Keyword getImpliesKeyword_1_1() { return cImpliesKeyword_1_1; }

		//rightOpd=AndExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//AndExpr
		public RuleCall getRightOpdAndExprParserRuleCall_1_2_0() { return cRightOpdAndExprParserRuleCall_1_2_0; }
	}

	public class AndExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdOrExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		//AndExpr returns mtctl::Expression:
		//	OrExpr ({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*;
		public ParserRule getRule() { return rule; }

		//OrExpr ({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*
		public Group getGroup() { return cGroup; }

		//OrExpr
		public RuleCall getOrExprParserRuleCall_0() { return cOrExprParserRuleCall_0; }

		//({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::AndExpr.leftOpd=current}
		public Action getAndExprLeftOpdAction_1_0() { return cAndExprLeftOpdAction_1_0; }

		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//rightOpd=OrExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//OrExpr
		public RuleCall getRightOpdOrExprParserRuleCall_1_2_0() { return cRightOpdOrExprParserRuleCall_1_2_0; }
	}

	public class OrExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdNotExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		//OrExpr returns mtctl::Expression:
		//	NotExpr ({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*;
		public ParserRule getRule() { return rule; }

		//NotExpr ({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*
		public Group getGroup() { return cGroup; }

		//NotExpr
		public RuleCall getNotExprParserRuleCall_0() { return cNotExprParserRuleCall_0; }

		//({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::OrExpr.leftOpd=current}
		public Action getOrExprLeftOpdAction_1_0() { return cOrExprLeftOpdAction_1_0; }

		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//rightOpd=NotExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//NotExpr
		public RuleCall getRightOpdNotExprParserRuleCall_1_2_0() { return cRightOpdNotExprParserRuleCall_1_2_0; }
	}

	public class NotExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cNotExprAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cOpdAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOpdNotExprParserRuleCall_0_2_0 = (RuleCall)cOpdAssignment_0_2.eContents().get(0);
		private final RuleCall cQuantifierExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////Unary operators
		//NotExpr returns mtctl::Expression:
		//	"not" {mtctl::NotExpr} opd=NotExpr | QuantifierExpr;
		public ParserRule getRule() { return rule; }

		//"not" {mtctl::NotExpr} opd=NotExpr | QuantifierExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//"not" {mtctl::NotExpr} opd=NotExpr
		public Group getGroup_0() { return cGroup_0; }

		//"not"
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//{mtctl::NotExpr}
		public Action getNotExprAction_0_1() { return cNotExprAction_0_1; }

		//opd=NotExpr
		public Assignment getOpdAssignment_0_2() { return cOpdAssignment_0_2; }

		//NotExpr
		public RuleCall getOpdNotExprParserRuleCall_0_2_0() { return cOpdNotExprParserRuleCall_0_2_0; }

		//QuantifierExpr
		public RuleCall getQuantifierExprParserRuleCall_1() { return cQuantifierExprParserRuleCall_1; }
	}

	public class QuantifierExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantifierExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUniversalQuantExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistentialQuantExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTemporalQuantifierExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAtomExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//QuantifierExpr returns mtctl::Expression:
		//	UniversalQuantExpr | ExistentialQuantExpr | TemporalQuantifierExpr | AtomExpr;
		public ParserRule getRule() { return rule; }

		//UniversalQuantExpr | ExistentialQuantExpr | TemporalQuantifierExpr | AtomExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//UniversalQuantExpr
		public RuleCall getUniversalQuantExprParserRuleCall_0() { return cUniversalQuantExprParserRuleCall_0; }

		//ExistentialQuantExpr
		public RuleCall getExistentialQuantExprParserRuleCall_1() { return cExistentialQuantExprParserRuleCall_1; }

		//TemporalQuantifierExpr
		public RuleCall getTemporalQuantifierExprParserRuleCall_2() { return cTemporalQuantifierExprParserRuleCall_2; }

		//AtomExpr
		public RuleCall getAtomExprParserRuleCall_3() { return cAtomExprParserRuleCall_3; }
	}

	public class UniversalQuantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UniversalQuantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForallKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cUniversalQuantExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cVarAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarVariableBindingParserRuleCall_3_0 = (RuleCall)cVarAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFormulaAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFormulaNotExprParserRuleCall_5_0 = (RuleCall)cFormulaAssignment_5.eContents().get(0);
		
		//UniversalQuantExpr returns mtctl::QuantifierExpr:
		//	"forall" "(" {mtctl::UniversalQuantExpr} var=VariableBinding ")" formula=NotExpr;
		public ParserRule getRule() { return rule; }

		//"forall" "(" {mtctl::UniversalQuantExpr} var=VariableBinding ")" formula=NotExpr
		public Group getGroup() { return cGroup; }

		//"forall"
		public Keyword getForallKeyword_0() { return cForallKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::UniversalQuantExpr}
		public Action getUniversalQuantExprAction_2() { return cUniversalQuantExprAction_2; }

		//var=VariableBinding
		public Assignment getVarAssignment_3() { return cVarAssignment_3; }

		//VariableBinding
		public RuleCall getVarVariableBindingParserRuleCall_3_0() { return cVarVariableBindingParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//formula=NotExpr
		public Assignment getFormulaAssignment_5() { return cFormulaAssignment_5; }

		//NotExpr
		public RuleCall getFormulaNotExprParserRuleCall_5_0() { return cFormulaNotExprParserRuleCall_5_0; }
	}

	public class ExistentialQuantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExistentialQuantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExistsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cExistenceQuantExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cVarAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarVariableBindingParserRuleCall_3_0 = (RuleCall)cVarAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFormulaAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFormulaNotExprParserRuleCall_5_0 = (RuleCall)cFormulaAssignment_5.eContents().get(0);
		
		//ExistentialQuantExpr returns mtctl::QuantifierExpr:
		//	"exists" "(" {mtctl::ExistenceQuantExpr} var=VariableBinding ")" formula=NotExpr;
		public ParserRule getRule() { return rule; }

		//"exists" "(" {mtctl::ExistenceQuantExpr} var=VariableBinding ")" formula=NotExpr
		public Group getGroup() { return cGroup; }

		//"exists"
		public Keyword getExistsKeyword_0() { return cExistsKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::ExistenceQuantExpr}
		public Action getExistenceQuantExprAction_2() { return cExistenceQuantExprAction_2; }

		//var=VariableBinding
		public Assignment getVarAssignment_3() { return cVarAssignment_3; }

		//VariableBinding
		public RuleCall getVarVariableBindingParserRuleCall_3_0() { return cVarVariableBindingParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//formula=NotExpr
		public Assignment getFormulaAssignment_5() { return cFormulaAssignment_5; }

		//NotExpr
		public RuleCall getFormulaNotExprParserRuleCall_5_0() { return cFormulaNotExprParserRuleCall_5_0; }
	}

	public class VariableBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSetSetExprParserRuleCall_2_0 = (RuleCall)cSetAssignment_2.eContents().get(0);
		
		//VariableBinding returns mtctl::BoundVariable:
		//	name=ID ":" set=SetExpr;
		public ParserRule getRule() { return rule; }

		//name=ID ":" set=SetExpr
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//set=SetExpr
		public Assignment getSetAssignment_2() { return cSetAssignment_2; }

		//SetExpr
		public RuleCall getSetSetExprParserRuleCall_2_0() { return cSetSetExprParserRuleCall_2_0; }
	}

	public class TemporalQuantifierExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TemporalQuantifierExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEFExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAFExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEGExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAGExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//TemporalQuantifierExpr returns mtctl::Expression:
		//	EFExpr | AFExpr | EGExpr | AGExpr;
		public ParserRule getRule() { return rule; }

		//EFExpr | AFExpr | EGExpr | AGExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//EFExpr
		public RuleCall getEFExprParserRuleCall_0() { return cEFExprParserRuleCall_0; }

		//AFExpr
		public RuleCall getAFExprParserRuleCall_1() { return cAFExprParserRuleCall_1; }

		//EGExpr
		public RuleCall getEGExprParserRuleCall_2() { return cEGExprParserRuleCall_2; }

		//AGExpr
		public RuleCall getAGExprParserRuleCall_3() { return cAGExprParserRuleCall_3; }
	}

	public class EFExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EFExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cEFKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cEKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cEFExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//EFExpr returns mtctl::TemporalQuantifierExpr:
		//	("EF" | "E<>") {mtctl::EFExpr} expr=NotExpr;
		public ParserRule getRule() { return rule; }

		//("EF" | "E<>") {mtctl::EFExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"EF" | "E<>"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"EF"
		public Keyword getEFKeyword_0_0() { return cEFKeyword_0_0; }

		//"E<>"
		public Keyword getEKeyword_0_1() { return cEKeyword_0_1; }

		//{mtctl::EFExpr}
		public Action getEFExprAction_1() { return cEFExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class AFExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AFExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cAFKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cAKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cAFExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//AFExpr returns mtctl::TemporalQuantifierExpr:
		//	("AF" | "A<>") {mtctl::AFExpr} expr=NotExpr;
		public ParserRule getRule() { return rule; }

		//("AF" | "A<>") {mtctl::AFExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"AF" | "A<>"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"AF"
		public Keyword getAFKeyword_0_0() { return cAFKeyword_0_0; }

		//"A<>"
		public Keyword getAKeyword_0_1() { return cAKeyword_0_1; }

		//{mtctl::AFExpr}
		public Action getAFExprAction_1() { return cAFExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class EGExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EGExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cEGKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cEKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cEGExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//EGExpr returns mtctl::TemporalQuantifierExpr:
		//	("EG" | "E[]") {mtctl::EGExpr} expr=NotExpr;
		public ParserRule getRule() { return rule; }

		//("EG" | "E[]") {mtctl::EGExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"EG" | "E[]"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"EG"
		public Keyword getEGKeyword_0_0() { return cEGKeyword_0_0; }

		//"E[]"
		public Keyword getEKeyword_0_1() { return cEKeyword_0_1; }

		//{mtctl::EGExpr}
		public Action getEGExprAction_1() { return cEGExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class AGExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AGExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cAGKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cAKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cAGExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//AGExpr returns mtctl::TemporalQuantifierExpr:
		//	("AG" | "A[]") {mtctl::AGExpr} expr=NotExpr;
		public ParserRule getRule() { return rule; }

		//("AG" | "A[]") {mtctl::AGExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"AG" | "A[]"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"AG"
		public Keyword getAGKeyword_0_0() { return cAGKeyword_0_0; }

		//"A[]"
		public Keyword getAKeyword_0_1() { return cAKeyword_0_1; }

		//{mtctl::AGExpr}
		public Action getAGExprAction_1() { return cAGExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class AtomExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cPredicateExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cComparisonExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////Bottom of precedence chain.
		//AtomExpr returns mtctl::Expression:
		//	"(" Expression ")" | PredicateExpr | ComparisonExpr;
		public ParserRule getRule() { return rule; }

		//"(" Expression ")" | PredicateExpr | ComparisonExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//PredicateExpr
		public RuleCall getPredicateExprParserRuleCall_1() { return cPredicateExprParserRuleCall_1; }

		//ComparisonExpr
		public RuleCall getComparisonExprParserRuleCall_2() { return cComparisonExprParserRuleCall_2; }
	}

	public class PredicateExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDeadlockExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStateExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMessageExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTransitionExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		////Predicates
		//PredicateExpr returns mtctl::Expression:
		//	DeadlockExpr | StateExpr | MessageExpr | TransitionExpr;
		public ParserRule getRule() { return rule; }

		//DeadlockExpr | StateExpr | MessageExpr | TransitionExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//DeadlockExpr
		public RuleCall getDeadlockExprParserRuleCall_0() { return cDeadlockExprParserRuleCall_0; }

		//StateExpr
		public RuleCall getStateExprParserRuleCall_1() { return cStateExprParserRuleCall_1; }

		//MessageExpr
		public RuleCall getMessageExprParserRuleCall_2() { return cMessageExprParserRuleCall_2; }

		//TransitionExpr
		public RuleCall getTransitionExprParserRuleCall_3() { return cTransitionExprParserRuleCall_3; }
	}

	public class DeadlockExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeadlockExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDeadlockExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDeadlockKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//DeadlockExpr returns mtctl::PredicateExpr:
		//	{mtctl::DeadlockExpr} "deadlock";
		public ParserRule getRule() { return rule; }

		//{mtctl::DeadlockExpr} "deadlock"
		public Group getGroup() { return cGroup; }

		//{mtctl::DeadlockExpr}
		public Action getDeadlockExprAction_0() { return cDeadlockExprAction_0; }

		//"deadlock"
		public Keyword getDeadlockKeyword_1() { return cDeadlockKeyword_1; }
	}

	public class StateExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStateActiveExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubstateOfExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//StateExpr returns mtctl::PredicateExpr:
		//	StateActiveExpr | SubstateOfExpr;
		public ParserRule getRule() { return rule; }

		//StateActiveExpr | SubstateOfExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//StateActiveExpr
		public RuleCall getStateActiveExprParserRuleCall_0() { return cStateActiveExprParserRuleCall_0; }

		//SubstateOfExpr
		public RuleCall getSubstateOfExprParserRuleCall_1() { return cSubstateOfExprParserRuleCall_1; }
	}

	public class StateActiveExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateActiveExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStateActiveKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cStateActiveExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cStateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cStateEObjectCrossReference_3_0 = (CrossReference)cStateAssignment_3.eContents().get(0);
		private final RuleCall cStateEObjectQualifiedNameParserRuleCall_3_0_1 = (RuleCall)cStateEObjectCrossReference_3_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//StateActiveExpr returns mtctl::StateActiveExpr:
		//	"stateActive" "(" {mtctl::StateActiveExpr} state=[ecore::EObject|QualifiedName] ")";
		public ParserRule getRule() { return rule; }

		//"stateActive" "(" {mtctl::StateActiveExpr} state=[ecore::EObject|QualifiedName] ")"
		public Group getGroup() { return cGroup; }

		//"stateActive"
		public Keyword getStateActiveKeyword_0() { return cStateActiveKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::StateActiveExpr}
		public Action getStateActiveExprAction_2() { return cStateActiveExprAction_2; }

		//state=[ecore::EObject|QualifiedName]
		public Assignment getStateAssignment_3() { return cStateAssignment_3; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getStateEObjectCrossReference_3_0() { return cStateEObjectCrossReference_3_0; }

		//QualifiedName
		public RuleCall getStateEObjectQualifiedNameParserRuleCall_3_0_1() { return cStateEObjectQualifiedNameParserRuleCall_3_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class SubstateOfExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubstateOfExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSubstateOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cSubstateOfExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cStateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cStateEObjectCrossReference_3_0 = (CrossReference)cStateAssignment_3.eContents().get(0);
		private final RuleCall cStateEObjectQualifiedNameParserRuleCall_3_0_1 = (RuleCall)cStateEObjectCrossReference_3_0.eContents().get(1);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cSuperstateAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cSuperstateEObjectCrossReference_5_0 = (CrossReference)cSuperstateAssignment_5.eContents().get(0);
		private final RuleCall cSuperstateEObjectQualifiedNameParserRuleCall_5_0_1 = (RuleCall)cSuperstateEObjectCrossReference_5_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//SubstateOfExpr returns mtctl::SubstateOfExpr:
		//	"substateOf" "(" {mtctl::SubstateOfExpr} state=[ecore::EObject|QualifiedName] ","
		//	superstate=[ecore::EObject|QualifiedName] ")";
		public ParserRule getRule() { return rule; }

		//"substateOf" "(" {mtctl::SubstateOfExpr} state=[ecore::EObject|QualifiedName] ","
		//superstate=[ecore::EObject|QualifiedName] ")"
		public Group getGroup() { return cGroup; }

		//"substateOf"
		public Keyword getSubstateOfKeyword_0() { return cSubstateOfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::SubstateOfExpr}
		public Action getSubstateOfExprAction_2() { return cSubstateOfExprAction_2; }

		//state=[ecore::EObject|QualifiedName]
		public Assignment getStateAssignment_3() { return cStateAssignment_3; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getStateEObjectCrossReference_3_0() { return cStateEObjectCrossReference_3_0; }

		//QualifiedName
		public RuleCall getStateEObjectQualifiedNameParserRuleCall_3_0_1() { return cStateEObjectQualifiedNameParserRuleCall_3_0_1; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//superstate=[ecore::EObject|QualifiedName]
		public Assignment getSuperstateAssignment_5() { return cSuperstateAssignment_5; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getSuperstateEObjectCrossReference_5_0() { return cSuperstateEObjectCrossReference_5_0; }

		//QualifiedName
		public RuleCall getSuperstateEObjectQualifiedNameParserRuleCall_5_0_1() { return cSuperstateEObjectQualifiedNameParserRuleCall_5_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class MessageExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMessageInBufferExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMessageInTransitExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBufferOverflowExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//MessageExpr returns mtctl::PredicateExpr:
		//	MessageInBufferExpr | MessageInTransitExpr | BufferOverflowExpr;
		public ParserRule getRule() { return rule; }

		//MessageInBufferExpr | MessageInTransitExpr | BufferOverflowExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//MessageInBufferExpr
		public RuleCall getMessageInBufferExprParserRuleCall_0() { return cMessageInBufferExprParserRuleCall_0; }

		//MessageInTransitExpr
		public RuleCall getMessageInTransitExprParserRuleCall_1() { return cMessageInTransitExprParserRuleCall_1; }

		//BufferOverflowExpr
		public RuleCall getBufferOverflowExprParserRuleCall_2() { return cBufferOverflowExprParserRuleCall_2; }
	}

	public class MessageInTransitExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageInTransitExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMessageInTransitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cMessageInTransitExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cMessageAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cMessageEObjectCrossReference_3_0 = (CrossReference)cMessageAssignment_3.eContents().get(0);
		private final RuleCall cMessageEObjectQualifiedNameParserRuleCall_3_0_1 = (RuleCall)cMessageEObjectCrossReference_3_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MessageInTransitExpr returns mtctl::MessageInTransitExpr:
		//	"messageInTransit" "(" {mtctl::MessageInTransitExpr} message=[ecore::EObject|QualifiedName] //TODO (roleInstance)  ',' role=[ecore::EObject|QualifiedName] 
		//	")";
		public ParserRule getRule() { return rule; }

		//"messageInTransit" "(" {mtctl::MessageInTransitExpr} message=[ecore::EObject|QualifiedName] //TODO (roleInstance)  ',' role=[ecore::EObject|QualifiedName] 
		//")"
		public Group getGroup() { return cGroup; }

		//"messageInTransit"
		public Keyword getMessageInTransitKeyword_0() { return cMessageInTransitKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::MessageInTransitExpr}
		public Action getMessageInTransitExprAction_2() { return cMessageInTransitExprAction_2; }

		//message=[ecore::EObject|QualifiedName]
		public Assignment getMessageAssignment_3() { return cMessageAssignment_3; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getMessageEObjectCrossReference_3_0() { return cMessageEObjectCrossReference_3_0; }

		//QualifiedName
		public RuleCall getMessageEObjectQualifiedNameParserRuleCall_3_0_1() { return cMessageEObjectQualifiedNameParserRuleCall_3_0_1; }

		////TODO (roleInstance)  ',' role=[ecore::EObject|QualifiedName] 
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class MessageInBufferExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageInBufferExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMessageInBufferKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cMessageInBufferExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cRoleAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cRoleEObjectCrossReference_3_0 = (CrossReference)cRoleAssignment_3.eContents().get(0);
		private final RuleCall cRoleEObjectIDTerminalRuleCall_3_0_1 = (RuleCall)cRoleEObjectCrossReference_3_0.eContents().get(1);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cMessageAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cMessageEObjectCrossReference_5_0 = (CrossReference)cMessageAssignment_5.eContents().get(0);
		private final RuleCall cMessageEObjectQualifiedNameParserRuleCall_5_0_1 = (RuleCall)cMessageEObjectCrossReference_5_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//MessageInBufferExpr returns mtctl::MessageInBufferExpr:
		//	"messageInBuffer" "(" {mtctl::MessageInBufferExpr} role=[ecore::EObject] "," message=[ecore::EObject|QualifiedName]
		//	")";
		public ParserRule getRule() { return rule; }

		//"messageInBuffer" "(" {mtctl::MessageInBufferExpr} role=[ecore::EObject] "," message=[ecore::EObject|QualifiedName] ")"
		public Group getGroup() { return cGroup; }

		//"messageInBuffer"
		public Keyword getMessageInBufferKeyword_0() { return cMessageInBufferKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::MessageInBufferExpr}
		public Action getMessageInBufferExprAction_2() { return cMessageInBufferExprAction_2; }

		//role=[ecore::EObject]
		public Assignment getRoleAssignment_3() { return cRoleAssignment_3; }

		//[ecore::EObject]
		public CrossReference getRoleEObjectCrossReference_3_0() { return cRoleEObjectCrossReference_3_0; }

		//ID
		public RuleCall getRoleEObjectIDTerminalRuleCall_3_0_1() { return cRoleEObjectIDTerminalRuleCall_3_0_1; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//message=[ecore::EObject|QualifiedName]
		public Assignment getMessageAssignment_5() { return cMessageAssignment_5; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getMessageEObjectCrossReference_5_0() { return cMessageEObjectCrossReference_5_0; }

		//QualifiedName
		public RuleCall getMessageEObjectQualifiedNameParserRuleCall_5_0_1() { return cMessageEObjectQualifiedNameParserRuleCall_5_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class BufferOverflowExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BufferOverflowExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBufferOverflowExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBufferOverflowKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//BufferOverflowExpr returns mtctl::BufferOverflowExpr:
		//	{mtctl::BufferOverflowExpr} "bufferOverflow";
		public ParserRule getRule() { return rule; }

		//{mtctl::BufferOverflowExpr} "bufferOverflow"
		public Group getGroup() { return cGroup; }

		//{mtctl::BufferOverflowExpr}
		public Action getBufferOverflowExprAction_0() { return cBufferOverflowExprAction_0; }

		//"bufferOverflow"
		public Keyword getBufferOverflowKeyword_1() { return cBufferOverflowKeyword_1; }
	}

	public class TransitionExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransitionExpr");
		private final RuleCall cTransitionFiringExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TransitionExpr returns mtctl::PredicateExpr:
		//	TransitionFiringExpr;
		public ParserRule getRule() { return rule; }

		//TransitionFiringExpr
		public RuleCall getTransitionFiringExprParserRuleCall() { return cTransitionFiringExprParserRuleCall; }
	}

	public class TransitionFiringExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransitionFiringExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTransitionFiringKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cTransitionFiringExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cTransitionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTransitionEObjectCrossReference_3_0 = (CrossReference)cTransitionAssignment_3.eContents().get(0);
		private final RuleCall cTransitionEObjectQualifiedNameParserRuleCall_3_0_1 = (RuleCall)cTransitionEObjectCrossReference_3_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TransitionFiringExpr returns mtctl::TransitionFiringExpr:
		//	"transitionFiring" "(" {mtctl::TransitionFiringExpr} transition=[ecore::EObject|QualifiedName] ")";
		public ParserRule getRule() { return rule; }

		//"transitionFiring" "(" {mtctl::TransitionFiringExpr} transition=[ecore::EObject|QualifiedName] ")"
		public Group getGroup() { return cGroup; }

		//"transitionFiring"
		public Keyword getTransitionFiringKeyword_0() { return cTransitionFiringKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::TransitionFiringExpr}
		public Action getTransitionFiringExprAction_2() { return cTransitionFiringExprAction_2; }

		//transition=[ecore::EObject|QualifiedName]
		public Assignment getTransitionAssignment_3() { return cTransitionAssignment_3; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getTransitionEObjectCrossReference_3_0() { return cTransitionEObjectCrossReference_3_0; }

		//QualifiedName
		public RuleCall getTransitionEObjectQualifiedNameParserRuleCall_3_0_1() { return cTransitionEObjectQualifiedNameParserRuleCall_3_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class ComparisonExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cComparisonExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cLhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cLhsAlternatives_1_0 = (Alternatives)cLhsAssignment_1.eContents().get(0);
		private final RuleCall cLhsPrimitiveVariableExprParserRuleCall_1_0_0 = (RuleCall)cLhsAlternatives_1_0.eContents().get(0);
		private final RuleCall cLhsMapExprParserRuleCall_1_0_1 = (RuleCall)cLhsAlternatives_1_0.eContents().get(1);
		private final RuleCall cLhsConstExprParserRuleCall_1_0_2 = (RuleCall)cLhsAlternatives_1_0.eContents().get(2);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOpComparisonOpEnumRuleCall_2_0 = (RuleCall)cOpAssignment_2.eContents().get(0);
		private final Assignment cRhsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cRhsAlternatives_3_0 = (Alternatives)cRhsAssignment_3.eContents().get(0);
		private final RuleCall cRhsPrimitiveVariableExprParserRuleCall_3_0_0 = (RuleCall)cRhsAlternatives_3_0.eContents().get(0);
		private final RuleCall cRhsMapExprParserRuleCall_3_0_1 = (RuleCall)cRhsAlternatives_3_0.eContents().get(1);
		private final RuleCall cRhsConstExprParserRuleCall_3_0_2 = (RuleCall)cRhsAlternatives_3_0.eContents().get(2);
		
		////Comparisons
		//ComparisonExpr returns mtctl::Expression:
		//	{mtctl::ComparisonExpr} lhs=(PrimitiveVariableExpr | MapExpr | ConstExpr) op=ComparisonOp rhs=(PrimitiveVariableExpr
		//	| MapExpr | ConstExpr);
		public ParserRule getRule() { return rule; }

		//{mtctl::ComparisonExpr} lhs=(PrimitiveVariableExpr | MapExpr | ConstExpr) op=ComparisonOp rhs=(PrimitiveVariableExpr |
		//MapExpr | ConstExpr)
		public Group getGroup() { return cGroup; }

		//{mtctl::ComparisonExpr}
		public Action getComparisonExprAction_0() { return cComparisonExprAction_0; }

		//lhs=(PrimitiveVariableExpr | MapExpr | ConstExpr)
		public Assignment getLhsAssignment_1() { return cLhsAssignment_1; }

		//PrimitiveVariableExpr | MapExpr | ConstExpr
		public Alternatives getLhsAlternatives_1_0() { return cLhsAlternatives_1_0; }

		//PrimitiveVariableExpr
		public RuleCall getLhsPrimitiveVariableExprParserRuleCall_1_0_0() { return cLhsPrimitiveVariableExprParserRuleCall_1_0_0; }

		//MapExpr
		public RuleCall getLhsMapExprParserRuleCall_1_0_1() { return cLhsMapExprParserRuleCall_1_0_1; }

		//ConstExpr
		public RuleCall getLhsConstExprParserRuleCall_1_0_2() { return cLhsConstExprParserRuleCall_1_0_2; }

		//op=ComparisonOp
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }

		//ComparisonOp
		public RuleCall getOpComparisonOpEnumRuleCall_2_0() { return cOpComparisonOpEnumRuleCall_2_0; }

		//rhs=(PrimitiveVariableExpr | MapExpr | ConstExpr)
		public Assignment getRhsAssignment_3() { return cRhsAssignment_3; }

		//PrimitiveVariableExpr | MapExpr | ConstExpr
		public Alternatives getRhsAlternatives_3_0() { return cRhsAlternatives_3_0; }

		//PrimitiveVariableExpr
		public RuleCall getRhsPrimitiveVariableExprParserRuleCall_3_0_0() { return cRhsPrimitiveVariableExprParserRuleCall_3_0_0; }

		//MapExpr
		public RuleCall getRhsMapExprParserRuleCall_3_0_1() { return cRhsMapExprParserRuleCall_3_0_1; }

		//ConstExpr
		public RuleCall getRhsConstExprParserRuleCall_3_0_2() { return cRhsConstExprParserRuleCall_3_0_2; }
	}

	public class MapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MapExpr");
		private final RuleCall cBufferMessageCountExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////Expressions usable in comparisons
		//MapExpr returns mtctl::Expression:
		//	BufferMessageCountExpr;
		public ParserRule getRule() { return rule; }

		//BufferMessageCountExpr
		public RuleCall getBufferMessageCountExprParserRuleCall() { return cBufferMessageCountExprParserRuleCall; }
	}

	public class BufferMessageCountExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BufferMessageCountExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBufferMessageCountKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cBufferMsgCountExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cBufferAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cBufferEObjectCrossReference_3_0 = (CrossReference)cBufferAssignment_3.eContents().get(0);
		private final RuleCall cBufferEObjectQualifiedNameParserRuleCall_3_0_1 = (RuleCall)cBufferEObjectCrossReference_3_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BufferMessageCountExpr returns mtctl::MapExpr:
		//	"bufferMessageCount" "(" {mtctl::BufferMsgCountExpr} buffer=[ecore::EObject|QualifiedName] ")";
		public ParserRule getRule() { return rule; }

		//"bufferMessageCount" "(" {mtctl::BufferMsgCountExpr} buffer=[ecore::EObject|QualifiedName] ")"
		public Group getGroup() { return cGroup; }

		//"bufferMessageCount"
		public Keyword getBufferMessageCountKeyword_0() { return cBufferMessageCountKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::BufferMsgCountExpr}
		public Action getBufferMsgCountExprAction_2() { return cBufferMsgCountExprAction_2; }

		//buffer=[ecore::EObject|QualifiedName]
		public Assignment getBufferAssignment_3() { return cBufferAssignment_3; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getBufferEObjectCrossReference_3_0() { return cBufferEObjectCrossReference_3_0; }

		//QualifiedName
		public RuleCall getBufferEObjectQualifiedNameParserRuleCall_3_0_1() { return cBufferEObjectQualifiedNameParserRuleCall_3_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class PrimitiveVariableExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveVariableExpr");
		private final Assignment cVarAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cVarEObjectCrossReference_0 = (CrossReference)cVarAssignment.eContents().get(0);
		private final RuleCall cVarEObjectQualifiedNameParserRuleCall_0_1 = (RuleCall)cVarEObjectCrossReference_0.eContents().get(1);
		
		//PrimitiveVariableExpr returns mtctl::PrimitiveVariableExpr:
		//	var=[ecore::EObject|QualifiedName];
		public ParserRule getRule() { return rule; }

		//var=[ecore::EObject|QualifiedName]
		public Assignment getVarAssignment() { return cVarAssignment; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getVarEObjectCrossReference_0() { return cVarEObjectCrossReference_0; }

		//QualifiedName
		public RuleCall getVarEObjectQualifiedNameParserRuleCall_0_1() { return cVarEObjectQualifiedNameParserRuleCall_0_1; }
	}

	public class ConstExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValEIntParserRuleCall_1_0 = (RuleCall)cValAssignment_1.eContents().get(0);
		
		//ConstExpr returns mtctl::Expression:
		//	{mtctl::ConstExpr} val=EInt;
		public ParserRule getRule() { return rule; }

		//{mtctl::ConstExpr} val=EInt
		public Group getGroup() { return cGroup; }

		//{mtctl::ConstExpr}
		public Action getConstExprAction_0() { return cConstExprAction_0; }

		//val=EInt
		public Assignment getValAssignment_1() { return cValAssignment_1; }

		//EInt
		public RuleCall getValEIntParserRuleCall_1_0() { return cValEIntParserRuleCall_1_0; }
	}

	public class SetExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntervalSetExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cStateSetExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cStatesKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cTransitionSetExprAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cTransitionsKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cMessageSetExprAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cMessageTypesKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cClockSetExprAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cClocksKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		
		////Sets
		//SetExpr returns mtctl::SetExpr:
		//	IntervalSetExpr | {mtctl::StateSetExpr} "States" | {mtctl::TransitionSetExpr} "Transitions" | {mtctl::MessageSetExpr}
		//	"MessageTypes" | {mtctl::ClockSetExpr} "Clocks";
		public ParserRule getRule() { return rule; }

		//IntervalSetExpr | {mtctl::StateSetExpr} "States" | {mtctl::TransitionSetExpr} "Transitions" | {mtctl::MessageSetExpr}
		//"MessageTypes" | {mtctl::ClockSetExpr} "Clocks"
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntervalSetExpr
		public RuleCall getIntervalSetExprParserRuleCall_0() { return cIntervalSetExprParserRuleCall_0; }

		//{mtctl::StateSetExpr} "States"
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::StateSetExpr}
		public Action getStateSetExprAction_1_0() { return cStateSetExprAction_1_0; }

		//"States"
		public Keyword getStatesKeyword_1_1() { return cStatesKeyword_1_1; }

		//{mtctl::TransitionSetExpr} "Transitions"
		public Group getGroup_2() { return cGroup_2; }

		//{mtctl::TransitionSetExpr}
		public Action getTransitionSetExprAction_2_0() { return cTransitionSetExprAction_2_0; }

		//"Transitions"
		public Keyword getTransitionsKeyword_2_1() { return cTransitionsKeyword_2_1; }

		//{mtctl::MessageSetExpr} "MessageTypes"
		public Group getGroup_3() { return cGroup_3; }

		//{mtctl::MessageSetExpr}
		public Action getMessageSetExprAction_3_0() { return cMessageSetExprAction_3_0; }

		//"MessageTypes"
		public Keyword getMessageTypesKeyword_3_1() { return cMessageTypesKeyword_3_1; }

		//{mtctl::ClockSetExpr} "Clocks"
		public Group getGroup_4() { return cGroup_4; }

		//{mtctl::ClockSetExpr}
		public Action getClockSetExprAction_4_0() { return cClockSetExprAction_4_0; }

		//"Clocks"
		public Keyword getClocksKeyword_4_1() { return cClocksKeyword_4_1; }
	}

	public class IntervalSetExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntervalSetExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntervalSetExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLowerValAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLowerValINTTerminalRuleCall_2_0 = (RuleCall)cLowerValAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cUpperValAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cUpperValINTTerminalRuleCall_4_0 = (RuleCall)cUpperValAssignment_4.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IntervalSetExpr returns mtctl::SetExpr:
		//	{mtctl::IntervalSetExpr} "[" lowerVal=INT "," upperVal=INT "]";
		public ParserRule getRule() { return rule; }

		//{mtctl::IntervalSetExpr} "[" lowerVal=INT "," upperVal=INT "]"
		public Group getGroup() { return cGroup; }

		//{mtctl::IntervalSetExpr}
		public Action getIntervalSetExprAction_0() { return cIntervalSetExprAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//lowerVal=INT
		public Assignment getLowerValAssignment_2() { return cLowerValAssignment_2; }

		//INT
		public RuleCall getLowerValINTTerminalRuleCall_2_0() { return cLowerValINTTerminalRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//upperVal=INT
		public Assignment getUpperValAssignment_4() { return cUpperValAssignment_4; }

		//INT
		public RuleCall getUpperValINTTerminalRuleCall_4_0() { return cUpperValINTTerminalRuleCall_4_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		////Other necessary definitions
		//QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class EIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EInt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//EInt returns ecore::EInt:
		//	"-"? INT;
		public ParserRule getRule() { return rule; }

		//"-"? INT
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	
	public class ComparisonOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATERGreaterThanSignKeyword_1_0 = (Keyword)cGREATEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESSLessThanSignKeyword_3_0 = (Keyword)cLESSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cLESS_OR_EQALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cLESS_OR_EQALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQUALEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNOT_EQUALExclamationMarkEqualsSignKeyword_5_0 = (Keyword)cNOT_EQUALEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum ComparisonOp returns mtctl::ComparisonOp:
		//	EQUALS="==" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQAL="<=" | NOT_EQUAL="!=";
		public EnumRule getRule() { return rule; }

		//EQUALS="==" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQAL="<=" | NOT_EQUAL="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUALS="=="
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQUALSEqualsSignEqualsSignKeyword_0_0() { return cEQUALSEqualsSignEqualsSignKeyword_0_0; }

		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_1() { return cGREATEREnumLiteralDeclaration_1; }

		//">"
		public Keyword getGREATERGreaterThanSignKeyword_1_0() { return cGREATERGreaterThanSignKeyword_1_0; }

		//GREATER_OR_EQUAL=">="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_2() { return cGREATER_OR_EQUALEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0; }

		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_3() { return cLESSEnumLiteralDeclaration_3; }

		//"<"
		public Keyword getLESSLessThanSignKeyword_3_0() { return cLESSLessThanSignKeyword_3_0; }

		//LESS_OR_EQAL="<="
		public EnumLiteralDeclaration getLESS_OR_EQALEnumLiteralDeclaration_4() { return cLESS_OR_EQALEnumLiteralDeclaration_4; }

		//"<="
		public Keyword getLESS_OR_EQALLessThanSignEqualsSignKeyword_4_0() { return cLESS_OR_EQALLessThanSignEqualsSignKeyword_4_0; }

		//NOT_EQUAL="!="
		public EnumLiteralDeclaration getNOT_EQUALEnumLiteralDeclaration_5() { return cNOT_EQUALEnumLiteralDeclaration_5; }

		//"!="
		public Keyword getNOT_EQUALExclamationMarkEqualsSignKeyword_5_0() { return cNOT_EQUALExclamationMarkEqualsSignKeyword_5_0; }
	}
	
	private PropertyRepositoryElements pPropertyRepository;
	private PropertyElements pProperty;
	private ExpressionElements pExpression;
	private LeadsToExprElements pLeadsToExpr;
	private TimeIntervalExprElements pTimeIntervalExpr;
	private ImplyExprElements pImplyExpr;
	private AndExprElements pAndExpr;
	private OrExprElements pOrExpr;
	private NotExprElements pNotExpr;
	private QuantifierExprElements pQuantifierExpr;
	private UniversalQuantExprElements pUniversalQuantExpr;
	private ExistentialQuantExprElements pExistentialQuantExpr;
	private VariableBindingElements pVariableBinding;
	private TemporalQuantifierExprElements pTemporalQuantifierExpr;
	private EFExprElements pEFExpr;
	private AFExprElements pAFExpr;
	private EGExprElements pEGExpr;
	private AGExprElements pAGExpr;
	private AtomExprElements pAtomExpr;
	private PredicateExprElements pPredicateExpr;
	private DeadlockExprElements pDeadlockExpr;
	private StateExprElements pStateExpr;
	private StateActiveExprElements pStateActiveExpr;
	private SubstateOfExprElements pSubstateOfExpr;
	private MessageExprElements pMessageExpr;
	private MessageInTransitExprElements pMessageInTransitExpr;
	private MessageInBufferExprElements pMessageInBufferExpr;
	private BufferOverflowExprElements pBufferOverflowExpr;
	private TransitionExprElements pTransitionExpr;
	private TransitionFiringExprElements pTransitionFiringExpr;
	private ComparisonExprElements pComparisonExpr;
	private ComparisonOpElements unknownRuleComparisonOp;
	private MapExprElements pMapExpr;
	private BufferMessageCountExprElements pBufferMessageCountExpr;
	private PrimitiveVariableExprElements pPrimitiveVariableExpr;
	private ConstExprElements pConstExpr;
	private SetExprElements pSetExpr;
	private IntervalSetExprElements pIntervalSetExpr;
	private QualifiedNameElements pQualifiedName;
	private EIntElements pEInt;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public MtctlGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.uni_paderborn.fujaba.muml.verification.uppaal.Mtctl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//PropertyRepository returns mtctl::PropertyRepository:
	//	properties+=Property*;
	public PropertyRepositoryElements getPropertyRepositoryAccess() {
		return (pPropertyRepository != null) ? pPropertyRepository : (pPropertyRepository = new PropertyRepositoryElements());
	}
	
	public ParserRule getPropertyRepositoryRule() {
		return getPropertyRepositoryAccess().getRule();
	}

	//Property returns mtctl::Property hidden(WS, ML_COMMENT):
	//	Expression ";" comment=SL_COMMENT?;
	public PropertyElements getPropertyAccess() {
		return (pProperty != null) ? pProperty : (pProperty = new PropertyElements());
	}
	
	public ParserRule getPropertyRule() {
		return getPropertyAccess().getRule();
	}

	//Expression returns mtctl::Expression:
	//	LeadsToExpr;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	////Binary operators (increasing precedence)
	//LeadsToExpr returns mtctl::Expression:
	//	TimeIntervalExpr ({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=TimeIntervalExpr)*;
	public LeadsToExprElements getLeadsToExprAccess() {
		return (pLeadsToExpr != null) ? pLeadsToExpr : (pLeadsToExpr = new LeadsToExprElements());
	}
	
	public ParserRule getLeadsToExprRule() {
		return getLeadsToExprAccess().getRule();
	}

	//TimeIntervalExpr returns mtctl::Expression:
	//	"timeInterval" {mtctl::TimeIntervalExpr} lhs=ImplyExpr "[" lower=INT "," upper=INT "]" rhs=ImplyExpr | //TODO use units from action lang
	//	ImplyExpr;
	public TimeIntervalExprElements getTimeIntervalExprAccess() {
		return (pTimeIntervalExpr != null) ? pTimeIntervalExpr : (pTimeIntervalExpr = new TimeIntervalExprElements());
	}
	
	public ParserRule getTimeIntervalExprRule() {
		return getTimeIntervalExprAccess().getRule();
	}

	//ImplyExpr returns mtctl::Expression:
	//	AndExpr ({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*;
	public ImplyExprElements getImplyExprAccess() {
		return (pImplyExpr != null) ? pImplyExpr : (pImplyExpr = new ImplyExprElements());
	}
	
	public ParserRule getImplyExprRule() {
		return getImplyExprAccess().getRule();
	}

	//AndExpr returns mtctl::Expression:
	//	OrExpr ({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*;
	public AndExprElements getAndExprAccess() {
		return (pAndExpr != null) ? pAndExpr : (pAndExpr = new AndExprElements());
	}
	
	public ParserRule getAndExprRule() {
		return getAndExprAccess().getRule();
	}

	//OrExpr returns mtctl::Expression:
	//	NotExpr ({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*;
	public OrExprElements getOrExprAccess() {
		return (pOrExpr != null) ? pOrExpr : (pOrExpr = new OrExprElements());
	}
	
	public ParserRule getOrExprRule() {
		return getOrExprAccess().getRule();
	}

	////Unary operators
	//NotExpr returns mtctl::Expression:
	//	"not" {mtctl::NotExpr} opd=NotExpr | QuantifierExpr;
	public NotExprElements getNotExprAccess() {
		return (pNotExpr != null) ? pNotExpr : (pNotExpr = new NotExprElements());
	}
	
	public ParserRule getNotExprRule() {
		return getNotExprAccess().getRule();
	}

	//QuantifierExpr returns mtctl::Expression:
	//	UniversalQuantExpr | ExistentialQuantExpr | TemporalQuantifierExpr | AtomExpr;
	public QuantifierExprElements getQuantifierExprAccess() {
		return (pQuantifierExpr != null) ? pQuantifierExpr : (pQuantifierExpr = new QuantifierExprElements());
	}
	
	public ParserRule getQuantifierExprRule() {
		return getQuantifierExprAccess().getRule();
	}

	//UniversalQuantExpr returns mtctl::QuantifierExpr:
	//	"forall" "(" {mtctl::UniversalQuantExpr} var=VariableBinding ")" formula=NotExpr;
	public UniversalQuantExprElements getUniversalQuantExprAccess() {
		return (pUniversalQuantExpr != null) ? pUniversalQuantExpr : (pUniversalQuantExpr = new UniversalQuantExprElements());
	}
	
	public ParserRule getUniversalQuantExprRule() {
		return getUniversalQuantExprAccess().getRule();
	}

	//ExistentialQuantExpr returns mtctl::QuantifierExpr:
	//	"exists" "(" {mtctl::ExistenceQuantExpr} var=VariableBinding ")" formula=NotExpr;
	public ExistentialQuantExprElements getExistentialQuantExprAccess() {
		return (pExistentialQuantExpr != null) ? pExistentialQuantExpr : (pExistentialQuantExpr = new ExistentialQuantExprElements());
	}
	
	public ParserRule getExistentialQuantExprRule() {
		return getExistentialQuantExprAccess().getRule();
	}

	//VariableBinding returns mtctl::BoundVariable:
	//	name=ID ":" set=SetExpr;
	public VariableBindingElements getVariableBindingAccess() {
		return (pVariableBinding != null) ? pVariableBinding : (pVariableBinding = new VariableBindingElements());
	}
	
	public ParserRule getVariableBindingRule() {
		return getVariableBindingAccess().getRule();
	}

	//TemporalQuantifierExpr returns mtctl::Expression:
	//	EFExpr | AFExpr | EGExpr | AGExpr;
	public TemporalQuantifierExprElements getTemporalQuantifierExprAccess() {
		return (pTemporalQuantifierExpr != null) ? pTemporalQuantifierExpr : (pTemporalQuantifierExpr = new TemporalQuantifierExprElements());
	}
	
	public ParserRule getTemporalQuantifierExprRule() {
		return getTemporalQuantifierExprAccess().getRule();
	}

	//EFExpr returns mtctl::TemporalQuantifierExpr:
	//	("EF" | "E<>") {mtctl::EFExpr} expr=NotExpr;
	public EFExprElements getEFExprAccess() {
		return (pEFExpr != null) ? pEFExpr : (pEFExpr = new EFExprElements());
	}
	
	public ParserRule getEFExprRule() {
		return getEFExprAccess().getRule();
	}

	//AFExpr returns mtctl::TemporalQuantifierExpr:
	//	("AF" | "A<>") {mtctl::AFExpr} expr=NotExpr;
	public AFExprElements getAFExprAccess() {
		return (pAFExpr != null) ? pAFExpr : (pAFExpr = new AFExprElements());
	}
	
	public ParserRule getAFExprRule() {
		return getAFExprAccess().getRule();
	}

	//EGExpr returns mtctl::TemporalQuantifierExpr:
	//	("EG" | "E[]") {mtctl::EGExpr} expr=NotExpr;
	public EGExprElements getEGExprAccess() {
		return (pEGExpr != null) ? pEGExpr : (pEGExpr = new EGExprElements());
	}
	
	public ParserRule getEGExprRule() {
		return getEGExprAccess().getRule();
	}

	//AGExpr returns mtctl::TemporalQuantifierExpr:
	//	("AG" | "A[]") {mtctl::AGExpr} expr=NotExpr;
	public AGExprElements getAGExprAccess() {
		return (pAGExpr != null) ? pAGExpr : (pAGExpr = new AGExprElements());
	}
	
	public ParserRule getAGExprRule() {
		return getAGExprAccess().getRule();
	}

	////Bottom of precedence chain.
	//AtomExpr returns mtctl::Expression:
	//	"(" Expression ")" | PredicateExpr | ComparisonExpr;
	public AtomExprElements getAtomExprAccess() {
		return (pAtomExpr != null) ? pAtomExpr : (pAtomExpr = new AtomExprElements());
	}
	
	public ParserRule getAtomExprRule() {
		return getAtomExprAccess().getRule();
	}

	////Predicates
	//PredicateExpr returns mtctl::Expression:
	//	DeadlockExpr | StateExpr | MessageExpr | TransitionExpr;
	public PredicateExprElements getPredicateExprAccess() {
		return (pPredicateExpr != null) ? pPredicateExpr : (pPredicateExpr = new PredicateExprElements());
	}
	
	public ParserRule getPredicateExprRule() {
		return getPredicateExprAccess().getRule();
	}

	//DeadlockExpr returns mtctl::PredicateExpr:
	//	{mtctl::DeadlockExpr} "deadlock";
	public DeadlockExprElements getDeadlockExprAccess() {
		return (pDeadlockExpr != null) ? pDeadlockExpr : (pDeadlockExpr = new DeadlockExprElements());
	}
	
	public ParserRule getDeadlockExprRule() {
		return getDeadlockExprAccess().getRule();
	}

	//StateExpr returns mtctl::PredicateExpr:
	//	StateActiveExpr | SubstateOfExpr;
	public StateExprElements getStateExprAccess() {
		return (pStateExpr != null) ? pStateExpr : (pStateExpr = new StateExprElements());
	}
	
	public ParserRule getStateExprRule() {
		return getStateExprAccess().getRule();
	}

	//StateActiveExpr returns mtctl::StateActiveExpr:
	//	"stateActive" "(" {mtctl::StateActiveExpr} state=[ecore::EObject|QualifiedName] ")";
	public StateActiveExprElements getStateActiveExprAccess() {
		return (pStateActiveExpr != null) ? pStateActiveExpr : (pStateActiveExpr = new StateActiveExprElements());
	}
	
	public ParserRule getStateActiveExprRule() {
		return getStateActiveExprAccess().getRule();
	}

	//SubstateOfExpr returns mtctl::SubstateOfExpr:
	//	"substateOf" "(" {mtctl::SubstateOfExpr} state=[ecore::EObject|QualifiedName] ","
	//	superstate=[ecore::EObject|QualifiedName] ")";
	public SubstateOfExprElements getSubstateOfExprAccess() {
		return (pSubstateOfExpr != null) ? pSubstateOfExpr : (pSubstateOfExpr = new SubstateOfExprElements());
	}
	
	public ParserRule getSubstateOfExprRule() {
		return getSubstateOfExprAccess().getRule();
	}

	//MessageExpr returns mtctl::PredicateExpr:
	//	MessageInBufferExpr | MessageInTransitExpr | BufferOverflowExpr;
	public MessageExprElements getMessageExprAccess() {
		return (pMessageExpr != null) ? pMessageExpr : (pMessageExpr = new MessageExprElements());
	}
	
	public ParserRule getMessageExprRule() {
		return getMessageExprAccess().getRule();
	}

	//MessageInTransitExpr returns mtctl::MessageInTransitExpr:
	//	"messageInTransit" "(" {mtctl::MessageInTransitExpr} message=[ecore::EObject|QualifiedName] //TODO (roleInstance)  ',' role=[ecore::EObject|QualifiedName] 
	//	")";
	public MessageInTransitExprElements getMessageInTransitExprAccess() {
		return (pMessageInTransitExpr != null) ? pMessageInTransitExpr : (pMessageInTransitExpr = new MessageInTransitExprElements());
	}
	
	public ParserRule getMessageInTransitExprRule() {
		return getMessageInTransitExprAccess().getRule();
	}

	//MessageInBufferExpr returns mtctl::MessageInBufferExpr:
	//	"messageInBuffer" "(" {mtctl::MessageInBufferExpr} role=[ecore::EObject] "," message=[ecore::EObject|QualifiedName]
	//	")";
	public MessageInBufferExprElements getMessageInBufferExprAccess() {
		return (pMessageInBufferExpr != null) ? pMessageInBufferExpr : (pMessageInBufferExpr = new MessageInBufferExprElements());
	}
	
	public ParserRule getMessageInBufferExprRule() {
		return getMessageInBufferExprAccess().getRule();
	}

	//BufferOverflowExpr returns mtctl::BufferOverflowExpr:
	//	{mtctl::BufferOverflowExpr} "bufferOverflow";
	public BufferOverflowExprElements getBufferOverflowExprAccess() {
		return (pBufferOverflowExpr != null) ? pBufferOverflowExpr : (pBufferOverflowExpr = new BufferOverflowExprElements());
	}
	
	public ParserRule getBufferOverflowExprRule() {
		return getBufferOverflowExprAccess().getRule();
	}

	//TransitionExpr returns mtctl::PredicateExpr:
	//	TransitionFiringExpr;
	public TransitionExprElements getTransitionExprAccess() {
		return (pTransitionExpr != null) ? pTransitionExpr : (pTransitionExpr = new TransitionExprElements());
	}
	
	public ParserRule getTransitionExprRule() {
		return getTransitionExprAccess().getRule();
	}

	//TransitionFiringExpr returns mtctl::TransitionFiringExpr:
	//	"transitionFiring" "(" {mtctl::TransitionFiringExpr} transition=[ecore::EObject|QualifiedName] ")";
	public TransitionFiringExprElements getTransitionFiringExprAccess() {
		return (pTransitionFiringExpr != null) ? pTransitionFiringExpr : (pTransitionFiringExpr = new TransitionFiringExprElements());
	}
	
	public ParserRule getTransitionFiringExprRule() {
		return getTransitionFiringExprAccess().getRule();
	}

	////Comparisons
	//ComparisonExpr returns mtctl::Expression:
	//	{mtctl::ComparisonExpr} lhs=(PrimitiveVariableExpr | MapExpr | ConstExpr) op=ComparisonOp rhs=(PrimitiveVariableExpr
	//	| MapExpr | ConstExpr);
	public ComparisonExprElements getComparisonExprAccess() {
		return (pComparisonExpr != null) ? pComparisonExpr : (pComparisonExpr = new ComparisonExprElements());
	}
	
	public ParserRule getComparisonExprRule() {
		return getComparisonExprAccess().getRule();
	}

	//enum ComparisonOp returns mtctl::ComparisonOp:
	//	EQUALS="==" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQAL="<=" | NOT_EQUAL="!=";
	public ComparisonOpElements getComparisonOpAccess() {
		return (unknownRuleComparisonOp != null) ? unknownRuleComparisonOp : (unknownRuleComparisonOp = new ComparisonOpElements());
	}
	
	public EnumRule getComparisonOpRule() {
		return getComparisonOpAccess().getRule();
	}

	////Expressions usable in comparisons
	//MapExpr returns mtctl::Expression:
	//	BufferMessageCountExpr;
	public MapExprElements getMapExprAccess() {
		return (pMapExpr != null) ? pMapExpr : (pMapExpr = new MapExprElements());
	}
	
	public ParserRule getMapExprRule() {
		return getMapExprAccess().getRule();
	}

	//BufferMessageCountExpr returns mtctl::MapExpr:
	//	"bufferMessageCount" "(" {mtctl::BufferMsgCountExpr} buffer=[ecore::EObject|QualifiedName] ")";
	public BufferMessageCountExprElements getBufferMessageCountExprAccess() {
		return (pBufferMessageCountExpr != null) ? pBufferMessageCountExpr : (pBufferMessageCountExpr = new BufferMessageCountExprElements());
	}
	
	public ParserRule getBufferMessageCountExprRule() {
		return getBufferMessageCountExprAccess().getRule();
	}

	//PrimitiveVariableExpr returns mtctl::PrimitiveVariableExpr:
	//	var=[ecore::EObject|QualifiedName];
	public PrimitiveVariableExprElements getPrimitiveVariableExprAccess() {
		return (pPrimitiveVariableExpr != null) ? pPrimitiveVariableExpr : (pPrimitiveVariableExpr = new PrimitiveVariableExprElements());
	}
	
	public ParserRule getPrimitiveVariableExprRule() {
		return getPrimitiveVariableExprAccess().getRule();
	}

	//ConstExpr returns mtctl::Expression:
	//	{mtctl::ConstExpr} val=EInt;
	public ConstExprElements getConstExprAccess() {
		return (pConstExpr != null) ? pConstExpr : (pConstExpr = new ConstExprElements());
	}
	
	public ParserRule getConstExprRule() {
		return getConstExprAccess().getRule();
	}

	////Sets
	//SetExpr returns mtctl::SetExpr:
	//	IntervalSetExpr | {mtctl::StateSetExpr} "States" | {mtctl::TransitionSetExpr} "Transitions" | {mtctl::MessageSetExpr}
	//	"MessageTypes" | {mtctl::ClockSetExpr} "Clocks";
	public SetExprElements getSetExprAccess() {
		return (pSetExpr != null) ? pSetExpr : (pSetExpr = new SetExprElements());
	}
	
	public ParserRule getSetExprRule() {
		return getSetExprAccess().getRule();
	}

	//IntervalSetExpr returns mtctl::SetExpr:
	//	{mtctl::IntervalSetExpr} "[" lowerVal=INT "," upperVal=INT "]";
	public IntervalSetExprElements getIntervalSetExprAccess() {
		return (pIntervalSetExpr != null) ? pIntervalSetExpr : (pIntervalSetExpr = new IntervalSetExprElements());
	}
	
	public ParserRule getIntervalSetExprRule() {
		return getIntervalSetExprAccess().getRule();
	}

	////Other necessary definitions
	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//EInt returns ecore::EInt:
	//	"-"? INT;
	public EIntElements getEIntAccess() {
		return (pEInt != null) ? pEInt : (pEInt = new EIntElements());
	}
	
	public ParserRule getEIntRule() {
		return getEIntAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
