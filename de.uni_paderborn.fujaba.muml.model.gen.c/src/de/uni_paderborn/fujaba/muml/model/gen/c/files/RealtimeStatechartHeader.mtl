[comment encoding = UTF-8 /]
[**
 * The documentation of the module RealtimeStatechartHeader.
 */]
[module RealtimeStatechartHeader('http://www.fujaba.de/muml/connector/0.4.0', 'http://www.fujaba.de/muml/behavior/0.4.0',
				'http://www.storydriven.org/core/0.3.1',
				'http://www.fujaba.de/muml/actionlanguage/0.4.0',
				'http://www.fujaba.de/muml/msgtype/0.4.0',
				'http://www.fujaba.de/muml/types/0.4.0',
				'http://www.fujaba.de/modelinstance/0.4.0',
				'http://www.fujaba.de/muml/component/0.4.0',
				'http://www.fujaba.de/muml/instance/0.4.0',
				'http://www.fujaba.de/muml/realtimestatechart/0.4.0')]

[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::stringQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::modelQueries]

[**
 * The documentation of the template generateElement.
 * @param anOclAny
 */]
[template public generate_RTSCHeader(comp: Component, rtsc : RealtimeStatechart, path : String) post(trim())]

[file (path+getFileName(rtsc, true, false), false, 'UTF-8')]

#ifndef [getHeaderDefine(rtsc)/]
#define [getHeaderDefine(rtsc)/]

[includes(comp, rtsc)/]
//ENUM
	[variables(comp, rtsc)/]

//METHOD STUBS
	[constructor(rtsc)/]
	[initialize(rtsc)/]
	[destroy(rtsc)/]		
	[process(rtsc)/]

	[exit(rtsc)/]
			
	[isInState(rtsc)/]
	[isTerminated(rtsc)/]

#endif /* [getHeaderDefine(rtsc)/] */
[/file]
[/template]


[**
 * Generates includes
 * 
 * @param statechart
*/]
[template public includes (comp:Component, rtsc : RealtimeStatechart) post(trim())]
#include "../lib/clock.h"
#include "../lib/syncChannel.h"
#include "../[comp.getFileName(true)/]"
[if (rtsc.eAllContents(Operation)->size() > 0)]#include "../operations/operations.h"[/if]
[/template]

[**
 * Generates the enum for the statechart.
 * 
 * @param statechart
*/]
[template private variables (comp: Component, rtsc: RealtimeStatechart) post(trim())]
	typedef enum {
				[for (state : State | rtsc.states) separator (',')]
			[getStateNames(state)/]	
		[/for]
	}[getClassName(rtsc, true)/];


struct [getClassName(rtsc)/] {	
		[comment Member variable for the parent component. /]	
		[comp.getClassName()/] * parentComponent;		


					[getClassName(rtsc, true)/] [getVariableName(rtsc)/];
		[comment Member variables for the current state of each region. /]	

		[for (region : Region | rtsc.eAllContents(Region))]
			[getClassName(rtsc, true)/] [getVariableName(region.embeddedStatechart)/];
		[/for]
		[comment]
		[for (state : State | rtsc.states)]

				[if (not state.oclAsType(State).simple)]
					[for (region : Region | state.embeddedRegions)]	
				[getClassName(rtsc, true)/] [getVariableName(region.embeddedStatechart)/];
						[for (innerState : State | region.embeddedStatechart.states)]
							[if (not innerState.oclAsType(State).simple)]
								[for (innerRegion : Region | innerState.embeddedRegions)]	
				[getClassName(rtsc, true)/] [getVariableName(innerRegion.embeddedStatechart)/];
								[/for]
							[/if]
						[/for]		
					[/for]
				[/if]
		[/for]
		[/comment]
	
		[comment Member variables for the clocks of each region. /]
		[for (clock : Clock | rtsc.eAllContents(Clock))]
			Clock [getVariableName(clock)/];
		[/for]
	
		[comment @TODO Member variables for the clocks of after transitions. /]	
		
	
		[comment Member variables for the clocks of do actions. /]
		[for (state : State | rtsc.states) ? (not state.doEvent.oclIsUndefined() and state.doEvent.action.extension->size()>0)]
			Clock [getClockVariableName(state)/];
		[/for]
	

		
		[comment Member variables for the variables of each region. /]	
		[for (var : Variable | rtsc.eAllContents(Variable))]
			[comment]			
			[if (variable.kind = VariableKind::EXTERN)]extern[elseif (variable.scope = VariableScope::LOCAL)]static[/if]
			[/comment] 
			[getTypeName(var)/] [getVariableName(var)/];
		[/for]
	
		[for (port : Port | comp.ports) ? (oclIsKindOf(HybridPort))]
			[let hPort : HybridPort = port.oclAsType(HybridPort)]
				[hPort.dataType.getTypeName()/] [hPort.getVariableName()/];
			[/let]		
		[/for]


		[comment Member variables for the synchronization channels /]	
		[for (syncChannel : SynchronizationChannel | rtsc.eAllContents(State)->collect(channels)->asSet())]
			[getClassName(syncChannel)/]* [getVariableName(syncChannel)/];
		[/for]
	} ;
[/template]


[template private getStateNames (state : State) post(trim())]
[getName(state)/]
[if not (state.simple)],
	[for (innerState : State | state.embeddedRegions.embeddedStatechart.states) separator (',')]
		[getStateNames(innerState)/]
	[/for]
[/if]
[/template]

[**
 * Generates header of the constructor of the statechart
 * 
 * @param statechart
*/]
[template public constructor (rtsc : RealtimeStatechart) post(trim())]
	[getClassName(rtsc)/]* [getConstructorName(rtsc)/]();
[/template]

[template private initialize (rtsc : RealtimeStatechart) post(trim())]
	void [getInitializeMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[for (region: Region | rtsc.eAllContents(Region))]
	void [getInitializeMethodName(region)/]([getSuperClassName(rtsc)/]* stateChart);
[/for]
[/template]

[template private destroy(rtsc : RealtimeStatechart) post(trim())]
	void [getDestroyMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]

[template private process (rtsc : RealtimeStatechart) post(trim())]
	void [getProcessMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]

[template private exit (rtsc : RealtimeStatechart) post(trim())]
	[for (region : Region | rtsc.getAllRegions())]
	void [getExitMethodName(region)/]([getClassName(rtsc)/]* rtsc);
	[/for]
[/template]

[template private isInState (rtsc : RealtimeStatechart) post(trim())]
	int [getIsInStateMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc, [getClassName(rtsc, true)/] state);
[/template]
[template private isTerminated (rtsc : RealtimeStatechart) post(trim())]
	bool [getTerminateMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]


