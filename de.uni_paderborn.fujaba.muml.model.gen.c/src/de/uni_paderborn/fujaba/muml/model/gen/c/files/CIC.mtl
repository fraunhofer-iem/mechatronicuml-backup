[comment encoding = UTF-8 /]
[**
 * This module contains all templates, that are used to generate the Configuration-files
 * for a given CIC.
 */]
[module CIC('http://www.fujaba.de/muml/connector/0.4.0', 'http://www.fujaba.de/muml/behavior/0.4.0',
				'http://www.storydriven.org/core/0.3.1',
				'http://www.fujaba.de/muml/actionlanguage/0.4.0',
				'http://www.fujaba.de/muml/msgtype/0.4.0',
				'http://www.fujaba.de/muml/types/0.4.0',
				'http://www.fujaba.de/modelinstance/0.4.0',
				'http://www.fujaba.de/muml/component/0.4.0',
				'http://www.fujaba.de/muml/instance/0.4.0',
				'http://www.fujaba.de/muml/realtimestatechart/0.4.0',
				'http://www.fujaba.de/muml/hardware/1.0/',
				'http://www.fujaba.de/muml/psm/codegen/0.1.0',
				'http://www.fujaba.de/muml/swplatform/0.4.0/',
				'http://www.fujaba.de/muml/psm/0.4.0/')]


[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::stringQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::modelQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::middlewareQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::actionlanguage::expression]
[import de::uni_paderborn::fujaba::muml::model::gen::c::files::RealtimeStatechart]


[**
 * Generates the implementation file "Configuration.c" for a given RSRI.
 * 
 * @param rsri The RefinedStructuredResourceInstance for which the file "Configuration.c" will be generated.
 * @param path The relative path to the target folder of this file.
 */]
[template public generateCICClass(rsri : RefinedStructuredResourceInstance, path: String)]
	[file (path+'Configuration.c', false, 'UTF-8')]
		#include "Configuration.h"
	void [getConfigureMethodName(rsri)/](void){

MessageID * messageIDsOfbuffer;
	[comment create component instances/]
	[for (ci : AtomicComponentInstance | rsri.allocatedAtomicComponentInstances.oclAsType(AtomicComponentInstance))]
		//create instance [ci.getName()/] of type [ci.componentType.getClassName()/]
		 mw->[ci.getVariableName()/] = [ci.getCreateMethodName()/]();
		[comment create ports for component/]
		[for (portInst : DiscretePortInstance | ci.eAllContents(DiscretePortInstance))]
		[let port : DiscretePort = portInst.portType]
			[comment if the port is kind of IN-port, we need to generate all port properties, like supported messagesIDs and buffers/]
			[if (port.isDiscreteInPort or port.isDiscreteInOutPort)]
				[comment create port property objects/]
				[for (msgBuffer : MessageBuffer | port.receiverMessageBuffer)]
					messageIDsOfbuffer = (MessageID*) calloc([msgBuffer.messageType->size()/],sizeof(MessageID));
					[for (msgType: MessageType| port.receiverMessageTypes)]
						messageIDsOfbuffer['['/][i-1/][']'/] = [msgType.getIdentifierVariableName()/];
					[/for]
					MessageBuffer* buffer[i/]of[portInst.getName()/][port.getName()/] = MessageBuffer_create([msgBuffer.getSizeOfMessageBuffer()/],false,[msgBuffer.messageType->size()/],messageIDsOfbuffer);
				[/for]
				MessageBuffer** allBuffersOf[portInst.getName()/][port.getName()/] = (MessageBuffer**) malloc([port.receiverMessageBuffer->size()/]*sizeof(MessageBuffer*));
				[for (buf : MessageBuffer | port.receiverMessageBuffer)]
				allBuffersOf[portInst.getName()/][port.getName()/]['['/][i-1/][']'/] = buffer[i/]of[portInst.getName()/][port.getName()/];
				[/for]
	
				[comment create port/]
				mw->[ci.getVariableName()/]->[port.getVariableName()/] = Port_create([portInst.getIdentifierVariableName()/], [port.getNumberOfMessageBuffers()/], allBuffersOf[portInst.getName()/][port.getName()/]);
			
			[comment if the port is just an OUT-port, we only need to set the ID of the port and create the object/]
			[elseif port.isDiscreteOutPort]
			[comment create port/]
			mw->[ci.getVariableName()/]->[port.getVariableName()/] = Port_create([portInst.getIdentifierVariableName()/], 0, NULL);

			[/if]
		[/let]
		[/for]
		[comment create behavior for component/]
		//create behavior for component [ci.getVariableName()/]
		mw->[ci.getVariableName()/]->stateChart = [ci.componentType.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart).getCreateMethodName()/](mw->[ci.getVariableName()/]);
		[if (ci.componentType.oclAsType(AtomicComponent).behavior.oclIsKindOf(ParameterizedRealtimeStatechart))]
		[for (apiCall : APICallParameterBinding | ci.eAllContents(APICallParameterBinding))]
		mw->[ci.getVariableName()/]->stateChart->[apiCall.getRTSCPointerName()/] = [apiCall.getMethodName()/];
		[/for]
		[/if]
[/for]

	//call the initialize method after generation
	[getInitializeMethodName(rsri)/]();

}

[comment create the initialize function for the RSRI/]
///////////////////////////////////////
/// \brief Initialize function for RSRI [rsri.getName()/]
/// This is the initialize function for RSRI [rsri.getName()/]. This function calls the initialization function
/// for the middleware of the ECU and of all AtomicComponentInstances which are allocated on this RSRI.
//////////////////////////////////////
void [getInitializeMethodName(rsri)/](void){
 
  //init component instances (inside of this init-functions,
  //the ports ands and the RTSC of the component instance is initialized
  [comment generate the call of the initialize function of every allocated AtomicComponentInstance/]
  [for (ci : AtomicComponentInstance | rsri.allocatedAtomicComponentInstances.oclAsType(AtomicComponentInstance))]
	  [ci.getInitializeMethodName()/](mw->[ci.getVariableName()/]);
  [/for]
	
}
	[/file]
[/template]
