[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate_rtsc.
 */]
[module componentHeader('http://www.fujaba.de/muml/connector/0.4.0', 'http://www.fujaba.de/muml/behavior/0.4.0',
				'http://www.storydriven.org/core/0.3.1',
				'http://www.fujaba.de/muml/actionlanguage/0.4.0',
				'http://www.fujaba.de/muml/msgtype/0.4.0',
				'http://www.fujaba.de/muml/types/0.4.0',
				'http://www.fujaba.de/modelinstance/0.4.0',
				'http://www.fujaba.de/muml/component/0.4.0',
				'http://www.fujaba.de/muml/instance/0.4.0',
				'http://www.fujaba.de/muml/realtimestatechart/0.4.0')]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::stringQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::queries::modelQueries]
[import de::uni_paderborn::fujaba::muml::model::gen::c::actionlanguage::expression]
[import de::uni_paderborn::fujaba::muml::model::gen::c::files::RealtimeStatechart]


[**
 * Generates the class for the given component.
 * 
 * @param component The component for which the class will be generated.
 * @param statechart The behaviour of the component, if one exist otherwise null.
 */]
[template public generate_ComponentHeader(component : Component, path : String)]
	[file (path+getFileName(component, true), false, 'UTF-8')]

		#ifndef [getHeaderDefine(component)/]
		#define [getHeaderDefine(component)/]
			[includes(component)/]
	
			[variables(component)/]
		
			[initialize(component)/]
	
			[constructor(component)/]
	
			[destroy(component)/]
		
			[isTerminated(component)/]
			
			[processStep(component)/]
		
			[getterAndSetter(component)/]
	
			[createHybridPortMethods(component)/]
		
			[queueMethods(component)/]
	
			[comment @TODO connect(component)/]


		#endif /* [getHeaderDefine(component)/] */
	[/file]
[/template]

[**
 * @param component
 * @param statechart
*/]
[template public includes(component : Component)]
	// Library
	#include "../lib/types.h"
	[if (component.eAllContents(DiscretePort)->size()>0)]
		#include "../lib/ports/discretePort.h"
		#include "../msg/messages.h"
		[comment]
		[let portList : Sequence(DiscretePort) = component.eAllContents(DiscretePort)]
		[for (rep: MessageTypeRepository | portList.receiverMessageTypes->union(portList.senderMessageTypes).repository->asOrderedSet())]
		#include "../[rep.getFileName(true)/]"
		[/for]
		[/let]
		[/comment]
	[/if]
	[if (component.ports.eAllContents(ContinuousPort)->size() > 0)]
		#warning ContinuosPorts are not supported yet.		
	[/if]
	[if component.oclIsKindOf(StructuredComponent)]	
	[if (component.oclAsType(StructuredComponent).connectors->size() > 0)]
		#include "../lib/discreteConnection.h"
		#include "../lib/discreteConnectionList.h"
	[comment @TODO only inlcude, if needed/]
		#include "../lib/continuousConnection.h"
	[/if]	


	// Generated implementation
	
	[for (subComponent : Component | component.oclAsType(StructuredComponent).embeddedComponentParts.componentType->asSet())]
		#include "../[getFileName(subComponent, true)/]"	
	[/for]

	[/if]
	[if (component.oclIsKindOf(AtomicComponent))]
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior]
		//#include "../[getFileName(rtsc, true,false)/]"	
	[/let]
	[/if]
[/template]

[**
 * Generates the member variables.
 * 
 * @param component
 * @param statechart
*/]
[template private variables (component : Component) post (trim())]
[if component.oclIsKindOf(AtomicComponent)]
 typedef struct [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/];
[/if]
	typedef struct [getClassName(component)/] [getClassName(component)/];
struct [getClassName(component)/] {

		[comment if structured component, list all embedded components/]
		[if component.oclIsKindOf(StructuredComponent)]
		[for (cpart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts)]
			[getClassName(cpart)/]* [getVariableName(cpart)/];
		[/for]
		[/if]

		[comment if atomic, list the RTSC of the component/]
		[if component.oclIsKindOf(AtomicComponent)]
			[getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/]* stateChart;	
		[/if]
	
		[comment list all ports of the component/]
		[for (port : Port | component.ports)]
			[if (port.oclIsTypeOf(DiscretePort))]
				DiscretePort* [getVariableName(port)/];
			[elseif (port.oclIsTypeOf(ContinuousPort))]
			[/if]
		[/for]
		
		[comment if structured comp, list all port connectors/]
		[if component.oclIsKindOf(StructuredComponent)]
		DiscreteConnectionList * connectorList;
		[/if]

		[comment add list pointer/]
		[component.getClassName()/] * next;
		
	};

[/template]

[**
 * @param component
 * @param statechart
*/]
[template private initialize (component : Component) post (trim())]
	void [getInitializeMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the constructor.
 * 
 * @param component
 * @param statechart
*/]
[template public constructor (component : Component) post (trim())]
	[getClassName(component)/]* [getCreateMethodName(component)/]();
[/template]

[**
 * 
*/]
[template private destroy(component : Component)]
	void [getDestroyMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the isTerminated method.
 * 
 * @param component
 * @param statechart
*/]
[template private isTerminated (component : Component) post (trim())]
	bool_t [getTerminateMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generated the processStep method.
 * 
 * @param component
 * @param statechart
*/]
[template private processStep (component : Component) post (trim())]
	void [getProcessMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the getter methods for the statechart and all ports.
 * 
 * @param component
 * @param statechart
*/]
[template private getterAndSetter (component : Component) post (trim())]
	[if (component.oclIsTypeOf(AtomicComponent))]
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior]
		[getClassName(rtsc)/]* [getGetterName(component)/]([getClassName(component)/]* component);
	[/let]
	[/if]

	[for (port : Port | component.ports)]
	[if (port.oclIsKindOf(DiscretePort))]
		[getClassName(port)/]* [getGetterName(port)/]([getClassName(component)/]* component);
	[/if]
	[/for]
[/template]

[**
 * 
 * @param component
*/]
[template private queueMethods(component : Component) post (trim())]
[if (component.oclIsKindOf(StructuredComponent))]
[for (compPart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts->asSet())]
//Queue methods for component parts of type '[getName(compPart)/]'
void [getAddMethodName(component,compPart)/]([getClassName(component)/]* component, [getClassName(compPart)/]* multiPart);		
void [getRemoveMethodName(component,compPart)/]([getClassName(compPart)/]* component, [getClassName(compPart)/]* multiPart);
[/for]
[/if]
[/template]


[template private createHybridPortMethods (component : Component) post (trim())]
[for (port : Port | component.ports) ? (oclIsKindOf(HybridPort))]
	[let hybridPort  :HybridPort = port.oclAsType(HybridPort)]
	
	void setValueOf_[hybridPort.getName()/]([component.getClassName()/] *component, [hybridPort.dataType.getTypeName()/] value);
	[hybridPort.dataType.getTypeName()/] getValueOf_[hybridPort.getName()/]([component.getClassName()/] *component);
	[/let]
[/for]
[/template]

[**
 * 
 * @param component
 * @param statechart
*/]
[template private connect (component : Component) post (trim())]
	[comment @TODO only for continous ports?!/]
[/template]

