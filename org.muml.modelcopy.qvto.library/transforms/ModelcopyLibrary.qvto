import org.muml.modelcopy.qvto._library.ModelcopyBlackbox;
import CreateChangeDescription;

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype change uses 'http://www.eclipse.org/emf/2003/Change';

library ModelcopyLibrary access CreateChangeDescription;

helper Element::create(context : OclAny) : Element {
	if(self.oclAsType(EObject).eResource().toString().matches("platform:/plugin")) {
		return self.oclAsType(EObject);
	};
	
	var eclass : ecore::EClass := self.oclAsType(EObject).eClass();
	var factory : ecore::EFactory := eclass.ePackage.eFactoryInstance;
	return factory.create(self.oclAsType(EObject).eClass());
}

helper Element :: setValues(f : EStructuralFeature, values : Sequence(OclAny)) {
	
	var tmp = change.createEmptyModel();
	new CreateChangeDescription(tmp).transform();
	
	var desc = tmp.rootObjects()[ChangeDescription]->any(true);
	var objectChange = desc.objectChanges->first();
	var featureChange = objectChange.value->first();
	var listChange = featureChange.listChanges->first();
	
	listChange.index := 0;
	featureChange.feature := f;
	objectChange.key := self.oclAsType(EObject);
		
	if (f.many) {
		listChange.referenceValues := values.oclAsType(EObject);
		featureChange.listChanges := listChange;
	}
	else {
		if (values->notEmpty()) {
			if (f.oclIsKindOf(EReference)) {
				featureChange.referenceValue := values->first().oclAsType(EObject);
			}
			elif (f.oclIsKindOf(EAttribute)) {
				featureChange.dataValue := values->first().toString();
			}
		}
	};
	
	desc.apply();
}

query Element :: getValues(feature : EStructuralFeature) : Sequence(OclAny) {
	
	var value = self.oclAsType(EObject).eGet(feature);
	
	if (feature.many) {
		return value.oclAsType(Sequence(OclAny));
	}
	elif (not value.oclIsUndefined()) {
		return Sequence{value};
	};
	
	return Sequence{};
}

mapping Element::transform() : Element {
	init {
		if (result.oclIsUndefined()) {
			result := self.create(null);
		}
	}
	
	var element := self.oclAsType(EObject);
	element.eClass().eAllReferences->select(f | f.isValidFeature())->forEach(f) {
		result.setValues(f, element.getValues(f)[Element].map transform());
	};
	element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
		result.setValues(f, element.getValues(f));
	};
}


mapping Element::transformWithContext(context : OclAny) : Element {
	init {
		if (result.oclIsUndefined()) {
			result := self.create(context);
		}
	}
	var element := self.oclAsType(EObject);
	element.eClass().eAllReferences->select(f | f.isValidFeature())->forEach(f) {
		result.setValues(f, element.getValues(f)[Element].map transformWithContext(context));
	};
	element.eClass().eAllAttributes->select(f | f.isValidFeature())->forEach(f) {
		result.setValues(f, element.getValues(f));
	};
}

query EStructuralFeature::isValidFeature() : Boolean {
	return self.changeable and not self._derived;
}