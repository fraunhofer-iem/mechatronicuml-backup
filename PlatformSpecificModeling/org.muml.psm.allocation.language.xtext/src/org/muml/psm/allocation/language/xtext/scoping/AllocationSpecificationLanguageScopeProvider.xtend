/*
 * generated by Xtext
 */
package org.muml.psm.allocation.language.xtext.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.ocl.pivot.internal.scoping.Attribution
import org.eclipse.ocl.xtext.completeocl.scoping.CompleteOCLScopeProvider
import org.eclipse.xtext.scoping.IScope
import org.muml.psm.allocation.language.cs.CsPackage
import org.muml.psm.allocation.language.cs.MeasureFunctionCS
import org.muml.psm.allocation.language.xtext.attributes.SpecificationCSAttribution

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class AllocationSpecificationLanguageScopeProvider extends CompleteOCLScopeProvider {
	
	def public static void init() {
		// register our Attribution (this method is called from the .ui plugin's activator)
		Attribution.REGISTRY.put(CsPackage.Literals.SPECIFICATION_CS, SpecificationCSAttribution.INSTANCE)
	}
	
	override IScope getScope(EObject context, EReference reference) {
		if (context instanceof MeasureFunctionCS) {
			polymorphicGetScope(context, reference)
		} else {
			super.getScope(context, reference)	
		}
	}
	
	// copied (and xtend-ified) from org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider.getScope
	// because getScope is overridden by a superclass
	def protected IScope polymorphicGetScope(EObject context, EReference reference) {
		var IScope scope = polymorphicFindScopeForReferenceName(context, reference)
		if (scope == null) {
			scope = polymorphicFindScopeForClassName(context, reference)
			if (scope == null) {
				scope = delegateGetScope(context, reference)
			}
		}
		scope
	}
}
