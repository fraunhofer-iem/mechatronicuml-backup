library ComponentInstanceLibrary;

modeltype Core uses core('http://www.storydriven.org/core/0.3.1');

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype MessagePackage uses muml::msgtype('http://www.fujaba.de/muml/0.4.0');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype ModelInstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype Actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.4.0');

modeltype PSM uses psm('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Allocation uses psm::allocation('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Codegen uses psm::codegen('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PortMappingModel uses psm::portapimapping('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype ApiExpessions uses psm::apiexpressions('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PSMInstance uses psm::instance('http://www.fujaba.de/muml/psm/0.4.0/');

modeltype SoftPlattform uses swplatform('http://www.fujaba.de/muml/swplatform/0.4.0/');
modeltype Hardware uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype Platform uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformInstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype ResourceInstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype Resource uses hardware::hwresource('http://www.fujaba.de/muml/hardware/1.0/');

// the message Type Repository for the api values 
property property_apiMessageRepository:MessageTypeRepository;
property property_genComponentInstance:Set(GenComponentInstance);


helper ComponentInstanceConfiguration::createPSMCIC(genComponentInstances:Set(GenComponentInstance),apiMessageRepository:MessageTypeRepository):ComponentInstanceConfiguration{
	property_genComponentInstance:=genComponentInstances;
	property_apiMessageRepository:=apiMessageRepository;
	return self.map mapCIC2CIC();
}

/**********************
* Here is the logic for mapping the ComponentInstances
***********************/
mapping ComponentInstanceConfiguration::mapCIC2CIC():ComponentInstanceConfiguration{	
	annotation:=self.annotation;
	extension:=self.extension.deepclone().oclAsType(Extension);
	name:=self.name;
	comment:=self.comment;
	componentInstances:=self.componentInstances->map mapComponentInstance();
	portConnectorInstances:=self.portConnectorInstances->map mapConnectorInstance();	
}


mapping PortConnectorInstance::mapConnectorInstance():PortConnectorInstance
	disjuncts AssemblyConnectorInstance::mapAssemblyConnectorInstance,DelegationConnectorInstance::mapDelegationConnectorInstance;


mapping AssemblyConnectorInstance::mapAssemblyConnectorInstance():AssemblyConnectorInstance{
	type:=self.type;
	connectorEndpointInstances:=self.connectorEndpointInstances.late resolve(ConnectorEndpointInstance);	
}

mapping DelegationConnectorInstance::mapDelegationConnectorInstance():DelegationConnectorInstance{
	type:=self.type;
	connectorEndpointInstances:=self.connectorEndpointInstances.late resolve(ConnectorEndpointInstance);	
}


/**
 * maps the ComponentInstances of the  CIC to RefinedComponentInstances
**/
abstract mapping ComponentInstance::abstractmapComponentInstance():ComponentInstance{
	name:=self.name;
	componentType:=self.componentType;
	portInstances:=self.portInstances->map mapPortInstance();
	annotation:=self.annotation;
	extension:=self.extension;
	componentPart:=self.componentPart;
	parentCIC:=self.parentCIC;
}

mapping ComponentInstance::mapComponentInstance():ComponentInstance
	disjuncts StructuredComponentInstance::mapStructuredComponentInstance,AtomicComponentInstance::mapAtomicComponentInstance;


mapping StructuredComponentInstance::mapStructuredComponentInstance():StructuredComponentInstance inherits ComponentInstance::abstractmapComponentInstance{ 
	 embeddedCIC:=self.embeddedCIC.map mapCIC2CIC();
}


mapping AtomicComponentInstance::mapAtomicComponentInstance():AtomicComponentInstance inherits ComponentInstance::abstractmapComponentInstance{
}



abstract mapping PortInstance::abstractmapPortInstance():PortInstance{
	name:=self.name;
	type:=self.type;
	annotation:=self.annotation;
	extension:=self.extension;
	comment:=self.comment;
	componentInstance:=self.componentInstance;
	connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);
}

mapping PortInstance::mapPortInstance():PortInstance disjuncts ContinuousPortInstance::ReplaceContinusPortInstanceWithParaDiscretePortInstance, ContinuousPortInstance::ReplaceContinusPortInstanceWithSingleDiscretePortInstance, DiscreteMultiPortInstance::mapDiscreteMultiPortInstance, DiscreteSinglePortInstance::mapDiscreteSinglePortInstance, HybridPortInstance::mapHybridPortInstance;



mapping DiscreteMultiPortInstance::mapDiscreteMultiPortInstance():DiscreteMultiPortInstance merges PortInstance::abstractmapPortInstance{
	subInteractionEndpointInstances:=self.subInteractionEndpointInstances.oclAsType(DiscreteSinglePortInstance)->map mapDiscreteSinglePortInstance();
}


mapping DiscreteSinglePortInstance::mapDiscreteSinglePortInstance():DiscreteSinglePortInstance merges PortInstance::abstractmapPortInstance{
	multiInteractionEndpointInstance:=self.multiInteractionEndpointInstance;
	
}




/**
* Replace a hybridPortInstance with a  DiscretePortinstance
*/
mapping HybridPortInstance::mapHybridPortInstance():DiscreteSinglePortInstance inherits PortInstance::abstractmapPortInstance{
	
}


/***************************************************************************
* 
*  Here starts the logic for the transformation of Component-Instances (Instance Level)
*
*****************************************************************************/


/**
* Replace a ContiniuosPortIsntance with a  ParametiredDiscreteSinglePortinstance
*/
mapping ContinuousPortInstance::ReplaceContinusPortInstanceWithParaDiscretePortInstance():ParameterisableDiscreteSinglePortInstance inherits PortInstance::abstractmapPortInstance 
when {self.componentInstance.oclIsKindOf(AtomicComponentInstance)}{
	// fix it
 	//bindings:=createPortBindingParameter(apiMappingRepository,result,self);
}

mapping ContinuousPortInstance::ReplaceContinusPortInstanceWithSingleDiscretePortInstance():DiscreteSinglePortInstance  inherits PortInstance::abstractmapPortInstance
when {self.componentInstance.oclIsKindOf(StructuredComponentInstance)}{
	
}


//don't know yet
//mapping ContinuousPortInstance::mapParameterisableDiscreteSinglePortInstance():ParameterisableDiscreteSinglePortInstance merges PortInstance::abstractmapPortInstance{
//	bindings:=self.bindings.deepclone().oclAsType(RealtimeStatechartParameterBinding);
//}






/***
* Query the CodeGen Model to get relevant information
**/
query ComponentInstance::getGenComponentInstance():GenComponentInstance{
	return property_genComponentInstance->select(genComp|genComp.componentInstance=self)->any(true);
}

query PortInstance::getGenPortInstance():GenPortInstance{
	return property_genComponentInstance.getPortInstances->select(port|port.portInstance=self)->any(true);
}