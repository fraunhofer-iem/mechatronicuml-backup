import StateChartLibrary;
import APIBindingLibrary;

library ComponentLibrary;

modeltype Core uses core('http://www.storydriven.org/core/0.3.1');

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype MessagePackage uses muml::msgtype('http://www.fujaba.de/muml/0.4.0');
modeltype Behavior uses muml::behavior('http://www.fujaba.de/muml/0.4.0');
modeltype RTSC uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype ModelInstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype Actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.4.0');

modeltype PSM uses psm('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Allocation uses psm::allocation('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Codegen uses psm::codegen('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PortMappingModel uses psm::portapimapping('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype ApiExpessions uses psm::apiexpressions('http://www.fujaba.de/muml/psm/0.4.0/');

modeltype SoftPlattform uses swplatform('http://www.fujaba.de/muml/swplatform/0.4.0/');
modeltype Hardware uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype Platform uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformInstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype ResourceInstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype Resource uses hardware::hwresource('http://www.fujaba.de/muml/hardware/1.0/');

// the message Type Repository for the api values 
property property_apiMessageRepository:MessageTypeRepository;
property property_genComponentInstance:Set(GenComponentInstance);


/***************************************************************************
* 
*  Here starts the logic for the transformation of Components (Type Level)
*
*****************************************************************************/
//component logic

abstract mapping Component::abstractmapComponent():Component{
	name:=self.name;
	annotation:=self.annotation;
	extension:=self.extension;
	comment:=self.comment;
}

mapping Component::mapComponent():Component
	disjuncts StaticStructuredComponent::ChangeHybridStructuredComponent2StructuredDiscreteComponent, StaticAtomicComponent::ChangeContinousComponent2DiscreteComponent,StaticAtomicComponent::ChangeSoftwareComponent2DiscreteComponent {}
	

/**
* The HybridPorts of a SturcutedComponent are Replaced  with DiscretePorts
*/
mapping in StaticStructuredComponent::ChangeHybridStructuredComponent2StructuredDiscreteComponent():StaticStructuredComponent when {self.componentKind=muml::component::ComponentKind::HYBRID_COMPONENT}{
	componentKind:=	muml::component::ComponentKind::SOFTWARE_COMPONENT;
	ports:=self.ports->map ReplacePortWithDiscretePort(null);	
}



/**
* Changes a ContiniusComponent to a DiscreteComponent and Replaces its ContinousPorts with DiscretePorts
*/
mapping in StaticAtomicComponent::ChangeContinousComponent2DiscreteComponent():StaticAtomicComponent when {self.componentKind=muml::component::ComponentKind::CONTINUOUS_COMPONENT}{
	componentKind:=	muml::component::ComponentKind::SOFTWARE_COMPONENT;
	//create empty statechart here
	//createEmptyRealtimeStateChart(muml.rootObjects()[RootNode]->any(true),self);
	ports:=self.ports[ContinuousPort]->map ReplacePortWithDiscretePort(self.behavior.oclAsType(RealtimeStatechart));	
}


/**
* The HybridPorts of a HybridComponent are Replaced  with DiscretePorts
*/
mapping in StaticAtomicComponent::ChangeSoftwareComponent2DiscreteComponent():StaticAtomicComponent when {self.componentKind=muml::component::ComponentKind::SOFTWARE_COMPONENT}{
	ports+=self.ports[HybridPort]->map ReplacePortWithDiscretePort(self.behavior.oclAsType(RealtimeStatechart));	
}


/**
* The General Logic to replace a Port with a  DiscretePort
*/
abstract mapping Port::abstractReplacePortWithDiscretePort():Port{
	name:=self.name;
	annotation:=self.annotation;
	extension:=self.extension;
	comment:=self.comment;
	connectors:=self.connectors.late resolve(Connector);
	component:=self.component;
	
}

mapping DiscretePort::ReplacePortWithDiscretePort():DiscretePort inherits Port::abstractReplacePortWithDiscretePort{
	cardinality:=object Cardinality{
			lowerBound:=object NaturalNumber{
				value:=1;
			};
			upperBound:=object NaturalNumber{
				value:=1;
			};
	};
	
}

/**
* Replace a HybridPort with a  DiscretePort
*/
mapping HybridPort::ReplacePortWithDiscretePort(inout componentStateChart:RealtimeStatechart):DiscretePort inherits Port::abstractReplacePortWithDiscretePort{
	
	if(self.component.oclIsKindOf(AtomicComponent)) then{
		//create the message stuff
		var messageType:MessageType:=self.connectedContiniousPort.map CreateMessageTypeForDiscretePort();
		var variable:Variable:=self.CreateStateChartVariable();
		self.CreateMessageAttributesForDiscretePort(result,messageType);
		//statechart stuff
		AddVariableToStateChart(componentStateChart,variable);
		self.ReplacePortExpressionWithVariableExpression(componentStateChart,variable);
		var portStateChart:RealtimeStatechart;
		portStateChart:=self.map createStatechartHybridPort(messageType,variable);
		storeRealtimeStatechart(portStateChart,componentStateChart);
		behavior:=portStateChart;
	}endif;

}

/**
* Replace a ContinuousPort with a  DiscretePort
*/
mapping ContinuousPort::ReplacePortWithDiscretePort(inout componentStateChart:RealtimeStatechart):DiscretePort inherits Port::abstractReplacePortWithDiscretePort{

	if(self.component.oclIsKindOf(AtomicComponent)) then{
		//create the message stuff
		var messageType:MessageType:=self.map CreateMessageTypeForDiscretePort();
		var variable:Variable:=self.CreateStateChartVariable();
		self.CreateMessageAttributesForDiscretePort(result,messageType);
		//statechart stuff		
		AddVariableToStateChart(componentStateChart,variable);
		var portStateChart:RealtimeStatechart;
		portStateChart:=self.map createStatechartContinuousPort(messageType,variable,self.samplingTimes,true,rootNode);
		storeRealtimeStatechart(portStateChart,componentStateChart);
		behavior:=portStateChart;
	}endif;
	
}




/***************************************************************************
* 
*  Here starts the logic for the transformation of Messages
*
*****************************************************************************/

// message stuff
/**
*	For each new DiscretePort (created from a ContinousPort) corresponding MessageBuffer and Messages are created
**/
helper DirectedTypedPort::CreateMessageAttributesForDiscretePort(inout port:DiscretePort, message:MessageType){
	if(self.inPort) then{
		port.receiverMessageBuffer := object MessageBuffer {
				bufferSize := object NaturalNumber {
						value := 1;
						infinity := false;
				};
			messageType := message;
		//discreteInteractionEndpoint := self;
		name:="Buffer";
		bufferOverflowAvoidanceStrategy:=BufferOverflowAvoidanceStrategy::DISCARD_OLDEST_MESSAGE_IN_BUFFER;
		};
		port.receiverMessageTypes:=message;
	}
	else{
		port.senderMessageTypes:=message;		
	}endif;
	return null;
}


/**
*	For each ConitniousPort and new Message is generated
**/
mapping ContinuousPort::CreateMessageTypeForDiscretePort():MessageType{
	name:=self.component.name+"_"+self.name+"_message";
	var parameter:Parameter := object Parameter{
		name:=self.name+"_value";
		dataType:=self.dataType;
	};
	parameters:=parameter;
	apiMessageRepository.messageTypes+=result;
}



/***************************************************************************
* 
*  Here starts the logic for the transformation of StateCharts
*
*****************************************************************************/
/**
	For each hybrid-port / continius port a new Variable in the RealtimeStateCharts is created,
	which represents the (old and now deleted) hybrid Port
**/
//StateChart stuff
helper DirectedTypedPort::CreateStateChartVariable():Variable{
	var variable:Variable;
	variable:=object Variable{
		name:=self.name+"_apiValue";
		dataType:=self.dataType;
		//we need the initalize Expression from the ContinousPort, also for the new Variable of the HybridPort
		if(self.oclIsKindOf(HybridPort)) then{
				initializeExpression:=self.oclAsType(HybridPort).connectedContiniousPort.initializeExpression.deepclone().oclAsType(core::expressions::Expression);
		}
		else{
			initializeExpression:=self.initializeExpression.deepclone().oclAsType(core::expressions::Expression);
		}endif;
	};
	return variable;
}


/**
 	In the RealtimeStateChart of a discret component with hybridPorts, all references to the hybridPort are replaced
 	with references to the new RealtimeStateChart Variable, that (now) represents the old hybirdPort
*/
helper HybridPort::ReplacePortExpressionWithVariableExpression(inout componentStateChart:RealtimeStatechart, in variable:Variable){
	actionlanguage::TypedNamedElementExpression.allInstances()->select(e|e.typedNamedElement=self)->forEach(typedNamedElementexpression){
		typedNamedElementexpression.typedNamedElement:=variable;
	}
}

/**
 A Variable is added to a RealtimeStateChart
**/
helper AddVariableToStateChart(inout stateChart:RealtimeStatechart, in variable:Variable){
	stateChart.variables+=variable;
	return null;
}