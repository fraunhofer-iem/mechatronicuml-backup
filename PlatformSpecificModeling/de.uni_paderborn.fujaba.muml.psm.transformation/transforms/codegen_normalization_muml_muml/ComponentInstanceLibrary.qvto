import ComponentLibrary;
import CommonLibrary;

library ComponentInstanceLibrary;

import ModelcopyLibrary;


modeltype Core uses core('http://www.storydriven.org/core/0.3.1');

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype MessagePackage uses muml::msgtype('http://www.fujaba.de/muml/0.4.0');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype ModelInstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype Actionlanguage uses actionlanguage('http://www.fujaba.de/muml/actionlanguage/0.4.0');

modeltype PSM uses psm('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Allocation uses psm::allocation('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Codegen uses psm::codegen('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PortMappingModel uses psm::portapimapping('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype ApiExpessions uses psm::apiexpressions('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PSMInstance uses psm::psm_instance('http://www.fujaba.de/muml/psm/0.4.0/');

modeltype SoftPlattform uses swplatform('http://www.fujaba.de/muml/swplatform/0.4.0/');
modeltype Hardware uses hardware('http://www.fujaba.de/muml/hardware/1.1/');
modeltype Platform uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.1/');
modeltype PlatformInstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype ResourceInstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype Resource uses hardware::hwresource('http://www.fujaba.de/muml/hardware/1.1/');

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';


helper ComponentInstanceConfiguration::createPSMCIC(genComponentInstances:Set(GenComponentInstance),apiMessageRepository:MessageTypeRepository):ComponentInstanceConfiguration{
	property_genComponentInstance:=genComponentInstances;
	property_apiMessageRepository:=apiMessageRepository;
	return self.map transform().oclAsType(ComponentInstanceConfiguration);
}


/***************************************************************************
* 
*  Here starts the logic for the transformation of Component-Instances (Instance Level)
*
*****************************************************************************/

/**
* Replace a hybridPortInstance with a  DiscretePortinstance
*/
mapping HybridPortInstance::transform():EObject{
	init{
	result:=new DiscreteSinglePortInstance();
	}
	var portInstance: DiscreteSinglePortInstance := result.oclAsType(DiscreteSinglePortInstance);
	portInstance.name:=self.name;
	portInstance.type:=self.type.late resolveone(Port);
	portInstance.annotation:=self.annotation;
	portInstance.extension:=self.extension;
	portInstance.comment:=self.comment;
	portInstance.componentInstance:=self.componentInstance;
	portInstance.connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);
	
}


/**
* Replace a ContiniuosPortIsntance with a  ParametiredDiscreteSinglePortinstance
*/
mapping ContinuousPortInstance::transform():EObject {
init{
	if(self.componentInstance.oclIsKindOf(AtomicComponentInstance)) then {
	result:=new ParameterisableDiscreteSinglePortInstance();
	}
	else{
		if(self.componentInstance.oclIsKindOf(StructuredComponentInstance)) then {
		result:=new DiscreteSinglePortInstance();
	}endif;
	}
	endif;
	
	}
	var portInstance: DiscreteSinglePortInstance := result.oclAsType(DiscreteSinglePortInstance);
	portInstance.name:=self.name;
	portInstance.type:=self.type.late resolveone(Port);
	portInstance.annotation:=self.annotation;
	portInstance.extension:=self.extension;
	portInstance.comment:=self.comment;
	portInstance.componentInstance:=self.componentInstance;
	portInstance.connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);
	
	if(result.oclIsKindOf(ParameterisableDiscreteSinglePortInstance)) then{
	
		// fix it
		//TODO
 		//bindings:=createPortBindingParameter(apiMappingRepository,result,self);
	} endif;
	
}


//don't know yet
//mapping ContinuousPortInstance::mapParameterisableDiscreteSinglePortInstance():ParameterisableDiscreteSinglePortInstance merges PortInstance::abstractmapPortInstance{
//	bindings:=self.bindings.deepclone().oclAsType(RealtimeStatechartParameterBinding);
//}



