import hierarchy_transformation;
import component.CopyRolePropertiesToPort;
transformation CodegenTransformation(in allocationmodel : Allocation, out codegenmodel:Codegen);

modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ConnectorPackage uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype ComponentPackage uses muml::component('http://www.fujaba.de/muml/0.4.0');
modeltype InstancePackage uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype ModelInstance uses modelinstance('http://www.fujaba.de/modelinstance/0.4.0');
modeltype PSM uses psm('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype SoftPlattform uses swplatform('http://www.fujaba.de/muml/swplatform/0.4.0/');
modeltype PSMInstance uses psm::instance('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype PSMRealtimeStateChart uses psm::realtimestatechart::realtimestatechartparameterbinding('http://www.fujaba.de/muml/psm/0.4.0/');

modeltype Allocation uses psm::allocation('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Codegen uses psm::codegen('http://www.fujaba.de/muml/psm/0.4.0/');
modeltype Hardware uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype Platform uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformInstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype ResourceInstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/1.1/');
modeltype Resource uses hardware::hwresource('http://www.fujaba.de/muml/hardware/1.0/');




modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

property allocationModel : SystemAllocation = allocationmodel.rootObjects()[SystemAllocation]->any(true);
	

main() {
	allocationModel:=allocationmodel.rootObjects()[SystemAllocation]->any(true);

	allocationmodel.rootObjects()[SystemAllocation]->map mapSystemAllocation2Codegen();
} 



query ComponentInstance::getAllocatedResourceInstance():hardware::hwresourceinstance::StructuredResourceInstance{	
	return allocationModel.allocations->any(allocation|allocation.componentInstance=self).resourceInstance;
}

/**
* Creates a Codegen model from a given SystemAllocation
**/
mapping SystemAllocation::mapSystemAllocation2Codegen():Codegen::CodeGenAllocation{
	cic:=self.unionCIC();
	//flat the hierarchy
	//cic.flatComponentInstanceConfiguration();	
	hpic:=self.unionHWPIC();	
}







/**********************
* Here is the logic for mapping the ResourceInstances
***********************/





/**
* maps the ResourceInstances to Refined ResourceInstances
**/
mapping hardware::hwresourceinstance::ResourceInstance::mapResourceInstance():hardware::hwresourceinstance::ResourceInstance
	disjuncts StructuredResourceInstance::mapStructuredResourceInstance,ActuatorInstance::mapActuatorInstance, SensorInstance::mapSensorInstance;



mapping hardware::hwresourceinstance::ActuatorInstance::mapActuatorInstance():hardware::hwresourceinstance::ActuatorInstance{
	name:=self.name;
	resourceType:=self.resourceType;
	hwports:=self.hwports.oclAsType(HWPortInstance)->map mapHWPort().oclAsType(HWPortInstance);
}

mapping hardware::hwresourceinstance::SensorInstance::mapSensorInstance():hardware::hwresourceinstance::SensorInstance{
	name:=self.name;
	resourceType:=self.resourceType;
	hwports:=self.hwports.oclAsType(HWPortInstance)->map mapHWPort().oclAsType(HWPortInstance);
}

mapping hardware::hwresourceinstance::StructuredResourceInstance::mapStructuredResourceInstance():RefinedStructuredResourceInstance{
	name:=self.name;
	resourceType:=self.resourceType;
	embeddedAtomicResourceInstances:=self.embeddedAtomicResourceInstances;
	hwports:=self.hwports.oclAsType(HWPortInstance)->map mapHWPort().oclAsType(HWPortInstance);
}


mapping HWPlatformInstanceConfiguration::mapHWPlatformInstanceConfiguration():HWPlatformInstanceConfiguration{
//	name:=self.name;
	hwplatformInstances:=self.hwplatformInstances->map mapHWPlatformInstance();
	networkingHardwareInstances:=self.networkingHardwareInstances->map mapNetworkHardwareInstance();
	networkConnectorInstances:=self.networkConnectorInstances->map mapNetworkConnectorInstance();
	resources:=self.resources->map mapResourceInstance();
	
}

mapping HWPlatformInstance::mapHWPlatformInstance():HWPlatformInstance{
	//resources:=self.resources->map mapResourceInstance();
	name:=self.name;
	hwplatformType:=self.hwplatformType;
	//networkingHardwareInstances:=self.networkingHardwareInstances->map mapNetworkHardwareInstance();
	delegationPorts:=self.delegationPorts->map mapHWPort().oclAsType(DelegationHWPortInstance);
	embeddedHPIC:=self.embeddedHPIC.map mapHWPlatformInstanceConfiguration();
}

mapping NetworkingHardwareInstance::mapNetworkHardwareInstance():NetworkingHardwareInstance
disjuncts NetworkBridgeInstance::mapBridgeInstance, BusInstance::mapBusInstance;


mapping NetworkBridgeInstance::mapBridgeInstance():NetworkBridgeInstance{
	name:=self.name;
	type:=self.type;
	connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);
	
}

mapping BusInstance::mapBusInstance():BusInstance{
	type:=self.type;
	name:=self.name;
	connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);
	
}

mapping NetworkConnectorInstance::mapNetworkConnectorInstance():NetworkConnectorInstance{
	type:=self.type;
	connectorEndpointInstances:=self.connectorEndpointInstances.late resolve(ConnectorEndpointInstance);
}


mapping ConnectorEndpointInstance::mapHWPort():ConnectorEndpointInstance
disjuncts HWPortInstance::mapHWPortInstance, DelegationHWPortInstance::mapDelegationHWPortInstance;

mapping HWPortInstance::mapHWPortInstance():HWPortInstance{
	name:=self.name;
	type:=self.type;
	connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);
} 

mapping DelegationHWPortInstance::mapDelegationHWPortInstance():DelegationHWPortInstance{
	name:=self.name;
	type:=self.type;
	connectorInstances:=self.connectorInstances.late resolve(ConnectorInstance);	
}