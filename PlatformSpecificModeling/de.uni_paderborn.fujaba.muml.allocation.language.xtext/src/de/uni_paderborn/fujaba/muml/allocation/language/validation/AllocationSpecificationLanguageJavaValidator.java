/*
* generated by Xtext
*/
package de.uni_paderborn.fujaba.muml.allocation.language.validation;

import java.util.List;

import org.eclipse.ocl.examples.pivot.ExpressionInOCL;
import org.eclipse.ocl.examples.pivot.Type;
import org.eclipse.ocl.examples.pivot.manager.MetaModelManager;
import org.eclipse.ocl.examples.xtext.essentialocl.essentialoclcs.ContextCS;
import org.eclipse.xtext.validation.Check;

import de.uni_paderborn.fujaba.muml.allocation.language.cs.ComponentResourceTupleDescriptorCS;
import de.uni_paderborn.fujaba.muml.allocation.language.cs.CsPackage;
import de.uni_paderborn.fujaba.muml.allocation.language.cs.EvaluatableElementCS;
import de.uni_paderborn.fujaba.muml.allocation.language.cs.LocationConstraintCS;
import de.uni_paderborn.fujaba.muml.allocation.language.cs.LocationTupleDescriptorCS;
import de.uni_paderborn.fujaba.muml.allocation.language.cs.QoSDimensionCS;
import de.uni_paderborn.fujaba.muml.allocation.language.cs.RequiredHardwareResourceInstanceConstraintCS;
import de.uni_paderborn.fujaba.muml.allocation.language.cs.ResourceConstraintCS;
import de.uni_paderborn.fujaba.muml.allocation.language.typing.TypesUtil;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class AllocationSpecificationLanguageJavaValidator extends de.uni_paderborn.fujaba.muml.allocation.language.validation.AbstractAllocationSpecificationLanguageJavaValidator {
	private static final String typeMismatch = "Type mismatch: expected %s but got %s"; 

//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital", MyDslPackage.Literals.GREETING__NAME);
//		}
//	}

	@Check
	public void checkLocationConstraintCS(LocationConstraintCS constraintCS) {
		LocationTupleDescriptorCS tupleDescriptor = constraintCS.getTupleDescriptor();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptor == null || oclExpression == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(constraintCS,
				TypesUtil.createLocationConstraintType(constraintCS));
	}
	
	@Check
	public void checkRequiredHardwareResourceInstanceConstraintCS(RequiredHardwareResourceInstanceConstraintCS constraintCS) {
		List<ComponentResourceTupleDescriptorCS> tupleDescriptorList = constraintCS.getTupleDescriptors();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorList.isEmpty() || oclExpression == null) {
			// in this case a different error is displayed
			return;
		}
		checkTypes(constraintCS,
				TypesUtil.createReqHWResInstanceConstraintType(constraintCS));
	}
	
	@Check
	public void checkResourceConstraintCS(ResourceConstraintCS constraintCS) {
		List<ComponentResourceTupleDescriptorCS> tupleDescriptorList = constraintCS.getTupleDescriptors();
		ContextCS oclExpression = constraintCS.getExpression();
		if (tupleDescriptorList.isEmpty() || oclExpression == null
				|| constraintCS.getWeighting() == null || constraintCS.getRhs() == null) {
			// parser/ui will display an error
			return;
		}
		checkTypes(constraintCS,
				TypesUtil.createResourceConstraintType(constraintCS));
	}
	
	@Check
	public void checkQoSDimensionCS(QoSDimensionCS qosDimensionCS) {
		List<ComponentResourceTupleDescriptorCS> tupleDescriptorList = qosDimensionCS.getTupleDescriptors();
		ContextCS oclExpression = qosDimensionCS.getExpression();
		if (tupleDescriptorList.isEmpty() || oclExpression == null) {
			return;
		}
		checkTypes(qosDimensionCS,
				TypesUtil.createQoSDimensionType(qosDimensionCS));
	}
	
	private void checkTypes(EvaluatableElementCS elementCS, Type expectedType) {
		MetaModelManager metaModelManager = TypesUtil.getMetaModelManager(elementCS);
		Type actualType = ((ExpressionInOCL) elementCS.getExpression().getPivot()).getType();
		boolean conformsTo = TypesUtil.conformsTo(metaModelManager, actualType, expectedType);
		if (!conformsTo) {
			error(String.format(typeMismatch, expectedType, actualType),
					CsPackage.Literals.EVALUATABLE_ELEMENT_CS__EXPRESSION);
		}
	}
	
/*	@Check
	public void checkRequiredHardwareResourceInstanceConstraintCSExpressionType(RequiredHardwareResourceInstanceConstraintCS constraint) {
		System.out.println("called");
		Type constraintType = ((ExpressionInOCL) constraint.getExpression()
				.getPivot()).getType();
		System.out.println(constraintType);
		MetaModelManager metaModelManager = PivotUtil.findMetaModelManager(constraint);
		TupleTypeManager tupleTypeManager = metaModelManager.getTupleManager();
		DomainType domainType = metaModelManager.getIdResolver().getType(
				InstancePackage.Literals.COMPONENT_INSTANCE);
		Type componentType = metaModelManager.getType(domainType);
		Map<String, Type> map = new HashMap<String, Type>();
		map.put("first", componentType);
		TupleType tupleType = tupleTypeManager.getTupleType("Tuple", map);
		Type expectedType = metaModelManager.getSetType(tupleType, null, null);
		System.out.println(expectedType);
		boolean conformsTo = metaModelManager.conformsTo(constraintType, expectedType, null); 
		System.out.println(conformsTo);
		if (!conformsTo) {
			error(constraintType + " does not conform to " + expectedType,
					CsPackage.Literals.CONSTRAINT_CS__EXPRESSION);
		}
	}*/
}
