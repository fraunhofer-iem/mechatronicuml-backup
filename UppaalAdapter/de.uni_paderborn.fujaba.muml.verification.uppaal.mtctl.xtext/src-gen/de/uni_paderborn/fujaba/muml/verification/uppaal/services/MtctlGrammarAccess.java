/*
 * generated by Xtext
 */
package de.uni_paderborn.fujaba.muml.verification.uppaal.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class MtctlGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class PropertyRepositoryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyRepository");
		private final Assignment cPropertiesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPropertiesPropertyParserRuleCall_0 = (RuleCall)cPropertiesAssignment.eContents().get(0);
		
		//PropertyRepository returns mtctl::PropertyRepository:
		//	properties+=Property*;
		@Override public ParserRule getRule() { return rule; }

		//properties+=Property*
		public Assignment getPropertiesAssignment() { return cPropertiesAssignment; }

		//Property
		public RuleCall getPropertiesPropertyParserRuleCall_0() { return cPropertiesPropertyParserRuleCall_0; }
	}

	public class PropertyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Property");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCommentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommentSL_COMMENTTerminalRuleCall_2_0 = (RuleCall)cCommentAssignment_2.eContents().get(0);
		
		//Property returns mtctl::Property hidden(WS, ML_COMMENT):
		//	expression=Expression ";" comment=SL_COMMENT?;
		@Override public ParserRule getRule() { return rule; }

		//expression=Expression ";" comment=SL_COMMENT?
		public Group getGroup() { return cGroup; }

		//expression=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }

		//comment=SL_COMMENT?
		public Assignment getCommentAssignment_2() { return cCommentAssignment_2; }

		//SL_COMMENT
		public RuleCall getCommentSL_COMMENTTerminalRuleCall_2_0() { return cCommentSL_COMMENTTerminalRuleCall_2_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLeadsToExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression returns mtctl::Expression:
		//	LeadsToExpr;
		@Override public ParserRule getRule() { return rule; }

		//LeadsToExpr
		public RuleCall getLeadsToExprParserRuleCall() { return cLeadsToExprParserRuleCall; }
	}

	public class LeadsToExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LeadsToExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImplyExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLeadsToExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeadsToKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdImplyExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		////Binary operators (increasing precedence)
		//LeadsToExpr returns mtctl::Expression:
		//	ImplyExpr ({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=ImplyExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//ImplyExpr ({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=ImplyExpr)*
		public Group getGroup() { return cGroup; }

		//ImplyExpr
		public RuleCall getImplyExprParserRuleCall_0() { return cImplyExprParserRuleCall_0; }

		//({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=ImplyExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::LeadsToExpr.leftOpd=current}
		public Action getLeadsToExprLeftOpdAction_1_0() { return cLeadsToExprLeftOpdAction_1_0; }

		//"leadsTo"
		public Keyword getLeadsToKeyword_1_1() { return cLeadsToKeyword_1_1; }

		//rightOpd=ImplyExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//ImplyExpr
		public RuleCall getRightOpdImplyExprParserRuleCall_1_2_0() { return cRightOpdImplyExprParserRuleCall_1_2_0; }
	}

	public class ImplyExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImplyExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplyExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImpliesKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdAndExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		//ImplyExpr returns mtctl::Expression:
		//	AndExpr ({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//AndExpr ({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*
		public Group getGroup() { return cGroup; }

		//AndExpr
		public RuleCall getAndExprParserRuleCall_0() { return cAndExprParserRuleCall_0; }

		//({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::ImplyExpr.leftOpd=current}
		public Action getImplyExprLeftOpdAction_1_0() { return cImplyExprLeftOpdAction_1_0; }

		//"implies"
		public Keyword getImpliesKeyword_1_1() { return cImpliesKeyword_1_1; }

		//rightOpd=AndExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//AndExpr
		public RuleCall getRightOpdAndExprParserRuleCall_1_2_0() { return cRightOpdAndExprParserRuleCall_1_2_0; }
	}

	public class AndExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdOrExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		//AndExpr returns mtctl::Expression:
		//	OrExpr ({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//OrExpr ({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*
		public Group getGroup() { return cGroup; }

		//OrExpr
		public RuleCall getOrExprParserRuleCall_0() { return cOrExprParserRuleCall_0; }

		//({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::AndExpr.leftOpd=current}
		public Action getAndExprLeftOpdAction_1_0() { return cAndExprLeftOpdAction_1_0; }

		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//rightOpd=OrExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//OrExpr
		public RuleCall getRightOpdOrExprParserRuleCall_1_2_0() { return cRightOpdOrExprParserRuleCall_1_2_0; }
	}

	public class OrExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExprLeftOpdAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOpdAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOpdNotExprParserRuleCall_1_2_0 = (RuleCall)cRightOpdAssignment_1_2.eContents().get(0);
		
		//OrExpr returns mtctl::Expression:
		//	NotExpr ({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//NotExpr ({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*
		public Group getGroup() { return cGroup; }

		//NotExpr
		public RuleCall getNotExprParserRuleCall_0() { return cNotExprParserRuleCall_0; }

		//({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{mtctl::OrExpr.leftOpd=current}
		public Action getOrExprLeftOpdAction_1_0() { return cOrExprLeftOpdAction_1_0; }

		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//rightOpd=NotExpr
		public Assignment getRightOpdAssignment_1_2() { return cRightOpdAssignment_1_2; }

		//NotExpr
		public RuleCall getRightOpdNotExprParserRuleCall_1_2_0() { return cRightOpdNotExprParserRuleCall_1_2_0; }
	}

	public class NotExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cNotExprAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cOpdAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOpdNotExprParserRuleCall_0_2_0 = (RuleCall)cOpdAssignment_0_2.eContents().get(0);
		private final RuleCall cQuantifierExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////Unary operators
		//NotExpr returns mtctl::Expression:
		//	"not" {mtctl::NotExpr} opd=NotExpr | QuantifierExpr;
		@Override public ParserRule getRule() { return rule; }

		//"not" {mtctl::NotExpr} opd=NotExpr | QuantifierExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//"not" {mtctl::NotExpr} opd=NotExpr
		public Group getGroup_0() { return cGroup_0; }

		//"not"
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//{mtctl::NotExpr}
		public Action getNotExprAction_0_1() { return cNotExprAction_0_1; }

		//opd=NotExpr
		public Assignment getOpdAssignment_0_2() { return cOpdAssignment_0_2; }

		//NotExpr
		public RuleCall getOpdNotExprParserRuleCall_0_2_0() { return cOpdNotExprParserRuleCall_0_2_0; }

		//QuantifierExpr
		public RuleCall getQuantifierExprParserRuleCall_1() { return cQuantifierExprParserRuleCall_1; }
	}

	public class QuantifierExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantifierExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUniversalQuantExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistentialQuantExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTemporalQuantifierExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAtomExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//QuantifierExpr returns mtctl::Expression:
		//	UniversalQuantExpr | ExistentialQuantExpr | TemporalQuantifierExpr | AtomExpr;
		@Override public ParserRule getRule() { return rule; }

		//UniversalQuantExpr | ExistentialQuantExpr | TemporalQuantifierExpr | AtomExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//UniversalQuantExpr
		public RuleCall getUniversalQuantExprParserRuleCall_0() { return cUniversalQuantExprParserRuleCall_0; }

		//ExistentialQuantExpr
		public RuleCall getExistentialQuantExprParserRuleCall_1() { return cExistentialQuantExprParserRuleCall_1; }

		//TemporalQuantifierExpr
		public RuleCall getTemporalQuantifierExprParserRuleCall_2() { return cTemporalQuantifierExprParserRuleCall_2; }

		//AtomExpr
		public RuleCall getAtomExprParserRuleCall_3() { return cAtomExprParserRuleCall_3; }
	}

	public class UniversalQuantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UniversalQuantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForallKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cUniversalQuantExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cVarAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarVariableBindingParserRuleCall_3_0 = (RuleCall)cVarAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFormulaAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFormulaNotExprParserRuleCall_5_0 = (RuleCall)cFormulaAssignment_5.eContents().get(0);
		
		//UniversalQuantExpr returns mtctl::QuantifierExpr:
		//	"forall" "(" {mtctl::UniversalQuantExpr} var=VariableBinding ")" formula=NotExpr;
		@Override public ParserRule getRule() { return rule; }

		//"forall" "(" {mtctl::UniversalQuantExpr} var=VariableBinding ")" formula=NotExpr
		public Group getGroup() { return cGroup; }

		//"forall"
		public Keyword getForallKeyword_0() { return cForallKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::UniversalQuantExpr}
		public Action getUniversalQuantExprAction_2() { return cUniversalQuantExprAction_2; }

		//var=VariableBinding
		public Assignment getVarAssignment_3() { return cVarAssignment_3; }

		//VariableBinding
		public RuleCall getVarVariableBindingParserRuleCall_3_0() { return cVarVariableBindingParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//formula=NotExpr
		public Assignment getFormulaAssignment_5() { return cFormulaAssignment_5; }

		//NotExpr
		public RuleCall getFormulaNotExprParserRuleCall_5_0() { return cFormulaNotExprParserRuleCall_5_0; }
	}

	public class ExistentialQuantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExistentialQuantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExistsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Action cExistenceQuantExprAction_2 = (Action)cGroup.eContents().get(2);
		private final Assignment cVarAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarVariableBindingParserRuleCall_3_0 = (RuleCall)cVarAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFormulaAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFormulaNotExprParserRuleCall_5_0 = (RuleCall)cFormulaAssignment_5.eContents().get(0);
		
		//ExistentialQuantExpr returns mtctl::QuantifierExpr:
		//	"exists" "(" {mtctl::ExistenceQuantExpr} var=VariableBinding ")" formula=NotExpr;
		@Override public ParserRule getRule() { return rule; }

		//"exists" "(" {mtctl::ExistenceQuantExpr} var=VariableBinding ")" formula=NotExpr
		public Group getGroup() { return cGroup; }

		//"exists"
		public Keyword getExistsKeyword_0() { return cExistsKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//{mtctl::ExistenceQuantExpr}
		public Action getExistenceQuantExprAction_2() { return cExistenceQuantExprAction_2; }

		//var=VariableBinding
		public Assignment getVarAssignment_3() { return cVarAssignment_3; }

		//VariableBinding
		public RuleCall getVarVariableBindingParserRuleCall_3_0() { return cVarVariableBindingParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//formula=NotExpr
		public Assignment getFormulaAssignment_5() { return cFormulaAssignment_5; }

		//NotExpr
		public RuleCall getFormulaNotExprParserRuleCall_5_0() { return cFormulaNotExprParserRuleCall_5_0; }
	}

	public class VariableBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSetSetExprParserRuleCall_2_0 = (RuleCall)cSetAssignment_2.eContents().get(0);
		
		//VariableBinding returns mtctl::BoundVariable:
		//	name=ID ":" set=SetExpr;
		@Override public ParserRule getRule() { return rule; }

		//name=ID ":" set=SetExpr
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//set=SetExpr
		public Assignment getSetAssignment_2() { return cSetAssignment_2; }

		//SetExpr
		public RuleCall getSetSetExprParserRuleCall_2_0() { return cSetSetExprParserRuleCall_2_0; }
	}

	public class TemporalQuantifierExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TemporalQuantifierExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEFExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAFExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEGExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAGExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//TemporalQuantifierExpr returns mtctl::Expression:
		//	EFExpr | AFExpr | EGExpr | AGExpr;
		@Override public ParserRule getRule() { return rule; }

		//EFExpr | AFExpr | EGExpr | AGExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//EFExpr
		public RuleCall getEFExprParserRuleCall_0() { return cEFExprParserRuleCall_0; }

		//AFExpr
		public RuleCall getAFExprParserRuleCall_1() { return cAFExprParserRuleCall_1; }

		//EGExpr
		public RuleCall getEGExprParserRuleCall_2() { return cEGExprParserRuleCall_2; }

		//AGExpr
		public RuleCall getAGExprParserRuleCall_3() { return cAGExprParserRuleCall_3; }
	}

	public class EFExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EFExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cEFKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cEKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cEFExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//EFExpr returns mtctl::TemporalQuantifierExpr:
		//	("EF" | "E<>") {mtctl::EFExpr} expr=NotExpr;
		@Override public ParserRule getRule() { return rule; }

		//("EF" | "E<>") {mtctl::EFExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"EF" | "E<>"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"EF"
		public Keyword getEFKeyword_0_0() { return cEFKeyword_0_0; }

		//"E<>"
		public Keyword getEKeyword_0_1() { return cEKeyword_0_1; }

		//{mtctl::EFExpr}
		public Action getEFExprAction_1() { return cEFExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class AFExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AFExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cAFKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cAKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cAFExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//AFExpr returns mtctl::TemporalQuantifierExpr:
		//	("AF" | "A<>") {mtctl::AFExpr} expr=NotExpr;
		@Override public ParserRule getRule() { return rule; }

		//("AF" | "A<>") {mtctl::AFExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"AF" | "A<>"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"AF"
		public Keyword getAFKeyword_0_0() { return cAFKeyword_0_0; }

		//"A<>"
		public Keyword getAKeyword_0_1() { return cAKeyword_0_1; }

		//{mtctl::AFExpr}
		public Action getAFExprAction_1() { return cAFExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class EGExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EGExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cEGKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cEKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cEGExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//EGExpr returns mtctl::TemporalQuantifierExpr:
		//	("EG" | "E[]") {mtctl::EGExpr} expr=NotExpr;
		@Override public ParserRule getRule() { return rule; }

		//("EG" | "E[]") {mtctl::EGExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"EG" | "E[]"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"EG"
		public Keyword getEGKeyword_0_0() { return cEGKeyword_0_0; }

		//"E[]"
		public Keyword getEKeyword_0_1() { return cEKeyword_0_1; }

		//{mtctl::EGExpr}
		public Action getEGExprAction_1() { return cEGExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class AGExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AGExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cAGKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cAKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Action cAGExprAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprNotExprParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//AGExpr returns mtctl::TemporalQuantifierExpr:
		//	("AG" | "A[]") {mtctl::AGExpr} expr=NotExpr;
		@Override public ParserRule getRule() { return rule; }

		//("AG" | "A[]") {mtctl::AGExpr} expr=NotExpr
		public Group getGroup() { return cGroup; }

		//"AG" | "A[]"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"AG"
		public Keyword getAGKeyword_0_0() { return cAGKeyword_0_0; }

		//"A[]"
		public Keyword getAKeyword_0_1() { return cAKeyword_0_1; }

		//{mtctl::AGExpr}
		public Action getAGExprAction_1() { return cAGExprAction_1; }

		//expr=NotExpr
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//NotExpr
		public RuleCall getExprNotExprParserRuleCall_2_0() { return cExprNotExprParserRuleCall_2_0; }
	}

	public class AtomExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cPredicateExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cComparisonExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////Bottom of precedence chain.
		//AtomExpr returns mtctl::Expression:
		//	"(" Expression ")" | PredicateExpr | ComparisonExpr;
		@Override public ParserRule getRule() { return rule; }

		//"(" Expression ")" | PredicateExpr | ComparisonExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//PredicateExpr
		public RuleCall getPredicateExprParserRuleCall_1() { return cPredicateExprParserRuleCall_1; }

		//ComparisonExpr
		public RuleCall getComparisonExprParserRuleCall_2() { return cComparisonExprParserRuleCall_2; }
	}

	public class PredicateExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTrueExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFalseExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDeadlockExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConnectorOverflowExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStateExprParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cMessageExprParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cTransitionExprParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		////Predicates
		//PredicateExpr returns mtctl::Expression:
		//	TrueExpr | FalseExpr | DeadlockExpr | ConnectorOverflowExpr | StateExpr | MessageExpr | TransitionExpr;
		@Override public ParserRule getRule() { return rule; }

		//TrueExpr | FalseExpr | DeadlockExpr | ConnectorOverflowExpr | StateExpr | MessageExpr | TransitionExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//TrueExpr
		public RuleCall getTrueExprParserRuleCall_0() { return cTrueExprParserRuleCall_0; }

		//FalseExpr
		public RuleCall getFalseExprParserRuleCall_1() { return cFalseExprParserRuleCall_1; }

		//DeadlockExpr
		public RuleCall getDeadlockExprParserRuleCall_2() { return cDeadlockExprParserRuleCall_2; }

		//ConnectorOverflowExpr
		public RuleCall getConnectorOverflowExprParserRuleCall_3() { return cConnectorOverflowExprParserRuleCall_3; }

		//StateExpr
		public RuleCall getStateExprParserRuleCall_4() { return cStateExprParserRuleCall_4; }

		//MessageExpr
		public RuleCall getMessageExprParserRuleCall_5() { return cMessageExprParserRuleCall_5; }

		//TransitionExpr
		public RuleCall getTransitionExprParserRuleCall_6() { return cTransitionExprParserRuleCall_6; }
	}

	public class DeadlockExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeadlockExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDeadlockExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDeadlockKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//DeadlockExpr returns mtctl::DeadlockExpr:
		//	{mtctl::DeadlockExpr} "deadlock";
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::DeadlockExpr} "deadlock"
		public Group getGroup() { return cGroup; }

		//{mtctl::DeadlockExpr}
		public Action getDeadlockExprAction_0() { return cDeadlockExprAction_0; }

		//"deadlock"
		public Keyword getDeadlockKeyword_1() { return cDeadlockKeyword_1; }
	}

	public class ConnectorOverflowExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConnectorOverflowExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConnectorOverflowExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cConnectorOverflowKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ConnectorOverflowExpr returns mtctl::ConnectorOverflowExpr:
		//	{mtctl::ConnectorOverflowExpr} "connectorOverflow";
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::ConnectorOverflowExpr} "connectorOverflow"
		public Group getGroup() { return cGroup; }

		//{mtctl::ConnectorOverflowExpr}
		public Action getConnectorOverflowExprAction_0() { return cConnectorOverflowExprAction_0; }

		//"connectorOverflow"
		public Keyword getConnectorOverflowKeyword_1() { return cConnectorOverflowKeyword_1; }
	}

	public class TrueExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrueExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrueExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TrueExpr returns mtctl::TrueExpr:
		//	{mtctl::TrueExpr} "true";
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::TrueExpr} "true"
		public Group getGroup() { return cGroup; }

		//{mtctl::TrueExpr}
		public Action getTrueExprAction_0() { return cTrueExprAction_0; }

		//"true"
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
	}

	public class FalseExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FalseExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFalseExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//FalseExpr returns mtctl::FalseExpr:
		//	{mtctl::FalseExpr} "false";
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::FalseExpr} "false"
		public Group getGroup() { return cGroup; }

		//{mtctl::FalseExpr}
		public Action getFalseExprAction_0() { return cFalseExprAction_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class StateExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStateActiveExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubstateOfExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStateInStatechartExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//StateExpr returns mtctl::PredicateExpr:
		//	StateActiveExpr | SubstateOfExpr | StateInStatechartExpr;
		@Override public ParserRule getRule() { return rule; }

		//StateActiveExpr | SubstateOfExpr | StateInStatechartExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//StateActiveExpr
		public RuleCall getStateActiveExprParserRuleCall_0() { return cStateActiveExprParserRuleCall_0; }

		//SubstateOfExpr
		public RuleCall getSubstateOfExprParserRuleCall_1() { return cSubstateOfExprParserRuleCall_1; }

		//StateInStatechartExpr
		public RuleCall getStateInStatechartExprParserRuleCall_2() { return cStateInStatechartExprParserRuleCall_2; }
	}

	public class StateActiveExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateActiveExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStateActiveKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStateStateMapExprParserRuleCall_2_0 = (RuleCall)cStateAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//StateActiveExpr returns mtctl::StateActiveExpr:
		//	"stateActive" "(" state=StateMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"stateActive" "(" state=StateMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"stateActive"
		public Keyword getStateActiveKeyword_0() { return cStateActiveKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//state=StateMapExpr
		public Assignment getStateAssignment_2() { return cStateAssignment_2; }

		//StateMapExpr
		public RuleCall getStateStateMapExprParserRuleCall_2_0() { return cStateStateMapExprParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class SubstateOfExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubstateOfExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSubstateOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStateStateMapExprParserRuleCall_2_0 = (RuleCall)cStateAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cSuperstateAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSuperstateStateMapExprParserRuleCall_4_0 = (RuleCall)cSuperstateAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//SubstateOfExpr returns mtctl::SubstateOfExpr:
		//	"substateOf" "(" state=StateMapExpr "," superstate=StateMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"substateOf" "(" state=StateMapExpr "," superstate=StateMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"substateOf"
		public Keyword getSubstateOfKeyword_0() { return cSubstateOfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//state=StateMapExpr
		public Assignment getStateAssignment_2() { return cStateAssignment_2; }

		//StateMapExpr
		public RuleCall getStateStateMapExprParserRuleCall_2_0() { return cStateStateMapExprParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//superstate=StateMapExpr
		public Assignment getSuperstateAssignment_4() { return cSuperstateAssignment_4; }

		//StateMapExpr
		public RuleCall getSuperstateStateMapExprParserRuleCall_4_0() { return cSuperstateStateMapExprParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class StateInStatechartExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateInStatechartExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStateInStatechartKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStateStateMapExprParserRuleCall_2_0 = (RuleCall)cStateAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatechartAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatechartStatechartMapExprParserRuleCall_4_0 = (RuleCall)cStatechartAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//StateInStatechartExpr returns mtctl::StateInStatechartExpr:
		//	"stateInStatechart" "(" state=StateMapExpr "," statechart=StatechartMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"stateInStatechart" "(" state=StateMapExpr "," statechart=StatechartMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"stateInStatechart"
		public Keyword getStateInStatechartKeyword_0() { return cStateInStatechartKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//state=StateMapExpr
		public Assignment getStateAssignment_2() { return cStateAssignment_2; }

		//StateMapExpr
		public RuleCall getStateStateMapExprParserRuleCall_2_0() { return cStateStateMapExprParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//statechart=StatechartMapExpr
		public Assignment getStatechartAssignment_4() { return cStatechartAssignment_4; }

		//StatechartMapExpr
		public RuleCall getStatechartStatechartMapExprParserRuleCall_4_0() { return cStatechartStatechartMapExprParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class MessageExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMessageInBufferExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMessageInTransitExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MessageExpr returns mtctl::PredicateExpr:
		//	MessageInBufferExpr | MessageInTransitExpr;
		@Override public ParserRule getRule() { return rule; }

		//MessageInBufferExpr | MessageInTransitExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//MessageInBufferExpr
		public RuleCall getMessageInBufferExprParserRuleCall_0() { return cMessageInBufferExprParserRuleCall_0; }

		//MessageInTransitExpr
		public RuleCall getMessageInTransitExprParserRuleCall_1() { return cMessageInTransitExprParserRuleCall_1; }
	}

	public class MessageInTransitExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageInTransitExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMessageInTransitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMessageAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMessageMessageMapExprParserRuleCall_2_0 = (RuleCall)cMessageAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MessageInTransitExpr returns mtctl::MessageInTransitExpr:
		//	"messageInTransit" "(" message=MessageMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"messageInTransit" "(" message=MessageMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"messageInTransit"
		public Keyword getMessageInTransitKeyword_0() { return cMessageInTransitKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//message=MessageMapExpr
		public Assignment getMessageAssignment_2() { return cMessageAssignment_2; }

		//MessageMapExpr
		public RuleCall getMessageMessageMapExprParserRuleCall_2_0() { return cMessageMessageMapExprParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class MessageInBufferExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageInBufferExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMessageInBufferKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMessageAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMessageMessageMapExprParserRuleCall_2_0 = (RuleCall)cMessageAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBufferAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBufferBufferMapExprParserRuleCall_4_0 = (RuleCall)cBufferAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MessageInBufferExpr returns mtctl::MessageInBufferExpr:
		//	"messageInBuffer" "(" message=MessageMapExpr "," buffer=BufferMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"messageInBuffer" "(" message=MessageMapExpr "," buffer=BufferMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"messageInBuffer"
		public Keyword getMessageInBufferKeyword_0() { return cMessageInBufferKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//message=MessageMapExpr
		public Assignment getMessageAssignment_2() { return cMessageAssignment_2; }

		//MessageMapExpr
		public RuleCall getMessageMessageMapExprParserRuleCall_2_0() { return cMessageMessageMapExprParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//buffer=BufferMapExpr
		public Assignment getBufferAssignment_4() { return cBufferAssignment_4; }

		//BufferMapExpr
		public RuleCall getBufferBufferMapExprParserRuleCall_4_0() { return cBufferBufferMapExprParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class TransitionExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransitionExpr");
		private final RuleCall cTransitionFiringExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TransitionExpr returns mtctl::PredicateExpr:
		//	TransitionFiringExpr;
		@Override public ParserRule getRule() { return rule; }

		//TransitionFiringExpr
		public RuleCall getTransitionFiringExprParserRuleCall() { return cTransitionFiringExprParserRuleCall; }
	}

	public class TransitionFiringExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransitionFiringExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTransitionFiringKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTransitionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTransitionTransitionMapExprParserRuleCall_2_0 = (RuleCall)cTransitionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TransitionFiringExpr returns mtctl::TransitionFiringExpr:
		//	"transitionFiring" "(" transition=TransitionMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"transitionFiring" "(" transition=TransitionMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"transitionFiring"
		public Keyword getTransitionFiringKeyword_0() { return cTransitionFiringKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//transition=TransitionMapExpr
		public Assignment getTransitionAssignment_2() { return cTransitionAssignment_2; }

		//TransitionMapExpr
		public RuleCall getTransitionTransitionMapExprParserRuleCall_2_0() { return cTransitionTransitionMapExprParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ComparisonExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cComparisonExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cLhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLhsMapExprParserRuleCall_1_0 = (RuleCall)cLhsAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOpComparisonOpEnumRuleCall_2_0 = (RuleCall)cOpAssignment_2.eContents().get(0);
		private final Assignment cRhsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRhsMapExprParserRuleCall_3_0 = (RuleCall)cRhsAssignment_3.eContents().get(0);
		
		////Comparisons
		//ComparisonExpr returns mtctl::Expression:
		//	{mtctl::ComparisonExpr} lhs=MapExpr op=ComparisonOp rhs=MapExpr;
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::ComparisonExpr} lhs=MapExpr op=ComparisonOp rhs=MapExpr
		public Group getGroup() { return cGroup; }

		//{mtctl::ComparisonExpr}
		public Action getComparisonExprAction_0() { return cComparisonExprAction_0; }

		//lhs=MapExpr
		public Assignment getLhsAssignment_1() { return cLhsAssignment_1; }

		//MapExpr
		public RuleCall getLhsMapExprParserRuleCall_1_0() { return cLhsMapExprParserRuleCall_1_0; }

		//op=ComparisonOp
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }

		//ComparisonOp
		public RuleCall getOpComparisonOpEnumRuleCall_2_0() { return cOpComparisonOpEnumRuleCall_2_0; }

		//rhs=MapExpr
		public Assignment getRhsAssignment_3() { return cRhsAssignment_3; }

		//MapExpr
		public RuleCall getRhsMapExprParserRuleCall_3_0() { return cRhsMapExprParserRuleCall_3_0; }
	}

	public class MapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MapExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMumlElemExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBufferMessageCountExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSourceStateExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTargetStateExprParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		////Expressions usable in comparisons. Starting with MapExpressions arranged by return type
		//MapExpr returns mtctl::MapExpr:
		//	MumlElemExpr | BufferMessageCountExpr | ConstExpr | SourceStateExpr | TargetStateExpr;
		@Override public ParserRule getRule() { return rule; }

		//MumlElemExpr | BufferMessageCountExpr | ConstExpr | SourceStateExpr | TargetStateExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//MumlElemExpr
		public RuleCall getMumlElemExprParserRuleCall_0() { return cMumlElemExprParserRuleCall_0; }

		//BufferMessageCountExpr
		public RuleCall getBufferMessageCountExprParserRuleCall_1() { return cBufferMessageCountExprParserRuleCall_1; }

		//ConstExpr
		public RuleCall getConstExprParserRuleCall_2() { return cConstExprParserRuleCall_2; }

		//SourceStateExpr
		public RuleCall getSourceStateExprParserRuleCall_3() { return cSourceStateExprParserRuleCall_3; }

		//TargetStateExpr
		public RuleCall getTargetStateExprParserRuleCall_4() { return cTargetStateExprParserRuleCall_4; }
	}

	public class IntegerMapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerMapExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMumlElemExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBufferMessageCountExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//IntegerMapExpr returns mtctl::MapExpr:
		//	MumlElemExpr | BufferMessageCountExpr | ConstExpr;
		@Override public ParserRule getRule() { return rule; }

		//MumlElemExpr | BufferMessageCountExpr | ConstExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//MumlElemExpr
		public RuleCall getMumlElemExprParserRuleCall_0() { return cMumlElemExprParserRuleCall_0; }

		//BufferMessageCountExpr
		public RuleCall getBufferMessageCountExprParserRuleCall_1() { return cBufferMessageCountExprParserRuleCall_1; }

		//ConstExpr
		public RuleCall getConstExprParserRuleCall_2() { return cConstExprParserRuleCall_2; }
	}

	public class TransitionMapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransitionMapExpr");
		private final RuleCall cMumlElemExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TransitionMapExpr returns mtctl::MapExpr:
		//	MumlElemExpr;
		@Override public ParserRule getRule() { return rule; }

		//MumlElemExpr
		public RuleCall getMumlElemExprParserRuleCall() { return cMumlElemExprParserRuleCall; }
	}

	public class StateMapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateMapExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMumlElemExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSourceStateExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTargetStateExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//StateMapExpr returns mtctl::MapExpr:
		//	MumlElemExpr | SourceStateExpr | TargetStateExpr;
		@Override public ParserRule getRule() { return rule; }

		//MumlElemExpr | SourceStateExpr | TargetStateExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//MumlElemExpr
		public RuleCall getMumlElemExprParserRuleCall_0() { return cMumlElemExprParserRuleCall_0; }

		//SourceStateExpr
		public RuleCall getSourceStateExprParserRuleCall_1() { return cSourceStateExprParserRuleCall_1; }

		//TargetStateExpr
		public RuleCall getTargetStateExprParserRuleCall_2() { return cTargetStateExprParserRuleCall_2; }
	}

	public class StatechartMapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatechartMapExpr");
		private final RuleCall cMumlElemExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StatechartMapExpr returns mtctl::MapExpr:
		//	MumlElemExpr;
		@Override public ParserRule getRule() { return rule; }

		//MumlElemExpr
		public RuleCall getMumlElemExprParserRuleCall() { return cMumlElemExprParserRuleCall; }
	}

	public class BufferMapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BufferMapExpr");
		private final RuleCall cMumlElemExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BufferMapExpr returns mtctl::MapExpr:
		//	MumlElemExpr;
		@Override public ParserRule getRule() { return rule; }

		//MumlElemExpr
		public RuleCall getMumlElemExprParserRuleCall() { return cMumlElemExprParserRuleCall; }
	}

	public class MessageMapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MessageMapExpr");
		private final RuleCall cMumlElemExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//MessageMapExpr returns mtctl::MapExpr:
		//	MumlElemExpr;
		@Override public ParserRule getRule() { return rule; }

		//MumlElemExpr
		public RuleCall getMumlElemExprParserRuleCall() { return cMumlElemExprParserRuleCall; }
	}

	public class BufferMessageCountExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BufferMessageCountExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBufferMessageCountKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBufferAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBufferBufferMapExprParserRuleCall_2_0 = (RuleCall)cBufferAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BufferMessageCountExpr returns mtctl::BufferMsgCountExpr:
		//	"bufferMessageCount" "(" buffer=BufferMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"bufferMessageCount" "(" buffer=BufferMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"bufferMessageCount"
		public Keyword getBufferMessageCountKeyword_0() { return cBufferMessageCountKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//buffer=BufferMapExpr
		public Assignment getBufferAssignment_2() { return cBufferAssignment_2; }

		//BufferMapExpr
		public RuleCall getBufferBufferMapExprParserRuleCall_2_0() { return cBufferBufferMapExprParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class SourceStateExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SourceStateExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSourceStateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTransitionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTransitionTransitionMapExprParserRuleCall_2_0 = (RuleCall)cTransitionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SourceStateExpr returns mtctl::SourceStateExpr:
		//	"sourceState" "(" transition=TransitionMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"sourceState" "(" transition=TransitionMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"sourceState"
		public Keyword getSourceStateKeyword_0() { return cSourceStateKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//transition=TransitionMapExpr
		public Assignment getTransitionAssignment_2() { return cTransitionAssignment_2; }

		//TransitionMapExpr
		public RuleCall getTransitionTransitionMapExprParserRuleCall_2_0() { return cTransitionTransitionMapExprParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class TargetStateExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TargetStateExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTargetStateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTransitionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTransitionTransitionMapExprParserRuleCall_2_0 = (RuleCall)cTransitionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TargetStateExpr returns mtctl::TargetStateExpr:
		//	"targetState" "(" transition=TransitionMapExpr ")";
		@Override public ParserRule getRule() { return rule; }

		//"targetState" "(" transition=TransitionMapExpr ")"
		public Group getGroup() { return cGroup; }

		//"targetState"
		public Keyword getTargetStateKeyword_0() { return cTargetStateKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//transition=TransitionMapExpr
		public Assignment getTransitionAssignment_2() { return cTransitionAssignment_2; }

		//TransitionMapExpr
		public RuleCall getTransitionTransitionMapExprParserRuleCall_2_0() { return cTransitionTransitionMapExprParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class MumlElemExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MumlElemExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cElemAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cElemEObjectCrossReference_0_0 = (CrossReference)cElemAssignment_0.eContents().get(0);
		private final RuleCall cElemEObjectQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cElemEObjectCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cInstanceAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cInstanceEObjectCrossReference_1_1_0 = (CrossReference)cInstanceAssignment_1_1.eContents().get(0);
		private final RuleCall cInstanceEObjectQualifiedNameParserRuleCall_1_1_0_1 = (RuleCall)cInstanceEObjectCrossReference_1_1_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//MumlElemExpr returns mtctl::MumlElemExpr:
		//	elem=[ecore::EObject|QualifiedName] ("[" instance=[ecore::EObject|QualifiedName] "]")?;
		@Override public ParserRule getRule() { return rule; }

		//elem=[ecore::EObject|QualifiedName] ("[" instance=[ecore::EObject|QualifiedName] "]")?
		public Group getGroup() { return cGroup; }

		//elem=[ecore::EObject|QualifiedName]
		public Assignment getElemAssignment_0() { return cElemAssignment_0; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getElemEObjectCrossReference_0_0() { return cElemEObjectCrossReference_0_0; }

		//QualifiedName
		public RuleCall getElemEObjectQualifiedNameParserRuleCall_0_0_1() { return cElemEObjectQualifiedNameParserRuleCall_0_0_1; }

		//("[" instance=[ecore::EObject|QualifiedName] "]")?
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//instance=[ecore::EObject|QualifiedName]
		public Assignment getInstanceAssignment_1_1() { return cInstanceAssignment_1_1; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getInstanceEObjectCrossReference_1_1_0() { return cInstanceEObjectCrossReference_1_1_0; }

		//QualifiedName
		public RuleCall getInstanceEObjectQualifiedNameParserRuleCall_1_1_0_1() { return cInstanceEObjectQualifiedNameParserRuleCall_1_1_0_1; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}

	public class ConstExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValEIntParserRuleCall_0_0 = (RuleCall)cValAssignment_0.eContents().get(0);
		private final Assignment cTimeUnitAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTimeUnitTimeUnitExprParserRuleCall_1_0 = (RuleCall)cTimeUnitAssignment_1.eContents().get(0);
		
		//ConstExpr returns mtctl::ConstExpr:
		//	val=EInt timeUnit=TimeUnitExpr?;
		@Override public ParserRule getRule() { return rule; }

		//val=EInt timeUnit=TimeUnitExpr?
		public Group getGroup() { return cGroup; }

		//val=EInt
		public Assignment getValAssignment_0() { return cValAssignment_0; }

		//EInt
		public RuleCall getValEIntParserRuleCall_0_0() { return cValEIntParserRuleCall_0_0; }

		//timeUnit=TimeUnitExpr?
		public Assignment getTimeUnitAssignment_1() { return cTimeUnitAssignment_1; }

		//TimeUnitExpr
		public RuleCall getTimeUnitTimeUnitExprParserRuleCall_1_0() { return cTimeUnitTimeUnitExprParserRuleCall_1_0; }
	}

	public class TimeUnitExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimeUnitExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDaysKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHrsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMinsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cSecsKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cMsecsKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cSecsKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cNsecsKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		
		//TimeUnitExpr returns valuetype::TimeUnit:
		//	"days" | "hrs" | "mins" | "secs" | "msecs" | "µsecs" | "nsecs";
		@Override public ParserRule getRule() { return rule; }

		//"days" | "hrs" | "mins" | "secs" | "msecs" | "µsecs" | "nsecs"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"days"
		public Keyword getDaysKeyword_0() { return cDaysKeyword_0; }

		//"hrs"
		public Keyword getHrsKeyword_1() { return cHrsKeyword_1; }

		//"mins"
		public Keyword getMinsKeyword_2() { return cMinsKeyword_2; }

		//"secs"
		public Keyword getSecsKeyword_3() { return cSecsKeyword_3; }

		//"msecs"
		public Keyword getMsecsKeyword_4() { return cMsecsKeyword_4; }

		//"µsecs"
		public Keyword getSecsKeyword_5() { return cSecsKeyword_5; }

		//"nsecs"
		public Keyword getNsecsKeyword_6() { return cNsecsKeyword_6; }
	}

	public class SetExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInstanceSetExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubinstanceSetExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntervalSetExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cStateSetExprAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cStatesKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cTransitionSetExprAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cTransitionsKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cMessageSetExprAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Keyword cMessageTypesKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cClockSetExprAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Keyword cClocksKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cBufferSetExprAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Keyword cBuffersKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		
		////Sets
		//SetExpr returns mtctl::SetExpr:
		//	InstanceSetExpr | SubinstanceSetExpr | IntervalSetExpr | {mtctl::StateSetExpr} "States" | {mtctl::TransitionSetExpr}
		//	"Transitions" | {mtctl::MessageSetExpr} "MessageTypes" | {mtctl::ClockSetExpr} "Clocks" | {mtctl::BufferSetExpr}
		//	"Buffers";
		@Override public ParserRule getRule() { return rule; }

		//InstanceSetExpr | SubinstanceSetExpr | IntervalSetExpr | {mtctl::StateSetExpr} "States" | {mtctl::TransitionSetExpr}
		//"Transitions" | {mtctl::MessageSetExpr} "MessageTypes" | {mtctl::ClockSetExpr} "Clocks" | {mtctl::BufferSetExpr}
		//"Buffers"
		public Alternatives getAlternatives() { return cAlternatives; }

		//InstanceSetExpr
		public RuleCall getInstanceSetExprParserRuleCall_0() { return cInstanceSetExprParserRuleCall_0; }

		//SubinstanceSetExpr
		public RuleCall getSubinstanceSetExprParserRuleCall_1() { return cSubinstanceSetExprParserRuleCall_1; }

		//IntervalSetExpr
		public RuleCall getIntervalSetExprParserRuleCall_2() { return cIntervalSetExprParserRuleCall_2; }

		//{mtctl::StateSetExpr} "States"
		public Group getGroup_3() { return cGroup_3; }

		//{mtctl::StateSetExpr}
		public Action getStateSetExprAction_3_0() { return cStateSetExprAction_3_0; }

		//"States"
		public Keyword getStatesKeyword_3_1() { return cStatesKeyword_3_1; }

		//{mtctl::TransitionSetExpr} "Transitions"
		public Group getGroup_4() { return cGroup_4; }

		//{mtctl::TransitionSetExpr}
		public Action getTransitionSetExprAction_4_0() { return cTransitionSetExprAction_4_0; }

		//"Transitions"
		public Keyword getTransitionsKeyword_4_1() { return cTransitionsKeyword_4_1; }

		//{mtctl::MessageSetExpr} "MessageTypes"
		public Group getGroup_5() { return cGroup_5; }

		//{mtctl::MessageSetExpr}
		public Action getMessageSetExprAction_5_0() { return cMessageSetExprAction_5_0; }

		//"MessageTypes"
		public Keyword getMessageTypesKeyword_5_1() { return cMessageTypesKeyword_5_1; }

		//{mtctl::ClockSetExpr} "Clocks"
		public Group getGroup_6() { return cGroup_6; }

		//{mtctl::ClockSetExpr}
		public Action getClockSetExprAction_6_0() { return cClockSetExprAction_6_0; }

		//"Clocks"
		public Keyword getClocksKeyword_6_1() { return cClocksKeyword_6_1; }

		//{mtctl::BufferSetExpr} "Buffers"
		public Group getGroup_7() { return cGroup_7; }

		//{mtctl::BufferSetExpr}
		public Action getBufferSetExprAction_7_0() { return cBufferSetExprAction_7_0; }

		//"Buffers"
		public Keyword getBuffersKeyword_7_1() { return cBuffersKeyword_7_1; }
	}

	public class IntervalSetExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntervalSetExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntervalSetExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLowerValAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLowerValINTTerminalRuleCall_2_0 = (RuleCall)cLowerValAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cUpperValAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cUpperValINTTerminalRuleCall_4_0 = (RuleCall)cUpperValAssignment_4.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IntervalSetExpr returns mtctl::SetExpr:
		//	{mtctl::IntervalSetExpr} "[" lowerVal=INT "," upperVal=INT "]";
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::IntervalSetExpr} "[" lowerVal=INT "," upperVal=INT "]"
		public Group getGroup() { return cGroup; }

		//{mtctl::IntervalSetExpr}
		public Action getIntervalSetExprAction_0() { return cIntervalSetExprAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//lowerVal=INT
		public Assignment getLowerValAssignment_2() { return cLowerValAssignment_2; }

		//INT
		public RuleCall getLowerValINTTerminalRuleCall_2_0() { return cLowerValINTTerminalRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//upperVal=INT
		public Assignment getUpperValAssignment_4() { return cUpperValAssignment_4; }

		//INT
		public RuleCall getUpperValINTTerminalRuleCall_4_0() { return cUpperValINTTerminalRuleCall_4_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class InstanceSetExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstanceSetExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInstanceSetExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInstancesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeMumlElemExprParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//InstanceSetExpr returns mtctl::SetExpr:
		//	{mtctl::InstanceSetExpr} "Instances" "<" type=MumlElemExpr ">";
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::InstanceSetExpr} "Instances" "<" type=MumlElemExpr ">"
		public Group getGroup() { return cGroup; }

		//{mtctl::InstanceSetExpr}
		public Action getInstanceSetExprAction_0() { return cInstanceSetExprAction_0; }

		//"Instances"
		public Keyword getInstancesKeyword_1() { return cInstancesKeyword_1; }

		//"<"
		public Keyword getLessThanSignKeyword_2() { return cLessThanSignKeyword_2; }

		//type=MumlElemExpr
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//MumlElemExpr
		public RuleCall getTypeMumlElemExprParserRuleCall_3_0() { return cTypeMumlElemExprParserRuleCall_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class SubinstanceSetExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubinstanceSetExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSubinstanceSetExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSubinstancesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeMumlElemExprParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SubinstanceSetExpr returns mtctl::SetExpr:
		//	{mtctl::SubinstanceSetExpr} "Subinstances" "<" type=MumlElemExpr ">";
		@Override public ParserRule getRule() { return rule; }

		//{mtctl::SubinstanceSetExpr} "Subinstances" "<" type=MumlElemExpr ">"
		public Group getGroup() { return cGroup; }

		//{mtctl::SubinstanceSetExpr}
		public Action getSubinstanceSetExprAction_0() { return cSubinstanceSetExprAction_0; }

		//"Subinstances"
		public Keyword getSubinstancesKeyword_1() { return cSubinstancesKeyword_1; }

		//"<"
		public Keyword getLessThanSignKeyword_2() { return cLessThanSignKeyword_2; }

		//type=MumlElemExpr
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//MumlElemExpr
		public RuleCall getTypeMumlElemExprParserRuleCall_3_0() { return cTypeMumlElemExprParserRuleCall_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		////Other necessary definitions
		//QualifiedName:
		//	ID ("." ID)*;
		@Override public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class EIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EInt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//EInt returns ecore::EInt:
		//	"-"? INT;
		@Override public ParserRule getRule() { return rule; }

		//"-"? INT
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	
	public class ComparisonOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATERGreaterThanSignKeyword_1_0 = (Keyword)cGREATEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESSLessThanSignKeyword_3_0 = (Keyword)cLESSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQUALEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNOT_EQUALExclamationMarkEqualsSignKeyword_5_0 = (Keyword)cNOT_EQUALEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum ComparisonOp returns mtctl::ComparisonOp:
		//	EQUALS="==" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQUAL="<=" | NOT_EQUAL="!=";
		public EnumRule getRule() { return rule; }

		//EQUALS="==" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQUAL="<=" | NOT_EQUAL="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUALS="=="
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQUALSEqualsSignEqualsSignKeyword_0_0() { return cEQUALSEqualsSignEqualsSignKeyword_0_0; }

		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_1() { return cGREATEREnumLiteralDeclaration_1; }

		//">"
		public Keyword getGREATERGreaterThanSignKeyword_1_0() { return cGREATERGreaterThanSignKeyword_1_0; }

		//GREATER_OR_EQUAL=">="
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_2() { return cGREATER_OR_EQUALEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_2_0; }

		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_3() { return cLESSEnumLiteralDeclaration_3; }

		//"<"
		public Keyword getLESSLessThanSignKeyword_3_0() { return cLESSLessThanSignKeyword_3_0; }

		//LESS_OR_EQUAL="<="
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_4() { return cLESS_OR_EQUALEnumLiteralDeclaration_4; }

		//"<="
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0; }

		//NOT_EQUAL="!="
		public EnumLiteralDeclaration getNOT_EQUALEnumLiteralDeclaration_5() { return cNOT_EQUALEnumLiteralDeclaration_5; }

		//"!="
		public Keyword getNOT_EQUALExclamationMarkEqualsSignKeyword_5_0() { return cNOT_EQUALExclamationMarkEqualsSignKeyword_5_0; }
	}
	
	private final PropertyRepositoryElements pPropertyRepository;
	private final PropertyElements pProperty;
	private final ExpressionElements pExpression;
	private final LeadsToExprElements pLeadsToExpr;
	private final ImplyExprElements pImplyExpr;
	private final AndExprElements pAndExpr;
	private final OrExprElements pOrExpr;
	private final NotExprElements pNotExpr;
	private final QuantifierExprElements pQuantifierExpr;
	private final UniversalQuantExprElements pUniversalQuantExpr;
	private final ExistentialQuantExprElements pExistentialQuantExpr;
	private final VariableBindingElements pVariableBinding;
	private final TemporalQuantifierExprElements pTemporalQuantifierExpr;
	private final EFExprElements pEFExpr;
	private final AFExprElements pAFExpr;
	private final EGExprElements pEGExpr;
	private final AGExprElements pAGExpr;
	private final AtomExprElements pAtomExpr;
	private final PredicateExprElements pPredicateExpr;
	private final DeadlockExprElements pDeadlockExpr;
	private final ConnectorOverflowExprElements pConnectorOverflowExpr;
	private final TrueExprElements pTrueExpr;
	private final FalseExprElements pFalseExpr;
	private final StateExprElements pStateExpr;
	private final StateActiveExprElements pStateActiveExpr;
	private final SubstateOfExprElements pSubstateOfExpr;
	private final StateInStatechartExprElements pStateInStatechartExpr;
	private final MessageExprElements pMessageExpr;
	private final MessageInTransitExprElements pMessageInTransitExpr;
	private final MessageInBufferExprElements pMessageInBufferExpr;
	private final TransitionExprElements pTransitionExpr;
	private final TransitionFiringExprElements pTransitionFiringExpr;
	private final ComparisonExprElements pComparisonExpr;
	private final ComparisonOpElements unknownRuleComparisonOp;
	private final MapExprElements pMapExpr;
	private final IntegerMapExprElements pIntegerMapExpr;
	private final TransitionMapExprElements pTransitionMapExpr;
	private final StateMapExprElements pStateMapExpr;
	private final StatechartMapExprElements pStatechartMapExpr;
	private final BufferMapExprElements pBufferMapExpr;
	private final MessageMapExprElements pMessageMapExpr;
	private final BufferMessageCountExprElements pBufferMessageCountExpr;
	private final SourceStateExprElements pSourceStateExpr;
	private final TargetStateExprElements pTargetStateExpr;
	private final MumlElemExprElements pMumlElemExpr;
	private final ConstExprElements pConstExpr;
	private final TimeUnitExprElements pTimeUnitExpr;
	private final SetExprElements pSetExpr;
	private final IntervalSetExprElements pIntervalSetExpr;
	private final InstanceSetExprElements pInstanceSetExpr;
	private final SubinstanceSetExprElements pSubinstanceSetExpr;
	private final QualifiedNameElements pQualifiedName;
	private final EIntElements pEInt;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MtctlGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pPropertyRepository = new PropertyRepositoryElements();
		this.pProperty = new PropertyElements();
		this.pExpression = new ExpressionElements();
		this.pLeadsToExpr = new LeadsToExprElements();
		this.pImplyExpr = new ImplyExprElements();
		this.pAndExpr = new AndExprElements();
		this.pOrExpr = new OrExprElements();
		this.pNotExpr = new NotExprElements();
		this.pQuantifierExpr = new QuantifierExprElements();
		this.pUniversalQuantExpr = new UniversalQuantExprElements();
		this.pExistentialQuantExpr = new ExistentialQuantExprElements();
		this.pVariableBinding = new VariableBindingElements();
		this.pTemporalQuantifierExpr = new TemporalQuantifierExprElements();
		this.pEFExpr = new EFExprElements();
		this.pAFExpr = new AFExprElements();
		this.pEGExpr = new EGExprElements();
		this.pAGExpr = new AGExprElements();
		this.pAtomExpr = new AtomExprElements();
		this.pPredicateExpr = new PredicateExprElements();
		this.pDeadlockExpr = new DeadlockExprElements();
		this.pConnectorOverflowExpr = new ConnectorOverflowExprElements();
		this.pTrueExpr = new TrueExprElements();
		this.pFalseExpr = new FalseExprElements();
		this.pStateExpr = new StateExprElements();
		this.pStateActiveExpr = new StateActiveExprElements();
		this.pSubstateOfExpr = new SubstateOfExprElements();
		this.pStateInStatechartExpr = new StateInStatechartExprElements();
		this.pMessageExpr = new MessageExprElements();
		this.pMessageInTransitExpr = new MessageInTransitExprElements();
		this.pMessageInBufferExpr = new MessageInBufferExprElements();
		this.pTransitionExpr = new TransitionExprElements();
		this.pTransitionFiringExpr = new TransitionFiringExprElements();
		this.pComparisonExpr = new ComparisonExprElements();
		this.unknownRuleComparisonOp = new ComparisonOpElements();
		this.pMapExpr = new MapExprElements();
		this.pIntegerMapExpr = new IntegerMapExprElements();
		this.pTransitionMapExpr = new TransitionMapExprElements();
		this.pStateMapExpr = new StateMapExprElements();
		this.pStatechartMapExpr = new StatechartMapExprElements();
		this.pBufferMapExpr = new BufferMapExprElements();
		this.pMessageMapExpr = new MessageMapExprElements();
		this.pBufferMessageCountExpr = new BufferMessageCountExprElements();
		this.pSourceStateExpr = new SourceStateExprElements();
		this.pTargetStateExpr = new TargetStateExprElements();
		this.pMumlElemExpr = new MumlElemExprElements();
		this.pConstExpr = new ConstExprElements();
		this.pTimeUnitExpr = new TimeUnitExprElements();
		this.pSetExpr = new SetExprElements();
		this.pIntervalSetExpr = new IntervalSetExprElements();
		this.pInstanceSetExpr = new InstanceSetExprElements();
		this.pSubinstanceSetExpr = new SubinstanceSetExprElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pEInt = new EIntElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.uni_paderborn.fujaba.muml.verification.uppaal.Mtctl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//PropertyRepository returns mtctl::PropertyRepository:
	//	properties+=Property*;
	public PropertyRepositoryElements getPropertyRepositoryAccess() {
		return pPropertyRepository;
	}
	
	public ParserRule getPropertyRepositoryRule() {
		return getPropertyRepositoryAccess().getRule();
	}

	//Property returns mtctl::Property hidden(WS, ML_COMMENT):
	//	expression=Expression ";" comment=SL_COMMENT?;
	public PropertyElements getPropertyAccess() {
		return pProperty;
	}
	
	public ParserRule getPropertyRule() {
		return getPropertyAccess().getRule();
	}

	//Expression returns mtctl::Expression:
	//	LeadsToExpr;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	////Binary operators (increasing precedence)
	//LeadsToExpr returns mtctl::Expression:
	//	ImplyExpr ({mtctl::LeadsToExpr.leftOpd=current} "leadsTo" rightOpd=ImplyExpr)*;
	public LeadsToExprElements getLeadsToExprAccess() {
		return pLeadsToExpr;
	}
	
	public ParserRule getLeadsToExprRule() {
		return getLeadsToExprAccess().getRule();
	}

	//ImplyExpr returns mtctl::Expression:
	//	AndExpr ({mtctl::ImplyExpr.leftOpd=current} "implies" rightOpd=AndExpr)*;
	public ImplyExprElements getImplyExprAccess() {
		return pImplyExpr;
	}
	
	public ParserRule getImplyExprRule() {
		return getImplyExprAccess().getRule();
	}

	//AndExpr returns mtctl::Expression:
	//	OrExpr ({mtctl::AndExpr.leftOpd=current} "and" rightOpd=OrExpr)*;
	public AndExprElements getAndExprAccess() {
		return pAndExpr;
	}
	
	public ParserRule getAndExprRule() {
		return getAndExprAccess().getRule();
	}

	//OrExpr returns mtctl::Expression:
	//	NotExpr ({mtctl::OrExpr.leftOpd=current} "or" rightOpd=NotExpr)*;
	public OrExprElements getOrExprAccess() {
		return pOrExpr;
	}
	
	public ParserRule getOrExprRule() {
		return getOrExprAccess().getRule();
	}

	////Unary operators
	//NotExpr returns mtctl::Expression:
	//	"not" {mtctl::NotExpr} opd=NotExpr | QuantifierExpr;
	public NotExprElements getNotExprAccess() {
		return pNotExpr;
	}
	
	public ParserRule getNotExprRule() {
		return getNotExprAccess().getRule();
	}

	//QuantifierExpr returns mtctl::Expression:
	//	UniversalQuantExpr | ExistentialQuantExpr | TemporalQuantifierExpr | AtomExpr;
	public QuantifierExprElements getQuantifierExprAccess() {
		return pQuantifierExpr;
	}
	
	public ParserRule getQuantifierExprRule() {
		return getQuantifierExprAccess().getRule();
	}

	//UniversalQuantExpr returns mtctl::QuantifierExpr:
	//	"forall" "(" {mtctl::UniversalQuantExpr} var=VariableBinding ")" formula=NotExpr;
	public UniversalQuantExprElements getUniversalQuantExprAccess() {
		return pUniversalQuantExpr;
	}
	
	public ParserRule getUniversalQuantExprRule() {
		return getUniversalQuantExprAccess().getRule();
	}

	//ExistentialQuantExpr returns mtctl::QuantifierExpr:
	//	"exists" "(" {mtctl::ExistenceQuantExpr} var=VariableBinding ")" formula=NotExpr;
	public ExistentialQuantExprElements getExistentialQuantExprAccess() {
		return pExistentialQuantExpr;
	}
	
	public ParserRule getExistentialQuantExprRule() {
		return getExistentialQuantExprAccess().getRule();
	}

	//VariableBinding returns mtctl::BoundVariable:
	//	name=ID ":" set=SetExpr;
	public VariableBindingElements getVariableBindingAccess() {
		return pVariableBinding;
	}
	
	public ParserRule getVariableBindingRule() {
		return getVariableBindingAccess().getRule();
	}

	//TemporalQuantifierExpr returns mtctl::Expression:
	//	EFExpr | AFExpr | EGExpr | AGExpr;
	public TemporalQuantifierExprElements getTemporalQuantifierExprAccess() {
		return pTemporalQuantifierExpr;
	}
	
	public ParserRule getTemporalQuantifierExprRule() {
		return getTemporalQuantifierExprAccess().getRule();
	}

	//EFExpr returns mtctl::TemporalQuantifierExpr:
	//	("EF" | "E<>") {mtctl::EFExpr} expr=NotExpr;
	public EFExprElements getEFExprAccess() {
		return pEFExpr;
	}
	
	public ParserRule getEFExprRule() {
		return getEFExprAccess().getRule();
	}

	//AFExpr returns mtctl::TemporalQuantifierExpr:
	//	("AF" | "A<>") {mtctl::AFExpr} expr=NotExpr;
	public AFExprElements getAFExprAccess() {
		return pAFExpr;
	}
	
	public ParserRule getAFExprRule() {
		return getAFExprAccess().getRule();
	}

	//EGExpr returns mtctl::TemporalQuantifierExpr:
	//	("EG" | "E[]") {mtctl::EGExpr} expr=NotExpr;
	public EGExprElements getEGExprAccess() {
		return pEGExpr;
	}
	
	public ParserRule getEGExprRule() {
		return getEGExprAccess().getRule();
	}

	//AGExpr returns mtctl::TemporalQuantifierExpr:
	//	("AG" | "A[]") {mtctl::AGExpr} expr=NotExpr;
	public AGExprElements getAGExprAccess() {
		return pAGExpr;
	}
	
	public ParserRule getAGExprRule() {
		return getAGExprAccess().getRule();
	}

	////Bottom of precedence chain.
	//AtomExpr returns mtctl::Expression:
	//	"(" Expression ")" | PredicateExpr | ComparisonExpr;
	public AtomExprElements getAtomExprAccess() {
		return pAtomExpr;
	}
	
	public ParserRule getAtomExprRule() {
		return getAtomExprAccess().getRule();
	}

	////Predicates
	//PredicateExpr returns mtctl::Expression:
	//	TrueExpr | FalseExpr | DeadlockExpr | ConnectorOverflowExpr | StateExpr | MessageExpr | TransitionExpr;
	public PredicateExprElements getPredicateExprAccess() {
		return pPredicateExpr;
	}
	
	public ParserRule getPredicateExprRule() {
		return getPredicateExprAccess().getRule();
	}

	//DeadlockExpr returns mtctl::DeadlockExpr:
	//	{mtctl::DeadlockExpr} "deadlock";
	public DeadlockExprElements getDeadlockExprAccess() {
		return pDeadlockExpr;
	}
	
	public ParserRule getDeadlockExprRule() {
		return getDeadlockExprAccess().getRule();
	}

	//ConnectorOverflowExpr returns mtctl::ConnectorOverflowExpr:
	//	{mtctl::ConnectorOverflowExpr} "connectorOverflow";
	public ConnectorOverflowExprElements getConnectorOverflowExprAccess() {
		return pConnectorOverflowExpr;
	}
	
	public ParserRule getConnectorOverflowExprRule() {
		return getConnectorOverflowExprAccess().getRule();
	}

	//TrueExpr returns mtctl::TrueExpr:
	//	{mtctl::TrueExpr} "true";
	public TrueExprElements getTrueExprAccess() {
		return pTrueExpr;
	}
	
	public ParserRule getTrueExprRule() {
		return getTrueExprAccess().getRule();
	}

	//FalseExpr returns mtctl::FalseExpr:
	//	{mtctl::FalseExpr} "false";
	public FalseExprElements getFalseExprAccess() {
		return pFalseExpr;
	}
	
	public ParserRule getFalseExprRule() {
		return getFalseExprAccess().getRule();
	}

	//StateExpr returns mtctl::PredicateExpr:
	//	StateActiveExpr | SubstateOfExpr | StateInStatechartExpr;
	public StateExprElements getStateExprAccess() {
		return pStateExpr;
	}
	
	public ParserRule getStateExprRule() {
		return getStateExprAccess().getRule();
	}

	//StateActiveExpr returns mtctl::StateActiveExpr:
	//	"stateActive" "(" state=StateMapExpr ")";
	public StateActiveExprElements getStateActiveExprAccess() {
		return pStateActiveExpr;
	}
	
	public ParserRule getStateActiveExprRule() {
		return getStateActiveExprAccess().getRule();
	}

	//SubstateOfExpr returns mtctl::SubstateOfExpr:
	//	"substateOf" "(" state=StateMapExpr "," superstate=StateMapExpr ")";
	public SubstateOfExprElements getSubstateOfExprAccess() {
		return pSubstateOfExpr;
	}
	
	public ParserRule getSubstateOfExprRule() {
		return getSubstateOfExprAccess().getRule();
	}

	//StateInStatechartExpr returns mtctl::StateInStatechartExpr:
	//	"stateInStatechart" "(" state=StateMapExpr "," statechart=StatechartMapExpr ")";
	public StateInStatechartExprElements getStateInStatechartExprAccess() {
		return pStateInStatechartExpr;
	}
	
	public ParserRule getStateInStatechartExprRule() {
		return getStateInStatechartExprAccess().getRule();
	}

	//MessageExpr returns mtctl::PredicateExpr:
	//	MessageInBufferExpr | MessageInTransitExpr;
	public MessageExprElements getMessageExprAccess() {
		return pMessageExpr;
	}
	
	public ParserRule getMessageExprRule() {
		return getMessageExprAccess().getRule();
	}

	//MessageInTransitExpr returns mtctl::MessageInTransitExpr:
	//	"messageInTransit" "(" message=MessageMapExpr ")";
	public MessageInTransitExprElements getMessageInTransitExprAccess() {
		return pMessageInTransitExpr;
	}
	
	public ParserRule getMessageInTransitExprRule() {
		return getMessageInTransitExprAccess().getRule();
	}

	//MessageInBufferExpr returns mtctl::MessageInBufferExpr:
	//	"messageInBuffer" "(" message=MessageMapExpr "," buffer=BufferMapExpr ")";
	public MessageInBufferExprElements getMessageInBufferExprAccess() {
		return pMessageInBufferExpr;
	}
	
	public ParserRule getMessageInBufferExprRule() {
		return getMessageInBufferExprAccess().getRule();
	}

	//TransitionExpr returns mtctl::PredicateExpr:
	//	TransitionFiringExpr;
	public TransitionExprElements getTransitionExprAccess() {
		return pTransitionExpr;
	}
	
	public ParserRule getTransitionExprRule() {
		return getTransitionExprAccess().getRule();
	}

	//TransitionFiringExpr returns mtctl::TransitionFiringExpr:
	//	"transitionFiring" "(" transition=TransitionMapExpr ")";
	public TransitionFiringExprElements getTransitionFiringExprAccess() {
		return pTransitionFiringExpr;
	}
	
	public ParserRule getTransitionFiringExprRule() {
		return getTransitionFiringExprAccess().getRule();
	}

	////Comparisons
	//ComparisonExpr returns mtctl::Expression:
	//	{mtctl::ComparisonExpr} lhs=MapExpr op=ComparisonOp rhs=MapExpr;
	public ComparisonExprElements getComparisonExprAccess() {
		return pComparisonExpr;
	}
	
	public ParserRule getComparisonExprRule() {
		return getComparisonExprAccess().getRule();
	}

	//enum ComparisonOp returns mtctl::ComparisonOp:
	//	EQUALS="==" | GREATER=">" | GREATER_OR_EQUAL=">=" | LESS="<" | LESS_OR_EQUAL="<=" | NOT_EQUAL="!=";
	public ComparisonOpElements getComparisonOpAccess() {
		return unknownRuleComparisonOp;
	}
	
	public EnumRule getComparisonOpRule() {
		return getComparisonOpAccess().getRule();
	}

	////Expressions usable in comparisons. Starting with MapExpressions arranged by return type
	//MapExpr returns mtctl::MapExpr:
	//	MumlElemExpr | BufferMessageCountExpr | ConstExpr | SourceStateExpr | TargetStateExpr;
	public MapExprElements getMapExprAccess() {
		return pMapExpr;
	}
	
	public ParserRule getMapExprRule() {
		return getMapExprAccess().getRule();
	}

	//IntegerMapExpr returns mtctl::MapExpr:
	//	MumlElemExpr | BufferMessageCountExpr | ConstExpr;
	public IntegerMapExprElements getIntegerMapExprAccess() {
		return pIntegerMapExpr;
	}
	
	public ParserRule getIntegerMapExprRule() {
		return getIntegerMapExprAccess().getRule();
	}

	//TransitionMapExpr returns mtctl::MapExpr:
	//	MumlElemExpr;
	public TransitionMapExprElements getTransitionMapExprAccess() {
		return pTransitionMapExpr;
	}
	
	public ParserRule getTransitionMapExprRule() {
		return getTransitionMapExprAccess().getRule();
	}

	//StateMapExpr returns mtctl::MapExpr:
	//	MumlElemExpr | SourceStateExpr | TargetStateExpr;
	public StateMapExprElements getStateMapExprAccess() {
		return pStateMapExpr;
	}
	
	public ParserRule getStateMapExprRule() {
		return getStateMapExprAccess().getRule();
	}

	//StatechartMapExpr returns mtctl::MapExpr:
	//	MumlElemExpr;
	public StatechartMapExprElements getStatechartMapExprAccess() {
		return pStatechartMapExpr;
	}
	
	public ParserRule getStatechartMapExprRule() {
		return getStatechartMapExprAccess().getRule();
	}

	//BufferMapExpr returns mtctl::MapExpr:
	//	MumlElemExpr;
	public BufferMapExprElements getBufferMapExprAccess() {
		return pBufferMapExpr;
	}
	
	public ParserRule getBufferMapExprRule() {
		return getBufferMapExprAccess().getRule();
	}

	//MessageMapExpr returns mtctl::MapExpr:
	//	MumlElemExpr;
	public MessageMapExprElements getMessageMapExprAccess() {
		return pMessageMapExpr;
	}
	
	public ParserRule getMessageMapExprRule() {
		return getMessageMapExprAccess().getRule();
	}

	//BufferMessageCountExpr returns mtctl::BufferMsgCountExpr:
	//	"bufferMessageCount" "(" buffer=BufferMapExpr ")";
	public BufferMessageCountExprElements getBufferMessageCountExprAccess() {
		return pBufferMessageCountExpr;
	}
	
	public ParserRule getBufferMessageCountExprRule() {
		return getBufferMessageCountExprAccess().getRule();
	}

	//SourceStateExpr returns mtctl::SourceStateExpr:
	//	"sourceState" "(" transition=TransitionMapExpr ")";
	public SourceStateExprElements getSourceStateExprAccess() {
		return pSourceStateExpr;
	}
	
	public ParserRule getSourceStateExprRule() {
		return getSourceStateExprAccess().getRule();
	}

	//TargetStateExpr returns mtctl::TargetStateExpr:
	//	"targetState" "(" transition=TransitionMapExpr ")";
	public TargetStateExprElements getTargetStateExprAccess() {
		return pTargetStateExpr;
	}
	
	public ParserRule getTargetStateExprRule() {
		return getTargetStateExprAccess().getRule();
	}

	//MumlElemExpr returns mtctl::MumlElemExpr:
	//	elem=[ecore::EObject|QualifiedName] ("[" instance=[ecore::EObject|QualifiedName] "]")?;
	public MumlElemExprElements getMumlElemExprAccess() {
		return pMumlElemExpr;
	}
	
	public ParserRule getMumlElemExprRule() {
		return getMumlElemExprAccess().getRule();
	}

	//ConstExpr returns mtctl::ConstExpr:
	//	val=EInt timeUnit=TimeUnitExpr?;
	public ConstExprElements getConstExprAccess() {
		return pConstExpr;
	}
	
	public ParserRule getConstExprRule() {
		return getConstExprAccess().getRule();
	}

	//TimeUnitExpr returns valuetype::TimeUnit:
	//	"days" | "hrs" | "mins" | "secs" | "msecs" | "µsecs" | "nsecs";
	public TimeUnitExprElements getTimeUnitExprAccess() {
		return pTimeUnitExpr;
	}
	
	public ParserRule getTimeUnitExprRule() {
		return getTimeUnitExprAccess().getRule();
	}

	////Sets
	//SetExpr returns mtctl::SetExpr:
	//	InstanceSetExpr | SubinstanceSetExpr | IntervalSetExpr | {mtctl::StateSetExpr} "States" | {mtctl::TransitionSetExpr}
	//	"Transitions" | {mtctl::MessageSetExpr} "MessageTypes" | {mtctl::ClockSetExpr} "Clocks" | {mtctl::BufferSetExpr}
	//	"Buffers";
	public SetExprElements getSetExprAccess() {
		return pSetExpr;
	}
	
	public ParserRule getSetExprRule() {
		return getSetExprAccess().getRule();
	}

	//IntervalSetExpr returns mtctl::SetExpr:
	//	{mtctl::IntervalSetExpr} "[" lowerVal=INT "," upperVal=INT "]";
	public IntervalSetExprElements getIntervalSetExprAccess() {
		return pIntervalSetExpr;
	}
	
	public ParserRule getIntervalSetExprRule() {
		return getIntervalSetExprAccess().getRule();
	}

	//InstanceSetExpr returns mtctl::SetExpr:
	//	{mtctl::InstanceSetExpr} "Instances" "<" type=MumlElemExpr ">";
	public InstanceSetExprElements getInstanceSetExprAccess() {
		return pInstanceSetExpr;
	}
	
	public ParserRule getInstanceSetExprRule() {
		return getInstanceSetExprAccess().getRule();
	}

	//SubinstanceSetExpr returns mtctl::SetExpr:
	//	{mtctl::SubinstanceSetExpr} "Subinstances" "<" type=MumlElemExpr ">";
	public SubinstanceSetExprElements getSubinstanceSetExprAccess() {
		return pSubinstanceSetExpr;
	}
	
	public ParserRule getSubinstanceSetExprRule() {
		return getSubinstanceSetExprAccess().getRule();
	}

	////Other necessary definitions
	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//EInt returns ecore::EInt:
	//	"-"? INT;
	public EIntElements getEIntAccess() {
		return pEInt;
	}
	
	public ParserRule getEIntRule() {
		return getEIntAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
