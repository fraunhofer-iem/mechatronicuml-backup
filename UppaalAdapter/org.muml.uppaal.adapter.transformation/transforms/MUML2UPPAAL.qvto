import transforms.lib.MUML2UPPAAL.Clocks;
import transforms.lib.MUML2UPPAAL.Types;
import transforms.lib.MUML2UPPAAL.Expressions;
import transforms.lib.MUML2UPPAAL.Sync;
import transforms.lib.MUML2UPPAAL.Decls;
import transforms.lib.MUML2UPPAAL.Util;
import transforms.lib.MUML2UPPAAL.IDs;
import transforms.lib.RTSCUtil;
import transforms.mtctl.MTCTL2Uppaal;
--
import transforms.lib.MUML2UPPAAL.Async;
import transforms.lib.MUML2UPPAAL.Async.Variables;
import transforms.lib.MUML2UPPAAL.Async.Events;
--
modeltype uppaal uses 'http://www.muml.org/uppaal/1.0.0';
modeltype uppaal_requirements uses 'http://www.uni-paderborn.de/requirements/0.4.0';
modeltype uppaal_expressions uses uppaal::expressions('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_types uses uppaal::types('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_templates uses uppaal::templates('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_visuals uses uppaal::visuals('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_declarations_system uses uppaal::declarations::system('http://www.muml.org/uppaal/1.0.0');
modeltype uppaal_declarations uses uppaal::declarations('http://www.muml.org/uppaal/1.0.0');
modeltype muml_component uses pim::component('http://www.muml.org/pim/1.0.0');
modeltype muml_rtsc uses pim::realtimestatechart('http://www.muml.org/pim/1.0.0');
modeltype muml_behavior uses pim::behavior('http://www.muml.org/pim/1.0.0');
modeltype muml_connector uses pim::connector('http://www.muml.org/pim/1.0.0');
modeltype muml_types uses pim::types('http://www.muml.org/pim/1.0.0');
modeltype muml_protocol uses pim::protocol('http://www.muml.org/pim/1.0.0');
modeltype muml_valuetype uses pim::valuetype('http://www.muml.org/pim/1.0.0');
modeltype muml_msgtype uses muml::msgtype('http://www.muml.org/pim/1.0.0');
modeltype muml_constraint uses muml::constraint('http://www.muml.org/pim/1.0.0');
modeltype muml_instance uses muml::instance('http://www.muml.org/pim/1.0.0');
modeltype storydriven uses 'http://www.muml.org/core/1.0.0';
modeltype storydriven_actionLanguage uses 'http://www.muml.org/pim/actionlanguage/1.0.0';
modeltype storydriven_common uses core::expressions::common('http://www.muml.org/core/1.0.0');
modeltype storydriven_expressions uses core::expressions('http://www.muml.org/core/1.0.0');
modeltype extension uses 'http://www.muml.org/uppaal/adapter/extension/verificationextension/1.0.0';
modeltype verification_options uses 'http://www.uni_paderborn.de/fujaba/muml/verification/uppaal/options';

/**
* 
* CIC Migration to Uppaal, yielding the NTA model and the Uppaal "requirements" model
*
*/

transformation MUML2UPPAAL(in original: muml_rtsc, in input: muml_instance, in options:verification_options, out output: uppaal, out output_req : uppaal_requirements);

	property connectorTemplate : Template = null;	
	
	property intermediateLocationName : String = 'INTERMEDIATE';
		
	/** 
	 *
	 * Queries 
	 *
	 **/
	 
	query RealtimeStatechart :: getRtscDependencies() : OrderedSet(RealtimeStatechart) {
		
		var depends := object OrderedSet(RealtimeStatechart) {};
		depends += self;
		var rtscBeforeHierarchyNormalization := self;

		while(rtscBeforeHierarchyNormalization.flat) {
			rtscBeforeHierarchyNormalization := 
				rtscBeforeHierarchyNormalization.invresolveone(RealtimeStatechart);
		};
		
		var allStatecharts : OrderedSet(RealtimeStatechart) = rtscBeforeHierarchyNormalization.getAllStatechartsPrefix();
		var allAndStates : OrderedSet(State) = rtscBeforeHierarchyNormalization.getAllStatesPrefix()[embeddedRegions->size() > 1];
		
		allStatecharts->forEach(statechart) {

			var inputRtscs := OrderedSet{statechart};
			var resolved := statechart.resolveone(RealtimeStatechart);
			while(resolved != null) {
				resolved := resolved.resolveone(RealtimeStatechart);
				inputRtscs += resolved;
			};
			depends += self.parentRegion.parentState.embeddedRegions->collect(embeddedStatechart)->asSet()->intersection(inputRtscs)
			
		};
		
		allAndStates->forEach(andState) {
			
			var inputRtscs : OrderedSet(RealtimeStatechart) = OrderedSet{};
			var resolved := andState.resolveone(RealtimeStatechart);
			while(resolved != null) {
				resolved := resolved.resolveone(RealtimeStatechart);
				inputRtscs += resolved;
			};
			depends += self.parentRegion.parentState.embeddedRegions->collect(embeddedStatechart)->asSet()->intersection(inputRtscs)				

		};
		
		return depends;
	}
	
	query muml_behavior::Variable :: variableContainedInPortBeforeHierarchyNormalization() : Boolean {		
		var allPortStatechartsbefHierarchyNormalization := getAllDiscretePortOrRoleRTSCsBeforHierarchyNormalization();
		var allPortVariablesBeforeHierarchyNormalization : Sequence(muml_behavior::Variable) := allPortStatechartsbefHierarchyNormalization.variables;
		
		return self.searchResolveTreeRecursively(allPortVariablesBeforeHierarchyNormalization);
	}
	
	query muml_behavior::Operation :: operationContainedInPortBeforeHierarchyNormalization() : Boolean {		
		var allPortStatechartsbefHierarchyNormalization := getAllDiscretePortOrRoleRTSCsBeforHierarchyNormalization();
		var allPortOperationsBeforeHierarchyNormalization : Sequence(muml_behavior::Operation) := allPortStatechartsbefHierarchyNormalization.operations;
		
		return self.searchResolveTreeRecursively(allPortOperationsBeforeHierarchyNormalization);
	}
	
	query SynchronizationChannel :: synchronizationChannelContainedInPortBeforeHierarchyNormalization() : Boolean {		
		var allPortStatechartsbefHierarchyNormalization := getAllDiscretePortOrRoleRTSCsBeforHierarchyNormalization();
		
		var allSynchronizationChannelsBeforeHierarchieNormalization : Sequence(SynchronizationChannel) 
		:= allPortStatechartsbefHierarchyNormalization.states->select(s|not s.embeddedRegions->isEmpty()).channels;
		
		return self.searchResolveTreeRecursively(allSynchronizationChannelsBeforeHierarchieNormalization);
	}
	
	query Clock :: clockContainedInPortBeforeHierarchyNormalization() : Boolean {
		var allPortStatechartsBeforeHierarchyNormalization := getAllDiscretePortOrRoleRTSCsBeforHierarchyNormalization();
		var allPortClocksBeforeHierarchyNormalization := allPortStatechartsBeforeHierarchyNormalization.clocks;
		
		return self.searchResolveTreeRecursively(allPortClocksBeforeHierarchyNormalization);			
	}
	
	query getAllDiscretePortOrRoleRTSCsBeforHierarchyNormalization() : Sequence(RealtimeStatechart) {
		var allPortStatecharts := cicToVerify().getAllDiscretePortRealtimeStatecharts();
		var allPortStatechartsbefHierarchyNormalization := allPortStatecharts->beforeHierarchyNormalization().getAllStatechartsPrefix();
		return allPortStatechartsbefHierarchyNormalization;
	}
	
	query RealtimeStatechart :: beforeHierarchyNormalization() : RealtimeStatechart {
		var rtscBeforeHierarchyNormalization := self;
		while(rtscBeforeHierarchyNormalization.flat) {
			rtscBeforeHierarchyNormalization := 
				rtscBeforeHierarchyNormalization.invresolveone(RealtimeStatechart);
		};		
		return rtscBeforeHierarchyNormalization;
	}
	
	query OclAny :: searchResolveTreeRecursively(set : Sequence(OclAny)) : Boolean {
		if(set->includes(self)) {
			return true;
		};
		var resolvingSequence : Sequence(OclAny);
		if(self.oclIsKindOf(SynchronizationChannel)) {
			resolvingSequence := self.invresolve(SynchronizationChannel);
		}
		else if(self.oclIsKindOf(muml_behavior::Variable)) {
			resolvingSequence := self.invresolve(muml_behavior::Variable);
		}
		else if(self.oclIsKindOf(muml_rtsc::Clock)) {
			resolvingSequence := self.invresolve(muml_rtsc::Clock);
		}
		else if(self.oclIsKindOf(muml_behavior::Operation)) {
			resolvingSequence := self.invresolve(muml_behavior::Operation);
		};
		if(resolvingSequence->size() > 0) {
			var returnValue : Boolean := false;
			resolvingSequence->forEach(variable) {				
				returnValue := returnValue or variable.searchResolveTreeRecursively(set);
				if(returnValue) {
					break;
				};
			};
			return returnValue;
		}
		else return false;
	}	
	
	query muml_behavior::Variable :: variableContainedInSubPortBeforeHierarchyNormalization() : Boolean {
		var subPortBehaviors : Sequence(RealtimeStatechart) := getAllSubPortStatechartsBeforeHierarchyNormalizion();
		var allSubroleVariablesBeforeHierarchyNormalization : Sequence(muml_behavior::Variable) := subPortBehaviors.getAllStatechartsPrefix().variables;
	
		var resulting :=  self.searchResolveTreeRecursively(allSubroleVariablesBeforeHierarchyNormalization);	
		return resulting; 		
	}
	
	query muml_behavior::Operation :: operationContainedInSubPortBeforeHierarchyNormalization() : Boolean {
		var subPortBehaviors : Sequence(RealtimeStatechart) := getAllSubPortStatechartsBeforeHierarchyNormalizion();
		var allSubroleOperationsBeforeHierarchyNormalization : Sequence(muml_behavior::Operation) := subPortBehaviors.getAllStatechartsPrefix().operations;
	
		var resulting :=  self.searchResolveTreeRecursively(allSubroleOperationsBeforeHierarchyNormalization);	
		return resulting; 		
	}
	
	query Clock :: clockContainedInSubPortBeforeHierarchyNormalization() : Boolean {
		var subPortBehaviors : Sequence(RealtimeStatechart) := getAllSubPortStatechartsBeforeHierarchyNormalizion();
		var allSubroleVariablesBeforeHierarchyNormalization : Sequence(Clock) := subPortBehaviors.getAllStatechartsPrefix().clocks;
	
		var resulting :=  self.searchResolveTreeRecursively(allSubroleVariablesBeforeHierarchyNormalization);	
		return resulting; 
	}
	
	query SynchronizationChannel :: synchChannelContainedInSubPortBeforeHierarchyNormalization() : Boolean {
		var subPortBehaviors : Sequence(RealtimeStatechart) := getAllSubPortStatechartsBeforeHierarchyNormalizion();
		var allSubroleVariablesBeforeHierarchyNormalization : Sequence(SynchronizationChannel) := subPortBehaviors.getAllStatechartsPrefix().states->select(s|not s.embeddedRegions->isEmpty()).channels;
	
		var resulting :=  self.searchResolveTreeRecursively(allSubroleVariablesBeforeHierarchyNormalization);	
		return resulting; 		
	}
	
	query getAllSubPortStatechartsBeforeHierarchyNormalizion() : Sequence(RealtimeStatechart) {		
		var allRoleStatechartsBeforHierarchyNormalization := getAllDiscretePortOrRoleRTSCsBeforHierarchyNormalization();		
		
		return allRoleStatechartsBeforHierarchyNormalization
			->select(rtsc : RealtimeStatechart | not rtsc.behavioralElement.oclIsUndefined() and rtsc.behavioralElement.oclIsKindOf(DiscreteInteractionEndpoint))
				.behavioralElement.oclAsType(DiscreteInteractionEndpoint).subroleBehavior.oclAsType(RealtimeStatechart);
	}
	
	query cicToVerify() : ComponentInstanceConfiguration {

		return input.objects()[ComponentInstanceConfiguration]
			->any(ve:ComponentInstanceConfiguration | ve.extension->exists(oclIsKindOf(ElementToVerifyExtension)));
	
	}

	query userDefinedDataTypes() : OrderedSet(DataType) {
		
		return object OrderedSet(DataType) {}
		
	}

	/**
	create a list that contains the number of message buffers of each discrete port. Return the maximum value of this list.
	*/
	query getMaximalNumberOfBuffersPerDiscretePort() : Integer {
		
		var maximum := cicToVerify()
			.discretePortInstances()
			->receiverMessageBuffer.size()
			->max();
		log("getMaximalNumberOfBuffersPerDiscretePort: " + maximum.toString());
		return maximum;
	}	
	
	query overallNumberOfDiscretePortInstances() : Integer {
		
		return cicToVerify().discretePortInstances()->size()
	}	
	
	query overallNumberOfComponentInstances() : Integer {
	
		return cicToVerify().componentInstances->size()	
	}

	query getMaxBufferSize() : Integer {
		// returns the max Buffer size
		
		var buffers : Set(MessageBuffer) := 
			cicToVerify()
			.discretePortInstances()
			->collect(receiverMessageBuffer)->asSet();

		assert fatal (buffers->notEmpty()) with log('At least one message buffer expected.');
		
		return buffers->bufferSize->sortedBy(value)->last().value;
	}
	
	query getMaxOfBufferAndConnectorSize() : Integer {		
		// set capacity for all message pools to the size of the largest buffer in the source model
		// or connector size				
		
		var maxBufferSize := getMaxBufferSize();
		var connectorOutBufferSize := getConnectorSize();
		
		return if maxBufferSize > connectorOutBufferSize then maxBufferSize else connectorOutBufferSize endif; 	
	}
	
	query getConnectorSize() : Integer {
		
		var connectorOutBufferSize := options.objects()->any(oclIsKindOf(Options)).oclAsType(Options).connectorOutBufferSize;
		
		return connectorOutBufferSize;
	}
	
	query DiscretePortInstance :: behavior() : Behavior {
	
		return self.portType.oclAsType(DiscretePort).behavior;
	}
	
	query ConnectorEndpoint :: getBufferSize() : Integer {
	
		return assert fatal (false) with log('Should never be reached.')		
	}

	query messageTypes() : OrderedSet(MessageType) {
	
		var ports := cicToVerify().discretePorts();
	
		// sort by name to ensure a reproducible order	
		return ports
			->collect(senderMessageTypes)
			->union(ports->collect(receiverMessageTypes))
			->flatten()
			->asOrderedSet() 
	}
	
	query getMaximalNumberOfMessagesInTransit() : Integer {
	
		var bufferInstances : Sequence(MessageBuffer) = 
			cicToVerify()
			.discretePortInstances()
			->collect(receiverMessageBuffer);
		
		var connectors : Set(ConnectorInstance) = cicToVerify().portConnectorInstances;
		
		// we assume here a message has to be inside a connector or inside a buffer
		return (bufferInstances->size() * getMaxBufferSize() + connectors->size() * getConnectorSize()) ;		
	}
    
   query getMaximalNumberOfBuffersPerPort() : Integer {
		
		var portInstances := cicToVerify().discretePortInstances();

		assert fatal (portInstances->notEmpty()) with log('At least one port instance expected.');

		return portInstances->sortedBy(receiverMessageBuffer->size())->last().receiverMessageBuffer->size();
	}

	query ConnectorInstance :: getRoleConnector() : RoleConnector {
		
		return self.connectorEndpointInstances->first().oclAsType(DiscretePortInstance).refinedRole.roleConnector;		
	}	
	// QoS assumptions	
			
	query Connector :: getMinDelay() : Expression {
		return new LiteralExpression(0);
	}	
	
	query Connector :: getMaxDelay() : Expression {
		return new LiteralExpression(0);
	}	
	
	query Connector :: getMessageLoss() : Expression {
		return new LiteralExpression(false);
	}
	
	query RoleConnector :: getMinDelay() : Expression {
		// TODO: if we support variables for protocols, replace the 'null' values below by appropriate IDs
		return self.connectorQualityOfServiceAssumptions.minMessageDelay.mapTimeValue2Expression(null,null,null);
	}	
	
	query RoleConnector :: getMaxDelay() : Expression {
		// TODO: if we support variables for protocols, replace the 'null' values below by appropriate IDs
		return self.connectorQualityOfServiceAssumptions.maxMessageDelay.mapTimeValue2Expression(null,null,null);
	}
	
	
	query RoleConnector :: getMessageLoss() : Expression {
		return new LiteralExpression(self.connectorQualityOfServiceAssumptions.messageLossPossible);
	}	
	
	//TODO move to shared library
	query Collection(OclAny) :: sortedByName() : Sequence(OclAny) {
	
		var named : Collection(OclAny) = self->select(not oclIsUndefined() and oclIsKindOf(NamedElement));
		
		var unnamed : Collection(OclAny) = self->select(not oclIsUndefined() and not oclIsKindOf(NamedElement));
	
		var objects : Sequence(OclAny) = object Sequence(OclAny) {};
		
		objects += named.oclAsType(NamedElement)->sortedBy(name);
		objects += unnamed;
	
		return objects;	
	}
	
	
	// true iff this transition originated from an original transition without a deadline
	query Transition :: shouldCreateIntermediateLocation() : Boolean {
		var resolvedTransitions := self->closure(t | t.invresolve(Transition));
		var originalTransition : Transition = original.objects()[Transition]->intersection(resolvedTransitions)->any(true);
		if (originalTransition.oclIsUndefined()) return false;
		if (originalTransition.absoluteDeadlines->notEmpty() or originalTransition.relativeDeadline != null) then return false endif;
		return true;
	}	
	
	query SynchronizationChannel :: isUrgent() : Boolean {
		
		var allAccessingTransitions : OrderedSet(Transition) = input.objects()[Transition]->select((not synchronization.oclIsUndefined()) and (synchronization.syncChannel = self))->asOrderedSet();
				
		var allReceivingTransitions : OrderedSet(Transition) = allAccessingTransitions->select(synchronization.kind = muml_rtsc::SynchronizationKind::RECEIVE)->asOrderedSet();
		
		var allSendingTransitions : OrderedSet(Transition) = allAccessingTransitions->select(synchronization.kind = muml_rtsc::SynchronizationKind::SEND)->asOrderedSet();
		
		
		-- a channel is urgent if all receiving OR all sending transitions are urgent
		if (allReceivingTransitions->forAll(urgent) or allSendingTransitions->forAll(urgent))
		then {
			return true;
		}
		endif;
		
		-- a channel is non-urgent if all receiving AND all sending transitions are non-urgent
		if (allReceivingTransitions->forAll(not urgent) and allSendingTransitions->forAll(not urgent))
		then {
			return false;
		}
		endif;
		
		return assert fatal (false) with log('Synchronization channel is accessed by both urgent and non-urgent transitions.');
		
		// TODO handle the above case by copying synchronization channels
		
	}
	
	query ComponentInstanceConfiguration :: getAllSubroleRtscs() : Sequence(RealtimeStatechart) {
		return self.discretePorts()
			->select(port | port.multi)
			->collect(subroleBehavior.oclAsType(RealtimeStatechart))
			->getRtscDependencies()
			->flatten();
	}		
	
	query ComponentInstanceConfiguration :: getAllDiscretePortBehaviors() : Sequence(Behavior) {
	
		return self.discretePorts()->collect(behavior.oclAsType(RealtimeStatechart)).getRtscDependencies();
	
	}
	
	query ComponentInstanceConfiguration :: getAllDiscretePortRealtimeStatecharts() : Sequence(RealtimeStatechart) {
	
		return self.discretePorts()->collect(behavior.oclAsType(RealtimeStatechart)).getRtscDependencies();
	
	}
	
	query RealtimeStatechart :: belongsToRole() : Boolean {
		
		return cicToVerify().getAllDiscretePortRealtimeStatecharts()->includes(self);
	}	
	
	query RealtimeStatechart :: belongsToSubrole() : Boolean {
				
		return cicToVerify().getAllSubroleRtscs()->includes(self);		
	}
	
	query SynchronizationChannel :: belongsToSubrole() : Boolean {
						
		var allChannelsOfSubroleRtscs := cicToVerify().getAllSubroleRtscs()->states->flatten()->channels->flatten();
		
		var isSubRoleChannel : Boolean := allChannelsOfSubroleRtscs->includes(self);
		
		if (not isSubRoleChannel) {
			isSubRoleChannel := self.synchChannelContainedInSubPortBeforeHierarchyNormalization();
		};
		
		return isSubRoleChannel;
	}
	
	query Clock :: belongsToSubrole() : Boolean {
	
		var allClocksOfSubroleRtscs := cicToVerify().getAllSubroleRtscs()->clocks->flatten();
		var isSubRoleClock : Boolean := allClocksOfSubroleRtscs->includes(self);
		
		if(not isSubRoleClock) {
			isSubRoleClock := self.clockContainedInSubPortBeforeHierarchyNormalization();
		};
		return isSubRoleClock;		
	}
	
	query muml_behavior::Variable :: belongsToSubrole() : Boolean {
		
		var allSubRoleRtscs := cicToVerify().getAllSubroleRtscs();		
		var allVariablesOfSubroleRtscs := allSubRoleRtscs->variables->flatten();		
		var isSubRoleVariable : Boolean :=  allVariablesOfSubroleRtscs->includes(self);
		
		if (not isSubRoleVariable) {
			isSubRoleVariable := self.variableContainedInSubPortBeforeHierarchyNormalization();
		};
		
		return isSubRoleVariable;
	}
	
	query muml_behavior::Operation :: belongsToSubrole() : Boolean {
	
		var allOperationsOfSubroleRtscs := cicToVerify().getAllSubroleRtscs()->operations->flatten();
		
		var isSubRoleOperation : Boolean := allOperationsOfSubroleRtscs->includes(self);
		
		if (not isSubRoleOperation) {
			isSubRoleOperation := self.operationContainedInSubPortBeforeHierarchyNormalization();
		};
		return isSubRoleOperation;
	}
	
	query AsynchronousMessageEvent :: belongsToSubrole() : Boolean {
	
		var allTransitionsOfSubroleRtscs := cicToVerify().getAllSubroleRtscs()->getTransitions()->flatten();
	
		var allRaiseMsgEventsOfSubroleRtscs := allTransitionsOfSubroleRtscs->raiseMessageEvent;

		var allTriggerMsgEventsOfSubroleRtscs := allTransitionsOfSubroleRtscs->triggerMessageEvent;
		
		return allTriggerMsgEventsOfSubroleRtscs->includes(self) or allRaiseMsgEventsOfSubroleRtscs->includes(self)
	}
	
	
	/**
	*
	* End Queries
	*/
	
	
	main() {
		
		assert fatal (cicToVerify().discretePortInstances()->collect(receiverMessageBuffer)->forAll(mb : MessageBuffer | not mb.bufferSize.infinity and mb.bufferSize.value < 5000)) 
		with log('Only finite buffer sizes <5000 are supported');
		
		
		
		// TODO Support arbitrary CICs
/*		assert fatal (input.objects()[ComponentInstance]
			->forAll(ci : ComponentInstance | ci.portInstances
				->select(pi | not (pi.oclIsKindOf(DiscreteSinglePortInstance) 
							  and not pi.oclAsType(DiscreteSinglePortInstance).multiInteractionEndpointInstance.oclIsUndefined()))->size() = 1)) 
		with log('Only component instances with exactly one (single/multi) port instance are supported');*/
		
		input.objects()[ComponentInstanceConfiguration]->map CIC2NTA();		

		// TODO
		var mtctlTranslation : MTCTL2Uppaal = new MTCTL2Uppaal(input, output_req);
		
		var retcode : Status = mtctlTranslation.transform();
		assert fatal (retcode.succeeded()) with log('Mtctl2Uppaal translation failed: ' + retcode.raisedException().repr());
		
		
		//Add noIntermediateLocationActive guards to all edges (except the ones leading away from an intermediate location)
		(output.objects()[Edge]-resolveIn(Transition :: Transition2FinalEdge)->asSet())->forEach(edge) {
			addNoIntermediateLocationActiveGuard(edge);
		};
		//Set intermediateLocationSemaphore upper integer bound to the number of intermediate locations
		(map createIntermediateLocationSemaphoreVariableDeclaration()).typeDefinition.oclAsType(RangeTypeSpecification)
			.bounds.upperBound.oclAsType(LiteralExpression).text := resolveIn(Transition::Transition2IntermediateLocation)->size().repr();
	}
	
		
	-- we assume here that a CIC has two atomic components or 1 atomic component with a multiport and n atomic components
	mapping ComponentInstanceConfiguration :: CIC2NTA() : NTA when {self = cicToVerify()} {
	
		name := self.name;
	
		Types::initialize();
		
		int := INT;		
		bool := BOOL;
		clock := CLOCK;
		chan := CHAN;
		void := VOID;
	
		-- create global declarations
		globalDeclarations := self.map CIC2GlobalDeclarations();
		
		-- create connector templatee 
		connectorTemplate := map Async::createConnectorTemplate(self.discretePortInstances());
		template += connectorTemplate;
		
		-- create templates for all components
		template += self.components().map Component2Templates();
		
		-- create system declarations
		systemDeclarations := self.map CIC2SystemDeclarations();
		
		-- create urgency provider template
		template += map UrgentSyncProvider();
	
	}
	
	mapping Component :: Component2Templates() : OrderedSet(Template)
	disjuncts 
		AtomicComponent::AtomicComponent2Templates,
		Component::failOnUnsupportedComponent;
	
	
	mapping AtomicComponent :: AtomicComponent2Templates() : OrderedSet(Template) {
		// for discrete single ports we transform only the behavior
		init {
			result := self.behavior.map Behavior2Templates()
		}
	}
	
	
	mapping Component :: failOnUnsupportedComponent() : OrderedSet(Template) {
		init {
			assert fatal (false) with log("Mapping this component to a template is unsupported.")
		}
	} 
	
	
	mapping PortInstance :: PortInstance2TemplateDeclarations() : OrderedSet(TemplateDeclaration)
	disjuncts 
		DiscreteSinglePortInstance::DiscreteSinglePortInstance2TemplateDeclarations, 
		DiscreteMultiPortInstance::DiscreteMultiPortInstance2TemplateDeclarations, 
		PortInstance::failOnUnsupportedPortInstance;
		
		
	mapping DiscreteSinglePortInstance :: DiscreteSinglePortInstance2TemplateDeclarations() : OrderedSet(TemplateDeclaration) {
		
		init {
			
			result := OrderedSet{};
			
			// this assumes that each component has only *one* discrete singleport
			self.componentInstance.componentType.oclAsType(AtomicComponent).behavior
				.getAllBehaviorsPrefix()		
				->map Behavior2Template()->forEach(template) {
					var rtsc := template.invresolveoneIn(Behavior::Behavior2Template).oclAsType(RealtimeStatechart);						
					if (not rtsc.belongsToRole())
						result += self.componentInstance.map ComponentInstance2Declaration(template)
					else
						result += self.map DiscretePortInstance2Declaration(template);
				}
		}
	}
	
	
	mapping DiscreteMultiPortInstance :: DiscreteMultiPortInstance2TemplateDeclarations() : OrderedSet(TemplateDeclaration) {
	
		init {
			// this assumes that each component has only *one* discrete multiport
			result := OrderedSet{};
			
			var subRoleBehavior := self.portType.oclAsType(DiscretePort).subroleBehavior;
			
			assert fatal (subRoleBehavior.oclIsKindOf(RealtimeStatechart)) with log("A subrole behavior has to be a RTSCs");
			
			var subRoleBehaviorDependencies := subRoleBehavior.oclAsType(RealtimeStatechart).getRtscDependencies();
			
			var allBehaviors := self.componentInstance.componentType.oclAsType(AtomicComponent).behavior.getAllBehaviorsPrefix();
			
			var allDiscretePortBehaviors := cicToVerify().getAllDiscretePortBehaviors();
			
			// remove dependencies of subrole behavior from allBehaviors
			var allBehaviorsWithoutDependencies : List(Behavior) = List{}; 
			allBehaviors->forEach(behavior) {
				if(not subRoleBehaviorDependencies->includes(behavior.oclAsType(RealtimeStatechart)))
				then {
					allBehaviorsWithoutDependencies->add(behavior)
				} endif;
			};

			allBehaviorsWithoutDependencies->map Behavior2Template()->forEach(template) {
				var behavior := template.invresolveoneIn(Behavior::Behavior2Template).oclAsType(Behavior);
				if (not behavior.oclIsUndefined() and not allDiscretePortBehaviors->includes(behavior))
					result += self.componentInstance.map ComponentInstance2Declaration(template)
				else
					result += self.map DiscretePortInstance2Declaration(template);
			};
			
			// for each connector instance instantiate a sub-role template
			var subInstances : List(DiscreteInteractionEndpointInstance) := List{};
			var currentInstance := self.first;
			while(currentInstance != null) {
				subInstances->append(currentInstance);
				currentInstance := currentInstance.next
			};
			
			subInstances->collect(oclAsType(DiscretePortInstance))->forEach(inst) {
				
				subRoleBehaviorDependencies->forEach(subroleDepend) {
					subroleDepend->map Behavior2Template()->forEach(template) {
						result += inst.map DiscreteSubPortInstance2Declaration(template, self)
					}
				}

			}
			
		}
	}
	
	
	mapping PortInstance :: failOnUnsupportedPortInstance() : OrderedSet(TemplateDeclaration) {
		
		init {
			assert fatal (false) with log("Mapping this port instance is unsupported.")
		}	
		
	}

	
	mapping ComponentInstanceConfiguration :: CIC2SystemDeclarations() : SystemDeclarations when {self = cicToVerify()}{
		var portInstances := self.discretePortInstances();
				
		// declare a parameter-less template for each port instance except for instances that have an underlying multiport instance (in UPPAAL, this is also known as process instantiation)
		var singlePortInstances := 
			portInstances->select(pi | pi.oclIsKindOf(DiscreteSinglePortInstance) 
							and pi.oclAsType(DiscreteSingleInteractionEndpointInstance)
							.multiInteractionEndpointInstance.oclIsUndefined());
		var multiPortInstances := 
			portInstances->select(pi | pi.oclIsKindOf(DiscreteMultiPortInstance));	

		singlePortInstances->asOrderedSet()->union(multiPortInstances->asOrderedSet())->forEach(pi) {
			declaration += pi.map PortInstance2TemplateDeclarations()
		};
		
		-- declare a parameter-less template for each connector instance (in UPPAAL, this is also known as process instantiation)				
		self.portConnectorInstances->forEach(conInstance) {		
			declaration += conInstance.map ConnectorInstance2Declarations()
		};	
				
		
		-- 'system' section: list all parameter-less templates declared earlier + the urgent sync provider
		
		system := object System {
			instantiationList += object InstantiationList {
			
				-- sort by name to ensure a reproducible order			
				template += declaration[TemplateDeclaration].declaredTemplate->sortedBy(name);
				
				template += map UrgentSyncProvider()
				
			}
		}
		
	}
	
	mapping DiscretePortInstance :: DiscretePortInstance2Declaration(template : Template) : TemplateDeclaration {
		
		declaredTemplate := object RedefinedTemplate {
			name := template.name + '_' + self.getID().repr();
			referredTemplate := template;
		};
				
		argument += new LiteralExpression(self.componentInstance.getID());
				
		argument += new LiteralExpression(self.getID());
				
	}
	
	mapping DiscretePortInstance :: DiscreteSubPortInstance2Declaration(template : Template, parent : DiscreteMultiPortInstance) : TemplateDeclaration {
		
		declaredTemplate := object RedefinedTemplate {
			name := template.name + '_subport_' + self.getID().repr();
			referredTemplate := template;
		};
				
		argument += new LiteralExpression(self.componentInstance.getID());
				
		argument += new LiteralExpression(parent.getID());
		
		argument += new LiteralExpression(self.getID());
		
	}
	
	mapping ComponentInstance :: ComponentInstance2Declaration(template : Template) : TemplateDeclaration {
		
		declaredTemplate := object RedefinedTemplate {
			name := template.name + '_component_' + self.getID().repr();
			referredTemplate := template;
		};
				
		argument += new LiteralExpression(self.getID());
				
	}
	
	mapping ConnectorInstance :: ConnectorInstance2Declarations() : OrderedSet(TemplateDeclaration) {

		init {
			if(not self.connectorEndpointInstances->forAll(c | c.oclIsKindOf(DiscretePortInstance))) 
			then {
				assert warning (false) with log("Couldn't migrate unsupported connector instance type (we only support discrete port instances as connector endpoints). Skipping...");
				result := null;
			}
			else {
				
				result := OrderedSet{};
				
				var sourceID := self.connectorEndpointInstances->first().oclAsType(DiscretePortInstance).getID();
				var targetID := self.connectorEndpointInstances->last().oclAsType(DiscretePortInstance).getID();
				
				// here, we declare a bidirectional connector. TODO create unidirectional connector only if required by the protocol see ticket #1457
				
				result += object TemplateDeclaration {
					
					declaredTemplate := object RedefinedTemplate {
						name := 'Connector_' + sourceID.repr() + '_' + targetID.repr();
						referredTemplate := connectorTemplate;
					};
					
					argument += new LiteralExpression(sourceID);
				
					argument += new LiteralExpression(targetID);
									
					argument += self.getRoleConnector().getMinDelay();
					
					argument += self.getRoleConnector().getMaxDelay();
					
					argument += self.getRoleConnector().getMessageLoss();
					
				};
				
				result += object TemplateDeclaration {
					
					declaredTemplate := object RedefinedTemplate {
						name := 'Connector_' + targetID.repr() + '_' + sourceID.repr();
						referredTemplate := connectorTemplate;
					};
					
					argument += new LiteralExpression(targetID);
				
					argument += new LiteralExpression(sourceID);
									
					argument += self.getRoleConnector().getMinDelay();
					
					argument += self.getRoleConnector().getMaxDelay();
					
					argument += self.getRoleConnector().getMessageLoss();
					
				};
			
			} endif;
		}

						
	}
	
	mapping Behavior :: Behavior2Templates() : OrderedSet(Template) disjuncts RealtimeStatechart::RTSC2Templates;
								
	mapping RealtimeStatechart :: RTSC2Templates() : OrderedSet(Template)
		disjuncts RealtimeStatechart::FlatRTSC2Templates, RealtimeStatechart::OrthogonalRTSC2Templates;
	
	mapping RealtimeStatechart :: FlatRTSC2Templates() : OrderedSet(Template) when {self.flat} {
		
		// TODO add bug URL
				
		init {
																
			result := OrderedSet {self.map RTSC2Template()}
						
		}
					
	}
	
	mapping RealtimeStatechart :: OrthogonalRTSC2Templates() : OrderedSet(Template) when {not self.flat} {
		
		// TODO add bug URL
		
		init {

					
			assert fatal (self.states->size() = 1) with log('Exactly one state expected.');
						
			-- map operations, variables, clocks, sync channels first
			globalDeclarations.declaration += self.operations->map Operation2FunctionDeclaration();
			globalDeclarations.declaration += self.variables->map Variable2VariableDeclaration();
			globalDeclarations.declaration += self.clocks->map Clock2VariableDeclaration();
			globalDeclarations.declaration += self.states->first().channels->map SyncChannel2VariableDeclaration();
						
			result := self.states->first().embeddedRegions->embeddedStatechart.map RTSC2Templates()->asOrderedSet()
			
		}
					
	}
			
	mapping RealtimeStatechart :: RTSC2Template() : Template when {self.flat} {
		
		name := self.name;
						
				
		-- declare ID parameters 
		-- parameters are to be used as an index for variable access inside the template
		
		var componentInstanceID : Variable = null;
		var portOrRoleInstanceID : Variable = null;
		var subPortOrRoleInstanceID : Variable = null;
		
		
		if (self.isComponentStatechart())
		then {
		
			parameter += object Parameter {
			
				variableDeclaration := object DataVariableDeclaration {
				
					typeDefinition := object TypeReference {
						referredType := map ComponentInstanceType()
					};
								
					componentInstanceID := self.map RTSC2ComponentInstanceID();
					
					variable += componentInstanceID;
					
					prefix := DataVariablePrefix::CONST
					
				}	
			
			}
		}
		endif;
		
		if (self.belongsToRole())
		then {
		
			parameter += object Parameter {
			
				variableDeclaration := object DataVariableDeclaration {
			
					typeDefinition := object TypeReference {
						referredType := map DiscretePortInstanceType();
					};
					
					portOrRoleInstanceID := self.map RTSC2DiscretePortInstanceID();
				
					variable += portOrRoleInstanceID;
					
					prefix := DataVariablePrefix::CONST;
				
				}	
							
			};
			
			if(self.belongsToSubrole())
			then {
				parameter += object Parameter {
				
					variableDeclaration := object DataVariableDeclaration {
				
						typeDefinition := object TypeReference {
							referredType := map DiscretePortInstanceType();
						};
						
						subPortOrRoleInstanceID := self.map RTSC2DiscreteSubPortInstanceID();
					
						variable += subPortOrRoleInstanceID;
						
						prefix := DataVariablePrefix::CONST;
					
					}	
								
				}
			} endif;
			
			
		}
		endif;
		
		globalDeclarations.declaration += self.variables->map Variable2VariableDeclaration();
		globalDeclarations.declaration += self.clocks->map Clock2VariableDeclaration();
		globalDeclarations.declaration += self.operations->map Operation2FunctionDeclaration();
		
		self.getTransitions()->collect(raiseMessageEvent)->map RaiseMessageEvent2ArrayInitializerExpressionDeclarations(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID)->forEach(decl) {
			globalDeclarations.declaration += decl;
		};
		
		declarations := object LocalDeclarations {
			-- local variable for storing  received messages
			declaration += self.map createMsgVariableDeclaration();
		};
						
		location += self.states->map State2Location(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		assert fatal (self.states->select(initial)->size()= 1) with log('Exactly one initial state expected.');
		_init := self.states->any(initial).resolveoneIn(State::State2Location, Location);
		
		edge += self.getTransitions()->map Transition2Edge(self, componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		location += self.getTransitions()->map Transition2IntermediateLocation();
		edge += self.getTransitions()->map Transition2InitialEdge(self, componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		edge += self.getTransitions()->map Transition2FinalEdge();
		
	}
	
	
	mapping State :: State2Location(componentInstanceID : Variable, portOrRoleInstanceID : Variable, subPortOrRoleInstanceID : Variable) : Location {
				
		name := self.name;
				
		locationTimeKind := self.getLocationKind();
				
		invariant := self.invariants->map ClockConstraint2CompareExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID)->constructConjunction();
				
	}
			
	mapping Transition :: Transition2Edge(rtsc : RealtimeStatechart, componentInstanceID : Variable, portOrRoleInstanceID : Variable, subPortOrRoleInstanceID : Variable) : Edge when {not self.shouldCreateIntermediateLocation()} {
		
		//assert fatal (self.urgent implies self.clockConstraints->isEmpty()) with log('Clock constraints on urgent edges unsupported by UPPAAL');
						
		init {
			var discretePortInstances := cicToVerify().discretePortInstances()
		}
		
		source := self.source.resolveoneIn(State::State2Location, Location);
		target := self.target.resolveoneIn(State::State2Location, Location);
		
		selection += self.action.allSubobjects()[Assignment]->map Assignment2Selection();
		
		guard := self.constructGuard(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
				
		if (self.synchronization = null and self.urgent)
		then {
			synchronization := map UrgentSyncChannel().getReceiveSynchronization();
		} else {
			synchronization := self.synchronization.map Synchronization2Synchronization(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		}
		endif;
		
			
		self.clockResets->forEach(clock) {
			update += new AssignmentExpression(clock, componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		};
	
		-- store message from buffer to a variable before its accessed via the action language
		update += self.triggerMessageEvent.map TriggerMessageEvent2StoreMessageExpression(rtsc, portOrRoleInstanceID, subPortOrRoleInstanceID, discretePortInstances);
	
		if (self.action != null)  
		then {
		
			update += self.action.expressions.map Expression2Expressions(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);

		}
		endif;

		update += self.triggerMessageEvent.map TriggerMessageEvent2ConsumeFunctionCall(portOrRoleInstanceID, subPortOrRoleInstanceID, discretePortInstances);
		
		-- if sending an array expression, first assign this array to a variable. This is because UPPAAL does not support arrays that are not assigned to a variable
		update += self.raiseMessageEvent.map RaiseMessageEvent2InitializerFunctionCalls(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		update += self.raiseMessageEvent.map RaiseMessageEvent2SendFunctionCall(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
							
	}
	
	mapping Transition :: Transition2IntermediateLocation() : Location when {self.shouldCreateIntermediateLocation()} {
		name := intermediateLocationName.addSuffixNumberUnderline();
		locationTimeKind := LocationKind::COMMITED;
		color := ColorKind::WHITE;
	}
	
	mapping Transition :: Transition2InitialEdge(rtsc : RealtimeStatechart, componentInstanceID : Variable, portOrRoleInstanceID : Variable, subPortOrRoleInstanceID : Variable) : Edge when {self.shouldCreateIntermediateLocation()} {
		//assert fatal (self.urgent implies self.clockConstraints->isEmpty()) with log('Clock constraints on urgent edges unsupported by UPPAAL');
		
		init {
			var discretePortInstances := cicToVerify().discretePortInstances()
		}
			
		source := self.source.resolveoneIn(State::State2Location, Location);
		target := self.map Transition2IntermediateLocation();
		
		selection += self.action.allSubobjects()[Assignment]->map Assignment2Selection();
		
		guard := self.constructGuard(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		
		if (self.synchronization = null and self.urgent)
		then {
			synchronization := map UrgentSyncChannel().getReceiveSynchronization();
		} else {
			synchronization := self.synchronization.map Synchronization2Synchronization(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		}
		endif;
		
			
		self.clockResets->forEach(clock) {
			update += new AssignmentExpression(clock, componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		};
	
		-- store message from buffer to a variable before its accessed via the action language
		update += self.triggerMessageEvent.map TriggerMessageEvent2StoreMessageExpression(rtsc, portOrRoleInstanceID, subPortOrRoleInstanceID, discretePortInstances);
	
		if (self.action != null)  
		then {
		
			update += self.action.expressions.map Expression2Expressions(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);

		}
		endif;
		

		update += self.triggerMessageEvent.map TriggerMessageEvent2ConsumeFunctionCall(portOrRoleInstanceID, subPortOrRoleInstanceID, discretePortInstances);
		
		-- if sending an array expression, first assign this array to a variable. This is because UPPAAL does not support arrays that are not assigned to a variable
		update += self.raiseMessageEvent.map RaiseMessageEvent2InitializerFunctionCalls(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		update += self.raiseMessageEvent.map RaiseMessageEvent2SendFunctionCall(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
		
		
		-- increment intermediate location semaphore (because we're entering an intermediate location)
		update += object IncrementDecrementExpression { // intermediateLocationSemaphore++;
			expression := object IdentifierExpression { identifier := map createIntermediateLocationSemaphoreVariable() };
			position := IncrementDecrementPosition::POST;
			operator := IncrementDecrementOperator::INCREMENT;
		};
	}
	
	mapping Transition :: Transition2FinalEdge() : Edge when {self.shouldCreateIntermediateLocation()} {
		source := self.map Transition2IntermediateLocation();
		target := self.target.resolveoneIn(State::State2Location, Location);
		update := object IncrementDecrementExpression { // intermediateLocationSemaphore--;
			expression := object IdentifierExpression { identifier := map createIntermediateLocationSemaphoreVariable() };
			position := IncrementDecrementPosition::POST;
			operator := IncrementDecrementOperator::DECREMENT;
		};
	}
	
	mapping createIntermediateLocationSemaphoreVariableDeclaration() : DataVariableDeclaration {
		typeDefinition := object RangeTypeSpecification {
			bounds := object IntegerBounds {
				lowerBound := object LiteralExpression {
					text := "0";
				};
				upperBound := object LiteralExpression {
					text := "0"; //will be changed to the number of intermediate locations as soon as it is determined
				};
			};
		};
		
		variable += map createIntermediateLocationSemaphoreVariable();
	}
	
	//The variable that is incremented whenever an intermediate location (~> Transition2IntermediateLocation) is entered and decremented whenever it is left.
	//This ensures that intermediate locations are left immediately when entered, before anything else can happen (even if another active location is also committed)
	mapping createIntermediateLocationSemaphoreVariable() : Variable {
		name := "intermediateLocationSemaphore";
	}
	
	//adds the "!intermediateLocationSemaphore" constraint to an edge
	helper addNoIntermediateLocationActiveGuard(inout edge : Edge) {
		var guards : OrderedSet(Expression) = edge.guard->asOrderedSet();
		guards += object NegationExpression {negatedExpression := object IdentifierExpression {identifier := map createIntermediateLocationSemaphoreVariable()}};
		edge.guard := guards->constructConjunction();
	}
	
	mapping Assignment :: Assignment2Selection() : Selection 
	when {self.rhs_assignExpression.oclIsKindOf(NondeterministicChoiceExpression)} {
	
		init {
			result := self.rhs_assignExpression.oclAsType(NondeterministicChoiceExpression).map Choice2Selection();
		}
		
		variable += self.rhs_assignExpression.oclAsType(NondeterministicChoiceExpression).map Choice2AuxVariable();	
		
	}
		
	mapping NondeterministicChoiceExpression :: Choice2Selection() : Selection {
		
		typeDefinition := self.map Choice2Range();
				
	}
	
	mapping NondeterministicChoiceExpression :: Choice2Range() : RangeTypeSpecification {
		
		// assert fatal (self.dataType.primitiveType = PrimitiveTypes::INT32);
		bounds := self.range.map Range2Bounds();
		
	}
	
	mapping Range :: Range2Bounds() : IntegerBounds {
		
		lowerBound := new LiteralExpression(self.lowerBound);
		upperBound := new LiteralExpression(self.upperBound);
		
	}
		
	
	
	helper Transition :: constructGuard(componentInstanceID : Variable, portOrRoleInstanceID : Variable, subPortOrRoleInstanceID : Variable) : uppaal_expressions::Expression {
							
		var guard : uppaal_expressions::Expression = self.guard.map createExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID);
				
		var clockConstraints : uppaal_expressions::Expression = self.clockConstraints->map ClockConstraint2CompareExpression(componentInstanceID, portOrRoleInstanceID, subPortOrRoleInstanceID)->constructConjunction();
		
		var trigger : uppaal_expressions::Expression = self.triggerMessageEvent.map TriggerMessageEvent2ReceiveFunctionCall(portOrRoleInstanceID, subPortOrRoleInstanceID, cicToVerify().discretePortInstances());
		
		var conditions : OrderedSet(uppaal_expressions::Expression) = object OrderedSet(uppaal_expressions::Expression) {};
				
		if(guard != null) then {
			conditions += guard;
		}
		endif;
		
		if(trigger != null) then {
			conditions += trigger;
		}
		endif;
		
		if(clockConstraints != null) then {
			conditions += clockConstraints;
		}
		endif;
										
		return conditions->constructConjunction();	
					
	}
		
	mapping UrgentSyncChannelDeclaration() : ChannelVariableDeclaration {
		
		typeDefinition := object TypeReference {
			referredType := CHAN;
		};
		
		urgent := true;
		
		variable += map UrgentSyncChannel();
		
	}
	
	mapping UrgentSyncChannel() : Variable {
		
		name := 'hurry';
		
	}
	
	mapping UrgentSyncProvider() : Template {
			
		name := 'UrgencyProvider';
		
		var loc : Location = object Location {
			name := 'idle';
		};
		
		location += loc;
		_init := loc;
		
		edge += object Edge {
			
			source := loc;
			target := loc;
			
			synchronization := map UrgentSyncChannel().getSendSynchronization();
			
		}
		
	}

	
	
	mapping Behavior :: Behavior2Template() : Template
		disjuncts RealtimeStatechart::RTSC2Template;
	
	mapping ComponentInstanceConfiguration :: CIC2GlobalDeclarations() : GlobalDeclarations when {self = cicToVerify()} {
	
		init {
			var discretePortInstances := self.discretePortInstances()
		}
	
		-- make global declarations accessible from all libraries
	
		globalDeclarations := result;
				
		-- create 'hurry' sync channel
		
		declaration += map UrgentSyncChannelDeclaration();
				
		-- declare user-defined types
						
		declaration += userDefinedDataTypes()->map createTypeDeclaration();
		
		-- declare MUML types
		
		declaration += map createMumlIntegerTypeDeclaration();
		
		declaration += map createMumlShortTypeDeclaration();
		
		declaration += map createMumlByteTypeDeclaration();
		
		-- declare types (based on the number of message kinds, buffer capacity, and maximal number of messages in transit)
		
		declaration += map createNumberOfMessageKindsDeclaration();
		
		declaration += map createNumberOfMessagesInTransitDeclaration();
		
		declaration += map createMaxBufferAndConnectorSizeVariableDeclaration();
		
		declaration += map createConnectorSizeVariableDeclaration();

		declaration += map createMaximalNumberOfBuffersPerRoleConstantDeclaration();
		
		declaration += map createMessageIdTypeDeclaration();
		
		declaration += map createMessageKindTypeDeclaration();
		
		declaration += map createMessageTypeDeclaration();
		
		declaration += map createBufferTypeDeclaration();
		
		declaration += messageTypes()->map createParameterTypeDeclaration();
		
		-- declare constants and variables
		
		declaration += map NumberOfPortInstancesDeclaration();
		
		declaration += map NumberOfComponentInstancesDeclaration();
		
		declaration += map DiscretePortInstanceTypeDeclaration();
		
		declaration += map ComponentInstanceTypeDeclaration();
		
		declaration += discretePortInstances->map createNextArrayDeclaration();
		
		declaration += discretePortInstances->map createPreviousArrayDeclaration();
		
		declaration += discretePortInstances->map createFirstArrayDeclaration();
		
		declaration += discretePortInstances->map createLastArrayDeclaration();
		
		declaration += discretePortInstances->map createSelfArrayDeclaration();

		declaration += discretePortInstances->map createBufferAssignmentArrayDeclaration();
		
		declaration += discretePortInstances->map createBufferSizeArrayDeclaration();

		declaration += BufferOverflowAvoidanceStrategy::DISCARD_INCOMING_MESSAGE.map createBufferOverflowConstantDeclaration();
		
		declaration += BufferOverflowAvoidanceStrategy::DISCARD_OLDEST_MESSAGE_IN_BUFFER.map createBufferOverflowConstantDeclaration();
		
		declaration += discretePortInstances->map createBufferOverflowStrategyArrayDeclaration();

		declaration += map createOverflowVariableDeclaration();
		
		declaration += map createIntermediateLocationSemaphoreVariableDeclaration();
		
		declaration += map createBuffersVariableDeclaration();
		
		declaration += map createConnectorsVariableDeclaration();
		
		declaration += map createEarliestVariableDeclaration();
		
		declaration += map createLatestVariableDeclaration();
		
		declaration += map createTransmissionTimesVariableDeclaration();
		
		declaration += map createMessageKindConstantsDeclaration();
		
		declaration += map createMessageIdNullConstantDeclaration();
		
		declaration += map createMessageNullConstantDeclaration();
		
		declaration += map createFreeIDsFieldDeclaration();
		
		declaration += messageTypes()->map createParameterTypeNullConstantDeclaration();
		
		declaration += messageTypes()->map createParameterTypeTailDeclaration();
		
		declaration += messageTypes()->map createParameterTypeBufferFieldDeclaration();
		
		-- declare functions
		
		declaration += map createAddFunctionDeclaration();
		
		declaration += map createGetNumElementsInBufferFunctionDeclaration();
		
		declaration += map createCheckFunctionDeclaration();
		
		declaration += map createCheckMessageInBufferFunctionDeclaration();
		
		declaration += map createRemoveFunctionDeclaration();
		
		declaration += discretePortInstances->map createReceiveFunctionDeclaration();
		
		declaration += map createRequestIdFunctionDeclaration();
		
		declaration += map createReleaseIdFunctionDeclaration();

		declaration += messageTypes()->map createAddFunctionForMessageTypeDeclaration();
		
		declaration += messageTypes()->map createRemoveFunctionForMessageTypeDeclaration();
		
		declaration += messageTypes()->map createSendFunctionDeclaration();
		
		declaration += discretePortInstances->map createConsumeFunctionDeclaration();
		
		declaration += map createClearConnectorFunctionDeclaration();
		
		declaration += map createDiscardFunctionDeclaration();
		
	}
	
	
	mapping pim::realtimestatechart::SynchronizationChannel :: SynchronizationChannel2SynchronizationChannel() : pim::realtimestatechart::SynchronizationChannel{
    	_name := self._name;
    	_comment := self._comment;
    	_annotation := self._annotation.map EAnnotation2EAnnotation();
    	_extension := self._extension.map Extension2Extension();
    --	_state := self._state.map State2State();
    	_selectorType := self._selectorType.map DataType2DataType();
   	}
   		 