import transforms.lib.MUML2MUML;
import de.uni_paderborn.fujaba.muml.verification.uppaal._blackbox.TimeLibUnit;

modeltype muml_protocol uses muml::protocol('http://www.fujaba.de/muml/0.4.0');
modeltype rtsc uses muml::realtimestatechart('http://www.fujaba.de/muml/0.4.0');
modeltype mumlConstraint uses 'http://www.fujaba.de/muml/constraint/0.4.0';
modeltype mumlBehavior uses 'http://www.fujaba.de/muml/behavior/0.4.0';
modeltype mumlconnector uses muml::connector('http://www.fujaba.de/muml/0.4.0');
modeltype mumlmsgtype uses muml::msgtype('http://www.fujaba.de/muml/0.4.0');
modeltype mumlinstance uses muml::instance('http://www.fujaba.de/muml/0.4.0');
modeltype mumlvaluetype uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype modelinstance uses 'http://www.fujaba.de/modelinstance/0.4.0';

modeltype mtctl uses 'http://www.uni_paderborn.de/fujaba/muml/verification/uppaal/Mtctl';
modeltype mtctlQuantifiers uses mtctl::Quantifiers('http://www.uni_paderborn.de/fujaba/muml/verification/uppaal/Mtctl');
modeltype mtctlPredicates uses mtctl::Predicates('http://www.uni_paderborn.de/fujaba/muml/verification/uppaal/Mtctl');
modeltype mtctlSets uses mtctl::Sets('http://www.uni_paderborn.de/fujaba/muml/verification/uppaal/Mtctl');
modeltype mtctlBooleanLogic uses mtctl::BooleanLogic('http://www.uni_paderborn.de/fujaba/muml/verification/uppaal/Mtctl');
modeltype mtctlComparables uses mtctl::Comparables('http://www.uni_paderborn.de/fujaba/muml/verification/uppaal/Mtctl');
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';

//Replaces all statically defined Predicates/MapExpressions with their actual values and vastly simplifies logical expressions
transformation MTCTLStaticNormalization(in input:muml_protocol, out output:muml_protocol) extends library MUML2MUML;

main() {
	input.objects()[RootNode]->map RootNode2RootNode();
}

//Overridden from MUML2MUML
mapping mtctl::Property :: Property2Property() : Property {
	comment := self.comment;
	
	expression := self.expression.map Expression2Expression();
}

//Overridden from MUML2MUML: check if we should apply one of our mappings here, otherwise fall back to a simple copying map
mapping mtctl::Expression :: Expression2Expression() : mtctl::Expression disjuncts 
	Expression::Expression2False, //Try to reduce the expression to "false"
	Expression::Expression2True, //Try to reduce the expression to "true"
	AndExpr::BinaryBoolOp2SingleOpd, OrExpr::BinaryBoolOp2SingleOpd, ImplyExpr::BinaryBoolOp2SingleOpd, //Try to reduce unnecessary lhs/rhs in these boolean operators that cannot be completely reduced to true/false
	SourceStateExpr::SourceStateExpr2MumlElemExpr, TargetStateExpr::TargetStateExpr2MumlElemExpr, //try to statically evaluate map expressions
	mtctl::Sets::SubinstanceSetExpr::SubinstanceSetExpr2SubinstanceSetExpr, mtctl::Sets::InstanceSetExpr::InstanceSetExpr2InstanceSetExpr, mtctl::Predicates::SubstateOfExpr::SubstateOfExpr2SubstateOfExpr, mtctl::Sets::TransitionSetExpr::TransitionSetExpr2TransitionSetExpr, mtctl::Quantifiers::LeadsToExpr::LeadsToExpr2LeadsToExpr, mtctl::BooleanLogic::ImplyExpr::ImplyExpr2ImplyExpr, mtctl::Quantifiers::EFExpr::EFExpr2EFExpr, mtctl::Quantifiers::QuantifierExpr::QuantifierExpr2QuantifierExpr, mtctl::Predicates::DynamicPredicateExpr::DynamicPredicateExpr2DynamicPredicateExpr, mtctl::Sets::ClockSetExpr::ClockSetExpr2ClockSetExpr, mtctl::Sets::StateSetExpr::StateSetExpr2StateSetExpr, mtctl::Predicates::FalseExpr::FalseExpr2FalseExpr, mtctl::Quantifiers::TemporalQuantifierExpr::TemporalQuantifierExpr2TemporalQuantifierExpr, mtctl::Comparables::TargetStateExpr::TargetStateExpr2TargetStateExpr, mtctl::Predicates::StateActiveExpr::StateActiveExpr2StateActiveExpr, mtctl::Quantifiers::BoundVariable::BoundVariable2BoundVariable, mtctl::BooleanLogic::NotExpr::NotExpr2NotExpr, mtctl::Quantifiers::EGExpr::EGExpr2EGExpr, mtctl::Predicates::ComparisonExpr::ComparisonExpr2ComparisonExpr, mtctl::Sets::MessageSetExpr::MessageSetExpr2MessageSetExpr, mtctl::BooleanLogic::AndExpr::AndExpr2AndExpr,  mtctl::Comparables::MapExpr::MapExpr2MapExprWorkaround, mtctl::Quantifiers::AGExpr::AGExpr2AGExpr, mtctl::Quantifiers::UniversalQuantExpr::UniversalQuantExpr2UniversalQuantExpr, mtctl::Quantifiers::AFExpr::AFExpr2AFExpr, mtctl::Sets::IntervalSetExpr::IntervalSetExpr2IntervalSetExpr, mtctl::BooleanLogic::OrExpr::OrExpr2OrExpr, mtctl::Comparables::BufferMsgCountExpr::BufferMsgCountExpr2BufferMsgCountExpr, mtctl::Comparables::SourceStateExpr::SourceStateExpr2SourceStateExpr, mtctl::Comparables::TransitionMap::TransitionMap2TransitionMap, mtctl::Predicates::TransitionFiringExpr::TransitionFiringExpr2TransitionFiringExpr, mtctl::Predicates::TrueExpr::TrueExpr2TrueExpr, mtctl::Predicates::MessageInBufferExpr::MessageInBufferExpr2MessageInBufferExpr, mtctl::Comparables::MumlElemExpr::MumlElemExpr2MumlElemExpr, mtctl::Sets::BufferSetExpr::BufferSetExpr2BufferSetExpr, mtctl::Predicates::MessageInTransitExpr::MessageInTransitExpr2MessageInTransitExpr, mtctl::Predicates::ConnectorOverflowExpr::ConnectorOverflowExpr2ConnectorOverflowExpr, mtctl::Predicates::StaticPredicateExpr::StaticPredicateExpr2StaticPredicateExpr, mtctl::Predicates::PredicateExpr::PredicateExpr2PredicateExpr, mtctl::Predicates::DeadlockExpr::DeadlockExpr2DeadlockExpr, mtctl::Quantifiers::ExistenceQuantExpr::ExistenceQuantExpr2ExistenceQuantExpr, mtctl::Comparables::ConstExpr::ConstExpr2ConstExpr, mtctl::Sets::SetExpr::SetExpr2SetExpr; //Fallback: copy

mapping mtctl::Comparables::MapExpr :: MapExpr2MapExpr() : mtctl::Comparables::MapExpr disjuncts
	SourceStateExpr::SourceStateExpr2MumlElemExpr, TargetStateExpr::TargetStateExpr2MumlElemExpr, //try to statically evaluate map expressions
	mtctl::Comparables::ConstExpr::ConstExpr2ConstExpr, mtctl::Comparables::BufferMsgCountExpr::BufferMsgCountExpr2BufferMsgCountExpr, mtctl::Comparables::MumlElemExpr::MumlElemExpr2MumlElemExpr, mtctl::Comparables::TransitionMap::TransitionMap2TransitionMap;

//Workaround for QVTo not allowing references to overridden MapExpr2MapExpr in the Expression2Expression disjuncts
//See QVTo bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=438038
mapping mtctl::Comparables::MapExpr::MapExpr2MapExprWorkaround() : mtctl::Comparables::MapExpr disjuncts
	SourceStateExpr::SourceStateExpr2MumlElemExpr, TargetStateExpr::TargetStateExpr2MumlElemExpr, //try to statically evaluate map expressions
	mtctl::Comparables::ConstExpr::ConstExpr2ConstExpr, mtctl::Comparables::BufferMsgCountExpr::BufferMsgCountExpr2BufferMsgCountExpr, mtctl::Comparables::MumlElemExpr::MumlElemExpr2MumlElemExpr, mtctl::Comparables::TransitionMap::TransitionMap2TransitionMap;
//Try to statically evaluate logical expressions to true/false
mapping Expression::Expression2False() : FalseExpr when {self.evaluateToBoolean()=false} {}
mapping Expression::Expression2True() : TrueExpr when {self.evaluateToBoolean()=true} {}


//Normalizes "true and null" expressions (only called when one operand is null)
mapping AndExpr::BinaryBoolOp2SingleOpd() : Expression when {self.leftOpd.evaluateToBoolean()=true or self.rightOpd.evaluateToBoolean()=true} { 
	init {
		if (self.leftOpd.evaluateToBoolean()=true) then 
			result := self.rightOpd.map Expression2Expression() 
		endif;
		if (self.rightOpd.evaluateToBoolean()=true) then
			result := self.leftOpd.map Expression2Expression()
		endif;
	}
}
//Normalizes "false or null" expressions (only called when one operand is null)
mapping OrExpr::BinaryBoolOp2SingleOpd() : Expression when {self.leftOpd.evaluateToBoolean()=false or self.rightOpd.evaluateToBoolean()=false} { 
	init {
		if (self.leftOpd.evaluateToBoolean()=false) then 
			result := self.rightOpd.map Expression2Expression() 
		endif;
		if (self.rightOpd.evaluateToBoolean()=false) then
			result := self.leftOpd.map Expression2Expression()
		endif;
	}
}
//Normalizes "true implies null" expressions (only called when one operand is null)
mapping ImplyExpr::BinaryBoolOp2SingleOpd() : Expression when {self.leftOpd.evaluateToBoolean()=true} { 
	init {
		result:=self.rightOpd.map Expression2Expression()
	}
}


//returns true or false if the expression can be simplified to true/false respectively; returns null otherwise
query Expression::evaluateToBoolean() : Boolean { 
	if (self.oclIsKindOf(TrueExpr)) return true endif;
	if (self.oclIsKindOf(FalseExpr)) return false endif;
	
	if (self.oclIsKindOf(AGExpr)) return self.oclAsType(AGExpr).expr.evaluateToBoolean() endif;
	if (self.oclIsKindOf(AFExpr)) return self.oclAsType(AFExpr).expr.evaluateToBoolean() endif;
	if (self.oclIsKindOf(EGExpr)) return self.oclAsType(EGExpr).expr.evaluateToBoolean() endif;
	if (self.oclIsKindOf(EFExpr)) return self.oclAsType(EFExpr).expr.evaluateToBoolean() endif;
	if (self.oclIsKindOf(LeadsToExpr)) {
		return not self.oclAsType(LeadsToExpr).leftOpd.evaluateToBoolean() or self.oclAsType(LeadsToExpr).rightOpd.evaluateToBoolean(); // a leadsTo b === AG (a implies EG b)
	};

	if (self.oclIsKindOf(NotExpr)) return not self.oclAsType(NotExpr).opd.evaluateToBoolean() endif;
	if (self.oclIsKindOf(AndExpr)) return self.oclAsType(AndExpr).leftOpd.evaluateToBoolean() and self.oclAsType(AndExpr).rightOpd.evaluateToBoolean() endif;
	if (self.oclIsKindOf(ImplyExpr)) return not self.oclAsType(ImplyExpr).leftOpd.evaluateToBoolean() or self.oclAsType(ImplyExpr).rightOpd.evaluateToBoolean() endif;
	if (self.oclIsKindOf(OrExpr)) return self.oclAsType(OrExpr).leftOpd.evaluateToBoolean() or self.oclAsType(OrExpr).rightOpd.evaluateToBoolean() endif;
	
	if (self.oclIsKindOf(SubstateOfExpr)) return self.oclAsType(SubstateOfExpr).state.oclAsType(MapExpr).getStaticValue().oclAsType(Vertex).allSuperVertices->includes(
						self.oclAsType(SubstateOfExpr).superstate.oclAsType(MapExpr).getStaticValue().oclAsType(Vertex))
						and (self.oclAsType(SubstateOfExpr).state.oclAsType(MapExpr).getStaticInstance() = self.oclAsType(SubstateOfExpr).superstate.oclAsType(MapExpr).getStaticInstance()
						or if self.oclAsType(SubstateOfExpr).superstate.oclAsType(MapExpr).getStaticInstance().oclIsKindOf(ComponentInstance) then
								self.oclAsType(SubstateOfExpr).superstate.oclAsType(MapExpr).getStaticInstance().oclAsType(ComponentInstance).portInstances.oclAsType(EObject)->includes(self.oclAsType(SubstateOfExpr).state.oclAsType(MapExpr).getStaticInstance())
							else
								false
							endif
						)
		endif;
	if (self.oclIsKindOf(StateInStatechartExpr)) return self.oclAsType(StateInStatechartExpr).statechart.getStaticValue().oclAsType(RealtimeStatechart).
						allSubobjectsOfKind(State).oclAsType(Vertex)->includes(self.oclAsType(StateInStatechartExpr).state.getStaticValue().oclAsType(Vertex))
						and (self.oclAsType(StateInStatechartExpr).statechart.oclAsType(MapExpr).getStaticInstance() = self.oclAsType(StateInStatechartExpr).state.oclAsType(MapExpr).getStaticInstance()
						or if self.oclAsType(StateInStatechartExpr).statechart.oclAsType(MapExpr).getStaticInstance().oclIsKindOf(ComponentInstance) then
								self.oclAsType(StateInStatechartExpr).statechart.oclAsType(MapExpr).getStaticInstance().oclAsType(ComponentInstance).portInstances.oclAsType(EObject)->includes(self.oclAsType(StateInStatechartExpr).state.oclAsType(MapExpr).getStaticInstance())
							else
								false
							endif
						)
		endif;
	if (self.oclIsKindOf(ComparisonExpr)) return self.oclAsType(ComparisonExpr).evaluateStaticComparison();
	return null;
}

//tries to statically evaluate a comparison. Returns true/false on success, null if the value cannot be statically decided
query ComparisonExpr::evaluateStaticComparison() : Boolean {
	var l_value = self.lhs.getStaticValue();
	var l_instance = self.lhs.getStaticInstance();
	var r_value = self.rhs.getStaticValue();
	var r_instance = self.rhs.getStaticInstance();

	if (l_value.oclIsUndefined() or r_value.oclIsUndefined()) return null endif;
	
	//Normalize time units
	if (self.lhs.getStaticTimeUnit() != null) {
		assert(self.rhs.getStaticTimeUnit() != null) with log ("Time unit not set");
		var smallestTimeUnit := OrderedSet {self.lhs.getStaticTimeUnit(), self.rhs.getStaticTimeUnit()}->sortedBy(u | getTimeUnits()->indexOf(u.repr()))->last();
		l_value := getUpscaleFactor(self.lhs.getStaticTimeUnit(), smallestTimeUnit) * l_value.oclAsType(Integer);
		r_value := getUpscaleFactor(self.rhs.getStaticTimeUnit(), smallestTimeUnit) * r_value.oclAsType(Integer);
	};
	
	//Return compared value
	switch {
		case (self.op = ComparisonOp::EQUALS) { return l_value = r_value and l_instance = r_instance; }
		case (self.op = ComparisonOp::NOT_EQUAL) { return l_value <> r_value or l_instance <> r_instance;}
		case (self.op = ComparisonOp::GREATER) { return l_value.oclAsType(Integer) > r_value.oclAsType(Integer); }
		case (self.op = ComparisonOp::GREATER_OR_EQUAL) { return l_value.oclAsType(Integer) >= r_value.oclAsType(Integer); }
		case (self.op = ComparisonOp::LESS) { return l_value.oclAsType(Integer) < r_value.oclAsType(Integer); }
		case (self.op = ComparisonOp::LESS_OR_EQUAL) { return l_value.oclAsType(Integer) <= r_value.oclAsType(Integer); }
	};
	return null;
}

mapping SourceStateExpr::SourceStateExpr2MumlElemExpr() : MumlElemExpr when {self.transition.getStaticValue() != null} {
	elem := self.transition.getStaticValue().oclAsType(Transition).source.map EObject2EObject();
	instance := self.transition.getStaticInstance().map EObject2EObject();
}

mapping TargetStateExpr::TargetStateExpr2MumlElemExpr() : MumlElemExpr when {self.transition.getStaticValue() != null} {
	elem := self.transition.getStaticValue().oclAsType(Transition).target.map EObject2EObject();
	instance := self.transition.getStaticInstance().map EObject2EObject();
}

//returns the (static) value of the MapExpr or null if the value can only be determined at runtime(/verification time)
query MapExpr::getStaticValue() : OclAny { 
	if (self.oclIsKindOf(MumlElemExpr) and self.oclAsType(MumlElemExpr).elem.oclIsKindOf(Clock)) return null endif; //clocks have a dynamic value
	if (self.oclIsKindOf(MumlElemExpr) and self.oclAsType(MumlElemExpr).elem.oclIsKindOf(Variable)) return null endif; //variables have a dynamic value
	if (self.oclIsKindOf(ConstExpr)) return self.oclAsType(ConstExpr).val endif;
	if (self.oclIsKindOf(MumlElemExpr)) return self.oclAsType(MumlElemExpr).elem endif; //MumlElemExpr (except clocks and variables) are simply compared statically
	if (self.oclIsKindOf(SourceStateExpr)) return self.oclAsType(SourceStateExpr).transition.getStaticValue().oclAsType(Transition).source endif;
	if (self.oclIsKindOf(TargetStateExpr)) return self.oclAsType(TargetStateExpr).transition.getStaticValue().oclAsType(Transition).target endif;
	
	return null;
}

query MapExpr::getStaticInstance() : EObject {
	if (self.oclIsKindOf(MumlElemExpr)) return self.oclAsType(MumlElemExpr).instance endif;
	if (self.oclIsKindOf(SourceStateExpr)) return self.oclAsType(SourceStateExpr).transition.getStaticInstance() endif;
	if (self.oclIsKindOf(TargetStateExpr)) return self.oclAsType(TargetStateExpr).transition.getStaticInstance() endif;
	
	return null;
}

query MapExpr::getStaticTimeUnit() : TimeUnit {
	if (self.oclIsKindOf(ConstExpr)) return self.oclAsType(ConstExpr).timeUnit;
	return null;
}

query getTimeUnits() : OrderedSet(String) {
	return OrderedSet {'DAYS', 'HOURS', 'MINUTES', 'SECONDS', 'MILLISECONDS', 'MICROSECONDS', 'NANOSECONDS'}
}


