transformation PlatformInstanceTransformation(inout hwplatformInstanceConfig:PlatformInstancePackage, in platform:PlatformPackage);


modeltype MumlPackage uses muml('http://www.fujaba.de/muml/0.4.0');
modeltype ValuetypePackage uses muml::valuetype('http://www.fujaba.de/muml/0.4.0');
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype HardwarePackage uses hardware('http://www.fujaba.de/muml/hardware/1.0/');
modeltype ResourcePackage uses hardware::hwresource('http://www.fujaba.de/muml/hardware/1.0/');
modeltype ResourceInstancePackage uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformPackage uses hardware::hwplatform('http://www.fujaba.de/muml/hardware/1.0/');
modeltype PlatformInstancePackage uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/1.0/');
modeltype HWValueTypePackage uses hardware::hwvaluetype('http://www.fujaba.de/muml/hardware/1.0/');




//This transformation creates an initial HWPlatformInstance.
//Therefore all embedded HWPlatforms, ResourceInstances and CommunicationResources 
//are created according to their cardinality of the HWPlatform type.

main() {
	log("QVT-O Script \"PlatformInstanceTransformation.qvto\" started.");
		hwplatformInstanceConfig.rootObjects()[HWPlatformInstanceConfiguration]->forEach(pi){
		pi.hwplatformInstances+=platform.rootObjects()[HWPlatform]->map createHWPlatformInstance(".0",pi);
		//pi.hwplatformType->map createHWPlatformInstance(".0",null);
	};
}

// This is an intermediate property used to map the connectedMedia of the HWPortInstances (used as DelegationPorts) in the HWPlatform-Model
//to connectedMedia of this HWPlatformInstance 
//From a HWPortInstance (used as a Delegation) point of view this is the grandparent

//create a HWPlatformInstance derived from a HWPlatform
//the number is used to distinguish between multiple instances of the same HWPlatform
mapping HWPlatform::createHWPlatformInstance(number:String, parent:HWPlatformInstanceConfiguration):HWPlatformInstance{
	result.name:=self.name;//+number.toString();
	result.hwplatformType:=self;
	//result.parentOfPlatformInstance:=parent;
	result.parentHPIC:=parent;
	log("Start to create the HWPlatformInstance for:" +result.eClass().name +", Name:" +result.name);
	
	result.embeddedHPIC:=new HWPlatformInstanceConfiguration();
	//create the embedded CommunicationMedia	
	result.embeddedHPIC.networkingHardwareInstances+=self.networkingHardware->map createNetworkingResourceInstance(number, result.embeddedHPIC)->asOrderedSet();
	result.embeddedHPIC.networkConnectorInstances+=self.networkConnectors->map mapNetworkConnector2NetworkConnectorInstance();
	//create the delegation ports
	
	result.delegationPorts:=self.delegationPorts->map createDelegationHWPortInstance(number, result);
	
	//create the embedded ResourceInstances
	var instances:Set(ResourceInstance);
	self.embeddedPlatformParts[ResourcePart]->forEach(rip){
		instances+=rip.ResourcePart2ResourceInstance(number,result.embeddedHPIC)->asOrderedSet();
	};
	result.embeddedHPIC.resources:=instances;
	
	
	//the delegation and delegation Ports are created by the mapping createPort(), to ease resolving
	//so each port with a delegation creats its delegation and corresponding DelegationPort
	
	//initialize the embedded HWPlatforms
	var platforminstances:Set(HWPlatformInstance);
	self.embeddedPlatformParts[HWPlatformPart]->forEach(hwp){
		platforminstances+=hwp.HWPlatformPart2HWPlatformInstance(number,result.embeddedHPIC);
	};
	result.embeddedHPIC.hwplatformInstances:=platforminstances;
}


//create the embedded ResourceInstances derived by the ResourceInstancePart
// each ResourceInstance gets a number
//the number is used to distinguish between multiple instances of the same ResourceInstance
// the argument parent is used to resolve the correct CommunicationMedia of the HWPortInstances
query ResourcePart::ResourcePart2ResourceInstance(number:String,parent:HWPlatformInstanceConfiguration):Set(ResourceInstance){
	var instances:Set(ResourceInstance);
	var lowerBound: Integer;
	lowerBound:=InitValue(self);
	while(lowerBound>0){
			instances+=self.map createResourceInstance(self.name,number+"."+lowerBound.toString(),parent)->asOrderedSet();
			lowerBound:=lowerBound-1;
			};
	return instances;
}



//create the embedded HWPlatformInstances derived by the HWPlatformPart
// each HWPlatformInstance gets a number
//the number is used to distinguish between multiple instances of the same HWPlatformIstance
query HWPlatformPart::HWPlatformPart2HWPlatformInstance(number:String,parent:HWPlatformInstanceConfiguration):Set(HWPlatformInstance){
	var instances:Set(HWPlatformInstance);
	var lowerBound: Integer;
	lowerBound:=InitValue(self);
	while(lowerBound>0){
			log("create embedded HWPlatformInstance for:"+self.eClass().name +", Name:" +self.name+", Parent is"+self.parentHWPlatform.name);
			instances+=self.hwplatformType.map createHWPlatformInstance(number+"."+lowerBound.toString(),parent);
			lowerBound:=lowerBound-1;
			};
	return instances;
}


mapping  ResourcePart::createResourceInstance(partName:String,number:String,parent:HWPlatformInstanceConfiguration):ResourceInstance
 disjuncts ResourcePart::createStructuredResourceInstance, ResourcePart::createActuatorInstance, ResourcePart::createSensorInstance
	{}


//create a StructuredResourceInstances
// the argument parent is used to resolve the correct CommunicationMedia of the HWPortInstances
mapping ResourcePart::createStructuredResourceInstance(partName:String,number:String,parent:HWPlatformInstanceConfiguration):StructuredResourceInstance when {self.resourceType.oclIsKindOf(StructuredResourceInstance)}{
	result.name:=partName+number;
	result.resourceType:=self.resourceType.resourceType;
	result.hwports+=self.hwPortParts->createPortInstances(number,parent);
	result.embeddedAtomicResourceInstances:=self.resourceType.oclAsType(StructuredResourceInstance).embeddedAtomicResourceInstances.deepclone().oclAsType(AtomicResourceInstance);
	
}


mapping ResourcePart::createActuatorInstance(partName:String,number:String,parent:HWPlatformInstanceConfiguration):ActuatorInstance when {self.resourceType.oclIsKindOf(ActuatorInstance)}{
	result.name:=partName+number;
	result.resourceType:=self.resourceType.resourceType;
 	result.hwports+=self.hwPortParts->createPortInstances(number,parent);
	
}

mapping ResourcePart::createSensorInstance(partName:String,number:String,parent:HWPlatformInstanceConfiguration):SensorInstance when {self.resourceType.oclIsKindOf(SensorInstance)}{
	result.name:=partName+number;
	result.resourceType:=self.resourceType.resourceType;
 	result.hwports+=self.hwPortParts->createPortInstances(number,parent);
	
}



helper Set(HWPortPart)::createPortInstances(number:String,parent:HWPlatformInstanceConfiguration):Set(HWPortInstance){
	var portInstances:Set(HWPortInstance);
	var lowerBound: Integer;
	self->forEach(portPart){
		lowerBound:=portPart.connectors->size();
	//	if(portPart.cardinality.lowerBound.toInteger() < portPart.connectors->size()) then{
	//				lowerBound:=portPart.connectors->size();	
	//	}
	//	else{
	//		lowerBound:=portPart.cardinality.lowerBound.toInteger();
	//	}
	//	endif;
		while(lowerBound>0){
				portInstances+=portPart.map createPortInstance(number, parent);
				lowerBound:=lowerBound-1;
				};
		};
	return portInstances;
}

//create a HWPortInstance and resovle the correct connectedCommunicationMedia with the help of the argument parent
mapping HWPortPart::createPortInstance(number:String,parent:HWPlatformInstanceConfiguration):HWPortInstance{

//	result.name:=self.name+number;
	type:= self;
	name:=self.hwport.name;
	comment:=self.comment;
	communicationResource:=self.hwport.communicationResource;
	connectorInstances:=self.connectors.late resolve(muml::connector::ConnectorInstance);
//	result.hwportType:=self.hwportType;
//	result.queuingTime:=self.queuingTime.deepclone().oclAsType(TimeInterval);
//	result.payloadDataSize:=self.payloadDataSize.deepclone().oclAsType(DataSize);
/*
	if(self.isDelegationPort) then{
	//resolve the corresponding delegation 
		result.delegation:=parent.delegations->any(hwPortInstance->size()<=1);
		//resolve the connectedMedia of the grandparent only for Busses
		if(parent.parentOfPlatformInstance<>null) then{
				result.connectedMedia:=self.connectedMedia.resolve(Bus)->asOrderedSet()->intersection(parent.parentOfPlatformInstance.communicationResources[Bus]);
		}endif;
	} else{
		result.delegation:=self.delegation.createDelegation(number,parent);
	}endif;
	*/
}

/*
//create a delegation an the correspond Delegation Port
helper Delegation::createDelegation(number:String, inout parent:HWPlatformInstance):Set(Delegation){
	var delegations:Set(Delegation);
	delegations:=parent.delegations+=self->map createDelegation(number);
//	parent.delegationPorts+=self.hwPortInstance->select(port|port.isDelegationPort=true)->map createPort(number,parent);
	return delegations;
}

*/


//creates a CommunicationMedia
mapping NetworkingHardware::createNetworkingResourceInstance(number:String, parentHPIC: HWPlatformInstanceConfiguration):NetworkingHardwareInstance
disjuncts Bus::createBusInstance, NetworkBridge::createBridgeInstance{}
//	result.comment:=self.comment+number;
	//result.bandwidth:=self.bandwidth.deepclone().oclAsType(DataRate);
	//result.protocol:=self.protocol;
	//result.isSerial:=self.isSerial;
	//result.dataFrameSize:=self.dataFrameSize.deepclone().oclAsType(DataSize);
//	result.



mapping NetworkConnector::mapNetworkConnector2NetworkConnectorInstance():NetworkConnectorInstance{
  	type:=self;
	comment:=self.comment;
	connectorEndpointInstances:=self.connectorEndpoints.late resolve(muml::connector::ConnectorEndpointInstance);
	}
	
	
mapping NetworkBridge::createBridgeInstance(number:String, parent:HWPlatformInstanceConfiguration):NetworkBridgeInstance{
	type:=self;
	comment:=self.comment+number;	 
	connectorInstances:=self.connectors.late resolve(muml::connector::ConnectorInstance);
	name:="Bridge";
	}
	

	
mapping Bus::createBusInstance(number:String, parent:HWPlatformInstanceConfiguration):BusInstance{
	type:=self;
	result.comment:=self.comment+number;
	connectorInstances:=self.connectors.late resolve(muml::connector::ConnectorInstance);	 
	name:="Bus";
	}	
	

mapping DelegationHWPort::createDelegationHWPortInstance(number:String, parent:HWPlatformInstance):DelegationHWPortInstance{
	type:=self;
	name:=self.comment+number;
	connectorInstances:=self.connectors.late resolve(muml::connector::ConnectorInstance);
}

// Convenience query to cast a natural number to an integer, using -1 as value for infinity.
query NaturalNumber::toInteger() : Integer {
	if (self.infinity) then {
		return -1;
	} endif;
	return self.value;
}

//just for test purpose
configuration property initVector : Dict(String,Integer);
			
constructor HWPlatformInstanceConfiguration::HWPlatformInstanceConfiguration() {
	
}
	
query InitValue(part:PlatformPart) : Integer {
if(initVector->hasKey(part.name)) then{
		return initVector->get(part.name);
	}
else{
		return part.cardinality.lowerBound.toInteger();
	}endif;
	return 0;
}
 