import helpers;

library CSD2SDUtil;

modeltype sdPatterns uses storydiagrams::patterns('http://www.storydriven.org/storydiagrams/0.2.1');

modeltype componentInstanceConfiguration uses 'http://www.fujaba.de/muml/instance/0.4.0';

modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';

modeltype reconfiguration uses 'http://www.fujaba.de/muml/reconfiguration/0.3.18';

modeltype csp uses 'http://www.fujaba.de/muml/componentstorypattern/0.4.0';

modeltype componentModel uses muml::component('http://www.fujaba.de/muml/0.4.0');

modeltype core uses 'http://www.storydriven.org/core/0.3.1';

modeltype sd_expressions uses core::expressions ('http://www.storydriven.org/core/0.3.1');


mapping componentstorypattern::ComponentStoryPattern :: createInitialCIC() : ObjectVariable{
	name := 'rootCIC';
	classifier:=ComponentInstanceConfiguration.oclAsType(EClass);
}

mapping componentstorypattern::ComponentVariable:: createEmbeddedCIC() : ObjectVariable{
	name := 'embeddedCIC';
	classifier:=ComponentInstanceConfiguration.oclAsType(EClass);
}

mapping componentstorypattern::ComponentStoryPatternVariable ::createComponentInstance() : ObjectVariable disjuncts componentstorypattern::ComponentVariable :: createStructuredComponentInstance,
 componentstorypattern::ComponentVariable :: createAtomicComponentInstance,
  componentstorypattern::PartVariable ::createStructuredComponentInstance,
   componentstorypattern::PartVariable ::createAtomicComponentInstance;


mapping componentstorypattern::ComponentVariable :: createStructuredComponentInstance() : ObjectVariable when{self.type.eClass() = ReconfigurableStructuredComponent or self.type.eClass() = StaticStructuredComponent}{
	name := self.name;
	classifier := StructuredComponentInstance.oclAsType(EClass);
	   	_bindingState := self._bindingState;
    	_bindingSemantics := self._bindingSemantics;
    	_bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::ComponentVariable :: createAtomicComponentInstance() : ObjectVariable when {self.type.eClass() = AtomicComponent or self.type.eClass() = ReconfigurableAtomicComponent}{
	name := self.name;
	classifier := AtomicComponentInstance.oclAsType(EClass);
	   	_bindingState := self._bindingState;
    	_bindingSemantics := self._bindingSemantics;
    	_bindingOperator := self._bindingOperator;
}

//mapping componentstorypattern::PartVariable ::createComponentInstance() : ObjectVariable disjuncts componentstorypattern::PartVariable ::createStructuredComponentInstance, componentstorypattern::PartVariable ::createAtomicComponentInstance;

mapping componentstorypattern::PartVariable ::createStructuredComponentInstance() : ObjectVariable when {self.type.componentType.eClass() = StaticStructuredComponent or self.type.componentType.eClass() = ReconfigurableStructuredComponent}{
	name := self.name;
	classifier := StructuredComponentInstance.oclAsType(EClass);
	   	_bindingState := self._bindingState;
    	_bindingSemantics := self._bindingSemantics;
    	_bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PartVariable ::createAtomicComponentInstance() : ObjectVariable when {self.type.componentType.eClass() = StaticAtomicComponent or self.type.componentType.eClass() = ReconfigurableAtomicComponent}{
	name := self.name;
	classifier := AtomicComponentInstance.oclAsType(EClass);
	  	_bindingState := self._bindingState;
    	_bindingSemantics := self._bindingSemantics;
    	_bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PortVariable :: createPortInstance() : ObjectVariable disjuncts componentstorypattern::PortVariable :: createDiscreteSinglePortInstance,
 componentstorypattern::PortVariable :: createDiscreteMultiPortInstance,
  componentstorypattern::PortVariable :: createContinousPortInstance,
   componentstorypattern::PortVariable :: createHybridPortInstance;

mapping componentstorypattern::PortVariable :: createDiscreteSinglePortInstance() : ObjectVariable when{self.type.eClass() = DiscretePort and self.type.oclAsType(DiscretePort).cardinality.upperBound.value = 1}{
	name := self.name;
	classifier := DiscreteSinglePortInstance.oclAsType(EClass);
	_bindingState := self._bindingState;
    _bindingSemantics := self._bindingSemantics;
    _bindingOperator := self._bindingOperator;
}

//TODO check if we need new references compared to single here
mapping componentstorypattern::PortVariable :: createDiscreteMultiPortInstance() : ObjectVariable when{self.type.eClass() = DiscretePort and self.type.oclAsType(DiscretePort).cardinality.upperBound.value > 1}{
	name := self.name;
	classifier := DiscreteMultiPortInstance.oclAsType(EClass);
	   	_bindingState := self._bindingState;
    	_bindingSemantics := self._bindingSemantics;
    	_bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PortVariable :: createContinousPortInstance() : ObjectVariable when{self.type.eClass() = ContinuousPort}{
	name := self.name;
	classifier := ContinuousPortInstance.oclAsType(EClass);
	   	_bindingState := self._bindingState;
    	_bindingSemantics := self._bindingSemantics;
    	_bindingOperator := self._bindingOperator;
}

mapping componentstorypattern::PortVariable :: createHybridPortInstance() : ObjectVariable when{self.type.eClass() = HybridPort}{
	name := self.name;
	classifier := HybridPortInstance.oclAsType(EClass);
	   	_bindingState := self._bindingState;
    	_bindingSemantics := self._bindingSemantics;
    	_bindingOperator := self._bindingOperator;
}


mapping Port :: createPortType(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	name := self.name;
	classifier := self.eClass();
	constraint := createNameConstraint(self.name);
}


mapping componentstorypattern::PortVariable :: createPortPart(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	name := self.name;
	classifier := PortPart.oclAsType(EClass);
	constraint := createNameConstraint(self.name);
}


-- we need the parameter to create every "component type variable" anew for each story pattern
mapping muml::component::Component ::createComponentType(compStoryPattern : componentstorypattern::ComponentStoryPattern) : ObjectVariable{
	name := self.name;
	classifier := self.eClass();
	constraint := createNameConstraint(self.name);
}


mapping componentstorypattern::PartVariable :: createComponentPart() : ObjectVariable{
	name := self.type.name;
	classifier := self.type.eClass();
	constraint := createNameConstraint(self.type.name);
}

mapping createLinkVaribale(sourceVariable : ObjectVariable, targetVariable : ObjectVariable, targetEndReference : EReference) : LinkVariable{
//	_name := self._name;
//    _bindingSemantics := self._bindingSemantics;
//    _bindingOperator := self._bindingOperator;
//    _annotation := self._annotation.map EAnnotation2EAnnotation();
//    _extension := self._extension.map Extension2Extension();
    _source := sourceVariable;
//    _secondLinkConstraint := self._secondLinkConstraint.map LinkConstraint2LinkConstraint();
//    _firstLinkConstraint := self._firstLinkConstraint.map LinkConstraint2LinkConstraint();
//    _pattern := self._pattern.map StoryPattern2StoryPattern();
    _target := targetVariable;
    
    _targetEnd := targetEndReference;
//    _qualifierExpression := self._qualifierExpression.map Expression2Expression();
}

mapping PartVariable:: createPartVariableEquivalence(in compStoryPattern : componentstorypattern::ComponentStoryPattern, inout container : StoryPattern){
	container._variable +=  self.map createComponentInstance();
	container._linkVariable += map createLinkVaribale(compStoryPattern.thisVariable.map createEmbeddedCIC(), self.map createComponentInstance(), getComponentInstancesReference());
	container._variable += self.type.componentType.map createComponentType(compStoryPattern);
	container._linkVariable += map createLinkVaribale(self.map createComponentInstance(), self.type.componentType.map createComponentType(compStoryPattern), getComponentTypeReference(ComponentInstance.oclAsType(EClass)));
	container._variable += self.map createComponentPart();
	container._linkVariable += map createLinkVaribale(self.map createComponentInstance(), self.map createComponentPart(), getComponentPartReference());
	container._linkVariable += map createLinkVaribale(compStoryPattern.thisVariable.type.map createComponentType(compStoryPattern), self.map createComponentPart(), getEmbeddedComponentPartsReference());
	container._linkVariable += map createLinkVaribale(self.map createComponentPart(), self.type.componentType.map createComponentType(compStoryPattern), getComponentTypeReference(self.map createComponentPart().classifier));

	self.portVariables->forEach(pV){
		pV.map createPortVariableEquivalence(compStoryPattern, container);
	}
}

mapping PortVariable :: createPortVariableEquivalence(in compStoryPattern : componentstorypattern::ComponentStoryPattern, inout container : StoryPattern){
	var portInstance : ObjectVariable := self.map createPortInstance();
	container.variable += portInstance;
	container.linkVariable += map createLinkVaribale(portInstance, self.container().oclAsType(ComponentStoryPatternVariable).map createComponentInstance(), getComponentInstanceReference());
	
	var portType : ObjectVariable := self.type.map createPortType(compStoryPattern);
	container.variable += portType;
	container.linkVariable += map createLinkVaribale(portInstance, portType, getPortTypeReference(portInstance.classifier));
	container.linkVariable += map createLinkVaribale(portType, self.type.component.map createComponentType(compStoryPattern), getComponentReference(self.type.map createPortType(compStoryPattern).classifier));
	
	var portPart : ObjectVariable := self.map createPortPart(compStoryPattern);
	container.variable += portPart;
	container.linkVariable += map createLinkVaribale(portInstance, portPart, getPortPartReference());
	container.linkVariable += map createLinkVaribale(portPart, portType, getPortTypeReference(portPart.classifier));
	container.linkVariable += map createLinkVaribale(portPart, self.type.component.map createComponentType(compStoryPattern), getComponentPartReference(portPart.classifier));
}
//mapping PortPart createPort

query createNameConstraint(name : String) : Constraint{
	return object Constraint{
		constraintExpression := object TextualExpression{
			language := 'OCL';
			expressionText := "name = \'".concat(name).concat("\'");
			languageVersion := '1.0';
		}
	}
}


